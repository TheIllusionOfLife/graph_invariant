{
  "experiment_id": "phase1_20260212T064018Z",
  "generation": 12,
  "rng_seed": 42,
  "rng_state": {
    "bit_generator": "PCG64",
    "state": {
      "state": 252344591763182659126541456219648799934,
      "inc": 332724090758049132448979897138935081983
    },
    "has_uint32": 1,
    "uinteger": 2121674413
  },
  "best_val_score": 0.6666372840718657,
  "no_improve_count": 9,
  "island_stagnation": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_prompt_mode": {
    "0": "free",
    "1": "free",
    "2": "free",
    "3": "free"
  },
  "island_constrained_generations": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_recent_failures": {
    "0": [
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "no_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`"
    ],
    "1": [
      "no_valid_train_predictions: static_invalid: non-whitelisted call detected: hasattr",
      "no_valid_train_predictions: static_invalid: disallowed syntax: Try",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ],
    "2": [
      "no_valid_train_predictions: static_invalid: disallowed syntax: Try",
      "no_valid_train_predictions: static_invalid: non-whitelisted call detected: hasattr",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ],
    "3": [
      "no_valid_train_predictions: static_invalid: disallowed syntax: Try",
      "no_valid_train_predictions: static_invalid: non-whitelisted call detected: dir",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ]
  },
  "islands": {
    "0": [
      {
        "id": "g0_i0_p0_89250953",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For connected graphs this is the mean of the shortest path lengths over all\n    unordered pairs of distinct nodes.  For disconnected graphs the average is\n    taken over all reachable pairs only.  If the graph has no edges or only a\n    single node, the function returns 0.0.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    float\n        The average shortest path length.\n    \"\"\"\n    # Handle trivial cases\n    n = G.number_of_nodes()\n    if n <= 1:\n        return 0.0\n\n    total_len = 0\n    pair_count = 0\n\n    # Perform a breadth‑first search from each node to compute distances\n    for s in G.nodes():\n        visited = {s}\n        dist = {s: 0}\n        queue = [s]\n        while queue:\n            u = queue.pop(0)\n            for v in G.neighbors(u):\n                if v not in visited:\n                    visited.add(v)\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n\n        # Sum distances to all reachable nodes (excluding the source)\n        for t, d in dist.items():\n            if t == s:\n                continue\n            total_len += d\n            pair_count += 1\n\n    if pair_count == 0:\n        return 0.0\n\n    avg = total_len / pair_count\n    # For undirected graphs each unordered pair is counted twice\n    if not G.is_directed():\n        avg *= 2\n    return avg",
        "island_id": 0,
        "generation": 0,
        "train_score": 0.9999999999999999,
        "val_score": 0.6663896768077913,
        "simplicity_score": 0.25214148393893143,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g1_i0_p1_450385937",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For connected graphs this is the mean of the shortest path lengths over all\n    unordered pairs of distinct nodes.  For disconnected graphs the average is\n    taken over all reachable pairs only.  If the graph has no edges or only a\n    single node, the function returns 0.0.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    float\n        The average shortest path length.\n    \"\"\"\n    # Handle trivial cases\n    n = G.number_of_nodes()\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    # For each source node run a BFS to compute distances to all reachable nodes\n    for source in G.nodes():\n        # BFS\n        dist = {source: 0}\n        queue = [source]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n\n        # Accumulate distances to all reachable nodes (excluding the source)\n        for target, d in dist.items():\n            if target == source:\n                continue\n            total_dist += d\n            pair_count += 1\n\n    if pair_count == 0:\n        return 0.0\n\n    avg = total_dist / pair_count\n    # For undirected graphs each unordered pair is counted twice\n    if not G.is_directed():\n        avg *= 2\n    return avg",
        "island_id": 0,
        "generation": 1,
        "train_score": 0.9999999999999999,
        "val_score": 0.6663680918461247,
        "simplicity_score": 0.2520335591305985,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g2_i0_p0_858291293",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For connected graphs this is the mean of the shortest path lengths over all\n    unordered pairs of distinct nodes.  For disconnected graphs the average is\n    taken over all reachable pairs only.  If the graph has no edges or only a\n    single node, the function returns 0.0.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    float\n        The average shortest path length.\n    \"\"\"\n    # Handle trivial cases\n    n = G.number_of_nodes()\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    # For each source node run a BFS to compute distances to all reachable nodes\n    for source in G.nodes():\n        dist = {source: 0}\n        queue = [source]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n\n        # Accumulate distances to all reachable nodes (excluding the source)\n        for target, d in dist.items():\n            if target == source:\n                continue\n            total_dist += d\n            pair_count += 1\n\n    if pair_count == 0:\n        return 0.0\n\n    avg = total_dist / pair_count\n    # For undirected graphs each unordered pair is counted twice\n    if not G.is_directed():\n        avg /= 2.0\n    return avg",
        "island_id": 0,
        "generation": 2,
        "train_score": 0.9999999999999999,
        "val_score": 0.6663680918461247,
        "simplicity_score": 0.2520335591305985,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g2_i0_p1_827631171",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For connected graphs this is the mean of the shortest path lengths over all\n    unordered pairs of distinct nodes.  For disconnected graphs the average is\n    taken over all reachable pairs only.  If the graph has no edges or only a\n    single node, the function returns 0.0.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    float\n        The average shortest path length.\n    \"\"\"\n    # Handle trivial cases\n    n = G.number_of_nodes()\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    # For each source node run a BFS to compute distances to all reachable nodes\n    for source in G.nodes():\n        dist = {source: 0}\n        queue = [source]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n\n        # Accumulate distances to all reachable nodes (excluding the source)\n        for target, d in dist.items():\n            if target == source:\n                continue\n            total_dist += d\n            pair_count += 1\n\n    if pair_count == 0:\n        return 0.0\n\n    avg = total_dist / pair_count\n    # For undirected graphs each unordered pair is counted twice\n    if not G.is_directed():\n        avg /= 2.0\n    return avg",
        "island_id": 0,
        "generation": 2,
        "train_score": 0.9999999999999999,
        "val_score": 0.6663680918461247,
        "simplicity_score": 0.2520335591305985,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g2_i0_p3_165229079",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For connected graphs this is the mean of the shortest path lengths over all\n    unordered pairs of distinct nodes.  For disconnected graphs the average is\n    taken over all reachable pairs only.  If the graph has no edges or only a\n    single node, the function returns 0.0.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    float\n        The average shortest path length.\n    \"\"\"\n    # Handle trivial cases\n    n = G.number_of_nodes()\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    # For each source node run a BFS to compute distances to all reachable nodes\n    for source in G.nodes():\n        dist = {source: 0}\n        queue = [source]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n\n        # Accumulate distances to all reachable nodes (excluding the source)\n        for target, d in dist.items():\n            if target == source:\n                continue\n            total_dist += d\n            pair_count += 1\n\n    if pair_count == 0:\n        return 0.0\n\n    avg = total_dist / pair_count\n    # For undirected graphs each unordered pair is counted twice\n    if not G.is_directed():\n        avg *= 2\n    return avg",
        "island_id": 0,
        "generation": 2,
        "train_score": 0.9999999999999999,
        "val_score": 0.6663680918461247,
        "simplicity_score": 0.2520335591305985,
        "novelty_bonus": 0.07980690010002534
      }
    ],
    "1": [
      {
        "id": "g2_i1_p2_970698024",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable directed pairs.\n    For undirected graphs, each unordered pair is counted once.\n    Unreachable pairs are ignored.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes)\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source}\n        queue = [(source, 0)]\n        while queue:\n            current, dist = queue.pop(0)\n            for neighbor in G.neighbors(current):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n                    total_dist += dist + 1\n                    pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # Each unordered pair was counted twice in the BFS loops\n        return 2 * total_dist / pair_count",
        "island_id": 1,
        "generation": 2,
        "train_score": 0.9999999999999999,
        "val_score": 0.6666372840718657,
        "simplicity_score": 0.25337952025930366,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g2_i1_p3_445687486",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n    For directed graphs, the average is taken over all reachable directed pairs.\n    For undirected graphs, each unordered pair is counted twice during the\n    computation, but the resulting average is the same as for the undirected case.\n    Unreachable pairs are ignored.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float\n        The average shortest path length, or 0.0 if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes)\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source}\n        queue = [(source, 0)]\n        while queue:\n            current, dist = queue.pop(0)\n            for neighbor in G.neighbors(current):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n                    total_dist += dist + 1\n                    pair_count += 1\n\n    if pair_count == 0:\n        return 0.0\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # For undirected graphs each unordered pair was counted twice\n        return 2 * total_dist / pair_count",
        "island_id": 1,
        "generation": 2,
        "train_score": 0.9999999999999999,
        "val_score": 0.6666372840718657,
        "simplicity_score": 0.25337952025930366,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g3_i1_p1_905535765",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable directed pairs.\n    For undirected graphs, each unordered pair is counted twice during the\n    computation, so the final average is multiplied by 2 to compensate.\n\n    Unreachable pairs are ignored.  If no pairs are reachable, None is returned.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes)\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source}\n        queue = [(source, 0)]\n        while queue:\n            current, dist = queue.pop(0)\n            for neighbor in G.neighbors(current):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n                    total_dist += dist + 1\n                    pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # For undirected graphs each unordered pair was counted twice\n        return 2 * total_dist / pair_count",
        "island_id": 1,
        "generation": 3,
        "train_score": 0.9999999999999999,
        "val_score": 0.6666372840718657,
        "simplicity_score": 0.25337952025930366,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g3_i1_p3_76343185",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable directed pairs.\n    For undirected graphs, each unordered pair is counted twice during the\n    computation, but the resulting average is the same as for the undirected case.\n    Unreachable pairs are ignored.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes)\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source}\n        queue = [(source, 0)]\n        while queue:\n            current, dist = queue.pop(0)\n            for neighbor in G.neighbors(current):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n                    total_dist += dist + 1\n                    pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        return 2 * total_dist / pair_count",
        "island_id": 1,
        "generation": 3,
        "train_score": 0.9999999999999999,
        "val_score": 0.6666372840718657,
        "simplicity_score": 0.25337952025930366,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g4_i1_p0_312366641",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable directed pairs.\n    For undirected graphs, each unordered pair is counted twice during the\n    computation, so the final average is multiplied by 2 to compensate.\n\n    Unreachable pairs are ignored.  If no pairs are reachable, None is returned.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes)\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source}\n        queue = [(source, 0)]\n        while queue:\n            current, dist = queue.pop(0)\n            for neighbor in G.neighbors(current):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n                    total_dist += dist + 1\n                    pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # For undirected graphs each unordered pair was counted twice\n        return 2 * total_dist / pair_count",
        "island_id": 1,
        "generation": 4,
        "train_score": 0.9999999999999999,
        "val_score": 0.6666372840718657,
        "simplicity_score": 0.25337952025930366,
        "novelty_bonus": 0.07980690010002534
      }
    ],
    "2": [
      {
        "id": "g2_i1_p2_970698024",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable directed pairs.\n    For undirected graphs, each unordered pair is counted once.\n    Unreachable pairs are ignored.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes)\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source}\n        queue = [(source, 0)]\n        while queue:\n            current, dist = queue.pop(0)\n            for neighbor in G.neighbors(current):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n                    total_dist += dist + 1\n                    pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # Each unordered pair was counted twice in the BFS loops\n        return 2 * total_dist / pair_count",
        "island_id": 1,
        "generation": 2,
        "train_score": 0.9999999999999999,
        "val_score": 0.6666372840718657,
        "simplicity_score": 0.25337952025930366,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g10_i2_p4_305956623",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable directed pairs.\n    For undirected graphs, each unordered pair is counted once.\n    Unreachable pairs are ignored.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes)\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source}\n        queue = [(source, 0)]\n        while queue:\n            current, dist = queue.pop(0)\n            for neighbor in G.neighbors(current):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n                    total_dist += dist + 1\n                    pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # Each unordered pair was counted twice in the BFS loops\n        return 2 * total_dist / pair_count",
        "island_id": 2,
        "generation": 10,
        "train_score": 0.9999999999999999,
        "val_score": 0.6666372840718657,
        "simplicity_score": 0.25337952025930366,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g11_i2_p0_584097968",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable ordered pairs.\n    For undirected graphs, each unordered pair is counted once.\n    Unreachable pairs are ignored.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes)\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        # Breadth‑first search from source\n        dist = {source: 0}\n        queue = [source]\n        while queue:\n            v = queue.pop(0)\n            d = dist[v]\n            for nb in G[v]:\n                if nb not in dist:\n                    dist[nb] = d + 1\n                    queue.append(nb)\n\n        # Accumulate distances to all reachable nodes\n        for target, d in dist.items():\n            if target == source:\n                continue\n            total_dist += d\n            pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # In an undirected graph each unordered pair was counted twice\n        return 2 * total_dist / pair_count",
        "island_id": 2,
        "generation": 11,
        "train_score": 0.9999999999999999,
        "val_score": 0.6664450497341566,
        "simplicity_score": 0.2524183485707579,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g10_i2_p2_202363364",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable ordered pairs.\n    For undirected graphs, each unordered pair is counted once.\n    Unreachable pairs are ignored.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes())\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source: 0}\n        queue = [source]\n        while queue:\n            v = queue.pop(0)\n            d = visited[v]\n            for nb in G[v]:\n                if nb not in visited:\n                    visited[nb] = d + 1\n                    queue.append(nb)\n\n        for target, dist in visited.items():\n            if target == source:\n                continue\n            total_dist += dist\n            pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # Each unordered pair was counted twice\n        return 2 * total_dist / pair_count",
        "island_id": 2,
        "generation": 10,
        "train_score": 0.9999999999999999,
        "val_score": 0.6664338096662339,
        "simplicity_score": 0.25236214823114467,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g11_i2_p4_84444320",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable directed pairs.\n    For undirected graphs, each unordered pair is counted once.\n    Unreachable pairs are ignored.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes())\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        dist = {source: 0}\n        queue = [source]\n        while queue:\n            v = queue.pop(0)\n            d = dist[v]\n            for nb in G[v]:\n                if nb not in dist:\n                    dist[nb] = d + 1\n                    queue.append(nb)\n\n        for t, d in dist.items():\n            if t == source:\n                continue\n            total_dist += d\n            pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # Each unordered pair was counted twice\n        return 2 * total_dist / pair_count",
        "island_id": 2,
        "generation": 11,
        "train_score": 0.9999999999999999,
        "val_score": 0.6664338096662339,
        "simplicity_score": 0.25236214823114467,
        "novelty_bonus": 0.07980690010002534
      }
    ],
    "3": [
      {
        "id": "g8_i3_p3_495625870",
        "code": "def new_invariant(G):\n    nodes = list(G.nodes())\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    idx = {node: i for i, node in enumerate(nodes)}\n    total = 0\n    pairs = 0\n\n    for src in nodes:\n        dist = {src: 0}\n        queue = [src]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n\n        si = idx[src]\n        for tgt, d in dist.items():\n            if tgt == src:\n                continue\n            if idx[tgt] > si:  # count each unordered pair only once\n                total += d\n                pairs += 1\n\n    if pairs == 0:\n        return 0.0\n    return total / pairs",
        "island_id": 3,
        "generation": 8,
        "train_score": 0.9999999999999999,
        "val_score": 0.6498343399386541,
        "simplicity_score": 0.16936479959324566,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g4_i3_p2_139752483",
        "code": "def new_invariant(G):\n    nodes = list(G.nodes())\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n    idx = {node: i for i, node in enumerate(nodes)}\n    total = 0\n    pairs = 0\n    for src in nodes:\n        dist = {src: 0}\n        queue = [src]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            du = dist[u]\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = du + 1\n                    queue.append(v)\n        si = idx[src]\n        for tgt, d in dist.items():\n            if tgt == src:\n                continue\n            ti = idx[tgt]\n            if ti > si:\n                total += d\n                pairs += 1\n    if pairs == 0:\n        return 0.0\n    return total / pairs",
        "island_id": 3,
        "generation": 4,
        "train_score": 0.9999999999999999,
        "val_score": 0.6497482368633731,
        "simplicity_score": 0.16893428421684087,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g6_i3_p1_436717389",
        "code": "def new_invariant(G):\n    nodes = list(G.nodes())\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n    idx = {node: i for i, node in enumerate(nodes)}\n    total = 0\n    pairs = 0\n    for src in nodes:\n        dist = {src: 0}\n        queue = [src]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            du = dist[u]\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = du + 1\n                    queue.append(v)\n        si = idx[src]\n        for tgt, d in dist.items():\n            if tgt == src:\n                continue\n            ti = idx[tgt]\n            if ti > si:\n                total += d\n                pairs += 1\n    if pairs == 0:\n        return 0.0\n    return total / pairs",
        "island_id": 3,
        "generation": 6,
        "train_score": 0.9999999999999999,
        "val_score": 0.6497482368633731,
        "simplicity_score": 0.16893428421684087,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g9_i3_p0_457417486",
        "code": "def new_invariant(G):\n    nodes = list(G.nodes())\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    idx = {node: i for i, node in enumerate(nodes)}\n    total = 0\n    pairs = 0\n\n    for src in nodes:\n        dist = {src: 0}\n        queue = [src]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            du = dist[u]\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = du + 1\n                    queue.append(v)\n\n        si = idx[src]\n        for tgt, d in dist.items():\n            if tgt == src:\n                continue\n            ti = idx[tgt]\n            if ti > si:\n                total += d\n                pairs += 1\n\n    if pairs == 0:\n        return 0.0\n    return total / pairs",
        "island_id": 3,
        "generation": 9,
        "train_score": 0.9999999999999999,
        "val_score": 0.6497482368633731,
        "simplicity_score": 0.16893428421684087,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g10_i3_p3_176772782",
        "code": "def new_invariant(G):\n    nodes = list(G.nodes())\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n    idx = {node: i for i, node in enumerate(nodes)}\n    total = 0\n    pairs = 0\n    for src in nodes:\n        dist = {src: 0}\n        queue = [src]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            du = dist[u]\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = du + 1\n                    queue.append(v)\n        si = idx[src]\n        for tgt, d in dist.items():\n            if tgt == src:\n                continue\n            ti = idx[tgt]\n            if ti > si:\n                total += d\n                pairs += 1\n    if pairs == 0:\n        return 0.0\n    return total / pairs",
        "island_id": 3,
        "generation": 10,
        "train_score": 0.9999999999999999,
        "val_score": 0.6497482368633731,
        "simplicity_score": 0.16893428421684087,
        "novelty_bonus": 0.07980690010002534
      }
    ]
  }
}