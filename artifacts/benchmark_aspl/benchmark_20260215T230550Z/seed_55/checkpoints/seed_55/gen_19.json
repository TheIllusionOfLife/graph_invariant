{
  "experiment_id": "seed_55",
  "generation": 19,
  "rng_seed": 55,
  "rng_state": {
    "bit_generator": "PCG64",
    "state": {
      "state": 250274908882721608979029420398373375270,
      "inc": 34071122550715517884140988759125521119
    },
    "has_uint32": 0,
    "uinteger": 1921796465
  },
  "best_val_score": 0.5706469319419225,
  "no_improve_count": 3,
  "island_stagnation": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_prompt_mode": {
    "0": "free",
    "1": "free",
    "2": "free",
    "3": "free"
  },
  "island_constrained_generations": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_recent_failures": {
    "0": [
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "no_valid_train_predictions: runtime_exception: AttributeError: 'float' object has no attribute 'bit_length'",
      "below_novelty_threshold: novelty_bonus=0.148435"
    ],
    "1": [
      "below_train_threshold: train_signal=0.137863",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_train_threshold: train_signal=0.265978"
    ],
    "2": [
      "below_novelty_threshold: novelty_bonus=0.102123",
      "below_novelty_threshold: novelty_bonus=0.111091",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ],
    "3": [
      "below_novelty_threshold: novelty_bonus=0.104613",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_novelty_threshold: novelty_bonus=0.110470"
    ]
  },
  "islands": {
    "0": [
      {
        "id": "g17_i0_p1_189721748",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines logarithmic size, degree, density, clustering,\n    triangle density, degree heterogeneity, assortativity, and a harmonic\n    mean of degrees.  Only built‑in Python operations are used.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    # Basic graph statistics\n    n          = s['n']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_clust  = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # ------------------------------------------------------------------\n    # 1. Logarithmic base (size vs. average degree)\n    # ------------------------------------------------------------------\n    log_n = n.bit_length() - 1\n    avg_deg_int = int(avg_deg) if avg_deg > 0 else 1\n    log_avg_deg = avg_deg_int.bit_length() - 1\n    base = log_n / max(1, log_avg_deg)\n\n    # ------------------------------------------------------------------\n    # 2. Adjust for connectivity (density) and clustering\n    # ------------------------------------------------------------------\n    base *= (1 + density) ** -0.4\n    base *= (1 + avg_clust) ** -0.2\n\n    # ------------------------------------------------------------------\n    # 3. Triangle density factor\n    # ------------------------------------------------------------------\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n        tri_frac = num_tri / (possible_tri + eps)\n    else:\n        tri_frac = 0.0\n    base *= (1 + tri_frac) ** -0.3\n\n    # ------------------------------------------------------------------\n    # 4. Assortativity and degree heterogeneity corrections\n    # ------------------------------------------------------------------\n    base *= (1 + abs(assort)) ** 0.05\n    if max_deg > 0:\n        base *= (1 + std_deg / max_deg) ** 0.1\n\n    # ------------------------------------------------------------------\n    # 5. Max/min degree ratio adjustment\n    # ------------------------------------------------------------------\n    if min_deg > 0:\n        base *= (1 + max_deg / min_deg) ** -0.05\n\n    # ------------------------------------------------------------------\n    # 6. Harmonic mean of degrees (captures prevalence of low‑degree nodes)\n    # ------------------------------------------------------------------\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            if d > 0:\n                inv_sum += 1.0 / (d + eps)\n        harmonic_mean = n / (inv_sum + eps)\n        base += harmonic_mean / (max_deg + 1)\n\n    return base",
        "island_id": 0,
        "generation": 17,
        "train_score": 0.6207442977190877,
        "val_score": 0.4493575775400958,
        "simplicity_score": 0.21961625809647964,
        "novelty_bonus": 0.16966820858072063
      },
      {
        "id": "g17_i0_p3_46099150",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines logarithmic size, degree, density, clustering,\n    triangle density, degree heterogeneity, assortativity, and a harmonic\n    mean of degrees.  Only built‑in Python operations are used.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    # Basic graph statistics\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg = s['avg_degree']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Logarithmic approximations using bit length (base‑2)\n    log_n = n.bit_length() - 1\n    avg_deg_int = int(avg_deg) if avg_deg > 0 else 1\n    log_avg_deg = avg_deg_int.bit_length() - 1\n\n    # Base estimate from random‑graph intuition\n    base = log_n / max(1, log_avg_deg)\n\n    # Adjust for density: denser graphs have shorter paths\n    base *= (1 + density) ** -0.4\n\n    # Adjust for clustering: higher clustering can reduce path length\n    base *= (1 + avg_clust) ** -0.2\n\n    # Triangle fraction adjustment\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n        tri_frac = num_tri / (possible_tri + eps)\n    else:\n        tri_frac = 0.0\n    base *= (1 + tri_frac) ** -0.3\n\n    # Degree heterogeneity adjustment\n    if max_deg > 0:\n        base *= (1 + std_deg / max_deg) ** 0.1\n\n    # Assortativity adjustment\n    base *= (1 + abs(assort)) ** 0.05\n\n    # Max/min degree ratio adjustment\n    if min_deg > 0:\n        base *= (1 + max_deg / min_deg) ** -0.05\n\n    # Harmonic mean of degrees contribution\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            if d > 0:\n                inv_sum += 1.0 / (d + eps)\n        harmonic_mean = n / (inv_sum + eps)\n        base += harmonic_mean / (max_deg + 1)\n\n    return base",
        "island_id": 0,
        "generation": 17,
        "train_score": 0.6207442977190877,
        "val_score": 0.4493209320671065,
        "simplicity_score": 0.2194330307315332,
        "novelty_bonus": 0.16966820858072063
      },
      {
        "id": "g11_i0_p0_892090119",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a non‑linear combination of size, density, clustering,\n    triangle density, assortativity, degree heterogeneity and the harmonic\n    mean of degrees.  Only built‑in Python operations are used – no imports,\n    no graph traversal, no external libraries.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    # Basic graph statistics\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_clust  = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    degs       = s['degrees']\n\n    # ------------------------------------------------------------------\n    # 1. Logarithmic base (size vs. average degree)\n    # ------------------------------------------------------------------\n    log_n = n.bit_length() - 1\n    # Convert avg_deg to int for bit_length; guard against zero\n    avg_deg_int = int(avg_deg) if avg_deg > 0 else 1\n    log_avg_deg = avg_deg_int.bit_length() - 1\n    base = log_n / max(1, log_avg_deg)\n\n    # ------------------------------------------------------------------\n    # 2. Adjust for connectivity (density) and clustering\n    # ------------------------------------------------------------------\n    base *= (1 + density) ** -0.4\n    base *= (1 + avg_clust) ** -0.2\n\n    # ------------------------------------------------------------------\n    # 3. Triangle density factor\n    # ------------------------------------------------------------------\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n        tri_frac = num_tri / (possible_tri + eps)\n    else:\n        tri_frac = 0.0\n    base *= (1 + tri_frac) ** -0.3\n\n    # ------------------------------------------------------------------\n    # 4. Assortativity and degree heterogeneity corrections\n    # ------------------------------------------------------------------\n    base *= (1 + abs(assort)) ** 0.05\n    if max_deg > 0:\n        base *= (1 + std_deg / max_deg) ** 0.1\n\n    # ------------------------------------------------------------------\n    # 5. Harmonic mean of degrees (captures prevalence of low‑degree nodes)\n    # ------------------------------------------------------------------\n    if degs:\n        inv_sum = 0.0\n        for d in degs:\n            if d > 0:\n                inv_sum += 1.0 / (d + eps)\n        harmonic_mean = n / (inv_sum + eps)\n        base += harmonic_mean / (max_deg + 1)\n\n    return base",
        "island_id": 0,
        "generation": 11,
        "train_score": 0.634765906362545,
        "val_score": 0.448213702862429,
        "simplicity_score": 0.21980506886437962,
        "novelty_bonus": 0.1596567673269358
      },
      {
        "id": "g16_i0_p4_205046971",
        "code": "def new_invariant(s):\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg = s['avg_degree']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    eps = 1e-12\n\n    log_n = n.bit_length() - 1\n    avg_deg_int = int(avg_deg)\n    log_avg_deg = avg_deg_int.bit_length() - 1 if avg_deg_int > 0 else 1\n\n    base = log_n / max(log_avg_deg, 1)\n\n    base *= (1 + density) ** -0.5\n    base *= (1 + avg_clust) ** -0.25\n\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n        tri_frac = num_tri / (possible_tri + eps)\n    else:\n        tri_frac = 0.0\n    base *= (1 + tri_frac) ** -0.2\n\n    if max_deg > 0:\n        base *= (1 + std_deg / max_deg) ** 0.1\n\n    base *= (1 + abs(assort)) ** 0.05\n\n    if min_deg > 0:\n        base *= (1 + max_deg / min_deg) ** -0.05\n\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            if d > 0:\n                inv_sum += 1.0 / (d + eps)\n        harmonic_mean = n / (inv_sum + eps)\n        base += harmonic_mean / (max_deg + 1)\n\n    return base",
        "island_id": 0,
        "generation": 16,
        "train_score": 0.6189195678271309,
        "val_score": 0.44669476528929325,
        "simplicity_score": 0.21947833032914538,
        "novelty_bonus": 0.17144438359620162
      },
      {
        "id": "g11_i0_p3_15789510",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines logarithmic size, degree, density, clustering,\n    triangle density, degree heterogeneity, assortativity, and a harmonic\n    mean of degrees.  Only built‑in Python operations are used.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Logarithmic approximations using bit length (base‑2)\n    log_n = n.bit_length() - 1\n    avg_deg_int = int(avg_deg) if avg_deg > 0 else 1\n    log_avg_deg = avg_deg_int.bit_length() - 1\n\n    # Base estimate from random‑graph intuition\n    base = log_n / max(1, log_avg_deg)\n\n    # Adjust for density: denser graphs have shorter paths\n    base *= (1 + density) ** -0.5\n\n    # Adjust for clustering: higher clustering can reduce path length\n    base *= (1 + avg_clust) ** -0.25\n\n    # Triangle fraction adjustment\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n        tri_frac = num_tri / (possible_tri + eps)\n    else:\n        tri_frac = 0.0\n    base *= (1 + tri_frac) ** -0.2\n\n    # Degree heterogeneity adjustment\n    if max_deg > 0:\n        base *= (1 + std_deg / max_deg) ** 0.1\n\n    # Assortativity adjustment\n    base *= (1 + abs(assort)) ** 0.05\n\n    # Max/min degree ratio adjustment\n    if min_deg > 0:\n        base *= (1 + max_deg / min_deg) ** -0.05\n\n    # Harmonic mean of degrees contribution\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            if d > 0:\n                inv_sum += 1.0 / (d + eps)\n        harmonic_mean = n / (inv_sum + eps)\n        base += harmonic_mean / (max_deg + 1)\n\n    return base",
        "island_id": 0,
        "generation": 11,
        "train_score": 0.6189195678271309,
        "val_score": 0.44665011870634924,
        "simplicity_score": 0.2192550974144253,
        "novelty_bonus": 0.17144438359620162
      }
    ],
    "1": [
      {
        "id": "g3_i1_p2_588779643",
        "code": "def new_invariant(s):\n    \"\"\"\n    Composite graph invariant combining size, density, degree distribution,\n    clustering, triangle density, and assortativity.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_cluster = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n\n    # Triangle density\n    possible_triangles = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    triangle_ratio = triangles / possible_triangles\n\n    # Size‑to‑edge ratio\n    size_edge_ratio = n / (m + 1)\n\n    # Degree spread and variability\n    denom = max_deg + 1\n    degree_spread = (max_deg - min_deg + 1) / denom\n    degree_variability = 1 + std_deg / denom\n    degree_factor = (avg_deg / denom) * degree_spread * degree_variability\n\n    # Clustering dampening\n    clustering_factor = (1 + avg_cluster) / (1 + trans)\n\n    # Triangle factor\n    triangle_factor = triangle_ratio + 0.1\n\n    # Assortativity influence\n    assort_factor = 1 + abs(assort)\n\n    # Size scaling\n    size_factor = n ** 0.5\n\n    # Combine all components multiplicatively\n    return (\n        size_edge_ratio *\n        degree_factor *\n        clustering_factor *\n        triangle_factor *\n        assort_factor *\n        size_factor\n    )",
        "island_id": 1,
        "generation": 3,
        "train_score": 0.7029531812725089,
        "val_score": 0.4606304153733223,
        "simplicity_score": 0.12250856077870916,
        "novelty_bonus": 0.185688142203555
      },
      {
        "id": "g4_i1_p2_57376479",
        "code": "def new_invariant(s):\n    \"\"\"\n    Composite graph invariant combining size, density, degree distribution,\n    clustering, triangle density, and assortativity into a single scalar.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_cluster= s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # Triangle density (ratio of existing to possible triangles)\n    possible_triangles = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    triangle_ratio = triangles / possible_triangles\n\n    # Component 1 – size‑to‑edge ratio\n    size_edge_ratio = n / (m + 1.0)\n\n    # Component 2 – degree spread and variability\n    denom = max_deg + 1.0\n    degree_spread = (max_deg - min_deg + 1.0) / denom\n    degree_variability = 1.0 + std_deg / denom\n    degree_factor = (avg_deg / denom) * degree_spread * degree_variability\n\n    # Component 3 – clustering dampening (local vs global)\n    clustering_factor = (1.0 + avg_cluster) / (1.0 + trans)\n\n    # Component 4 – triangle density boost\n    triangle_factor = triangle_ratio + 0.1\n\n    # Component 5 – assortativity influence\n    assort_factor = 1.0 + abs(assort)\n\n    # Component 6 – size scaling\n    size_factor = n ** 0.5\n\n    # Combine all components multiplicatively\n    return (\n        size_edge_ratio *\n        degree_factor *\n        clustering_factor *\n        triangle_factor *\n        assort_factor *\n        size_factor\n    )",
        "island_id": 1,
        "generation": 4,
        "train_score": 0.7029531812725089,
        "val_score": 0.4606304153733223,
        "simplicity_score": 0.12250856077870916,
        "novelty_bonus": 0.185688142203555
      },
      {
        "id": "g8_i1_p0_185420240",
        "code": "def new_invariant(s):\n    \"\"\"\n    Composite graph invariant that blends size, density, degree distribution,\n    clustering, triangle density, and assortativity into a single scalar.\n    \"\"\"\n    # Basic statistics\n    n          = s['n']\n    m          = s['m']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_cluster= s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # Triangle density (ratio of existing to possible triangles)\n    possible_triangles = (n * (n - 1) * (n - 2) / 6.0) if n > 2 else 1.0\n    triangle_ratio = triangles / possible_triangles\n\n    # Component 1 – size‑to‑edge ratio\n    size_edge_ratio = n / (m + 1.0)\n\n    # Component 2 – degree spread and variability\n    denom = max_deg + 1.0\n    degree_spread = (max_deg - min_deg + 1.0) / denom\n    degree_variability = 1.0 + std_deg / denom\n    degree_factor = (avg_deg / denom) * degree_spread * degree_variability\n\n    # Component 3 – clustering dampening (local vs global)\n    clustering_factor = (1.0 + avg_cluster) / (1.0 + trans)\n\n    # Component 4 – triangle density boost\n    triangle_factor = triangle_ratio + 0.1\n\n    # Component 5 – assortativity influence\n    assort_factor = 1.0 + abs(assort)\n\n    # Component 6 – size scaling\n    size_factor = n ** 0.5\n\n    # Combine all components multiplicatively\n    return (\n        size_edge_ratio *\n        degree_factor *\n        clustering_factor *\n        triangle_factor *\n        assort_factor *\n        size_factor\n    )",
        "island_id": 1,
        "generation": 8,
        "train_score": 0.7029531812725089,
        "val_score": 0.4606304153733223,
        "simplicity_score": 0.12250856077870916,
        "novelty_bonus": 0.185688142203555
      },
      {
        "id": "g9_i1_p1_110019618",
        "code": "def new_invariant(s):\n    \"\"\"\n    Composite graph invariant that blends size, density, degree distribution,\n    clustering, triangle density, and assortativity into a single scalar.\n    \"\"\"\n    # Basic statistics\n    n          = s['n']\n    m          = s['m']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_cluster= s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # Triangle density (ratio of existing to possible triangles)\n    possible_triangles = (n * (n - 1) * (n - 2) / 6.0) if n > 2 else 1.0\n    triangle_ratio = triangles / possible_triangles\n\n    # Component 1 – size‑to‑edge ratio\n    size_edge_ratio = n / (m + 1.0)\n\n    # Component 2 – degree spread and variability\n    denom = max_deg + 1.0\n    degree_spread = (max_deg - min_deg + 1.0) / denom\n    degree_variability = 1.0 + std_deg / denom\n    degree_factor = (avg_deg / denom) * degree_spread * degree_variability\n\n    # Component 3 – clustering dampening (local vs global)\n    clustering_factor = (1.0 + avg_cluster) / (1.0 + trans)\n\n    # Component 4 – triangle density boost\n    triangle_factor = triangle_ratio + 0.1\n\n    # Component 5 – assortativity influence\n    assort_factor = 1.0 + abs(assort)\n\n    # Component 6 – size scaling\n    size_factor = n ** 0.5\n\n    # Combine all components multiplicatively\n    return (\n        size_edge_ratio *\n        degree_factor *\n        clustering_factor *\n        triangle_factor *\n        assort_factor *\n        size_factor\n    )",
        "island_id": 1,
        "generation": 9,
        "train_score": 0.7029531812725089,
        "val_score": 0.4606304153733223,
        "simplicity_score": 0.12250856077870916,
        "novelty_bonus": 0.185688142203555
      },
      {
        "id": "g9_i1_p2_528696959",
        "code": "def new_invariant(s):\n    \"\"\"\n    Composite graph invariant that blends size, density, degree distribution,\n    clustering, triangle density, and assortativity into a single scalar.\n    \"\"\"\n    # Basic statistics\n    n          = s['n']\n    m          = s['m']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_cluster= s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # Triangle density (ratio of existing to possible triangles)\n    possible_triangles = (n * (n - 1) * (n - 2) / 6.0) if n > 2 else 1.0\n    triangle_ratio = triangles / possible_triangles\n\n    # Component 1 – size‑to‑edge ratio\n    size_edge_ratio = n / (m + 1.0)\n\n    # Component 2 – degree spread and variability\n    denom = max_deg + 1.0\n    degree_spread = (max_deg - min_deg + 1.0) / denom\n    degree_variability = 1.0 + std_deg / denom\n    degree_factor = (avg_deg / denom) * degree_spread * degree_variability\n\n    # Component 3 – clustering dampening (local vs global)\n    clustering_factor = (1.0 + avg_cluster) / (1.0 + trans)\n\n    # Component 4 – triangle density boost\n    triangle_factor = triangle_ratio + 0.1\n\n    # Component 5 – assortativity influence\n    assort_factor = 1.0 + abs(assort)\n\n    # Component 6 – size scaling\n    size_factor = n ** 0.5\n\n    # Combine all components multiplicatively\n    return (\n        size_edge_ratio *\n        degree_factor *\n        clustering_factor *\n        triangle_factor *\n        assort_factor *\n        size_factor\n    )",
        "island_id": 1,
        "generation": 9,
        "train_score": 0.7029531812725089,
        "val_score": 0.4606304153733223,
        "simplicity_score": 0.12250856077870916,
        "novelty_bonus": 0.185688142203555
      }
    ],
    "2": [
      {
        "id": "g15_i2_p4_284573368",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a dictionary of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            n (int)                     – number of nodes\n            m (int)                     – number of edges\n            density (float)             – edge density\n            avg_degree (float)          – average degree\n            max_degree (int)            – maximum degree\n            min_degree (int)            – minimum degree\n            std_degree (float)          – standard deviation of degrees\n            avg_clustering (float)      – average clustering coefficient\n            transitivity (float)        – global transitivity\n            degree_assortativity (float)- degree assortativity coefficient\n            num_triangles (int)         – total number of triangles\n            degrees (list[int])         – sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    if n <= 1:\n        return 0.0\n\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 1)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    tri        = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # Core connectivity term: higher density and average degree shorten paths\n    denom_conn = max(avg_deg, 1e-6) * max(density, 1e-6)\n    base = n / denom_conn\n\n    # Shortcuts from clustering and transitivity\n    base *= (1.0 + avg_clust + trans)\n\n    # Effect of assortativity (magnitude only)\n    base *= (1.0 + abs(assort))\n\n    # Triangle density adjustment\n    if m > 0:\n        base *= (1.0 + tri / m)\n\n    # Normalise by degree heterogeneity\n    base /= (1.0 + std_deg / max(avg_deg, 1e-6))\n    base /= (1.0 + min_deg / max(avg_deg, 1e-6))\n\n    # Penalise very high maximum degree\n    base /= (max_deg + 1.0)\n\n    # Median degree adjustment – captures skewness of the degree distribution\n    if degrees:\n        median_deg = degrees[len(degrees) // 2]\n        base *= (1.0 + (avg_deg - median_deg) / max(avg_deg, 1e-6))\n\n    return base",
        "island_id": 2,
        "generation": 15,
        "train_score": 0.9772388955582233,
        "val_score": 0.5706469319419225,
        "simplicity_score": 0.22113343699055302,
        "novelty_bonus": 0.18877249943814667
      },
      {
        "id": "g18_i2_p0_448558859",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a dictionary of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            n (int)                     – number of nodes\n            m (int)                     – number of edges\n            density (float)             – edge density\n            avg_degree (float)          – average degree\n            max_degree (int)            – maximum degree\n            min_degree (int)            – minimum degree\n            std_degree (float)          – standard deviation of degrees\n            avg_clustering (float)      – average clustering coefficient\n            transitivity (float)        – global transitivity\n            degree_assortativity (float)- degree assortativity coefficient\n            num_triangles (int)         – total number of triangles\n            degrees (list[int])         – sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    if n <= 1:\n        return 0.0\n\n    m = s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_deg = max(s.get('avg_degree', 0.0), 1e-6)\n\n    # Core connectivity term\n    base = n / (avg_deg * density + 1e-6)\n\n    # Shortcuts from clustering and transitivity\n    base *= 1.0 + s.get('avg_clustering', 0.0) + s.get('transitivity', 0.0)\n\n    # Effect of assortativity (magnitude only)\n    base *= 1.0 + abs(s.get('degree_assortativity', 0.0))\n\n    # Triangle density adjustment\n    tri = s.get('num_triangles', 0)\n    if m > 0:\n        base *= 1.0 + tri / m\n\n    # Normalize by degree heterogeneity\n    std_deg = s.get('std_degree', 0.0)\n    base /= 1.0 + std_deg / avg_deg\n    min_deg = s.get('min_degree', 0)\n    base /= 1.0 + min_deg / avg_deg\n\n    # Penalise very high maximum degree\n    max_deg = max(s.get('max_degree', 1), 1)\n    base /= (max_deg + 1.0)\n\n    # Median degree adjustment – captures skewness of the degree distribution\n    degrees = s.get('degrees', [])\n    if degrees:\n        median_deg = degrees[len(degrees) // 2]\n        base *= 1.0 + (avg_deg - median_deg) / avg_deg\n\n    # Edge‑count scaling – more edges generally reduce path length\n    base *= 1.0 + (m ** 0.5) / (n + 1e-6)\n\n    return base",
        "island_id": 2,
        "generation": 18,
        "train_score": 0.9760864345738295,
        "val_score": 0.5679812533719109,
        "simplicity_score": 0.2214354802823629,
        "novelty_bonus": 0.18032055788563106
      },
      {
        "id": "g14_i2_p0_892500570",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a dictionary of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            n (int)                     – number of nodes\n            m (int)                     – number of edges\n            density (float)             – edge density\n            avg_degree (float)          – average degree\n            max_degree (int)            – maximum degree\n            min_degree (int)            – minimum degree\n            std_degree (float)          – standard deviation of degrees\n            avg_clustering (float)      – average clustering coefficient\n            transitivity (float)        – global transitivity\n            degree_assortativity (float)- degree assortativity coefficient\n            num_triangles (int)         – total number of triangles\n            degrees (list[int])         – sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    if n <= 1:\n        return 0.0\n\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 1)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    tri        = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # Core connectivity term: higher density/average degree shortens paths\n    denom_conn = max(avg_deg, 1e-6) * max(density, 1e-6)\n    base = n / denom_conn\n\n    # Shortcuts from clustering and transitivity\n    base *= (1.0 + avg_clust + trans)\n\n    # Effect of assortativity (magnitude only)\n    base *= (1.0 + abs(assort))\n\n    # Triangle density adjustment\n    if m > 0:\n        base *= (1.0 + tri / m)\n\n    # Normalize by degree heterogeneity\n    base /= (1.0 + std_deg / max(avg_deg, 1e-6))\n    base /= (1.0 + min_deg / max(avg_deg, 1e-6))\n\n    # Penalise very high maximum degree\n    base /= (max_deg + 1.0)\n\n    # Median degree adjustment – captures skewness of the degree distribution\n    if degrees:\n        median_deg = degrees[len(degrees) // 2]\n        base *= (1.0 + (avg_deg - median_deg) / max(avg_deg, 1e-6))\n\n    # Edge‑count scaling – more edges generally reduce path length\n    base *= (1.0 + (m ** 0.5) / (n + 1e-6))\n\n    return base",
        "island_id": 2,
        "generation": 14,
        "train_score": 0.9760864345738295,
        "val_score": 0.567813274909468,
        "simplicity_score": 0.2205955879701489,
        "novelty_bonus": 0.18032055788563106
      },
      {
        "id": "g17_i2_p0_798753596",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a dictionary of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            n (int)                     – number of nodes\n            m (int)                     – number of edges\n            density (float)             – edge density\n            avg_degree (float)          – average degree\n            max_degree (int)            – maximum degree\n            min_degree (int)            – minimum degree\n            std_degree (float)          – standard deviation of degrees\n            avg_clustering (float)      – average clustering coefficient\n            transitivity (float)        – global transitivity\n            degree_assortativity (float)- degree assortativity coefficient\n            num_triangles (int)         – total number of triangles\n            degrees (list[int])         – sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    if n <= 1:\n        return 0.0\n\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 1)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    tri        = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # Base connectivity term: larger density or average degree shortens paths\n    denom_conn = max(avg_deg, 1e-6) * max(density, 1e-6)\n    base = n / denom_conn\n\n    # Shortcuts from clustering and transitivity\n    base *= (1.0 + avg_clust + trans)\n\n    # Effect of assortativity (magnitude only)\n    base *= (1.0 + abs(assort))\n\n    # Triangle density adjustment\n    if m > 0:\n        base *= (1.0 + tri / m)\n\n    # Normalize by degree heterogeneity\n    base /= (1.0 + std_deg / max(avg_deg, 1e-6))\n    base /= (1.0 + min_deg / max(avg_deg, 1e-6))\n\n    # Penalise very high maximum degree\n    base /= (max_deg + 1.0)\n\n    # Median degree adjustment – captures skewness of the degree distribution\n    if degrees:\n        median_deg = degrees[len(degrees) // 2]\n        base *= (1.0 + (avg_deg - median_deg) / max(avg_deg, 1e-6))\n\n    # Edge‑count scaling – more edges generally reduce path length\n    base *= (1.0 + (m ** 0.5) / (n + 1e-6))\n\n    return base",
        "island_id": 2,
        "generation": 17,
        "train_score": 0.9760864345738295,
        "val_score": 0.567813274909468,
        "simplicity_score": 0.2205955879701489,
        "novelty_bonus": 0.18032055788563106
      },
      {
        "id": "g17_i2_p1_208284614",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a dictionary of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            n (int)                     – number of nodes\n            m (int)                     – number of edges\n            density (float)             – edge density\n            avg_degree (float)          – average degree\n            max_degree (int)            – maximum degree\n            min_degree (int)            – minimum degree\n            std_degree (float)          – standard deviation of degrees\n            avg_clustering (float)      – average clustering coefficient\n            transitivity (float)        – global transitivity\n            degree_assortativity (float)- degree assortativity coefficient\n            num_triangles (int)         – total number of triangles\n            degrees (list[int])         – sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic graph size\n    n = s.get('n', 1)\n    if n <= 1:\n        return 0.0\n\n    # Retrieve statistics with safe defaults\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 1)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    tri        = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # ------------------------------------------------------------------\n    # 1. Base connectivity term – larger n or sparser graphs give longer\n    #    paths.  The denominator is a product of average degree and\n    #    density; we guard against zero with tiny constants.\n    # ------------------------------------------------------------------\n    denom_conn = max(avg_deg, 1e-6) * max(density, 1e-6)\n    base = n / denom_conn\n\n    # ------------------------------------------------------------------\n    # 2. Shortcuts from clustering and transitivity – they reduce path\n    #    length.\n    # ------------------------------------------------------------------\n    base *= (1.0 + avg_clust + trans)\n\n    # ------------------------------------------------------------------\n    # 3. Effect of assortativity – we treat the magnitude symmetrically.\n    # ------------------------------------------------------------------\n    base *= (1.0 + abs(assort))\n\n    # ------------------------------------------------------------------\n    # 4. Triangle density – more triangles usually provide additional\n    #    short cuts.\n    # ------------------------------------------------------------------\n    if m > 0:\n        base *= (1.0 + tri / m)\n\n    # ------------------------------------------------------------------\n    # 5. Degree heterogeneity – a very wide degree spread (many hubs)\n    #    typically shortens paths, so we divide by the spread.\n    # ------------------------------------------------------------------\n    base /= (1.0 + std_deg / max(avg_deg, 1e-6))\n    base /= (1.0 + min_deg / max(avg_deg, 1e-6))\n\n    # ------------------------------------------------------------------\n    # 6. Penalise an extremely high maximum degree (few hubs) to avoid\n    #    over‑shortening.\n    # ------------------------------------------------------------------\n    base /= (max_deg + 1.0)\n\n    # ------------------------------------------------------------------\n    # 7. Median degree adjustment – captures skewness of the degree\n    #    distribution.\n    # ------------------------------------------------------------------\n    if degrees:\n        median_deg = degrees[len(degrees) // 2]\n        base *= (1.0 + (avg_deg - median_deg) / max(avg_deg, 1e-6))\n\n    # ------------------------------------------------------------------\n    # 8. Edge‑count scaling – more edges generally reduce path length.\n    # ------------------------------------------------------------------\n    base *= (1.0 + (m ** 0.5) / (n + 1e-6))\n\n    return base",
        "island_id": 2,
        "generation": 17,
        "train_score": 0.9760864345738295,
        "val_score": 0.567813274909468,
        "simplicity_score": 0.2205955879701489,
        "novelty_bonus": 0.18032055788563106
      }
    ],
    "3": [
      {
        "id": "g5_i2_p4_26965764",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The formula starts with the graph size divided by a connectivity term and\n    then applies multiplicative adjustments for clustering, assortativity,\n    triangle density, and normalises by degree heterogeneity and maximum\n    degree.  No external libraries are required.\n    \"\"\"\n    n = s.get('n', 1)\n    if n <= 1:\n        return 0.0\n\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 1)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    tri        = s.get('num_triangles', 0)\n\n    # Connectivity denominator – higher density and average degree shorten paths\n    denom_conn = max(avg_deg, 1e-6) * max(density, 1e-6)\n    base = n / denom_conn\n\n    # Clustering creates shortcuts\n    base *= (1.0 + avg_clust)\n\n    # Assortativity affects path length – treat magnitude symmetrically\n    base *= (1.0 + abs(assort))\n\n    # Triangle density – more triangles usually reduce average distance\n    if m > 0:\n        base *= (1.0 + tri / m)\n\n    # Degree heterogeneity – highly heterogeneous networks (hubs) typically\n    # have shorter paths, so we divide by the spread\n    base /= (1.0 + std_deg / max(avg_deg, 1e-6))\n    base /= (1.0 + min_deg / max(avg_deg, 1e-6))\n\n    # Penalise very high maximum degree (few hubs) to avoid over‑shortening\n    base /= (max_deg + 1.0)\n\n    return base",
        "island_id": 2,
        "generation": 5,
        "train_score": 0.9677310924369749,
        "val_score": 0.5676243841107219,
        "simplicity_score": 0.22335485883721273,
        "novelty_bonus": 0.20045697311756405
      },
      {
        "id": "g16_i3_p1_35770155",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of\n    pre‑computed graph statistics.  The estimator is a handcrafted\n    non‑linear combination of size, density, degree, clustering,\n    triangles, assortativity, and degree heterogeneity.  It uses only\n    basic Python operations (no external imports, no graph traversal).\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph descriptors with keys:\n        - 'n'                   : int      number of vertices\n        - 'm'                   : int      number of edges\n        - 'density'             : float    edge density\n        - 'avg_degree'          : float    average degree\n        - 'max_degree'          : int\n        - 'min_degree'          : int\n        - 'std_degree'          : float\n        - 'avg_clustering'      : float\n        - 'transitivity'        : float\n        - 'degree_assortativity': float\n        - 'num_triangles'       : int\n        - 'degrees'             : list[int] sorted degree sequence\n\n    Returns\n    -------\n    float\n        A proxy that grows monotonically with the true average shortest‑path length.\n    \"\"\"\n    # Extract features as floats\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']\n\n    eps = 1e-12  # to avoid divisions by zero\n\n    # --------------------\n    # 1. Core scaling\n    #    In sparse or very large graphs the distance is large.\n    #    We use the square‑root of the size and divide by density\n    #    and average degree, which are classic ingredients for path length\n    #    in random graph theory.\n    # --------------------\n    base = (n ** 0.5) / ((density + eps) * (avg_deg + eps))\n\n    # --------------------\n    # 2. Modulators that lengthen or shorten paths\n    # --------------------\n    # 2a. Clustering / transitivity usually provide shortcuts:\n    #     we let them *increase* the base value (making it larger) and then\n    #     scale it by the same factor, effectively reducing the final output.\n    base *= (1 + avg_clust + eps)\n    base *= (1 + trans + eps)\n\n    # 2b. Assortativity magnitude tends to increase distances,\n    #     irrespective of its sign, so we multiply by a factor\n    #     that grows with |assort|.\n    base *= (1 + abs(assort) + eps)\n\n    # 2c. Triangles create many local cycles; the more abundant\n    #     they are relative to the edge count, the shorter the global\n    #     distance tends to be.  We therefore shrink the base in\n    #     proportion to the triangle-to‑edge ratio.\n    if m > 0:\n        tri_ratio = num_tri / (m + eps)\n        base *= (1 - 0.3 * tri_ratio)  # 0.3 is an empirically chosen weight\n\n    # --------------------\n    # 3. Heterogeneity corrections\n    # --------------------\n    # High degree variance (hubs) typically reduce distances.\n    base /= (1 + std_deg / (avg_deg + eps))\n\n    # The presence of very high or very low degrees also influences\n    # connectivity.  We penalise a high maximum degree (fewer hubs)\n    # and reward a higher minimum degree (fewer isolated nodes).\n    base /= (1 + max_deg / (avg_deg + eps))\n    base *= (1 + min_deg / (avg_deg + eps))\n\n    # --------------------\n    # 4. Harmonic‑mean bonus\n    # --------------------\n    # A large harmonic mean indicates many low‑degree nodes, which tends\n    # to increase distances.  We add a small scaled bonus to capture this.\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            if d > 0:\n                inv_sum += 1.0 / (d + eps)\n        h_mean = n / (inv_sum + eps)\n        base += 0.05 * h_mean\n\n    # Ensure a non‑negative return\n    return max(base, 0.0)",
        "island_id": 3,
        "generation": 16,
        "train_score": 0.7233909910812949,
        "val_score": 0.49546376938844383,
        "simplicity_score": 0.1569801800935419,
        "novelty_bonus": 0.18714239576370129
      },
      {
        "id": "g7_i3_p2_321199476",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a collection of\n    pre‑computed graph statistics.  The formula is a non‑linear\n    combination of size, density, clustering, triangles, assortativity,\n    and degree heterogeneity.  It uses only basic Python operations\n    (no imports, no graph traversal, no external libraries).\n\n    Parameters\n    ----------\n    s : dict\n        Graph features.  Expected keys:\n            n                     (int)      number of vertices\n            m                     (int)      number of edges\n            density               (float)    2m/(n(n-1))\n            avg_degree            (float)    average vertex degree\n            max_degree            (int)\n            min_degree            (int)\n            std_degree            (float)\n            avg_clustering        (float)    average local clustering\n            transitivity          (float)    global transitivity\n            degree_assortativity  (float)    assortativity coefficient\n            num_triangles         (int)      count of triangles\n            degrees               (list[int]) sorted degree sequence\n\n    Returns\n    -------\n    float\n        A scalar proxy for the average shortest‑path length.\n    \"\"\"\n    eps = 1e-12  # prevents divisions by zero\n\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    avg_deg = float(s['avg_degree'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    std_deg = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n    degs = s['degrees']\n\n    # ------------------------------------------------------------------\n    # 1. Harmonic mean of degrees (captures how many low‑degree nodes exist)\n    # ------------------------------------------------------------------\n    if degs:\n        inv_sum = 0.0\n        for d in degs:\n            if d > 0:\n                inv_sum += 1.0 / (d + eps)\n        harmonic_mean = n / (inv_sum + eps)\n    else:\n        harmonic_mean = 0.0\n\n    # ------------------------------------------------------------------\n    # 2. Triangle density factor (non‑linear, bell‑shaped influence)\n    # ------------------------------------------------------------------\n    if n >= 3:\n        possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n        tri_frac = num_tri / (possible_tri + eps)\n    else:\n        tri_frac = 0.0\n    tri_term = tri_frac * (1.0 - tri_frac)  # maximised near tri_frac≈0.5\n\n    # ------------------------------------------------------------------\n    # 3. Core multiplicative base: relates size & connectivity\n    # ------------------------------------------------------------------\n    base = (1.0 + n * density) / (1.0 + avg_deg + harmonic_mean)\n\n    # ------------------------------------------------------------------\n    # 4. Modulate with structural features\n    # ------------------------------------------------------------------\n    base *= (1.0 + tri_term) ** 0.6\n    base *= (1.0 - avg_clust) ** 0.4\n    base *= (1.0 - trans) ** 0.3\n    base *= (1.0 - assort) ** 0.2\n\n    # ------------------------------------------------------------------\n    # 5. Dispersion correction: captures heterogeneity in degrees\n    # ------------------------------------------------------------------\n    if degs:\n        mean_sq = sum(d * d for d in degs) / n\n    else:\n        mean_sq = 0.0\n    disp_term = (std_deg / (max_deg + eps)) * (mean_sq / (max_deg + eps))\n    base += disp_term\n\n    return base",
        "island_id": 3,
        "generation": 7,
        "train_score": 0.5928931572629051,
        "val_score": 0.4439060289952909,
        "simplicity_score": 0.21895565682377716,
        "novelty_bonus": 0.1920152829090549
      },
      {
        "id": "g7_i3_p4_507621439",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics\n    without performing any graph traversal. The estimator is a handcrafted\n    non‑linear combination of size, density, clustering, triangle richness,\n    assortativity, degree heterogeneity, and harmonic‑mean information.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph descriptors with keys:\n        - 'n'                   : int            number of nodes\n        - 'm'                   : int            number of edges\n        - 'density'             : float          edge density\n        - 'avg_clustering'      : float          average local clustering\n        - 'transitivity'        : float          global transitivity\n        - 'degree_assortativity': float          assortativity coefficient\n        - 'max_degree'          : int            maximum degree\n        - 'min_degree'          : int            minimum degree\n        - 'std_degree'          : float          standard deviation of degrees\n        - 'num_triangles'       : int            number of triangles\n        - 'degrees'             : list[int]      sorted degree list\n\n    Returns\n    -------\n    float\n        A scalar proxy that grows monotonically with the true average shortest‑path length.\n    \"\"\"\n    # --- extract and cast ---------------------------------------------\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    avg_c      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']\n\n    eps = 1e-12\n\n    # --- base term (inversely tied to edge density) -------------------\n    base = n / (m + 1.0)                 # larger graphs give a higher base\n    base *= (1.0 + density)              # denser graphs shrink typical distances\n    base *= (1.0 - avg_c)                # strong local clustering can lengthen paths\n    base *= (1.0 - trans)                # higher transitivity usually implies short cuts\n    base *= (1.0 - assort)               # disassortative mixing tends to lower path lengths\n\n    # --- triangle contribution -----------------------------------------\n    if n >= 3:\n        possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n        tri_frac = num_tri / (possible_tri + eps)\n    else:\n        tri_frac = 0.0\n    base += tri_frac * 10.0              # amplified around mid‑range triangle density\n\n    # --- harmonic mean of degrees -------------------------------------\n    if degrees:\n        inv_sum = sum(1.0 / (d + eps) for d in degrees if d > 0)\n        harmonic = n / (inv_sum + eps)\n    else:\n        harmonic = 0.0\n    base += harmonic * 0.1               # small boost from overall degree distribution\n\n    # --- dispersion and heterogeneity adjustment ----------------------\n    disp = std_deg / (max_deg + eps)     # degree variability factor\n    correction = disp * (harmonic - min_deg) / (max_deg + 1.0 + eps)\n    base += correction\n\n    return base",
        "island_id": 3,
        "generation": 7,
        "train_score": 0.4981992797118847,
        "val_score": 0.4367734221396053,
        "simplicity_score": 0.22002454515451178,
        "novelty_bonus": 0.4484443574285196
      },
      {
        "id": "g16_i3_p3_574471448",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    Only built‑in Python operations are used; no external libraries or graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph descriptors:\n            n                      (int)   number of nodes\n            m                      (int)   number of edges\n            density                (float) edge density\n            avg_degree             (float) average vertex degree\n            max_degree             (int)   maximum degree\n            min_degree             (int)   minimum degree\n            std_degree             (float) standard deviation of degrees\n            avg_clustering         (float) average local clustering\n            transitivity           (float) global transitivity\n            degree_assortativity   (float) degree assortativity coefficient\n            num_triangles          (int)   number of triangles\n            degrees                (list[int]) sorted degree list\n\n    Returns\n    -------\n    float\n        A scalar proxy for the average shortest‑path length.\n    \"\"\"\n    n           = s['n']\n    m           = s['m']\n    density     = s['density']\n    avg_deg     = s['avg_degree']\n    max_deg     = s['max_degree']\n    min_deg     = s['min_degree']\n    std_deg     = s['std_degree']\n    avg_clust   = s['avg_clustering']\n    trans       = s['transitivity']\n    assort      = s['degree_assortativity']\n    num_tri     = s['num_triangles']\n    degrees     = s['degrees']\n\n    # Base term: size inversely weighted by edge count\n    base = (n + 1) / (m + 1)\n\n    # Modifiers that generally shorten paths\n    base *= (1.0 + density)                   # higher density → shorter paths\n    base *= (1.0 + avg_clust)                 # local clustering adds shortcuts\n    base *= (1.0 + trans)                     # global transitivity shortens paths\n    base *= (1.0 + abs(assort))               # magnitude of assortativity matters\n\n    # Triangle influence\n    if n >= 3:\n        max_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_frac = num_tri / (max_tri + 1e-12)\n    else:\n        tri_frac = 0.0\n    base *= (1.0 + tri_frac)\n\n    # Harmonic mean of degrees (captures prevalence of low‑degree nodes)\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            inv_sum += 1.0 / (d + 1e-12)\n        hmean = n / (inv_sum + 1e-12)\n    else:\n        hmean = 0.0\n    base *= (1.0 + hmean / (n + 1.0))\n\n    # Penalty for degree heterogeneity\n    base /= (1.0 + std_deg / (max_deg + 1.0))\n\n    return float(base)",
        "island_id": 3,
        "generation": 16,
        "train_score": 0.5349819927971188,
        "val_score": 0.4281533884144931,
        "simplicity_score": 0.16667783984490941,
        "novelty_bonus": 0.16493812345308623
      }
    ]
  }
}