{
  "schema_version": 4,
  "experiment_id": "phase1_20260215T112609Z",
  "fitness_mode": "upper_bound",
  "model_name": "gpt-oss:20b",
  "best_candidate_id": "g19_i1_p3_5307072",
  "best_candidate_code_sha256": "aceff73b504fe3fd9ec2c4db8fbea208c5a9abae2beac877a2b7fef6021d10e3",
  "best_val_score": 0.45331732044510276,
  "stop_reason": "max_generations_reached",
  "success": false,
  "config": {
    "seed": 42,
    "target_name": "average_shortest_path_length",
    "num_train_graphs": 50,
    "num_val_graphs": 200,
    "num_test_graphs": 200,
    "max_generations": 20,
    "population_size": 5,
    "migration_interval": 10,
    "island_temperatures": [
      0.3,
      0.3,
      0.8,
      1.2
    ],
    "timeout_sec": 2.0,
    "memory_mb": 256,
    "sandbox_max_workers": null,
    "alpha": 0.5,
    "beta": 0.2,
    "gamma": 0.3,
    "train_score_threshold": 0.0,
    "early_stop_patience": 10,
    "artifacts_dir": "artifacts/experiment_upper_bound_aspl",
    "model_name": "gpt-oss:20b",
    "ollama_url": "http://localhost:11434/api/generate",
    "allow_remote_ollama": false,
    "checkpoint_keep_last": 3,
    "experiment_id": null,
    "enable_constrained_fallback": true,
    "stagnation_trigger_generations": 5,
    "constrained_recovery_generations": 3,
    "allow_late_constrained_recovery": true,
    "run_baselines": false,
    "persist_candidate_code_in_summary": true,
    "success_spearman_threshold": 0.85,
    "pysr_niterations": 30,
    "pysr_populations": 8,
    "pysr_procs": 0,
    "pysr_timeout_in_seconds": 60.0,
    "benchmark_seeds": [
      11,
      22,
      33,
      44,
      55
    ],
    "novelty_bootstrap_samples": 1000,
    "novelty_threshold": 0.7,
    "enforce_pysr_parity_for_success": true,
    "pysr_parity_epsilon": 0.0,
    "require_baselines_for_success": true,
    "persist_prompt_and_response_logs": true,
    "llm_timeout_sec": 600.0,
    "enable_self_correction": true,
    "self_correction_max_retries": 1,
    "self_correction_feedback_window": 3,
    "novelty_gate_threshold": 0.15,
    "fitness_mode": "upper_bound",
    "bound_tolerance": 1e-09,
    "success_bound_score_threshold": 0.7,
    "success_satisfaction_threshold": 0.95,
    "enable_map_elites": false,
    "map_elites_bins": 5
  },
  "final_generation": 20,
  "island_candidate_counts": {
    "0": 5,
    "1": 5,
    "2": 5,
    "3": 5
  },
  "train_metrics": {
    "spearman": 0.3485126565702982,
    "pearson": 0.28398536329593066,
    "rmse": 0.7656619239417034,
    "mae": 0.6484847312621871,
    "valid_count": 47,
    "novelty_bonus": null
  },
  "val_metrics": {
    "spearman": 0.42267500325526164,
    "pearson": 0.34811716697495687,
    "rmse": 0.89944816624298,
    "mae": 0.7382314683975297,
    "valid_count": 193,
    "novelty_bonus": 0.5474180993662181
  },
  "test_metrics": {
    "spearman": 0.3590295067690049,
    "pearson": 0.5252652436539976,
    "rmse": 0.7715733068891524,
    "mae": 0.6940555763534824,
    "valid_count": 193,
    "novelty_bonus": 0.6247523682533912
  },
  "sanity_metrics": {
    "spearman": 0.0,
    "pearson": 0.0,
    "rmse": 0.4978259341952216,
    "mae": 0.4883125818110338,
    "valid_count": 3,
    "novelty_bonus": null
  },
  "novelty_ci": {
    "validation": {
      "max_ci_upper_abs_rho": 0.5271104570036192,
      "novelty_passed": true,
      "threshold": 0.7,
      "per_invariant": {
        "density": {
          "point_abs_rho": 0.4492115033732038,
          "ci_upper_abs_rho": 0.5162831265772873
        },
        "clustering_coefficient": {
          "point_abs_rho": 0.06742818508378935,
          "ci_upper_abs_rho": 0.17612761253110318
        },
        "degree_assortativity": {
          "point_abs_rho": 0.09989360753153975,
          "ci_upper_abs_rho": 0.2077276789242519
        },
        "transitivity": {
          "point_abs_rho": 0.07648104326633513,
          "ci_upper_abs_rho": 0.1959377827307975
        },
        "average_degree": {
          "point_abs_rho": 0.32002042308529455,
          "ci_upper_abs_rho": 0.3939004580456802
        },
        "max_degree": {
          "point_abs_rho": 0.4525819006337819,
          "ci_upper_abs_rho": 0.5271104570036192
        },
        "spectral_radius": {
          "point_abs_rho": 0.424547832009044,
          "ci_upper_abs_rho": 0.4960394941344922
        },
        "diameter": {
          "point_abs_rho": 0.37681579805061355,
          "ci_upper_abs_rho": 0.4518907110852394
        },
        "algebraic_connectivity": {
          "point_abs_rho": 0.34151127074845156,
          "ci_upper_abs_rho": 0.419108530553225
        }
      }
    },
    "test": {
      "max_ci_upper_abs_rho": 0.45416665737209505,
      "novelty_passed": true,
      "threshold": 0.7,
      "per_invariant": {
        "density": {
          "point_abs_rho": 0.37266954964162163,
          "ci_upper_abs_rho": 0.45262677503488097
        },
        "clustering_coefficient": {
          "point_abs_rho": 0.009828186130294143,
          "ci_upper_abs_rho": 0.1398483340351865
        },
        "degree_assortativity": {
          "point_abs_rho": 0.08063120766544134,
          "ci_upper_abs_rho": 0.1663088904031412
        },
        "transitivity": {
          "point_abs_rho": 0.014641991581866784,
          "ci_upper_abs_rho": 0.13470290926340447
        },
        "average_degree": {
          "point_abs_rho": 0.31114373174068377,
          "ci_upper_abs_rho": 0.3848485778885389
        },
        "max_degree": {
          "point_abs_rho": 0.3752476317466088,
          "ci_upper_abs_rho": 0.45416665737209505
        },
        "spectral_radius": {
          "point_abs_rho": 0.36544791135928884,
          "ci_upper_abs_rho": 0.4432306031102965
        },
        "diameter": {
          "point_abs_rho": 0.3343511467266593,
          "ci_upper_abs_rho": 0.4113192335766776
        },
        "algebraic_connectivity": {
          "point_abs_rho": 0.32332713123555085,
          "ci_upper_abs_rho": 0.3976908770638027
        }
      }
    }
  },
  "dataset_fingerprint": "af08648a118017775c4ac728a8e467b5c9cf7e503c9a2ce19baa0b26358f420b",
  "self_correction_stats": {
    "enabled": true,
    "max_retries": 1,
    "feedback_window": 3,
    "attempted_repairs": 56,
    "successful_repairs": 27,
    "failed_repairs": 29,
    "failure_categories": {
      "below_train_threshold": 7,
      "no_valid_train_predictions": 47,
      "below_novelty_threshold": 36
    }
  },
  "bounds_metrics": {
    "val": {
      "bound_score": 0.5137132073914047,
      "satisfaction_rate": 0.8704663212435233,
      "mean_gap": 0.6944596882445031,
      "violation_count": 25,
      "valid_count": 193
    },
    "test": {
      "bound_score": 0.4986280800131158,
      "satisfaction_rate": 0.844559585492228,
      "mean_gap": 0.6937665954753548,
      "violation_count": 30,
      "valid_count": 193
    }
  },
  "success_criteria_bounds": {
    "bound_score_threshold": 0.7,
    "satisfaction_threshold": 0.95,
    "val_bound_score": 0.5137132073914047,
    "val_satisfaction_rate": 0.8704663212435233,
    "passed": false
  },
  "best_candidate_code": "def new_invariant(s):\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # Path‑graph bound (maximum ASPL over all connected graphs)\n    path_bound = (n + 1) / 3.0\n\n    # Density bound: if density > 0.5, diameter ≤ 2\n    density = s.get('density', 0.0)\n    density_bound = 2.0 if density > 0.5 else n - 1\n\n    # Moore bound using maximum degree Δ\n    max_deg = s.get('max_degree', 1)\n    moore_max = n - 1\n    if max_deg > 2:\n        nodes = 1\n        power = 1\n        radius = 0\n        deg = int(max_deg)\n        while nodes < n:\n            nodes += deg * power\n            power *= (deg - 1)\n            radius += 1\n        moore_max = radius + 1\n\n    # Moore bound using minimum degree δ\n    min_deg = s.get('min_degree', 1)\n    moore_min = n - 1\n    if min_deg > 1:\n        nodes = 1\n        power = 1\n        radius = 0\n        deg = int(min_deg)\n        while nodes < n:\n            nodes += deg * power\n            power *= (deg - 1)\n            radius += 1\n        moore_min = radius + 1\n\n    # Moore bound using average degree\n    avg_deg = s.get('avg_degree', 1)\n    moore_avg = n - 1\n    if avg_deg > 1:\n        nodes = 1\n        power = 1\n        radius = 0\n        deg = int(avg_deg)\n        while nodes < n:\n            nodes += deg * power\n            power *= (deg - 1)\n            radius += 1\n        moore_avg = radius + 1\n\n    # Trivial bound\n    trivial = n - 1\n\n    # Choose the tightest guaranteed upper bound\n    final = path_bound\n    if density_bound < final:\n        final = density_bound\n    if moore_max < final:\n        final = moore_max\n    if moore_min < final:\n        final = moore_min\n    if moore_avg < final:\n        final = moore_avg\n    if trivial < final:\n        final = trivial\n\n    return float(final)"
}