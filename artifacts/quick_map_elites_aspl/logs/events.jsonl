{"timestamp": "2026-02-14T02:19:22.339321+00:00", "event_type": "phase1_started", "payload": {"experiment_id": "phase1_20260214T021916Z", "resume": null, "model_name": "gemma3:12b", "dataset_fingerprint": "d703bf7c0bd2ca8c1401f166fcc0598d6476d4e45652497fe08a0f956dfa9361"}}
{"timestamp": "2026-02-14T02:20:23.573387+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.063348", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:20:30.759396+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:20:30.759903+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:20:36.383505+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.276639", "model_name": "gemma3:12b", "train_signal": 0.27663865546218486}}
{"timestamp": "2026-02-14T02:20:36.383808+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "below_train_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:20:45.125798+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.048264", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:20:50.260723+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:20:50.260960+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:20:54.171502+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.007631", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:20:54.171849+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:00.975279+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:00.975731+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:08.790340+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.006587", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:08.790825+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 1, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:14.804345+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:14.804583+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:19.091287+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.026938", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:19.091810+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:26.972926+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:26.973226+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:33.766822+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.032603", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:33.767095+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 2, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:41.405915+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:41.406127+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:48.009227+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.045676", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:48.009450+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:55.814009+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:21:55.814221+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:22:03.988268+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.134819", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:22:03.988478+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 2, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:22:16.403545+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:22:16.404585+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:22:27.872792+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 0, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.070739", "model_name": "gemma3:12b", "train_signal": 0.07073908691323642}}
{"timestamp": "2026-02-14T02:22:27.873793+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 3, "population_idx": 0, "status": "failed", "reason": "below_train_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:22:39.369548+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.091664", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:22:50.247065+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:22:50.248094+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:23:00.473657+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 2, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.044418", "model_name": "gemma3:12b", "train_signal": 0.04441776710684273}}
{"timestamp": "2026-02-14T02:23:00.474827+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 3, "population_idx": 2, "status": "failed", "reason": "below_train_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:23:00.476727+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "phase1_20260214T021916Z", "generation": 1, "model_name": "gemma3:12b", "best_val_score": 0.0, "no_improve_count": 1, "map_elites_stats": {"coverage": 0, "total_cells": 25, "best_fitness": 0.0, "mean_fitness": 0.0}}}
{"timestamp": "2026-02-14T02:23:08.772863+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.063348", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:23:16.579424+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.063348", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:23:22.635439+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:23:22.636963+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:23:29.251722+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.063348", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:23:29.252768+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 0, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:23:35.903643+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:23:35.904649+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:23:40.848168+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.114872", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:23:40.848558+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:23:47.945739+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:23:47.946352+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:23:53.998879+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.084558", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:23:53.999730+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:24:00.941132+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:24:00.941497+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:24:06.974658+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.084558", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:24:06.975150+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:24:18.996846+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:24:18.997333+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:24:30.458482+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.018644", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:24:30.459011+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 2, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:24:37.503929+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:24:37.504267+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:24:43.500559+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.254742", "model_name": "gemma3:12b", "train_signal": 0.25474189675870346}}
{"timestamp": "2026-02-14T02:24:43.500939+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "below_train_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:24:52.701454+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:24:52.701689+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:25:01.159986+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.063348", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:25:01.160297+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 2, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:25:16.942656+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.017310", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:25:27.226713+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.018815", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:25:41.990822+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:25:41.991308+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:25:56.239870+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.129456", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:25:56.241225+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 3, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:25:56.247453+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "phase1_20260214T021916Z", "generation": 2, "model_name": "gemma3:12b", "best_val_score": 0.0, "no_improve_count": 2, "map_elites_stats": {"coverage": 0, "total_cells": 25, "best_fitness": 0.0, "mean_fitness": 0.0}}}
{"timestamp": "2026-02-14T02:26:07.466782+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:26:07.467047+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:26:17.671366+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.042796", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:26:17.671804+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 0, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:26:24.833378+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.063348", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:26:32.312048+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i0_p2_89250953", "generation": 2, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.7837214885954381, "fitness_mode": "correlation", "simplicity_score": 0.15630897192799031, "novelty_bonus": 0.21450078320156385, "total_score": 0.4991106431234202, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\nNone yet.\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.042796\nbelow_novelty_threshold: novelty_bonus=0.063348\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))", "spearman": 0.8069972275547059, "pearson": 0.7947417462140343, "rmse": 9.204462123702092, "mae": 8.16170181081634}}
{"timestamp": "2026-02-14T02:26:40.424135+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i1_p0_773956048", "generation": 2, "island_id": 1, "model_name": "gemma3:12b", "train_signal": 0.7837214885954381, "fitness_mode": "correlation", "simplicity_score": 0.15630897192799031, "novelty_bonus": 0.21450078320156385, "total_score": 0.4991106431234202, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.114872\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.084558\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))", "spearman": 0.8069972275547059, "pearson": 0.7947417462140343, "rmse": 9.204462123702092, "mae": 8.16170181081634}}
{"timestamp": "2026-02-14T02:26:46.386716+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i1_p1_654571518", "generation": 2, "island_id": 1, "model_name": "gemma3:12b", "train_signal": 0.7837214885954381, "fitness_mode": "correlation", "simplicity_score": 0.15630897192799031, "novelty_bonus": 0.21450078320156385, "total_score": 0.4991106431234202, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.114872\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.084558\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))", "spearman": 0.8069972275547059, "pearson": 0.7947417462140343, "rmse": 9.204462123702092, "mae": 8.16170181081634}}
{"timestamp": "2026-02-14T02:26:51.972664+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i1_p2_438878439", "generation": 2, "island_id": 1, "model_name": "gemma3:12b", "train_signal": 0.7837214885954381, "fitness_mode": "correlation", "simplicity_score": 0.15630897192799031, "novelty_bonus": 0.21450078320156385, "total_score": 0.4991106431234202, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.114872\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.084558\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))", "spearman": 0.8069972275547059, "pearson": 0.7947417462140343, "rmse": 9.204462123702092, "mae": 8.16170181081634}}
{"timestamp": "2026-02-14T02:26:57.816066+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.005376", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:27:05.057926+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.076454", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:27:12.203653+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.039757", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:27:21.382638+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.282977", "model_name": "gemma3:12b", "train_signal": 0.28297719087635054}}
{"timestamp": "2026-02-14T02:27:30.874174+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.011929", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:27:38.562690+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.002133", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:27:38.563214+00:00", "event_type": "generation_migration", "payload": {"generation": 2, "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:27:38.564192+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "phase1_20260214T021916Z", "generation": 3, "model_name": "gemma3:12b", "best_val_score": 0.4991106431234202, "no_improve_count": 0, "map_elites_stats": {"coverage": 1, "total_cells": 25, "best_fitness": 0.8069972275547059, "mean_fitness": 0.8069972275547059}}}
{"timestamp": "2026-02-14T02:27:49.265718+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i0_p0_433015235", "generation": 3, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.7616326530612244, "fitness_mode": "correlation", "simplicity_score": 0.15347639308703107, "novelty_bonus": 0.22153299328892373, "total_score": 0.4908877925692412, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.042796\nbelow_novelty_threshold: novelty_bonus=0.063348\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)", "spearman": 0.7874652319303157, "pearson": 0.7785057318847626, "rmse": 11.38989305205449, "mae": 10.227328460425145}}
{"timestamp": "2026-02-14T02:27:55.981552+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i0_p1_858597919", "generation": 3, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.7616326530612244, "fitness_mode": "correlation", "simplicity_score": 0.15347639308703107, "novelty_bonus": 0.22153299328892373, "total_score": 0.4908877925692412, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.042796\nbelow_novelty_threshold: novelty_bonus=0.063348\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)", "spearman": 0.7874652319303157, "pearson": 0.7785057318847626, "rmse": 11.38989305205449, "mae": 10.227328460425145}}
{"timestamp": "2026-02-14T02:28:02.286237+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i0_p2_201469535", "generation": 3, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.7616326530612244, "fitness_mode": "correlation", "simplicity_score": 0.15347639308703107, "novelty_bonus": 0.22153299328892373, "total_score": 0.4908877925692412, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.042796\nbelow_novelty_threshold: novelty_bonus=0.063348\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)", "spearman": 0.7874652319303157, "pearson": 0.7785057318847626, "rmse": 11.38989305205449, "mae": 10.227328460425145}}
{"timestamp": "2026-02-14T02:28:13.280993+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i1_p0_94177347", "generation": 3, "island_id": 1, "model_name": "gemma3:12b", "train_signal": 0.8077310924369748, "fitness_mode": "correlation", "simplicity_score": 0.1465210027003948, "novelty_bonus": 0.15880786937510138, "total_score": 0.4974901076451262, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.114872\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.084558\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity,\n    with an added scaling factor based on graph density.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    density = s['density']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + density))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity,\n    with an added scaling factor based on graph density.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    density = s['density']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + density))", "spearman": 0.8410870925850336, "pearson": 0.8005534082899798, "rmse": 8.43085098909002, "mae": 7.256230990440169}}
{"timestamp": "2026-02-14T02:28:22.230439+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i1_p1_526478978", "generation": 3, "island_id": 1, "model_name": "gemma3:12b", "train_signal": 0.8077310924369748, "fitness_mode": "correlation", "simplicity_score": 0.1465210027003948, "novelty_bonus": 0.15880786937510138, "total_score": 0.4974901076451262, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.114872\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.084558\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity,\n    with an added scaling factor based on graph density.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    density = s['density']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + density))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity,\n    with an added scaling factor based on graph density.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    density = s['density']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + density))", "spearman": 0.8410870925850336, "pearson": 0.8005534082899798, "rmse": 8.43085098909002, "mae": 7.256230990440169}}
{"timestamp": "2026-02-14T02:28:28.449143+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i1_p2_975622351", "generation": 3, "island_id": 1, "model_name": "gemma3:12b", "train_signal": 0.7837214885954381, "fitness_mode": "correlation", "simplicity_score": 0.15630897192799031, "novelty_bonus": 0.21450078320156385, "total_score": 0.4991106431234202, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.114872\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.084558\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))", "spearman": 0.8069972275547059, "pearson": 0.7947417462140343, "rmse": 9.204462123702092, "mae": 8.16170181081634}}
{"timestamp": "2026-02-14T02:28:37.092355+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i2_p0_735752370", "generation": 3, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.7616326530612244, "fitness_mode": "correlation", "simplicity_score": 0.15347639308703107, "novelty_bonus": 0.22153299328892373, "total_score": 0.4908877925692412, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.005376\nbelow_novelty_threshold: novelty_bonus=0.076454\nbelow_novelty_threshold: novelty_bonus=0.039757\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + 0.8 * avg_degree * (1 - transitivity))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + 0.8 * avg_degree * (1 - transitivity))", "spearman": 0.7874652319303157, "pearson": 0.7785057318847626, "rmse": 11.38989305205449, "mae": 10.227328460425145}}
{"timestamp": "2026-02-14T02:28:43.265061+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i2_p1_761139701", "generation": 3, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.7616326530612244, "fitness_mode": "correlation", "simplicity_score": 0.15347639308703107, "novelty_bonus": 0.22153299328892373, "total_score": 0.4908877925692412, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.005376\nbelow_novelty_threshold: novelty_bonus=0.076454\nbelow_novelty_threshold: novelty_bonus=0.039757\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)", "spearman": 0.7874652319303157, "pearson": 0.7785057318847626, "rmse": 11.38989305205449, "mae": 10.227328460425145}}
{"timestamp": "2026-02-14T02:28:49.431323+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i2_p2_717477276", "generation": 3, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.7616326530612244, "fitness_mode": "correlation", "simplicity_score": 0.15347639308703107, "novelty_bonus": 0.22153299328892373, "total_score": 0.4908877925692412, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.005376\nbelow_novelty_threshold: novelty_bonus=0.076454\nbelow_novelty_threshold: novelty_bonus=0.039757\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)", "spearman": 0.7874652319303157, "pearson": 0.7785057318847626, "rmse": 11.38989305205449, "mae": 10.227328460425145}}
{"timestamp": "2026-02-14T02:28:59.937984+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.075009", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:29:09.510160+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i3_p1_786064305", "generation": 3, "island_id": 3, "model_name": "gemma3:12b", "train_signal": 0.7622088835534212, "fitness_mode": "correlation", "simplicity_score": 0.14529559383257518, "novelty_bonus": 0.27931696958590235, "total_score": 0.50897863629964, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity,\n    with an added scaling factor based on graph density.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    density = s['density']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + density))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.011929\nbelow_novelty_threshold: novelty_bonus=0.002133\nbelow_novelty_threshold: novelty_bonus=0.075009\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, transitivity,\n    and a correction factor based on degree standard deviation.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    std_degree = s['std_degree']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + std_degree / avg_degree))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, transitivity,\n    and a correction factor based on degree standard deviation.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    std_degree = s['std_degree']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + std_degree / avg_degree))", "spearman": 0.7922488533147086, "pearson": 0.7893903343211864, "rmse": 6.225783602380284, "mae": 5.539736381103921}}
{"timestamp": "2026-02-14T02:29:17.747552+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i3_p2_513226573", "generation": 3, "island_id": 3, "model_name": "gemma3:12b", "train_signal": 0.7788235294117648, "fitness_mode": "correlation", "simplicity_score": 0.14563056043180833, "novelty_bonus": 0.18913427537684113, "total_score": 0.49402337668286067, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity,\n    with an added scaling factor based on graph density.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    density = s['density']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + density))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.011929\nbelow_novelty_threshold: novelty_bonus=0.002133\nbelow_novelty_threshold: novelty_bonus=0.075009\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines graph size, average degree, transitivity, and degree variance.\n    It attempts to account for how well-connected the graph is and the spread of node degrees.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    std_degree = s['std_degree']\n\n    return n / (1 + avg_degree * (1 - transitivity) + 0.1 * std_degree)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines graph size, average degree, transitivity, and degree variance.\n    It attempts to account for how well-connected the graph is and the spread of node degrees.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    std_degree = s['std_degree']\n\n    return n / (1 + avg_degree * (1 - transitivity) + 0.1 * std_degree)", "spearman": 0.8163139639668933, "pearson": 0.7952210900993126, "rmse": 8.60927359630518, "mae": 7.662669627444975}}
{"timestamp": "2026-02-14T02:29:17.749846+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "phase1_20260214T021916Z", "generation": 4, "model_name": "gemma3:12b", "best_val_score": 0.50897863629964, "no_improve_count": 0, "map_elites_stats": {"coverage": 2, "total_cells": 25, "best_fitness": 0.8410870925850336, "mean_fitness": 0.8240421600698697}}}
{"timestamp": "2026-02-14T02:29:27.611213+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i0_p0_128113632", "generation": 4, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.7546218487394958, "fitness_mode": "correlation", "simplicity_score": 0.15306319461724227, "novelty_bonus": 0.22394656539441904, "total_score": 0.48784588104209126, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.042796\nbelow_novelty_threshold: novelty_bonus=0.063348\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.75)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.75)", "spearman": 0.7800985450006342, "pearson": 0.7731350162513901, "rmse": 12.071765074878684, "mae": 10.874677825388966}}
{"timestamp": "2026-02-14T02:29:33.977762+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i0_p1_839748229", "generation": 4, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.7546218487394958, "fitness_mode": "correlation", "simplicity_score": 0.15306319461724227, "novelty_bonus": 0.22394656539441904, "total_score": 0.48784588104209126, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.042796\nbelow_novelty_threshold: novelty_bonus=0.063348\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.75)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.75)", "spearman": 0.7800985450006342, "pearson": 0.7731350162513901, "rmse": 12.071765074878684, "mae": 10.874677825388966}}
{"timestamp": "2026-02-14T02:29:40.161281+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i0_p2_450385937", "generation": 4, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.7546218487394958, "fitness_mode": "correlation", "simplicity_score": 0.15306319461724227, "novelty_bonus": 0.22394656539441904, "total_score": 0.48784588104209126, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.042796\nbelow_novelty_threshold: novelty_bonus=0.063348\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.75)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.75)", "spearman": 0.7800985450006342, "pearson": 0.7731350162513901, "rmse": 12.071765074878684, "mae": 10.874677825388966}}
{"timestamp": "2026-02-14T02:29:50.619451+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p0_500351915", "generation": 4, "island_id": 1, "model_name": "gemma3:12b", "train_signal": 0.7730612244897959, "fitness_mode": "correlation", "simplicity_score": 0.14857708708505302, "novelty_bonus": 0.20360595771852297, "total_score": 0.4918605067138835, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.114872\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.084558\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity,\n    with an added scaling factor based on graph density.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    density = s['density']\n\n    return n / (1 + avg_degree * (1 - transitivity) + density)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity,\n    with an added scaling factor based on graph density.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    density = s['density']\n\n    return n / (1 + avg_degree * (1 - transitivity) + density)", "spearman": 0.802126603962632, "pearson": 0.7869430504485132, "rmse": 8.995281564030293, "mae": 7.943151350393302}}
{"timestamp": "2026-02-14T02:29:57.652070+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p1_370798024", "generation": 4, "island_id": 1, "model_name": "gemma3:12b", "train_signal": 0.8077310924369748, "fitness_mode": "correlation", "simplicity_score": 0.1465210027003948, "novelty_bonus": 0.15880786937510138, "total_score": 0.4974901076451262, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.114872\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.084558\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity,\n    with an added scaling factor based on graph density.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    density = s['density']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + density))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity,\n    with an added scaling factor based on graph density.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    density = s['density']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + density))", "spearman": 0.8410870925850336, "pearson": 0.8005534082899798, "rmse": 8.43085098909002, "mae": 7.256230990440169}}
{"timestamp": "2026-02-14T02:30:04.828776+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p2_182549636", "generation": 4, "island_id": 1, "model_name": "gemma3:12b", "train_signal": 0.8077310924369748, "fitness_mode": "correlation", "simplicity_score": 0.1465210027003948, "novelty_bonus": 0.15880786937510138, "total_score": 0.4974901076451262, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.114872\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.084558\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity,\n    with an added scaling factor based on graph density.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    density = s['density']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + density))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity,\n    with an added scaling factor based on graph density.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    density = s['density']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + density))", "spearman": 0.8410870925850336, "pearson": 0.8005534082899798, "rmse": 8.43085098909002, "mae": 7.256230990440169}}
{"timestamp": "2026-02-14T02:30:14.593734+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i2_p0_926764988", "generation": 4, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.7546218487394958, "fitness_mode": "correlation", "simplicity_score": 0.15306319461724227, "novelty_bonus": 0.22394656539441904, "total_score": 0.48784588104209126, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + 0.8 * avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.005376\nbelow_novelty_threshold: novelty_bonus=0.076454\nbelow_novelty_threshold: novelty_bonus=0.039757\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + 0.75 * avg_degree * (1 - transitivity))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + 0.75 * avg_degree * (1 - transitivity))", "spearman": 0.7800985450006342, "pearson": 0.7731350162513901, "rmse": 12.071765074878684, "mae": 10.874677825388966}}
{"timestamp": "2026-02-14T02:30:20.660472+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i2_p1_781567455", "generation": 4, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.7406002400960384, "fitness_mode": "correlation", "simplicity_score": 0.15347639308703107, "novelty_bonus": 0.22616288160689235, "total_score": 0.48485532074563387, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + 0.8 * avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.005376\nbelow_novelty_threshold: novelty_bonus=0.076454\nbelow_novelty_threshold: novelty_bonus=0.039757\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + 0.7 * avg_degree * (1 - transitivity))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + 0.7 * avg_degree * (1 - transitivity))", "spearman": 0.7726223552923199, "pearson": 0.7670281207298706, "rmse": 12.82516036731347, "mae": 11.59143828581782}}
{"timestamp": "2026-02-14T02:30:26.750541+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i2_p2_643865119", "generation": 4, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.7546218487394958, "fitness_mode": "correlation", "simplicity_score": 0.15306319461724227, "novelty_bonus": 0.22394656539441904, "total_score": 0.48784588104209126, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + 0.8 * avg_degree * (1 - transitivity))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity) * 0.8)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.005376\nbelow_novelty_threshold: novelty_bonus=0.076454\nbelow_novelty_threshold: novelty_bonus=0.039757\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + 0.75 * avg_degree * (1 - transitivity))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + 0.75 * avg_degree * (1 - transitivity))", "spearman": 0.7800985450006342, "pearson": 0.7731350162513901, "rmse": 12.071765074878684, "mae": 10.874677825388966}}
{"timestamp": "2026-02-14T02:30:38.965845+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i3_p0_402414364", "generation": 4, "island_id": 3, "model_name": "gemma3:12b", "train_signal": 0.7622088835534212, "fitness_mode": "correlation", "simplicity_score": 0.1342752410665512, "novelty_bonus": 0.27931696958590235, "total_score": 0.5067745657464353, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, transitivity,\n    and a correction factor based on degree standard deviation.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    std_degree = s['std_degree']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + std_degree / avg_degree))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines graph size, average degree, transitivity, and degree variance.\n    It attempts to account for how well-connected the graph is and the spread of node degrees.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    std_degree = s['std_degree']\n\n    return n / (1 + avg_degree * (1 - transitivity) + 0.1 * std_degree)\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.011929\nbelow_novelty_threshold: novelty_bonus=0.002133\nbelow_novelty_threshold: novelty_bonus=0.075009\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines graph size, average degree, transitivity, and degree standard deviation,\n    with an emphasis on the role of degree variance.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    std_degree = s['std_degree']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + (std_degree / (avg_degree + 1e-6))))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines graph size, average degree, transitivity, and degree standard deviation,\n    with an emphasis on the role of degree variance.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    std_degree = s['std_degree']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + (std_degree / (avg_degree + 1e-6))))", "spearman": 0.7922488533147086, "pearson": 0.7893903686266843, "rmse": 6.225784055731367, "mae": 5.539736775333017}}
{"timestamp": "2026-02-14T02:30:47.278145+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i3_p1_822761613", "generation": 4, "island_id": 3, "model_name": "gemma3:12b", "train_signal": 0.7879471788715485, "fitness_mode": "correlation", "simplicity_score": 0.14077278695507267, "novelty_bonus": 0.1936269095943417, "total_score": 0.4959649019719904, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, transitivity,\n    and a correction factor based on degree standard deviation.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    std_degree = s['std_degree']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + std_degree / avg_degree))\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines graph size, average degree, transitivity, and degree variance.\n    It attempts to account for how well-connected the graph is and the spread of node degrees.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    std_degree = s['std_degree']\n\n    return n / (1 + avg_degree * (1 - transitivity) + 0.1 * std_degree)\n\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula combines the number of nodes, average degree, and transitivity.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n\n    return n / (1 + avg_degree * (1 - transitivity))\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.011929\nbelow_novelty_threshold: novelty_bonus=0.002133\nbelow_novelty_threshold: novelty_bonus=0.075009\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula incorporates graph size, average degree, transitivity, \n    degree standard deviation, and a scaling factor based on density.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    std_degree = s['std_degree']\n    density = s['density']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + density * (std_degree / avg_degree)))\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An attempt to estimate average shortest path length based on graph features.\n    This formula incorporates graph size, average degree, transitivity, \n    degree standard deviation, and a scaling factor based on density.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    transitivity = s['transitivity']\n    std_degree = s['std_degree']\n    density = s['density']\n\n    return n / (1 + avg_degree * (1 - transitivity) * (1 + density * (std_degree / avg_degree)))", "spearman": 0.8194445434053467, "pearson": 0.7979848372731604, "rmse": 8.872034898358265, "mae": 7.8066537303676045}}
{"timestamp": "2026-02-14T02:30:55.608248+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.140325", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:30:55.610604+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "phase1_20260214T021916Z", "generation": 5, "model_name": "gemma3:12b", "best_val_score": 0.50897863629964, "no_improve_count": 1, "map_elites_stats": {"coverage": 2, "total_cells": 25, "best_fitness": 0.8410870925850336, "mean_fitness": 0.8240421600698697}}}
