{
  "experiment_id": "seed_55",
  "generation": 20,
  "rng_seed": 55,
  "rng_state": {
    "bit_generator": "PCG64",
    "state": {
      "state": 118515418824577757149490424166256128773,
      "inc": 34071122550715517884140988759125521119
    },
    "has_uint32": 0,
    "uinteger": 966838535
  },
  "best_val_score": 0.5706469319419225,
  "no_improve_count": 4,
  "island_stagnation": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_prompt_mode": {
    "0": "free",
    "1": "free",
    "2": "free",
    "3": "free"
  },
  "island_constrained_generations": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_recent_failures": {
    "0": [
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "no_valid_train_predictions: runtime_exception: AttributeError: 'float' object has no attribute 'bit_length'",
      "below_novelty_threshold: novelty_bonus=0.148435"
    ],
    "1": [
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_train_threshold: train_signal=0.265978",
      "below_train_threshold: train_signal=0.166867"
    ],
    "2": [
      "below_novelty_threshold: novelty_bonus=0.102123",
      "below_novelty_threshold: novelty_bonus=0.111091",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ],
    "3": [
      "below_novelty_threshold: novelty_bonus=0.097707",
      "below_novelty_threshold: novelty_bonus=0.108550",
      "below_novelty_threshold: novelty_bonus=0.071670"
    ]
  },
  "islands": {
    "0": [
      {
        "id": "g17_i0_p1_189721748",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines logarithmic size, degree, density, clustering,\n    triangle density, degree heterogeneity, assortativity, and a harmonic\n    mean of degrees.  Only built‑in Python operations are used.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    # Basic graph statistics\n    n          = s['n']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_clust  = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # ------------------------------------------------------------------\n    # 1. Logarithmic base (size vs. average degree)\n    # ------------------------------------------------------------------\n    log_n = n.bit_length() - 1\n    avg_deg_int = int(avg_deg) if avg_deg > 0 else 1\n    log_avg_deg = avg_deg_int.bit_length() - 1\n    base = log_n / max(1, log_avg_deg)\n\n    # ------------------------------------------------------------------\n    # 2. Adjust for connectivity (density) and clustering\n    # ------------------------------------------------------------------\n    base *= (1 + density) ** -0.4\n    base *= (1 + avg_clust) ** -0.2\n\n    # ------------------------------------------------------------------\n    # 3. Triangle density factor\n    # ------------------------------------------------------------------\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n        tri_frac = num_tri / (possible_tri + eps)\n    else:\n        tri_frac = 0.0\n    base *= (1 + tri_frac) ** -0.3\n\n    # ------------------------------------------------------------------\n    # 4. Assortativity and degree heterogeneity corrections\n    # ------------------------------------------------------------------\n    base *= (1 + abs(assort)) ** 0.05\n    if max_deg > 0:\n        base *= (1 + std_deg / max_deg) ** 0.1\n\n    # ------------------------------------------------------------------\n    # 5. Max/min degree ratio adjustment\n    # ------------------------------------------------------------------\n    if min_deg > 0:\n        base *= (1 + max_deg / min_deg) ** -0.05\n\n    # ------------------------------------------------------------------\n    # 6. Harmonic mean of degrees (captures prevalence of low‑degree nodes)\n    # ------------------------------------------------------------------\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            if d > 0:\n                inv_sum += 1.0 / (d + eps)\n        harmonic_mean = n / (inv_sum + eps)\n        base += harmonic_mean / (max_deg + 1)\n\n    return base",
        "island_id": 0,
        "generation": 17,
        "train_score": 0.6207442977190877,
        "val_score": 0.4493575775400958,
        "simplicity_score": 0.21961625809647964,
        "novelty_bonus": 0.16966820858072063
      },
      {
        "id": "g17_i0_p3_46099150",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines logarithmic size, degree, density, clustering,\n    triangle density, degree heterogeneity, assortativity, and a harmonic\n    mean of degrees.  Only built‑in Python operations are used.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    # Basic graph statistics\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg = s['avg_degree']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Logarithmic approximations using bit length (base‑2)\n    log_n = n.bit_length() - 1\n    avg_deg_int = int(avg_deg) if avg_deg > 0 else 1\n    log_avg_deg = avg_deg_int.bit_length() - 1\n\n    # Base estimate from random‑graph intuition\n    base = log_n / max(1, log_avg_deg)\n\n    # Adjust for density: denser graphs have shorter paths\n    base *= (1 + density) ** -0.4\n\n    # Adjust for clustering: higher clustering can reduce path length\n    base *= (1 + avg_clust) ** -0.2\n\n    # Triangle fraction adjustment\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n        tri_frac = num_tri / (possible_tri + eps)\n    else:\n        tri_frac = 0.0\n    base *= (1 + tri_frac) ** -0.3\n\n    # Degree heterogeneity adjustment\n    if max_deg > 0:\n        base *= (1 + std_deg / max_deg) ** 0.1\n\n    # Assortativity adjustment\n    base *= (1 + abs(assort)) ** 0.05\n\n    # Max/min degree ratio adjustment\n    if min_deg > 0:\n        base *= (1 + max_deg / min_deg) ** -0.05\n\n    # Harmonic mean of degrees contribution\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            if d > 0:\n                inv_sum += 1.0 / (d + eps)\n        harmonic_mean = n / (inv_sum + eps)\n        base += harmonic_mean / (max_deg + 1)\n\n    return base",
        "island_id": 0,
        "generation": 17,
        "train_score": 0.6207442977190877,
        "val_score": 0.4493209320671065,
        "simplicity_score": 0.2194330307315332,
        "novelty_bonus": 0.16966820858072063
      },
      {
        "id": "g19_i0_p0_811803572",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines logarithmic size, degree, density, clustering,\n    triangle density, assortativity, degree heterogeneity, and a harmonic\n    mean of degrees.  Only built‑in Python operations are used – no imports,\n    no graph traversal, no external libraries.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    # Basic graph statistics\n    n          = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg    = s['avg_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_clust  = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Logarithmic base (size vs. average degree)\n    log_n = n.bit_length() - 1\n    avg_deg_int = int(avg_deg) if avg_deg > 0 else 1\n    log_avg_deg = avg_deg_int.bit_length() - 1\n    base = log_n / max(1, log_avg_deg)\n\n    # 2. Adjust for connectivity (density) and clustering\n    base *= (1 + density) ** -0.4\n    base *= (1 + avg_clust) ** -0.2\n\n    # 3. Triangle density factor\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n        tri_frac = num_tri / (possible_tri + eps)\n    else:\n        tri_frac = 0.0\n    base *= (1 + tri_frac) ** -0.3\n\n    # 4. Degree heterogeneity and assortativity corrections\n    base *= (1 + abs(assort)) ** 0.05\n    if max_deg > 0:\n        base *= (1 + std_deg / max_deg) ** 0.1\n\n    # 5. Max/min degree ratio adjustment\n    if min_deg > 0:\n        base *= (1 + max_deg / min_deg) ** -0.05\n\n    # 6. Harmonic mean of degrees (captures prevalence of low‑degree nodes)\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            if d > 0:\n                inv_sum += 1.0 / (d + eps)\n        harmonic_mean = n / (inv_sum + eps)\n        base += harmonic_mean / (max_deg + 1)\n\n    return base",
        "island_id": 0,
        "generation": 19,
        "train_score": 0.6207442977190877,
        "val_score": 0.4493209320671065,
        "simplicity_score": 0.2194330307315332,
        "novelty_bonus": 0.16966820858072063
      },
      {
        "id": "g19_i0_p2_560863448",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula uses only built‑in Python operations and avoids any imports.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    # Basic graph statistics\n    n          = s['n']\n    if n <= 1:\n        return 0.0\n\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_clust  = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Logarithmic base (size vs. average degree)\n    log_n = n.bit_length() - 1\n    # Convert avg_deg to int for bit_length; guard against zero\n    avg_deg_int = int(avg_deg) if avg_deg > 0 else 1\n    log_avg_deg = avg_deg_int.bit_length() - 1\n    base = log_n / max(1, log_avg_deg)\n\n    # 2. Adjust for connectivity (density) and clustering\n    base *= (1 + density) ** -0.4\n    base *= (1 + avg_clust) ** -0.2\n\n    # 3. Triangle density factor\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n        tri_frac = num_tri / (possible_tri + eps)\n    else:\n        tri_frac = 0.0\n    base *= (1 + tri_frac) ** -0.3\n\n    # 4. Degree heterogeneity correction\n    if max_deg > 0:\n        base *= (1 + std_deg / max_deg) ** 0.1\n\n    # 5. Assortativity correction\n    base *= (1 + abs(assort)) ** 0.05\n\n    # 6. Max/min degree ratio adjustment\n    if min_deg > 0:\n        base *= (1 + max_deg / min_deg) ** -0.05\n\n    # 7. Harmonic mean of degrees contribution\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            if d > 0:\n                inv_sum += 1.0 / (d + eps)\n        harmonic_mean = n / (inv_sum + eps)\n        base += harmonic_mean / (max_deg + 1)\n\n    return base",
        "island_id": 0,
        "generation": 19,
        "train_score": 0.6207442977190877,
        "val_score": 0.4493209320671065,
        "simplicity_score": 0.2194330307315332,
        "novelty_bonus": 0.16966820858072063
      },
      {
        "id": "g5_i2_p4_26965764",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The formula starts with the graph size divided by a connectivity term and\n    then applies multiplicative adjustments for clustering, assortativity,\n    triangle density, and normalises by degree heterogeneity and maximum\n    degree.  No external libraries are required.\n    \"\"\"\n    n = s.get('n', 1)\n    if n <= 1:\n        return 0.0\n\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 1)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    tri        = s.get('num_triangles', 0)\n\n    # Connectivity denominator – higher density and average degree shorten paths\n    denom_conn = max(avg_deg, 1e-6) * max(density, 1e-6)\n    base = n / denom_conn\n\n    # Clustering creates shortcuts\n    base *= (1.0 + avg_clust)\n\n    # Assortativity affects path length – treat magnitude symmetrically\n    base *= (1.0 + abs(assort))\n\n    # Triangle density – more triangles usually reduce average distance\n    if m > 0:\n        base *= (1.0 + tri / m)\n\n    # Degree heterogeneity – highly heterogeneous networks (hubs) typically\n    # have shorter paths, so we divide by the spread\n    base /= (1.0 + std_deg / max(avg_deg, 1e-6))\n    base /= (1.0 + min_deg / max(avg_deg, 1e-6))\n\n    # Penalise very high maximum degree (few hubs) to avoid over‑shortening\n    base /= (max_deg + 1.0)\n\n    return base",
        "island_id": 2,
        "generation": 5,
        "train_score": 0.9677310924369749,
        "val_score": 0.5676243841107219,
        "simplicity_score": 0.22335485883721273,
        "novelty_bonus": 0.20045697311756405
      }
    ],
    "1": [
      {
        "id": "g3_i1_p2_588779643",
        "code": "def new_invariant(s):\n    \"\"\"\n    Composite graph invariant combining size, density, degree distribution,\n    clustering, triangle density, and assortativity.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_cluster = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n\n    # Triangle density\n    possible_triangles = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    triangle_ratio = triangles / possible_triangles\n\n    # Size‑to‑edge ratio\n    size_edge_ratio = n / (m + 1)\n\n    # Degree spread and variability\n    denom = max_deg + 1\n    degree_spread = (max_deg - min_deg + 1) / denom\n    degree_variability = 1 + std_deg / denom\n    degree_factor = (avg_deg / denom) * degree_spread * degree_variability\n\n    # Clustering dampening\n    clustering_factor = (1 + avg_cluster) / (1 + trans)\n\n    # Triangle factor\n    triangle_factor = triangle_ratio + 0.1\n\n    # Assortativity influence\n    assort_factor = 1 + abs(assort)\n\n    # Size scaling\n    size_factor = n ** 0.5\n\n    # Combine all components multiplicatively\n    return (\n        size_edge_ratio *\n        degree_factor *\n        clustering_factor *\n        triangle_factor *\n        assort_factor *\n        size_factor\n    )",
        "island_id": 1,
        "generation": 3,
        "train_score": 0.7029531812725089,
        "val_score": 0.4606304153733223,
        "simplicity_score": 0.12250856077870916,
        "novelty_bonus": 0.185688142203555
      },
      {
        "id": "g4_i1_p2_57376479",
        "code": "def new_invariant(s):\n    \"\"\"\n    Composite graph invariant combining size, density, degree distribution,\n    clustering, triangle density, and assortativity into a single scalar.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_cluster= s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # Triangle density (ratio of existing to possible triangles)\n    possible_triangles = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    triangle_ratio = triangles / possible_triangles\n\n    # Component 1 – size‑to‑edge ratio\n    size_edge_ratio = n / (m + 1.0)\n\n    # Component 2 – degree spread and variability\n    denom = max_deg + 1.0\n    degree_spread = (max_deg - min_deg + 1.0) / denom\n    degree_variability = 1.0 + std_deg / denom\n    degree_factor = (avg_deg / denom) * degree_spread * degree_variability\n\n    # Component 3 – clustering dampening (local vs global)\n    clustering_factor = (1.0 + avg_cluster) / (1.0 + trans)\n\n    # Component 4 – triangle density boost\n    triangle_factor = triangle_ratio + 0.1\n\n    # Component 5 – assortativity influence\n    assort_factor = 1.0 + abs(assort)\n\n    # Component 6 – size scaling\n    size_factor = n ** 0.5\n\n    # Combine all components multiplicatively\n    return (\n        size_edge_ratio *\n        degree_factor *\n        clustering_factor *\n        triangle_factor *\n        assort_factor *\n        size_factor\n    )",
        "island_id": 1,
        "generation": 4,
        "train_score": 0.7029531812725089,
        "val_score": 0.4606304153733223,
        "simplicity_score": 0.12250856077870916,
        "novelty_bonus": 0.185688142203555
      },
      {
        "id": "g8_i1_p0_185420240",
        "code": "def new_invariant(s):\n    \"\"\"\n    Composite graph invariant that blends size, density, degree distribution,\n    clustering, triangle density, and assortativity into a single scalar.\n    \"\"\"\n    # Basic statistics\n    n          = s['n']\n    m          = s['m']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_cluster= s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # Triangle density (ratio of existing to possible triangles)\n    possible_triangles = (n * (n - 1) * (n - 2) / 6.0) if n > 2 else 1.0\n    triangle_ratio = triangles / possible_triangles\n\n    # Component 1 – size‑to‑edge ratio\n    size_edge_ratio = n / (m + 1.0)\n\n    # Component 2 – degree spread and variability\n    denom = max_deg + 1.0\n    degree_spread = (max_deg - min_deg + 1.0) / denom\n    degree_variability = 1.0 + std_deg / denom\n    degree_factor = (avg_deg / denom) * degree_spread * degree_variability\n\n    # Component 3 – clustering dampening (local vs global)\n    clustering_factor = (1.0 + avg_cluster) / (1.0 + trans)\n\n    # Component 4 – triangle density boost\n    triangle_factor = triangle_ratio + 0.1\n\n    # Component 5 – assortativity influence\n    assort_factor = 1.0 + abs(assort)\n\n    # Component 6 – size scaling\n    size_factor = n ** 0.5\n\n    # Combine all components multiplicatively\n    return (\n        size_edge_ratio *\n        degree_factor *\n        clustering_factor *\n        triangle_factor *\n        assort_factor *\n        size_factor\n    )",
        "island_id": 1,
        "generation": 8,
        "train_score": 0.7029531812725089,
        "val_score": 0.4606304153733223,
        "simplicity_score": 0.12250856077870916,
        "novelty_bonus": 0.185688142203555
      },
      {
        "id": "g9_i1_p1_110019618",
        "code": "def new_invariant(s):\n    \"\"\"\n    Composite graph invariant that blends size, density, degree distribution,\n    clustering, triangle density, and assortativity into a single scalar.\n    \"\"\"\n    # Basic statistics\n    n          = s['n']\n    m          = s['m']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_cluster= s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # Triangle density (ratio of existing to possible triangles)\n    possible_triangles = (n * (n - 1) * (n - 2) / 6.0) if n > 2 else 1.0\n    triangle_ratio = triangles / possible_triangles\n\n    # Component 1 – size‑to‑edge ratio\n    size_edge_ratio = n / (m + 1.0)\n\n    # Component 2 – degree spread and variability\n    denom = max_deg + 1.0\n    degree_spread = (max_deg - min_deg + 1.0) / denom\n    degree_variability = 1.0 + std_deg / denom\n    degree_factor = (avg_deg / denom) * degree_spread * degree_variability\n\n    # Component 3 – clustering dampening (local vs global)\n    clustering_factor = (1.0 + avg_cluster) / (1.0 + trans)\n\n    # Component 4 – triangle density boost\n    triangle_factor = triangle_ratio + 0.1\n\n    # Component 5 – assortativity influence\n    assort_factor = 1.0 + abs(assort)\n\n    # Component 6 – size scaling\n    size_factor = n ** 0.5\n\n    # Combine all components multiplicatively\n    return (\n        size_edge_ratio *\n        degree_factor *\n        clustering_factor *\n        triangle_factor *\n        assort_factor *\n        size_factor\n    )",
        "island_id": 1,
        "generation": 9,
        "train_score": 0.7029531812725089,
        "val_score": 0.4606304153733223,
        "simplicity_score": 0.12250856077870916,
        "novelty_bonus": 0.185688142203555
      },
      {
        "id": "g9_i1_p2_528696959",
        "code": "def new_invariant(s):\n    \"\"\"\n    Composite graph invariant that blends size, density, degree distribution,\n    clustering, triangle density, and assortativity into a single scalar.\n    \"\"\"\n    # Basic statistics\n    n          = s['n']\n    m          = s['m']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_cluster= s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # Triangle density (ratio of existing to possible triangles)\n    possible_triangles = (n * (n - 1) * (n - 2) / 6.0) if n > 2 else 1.0\n    triangle_ratio = triangles / possible_triangles\n\n    # Component 1 – size‑to‑edge ratio\n    size_edge_ratio = n / (m + 1.0)\n\n    # Component 2 – degree spread and variability\n    denom = max_deg + 1.0\n    degree_spread = (max_deg - min_deg + 1.0) / denom\n    degree_variability = 1.0 + std_deg / denom\n    degree_factor = (avg_deg / denom) * degree_spread * degree_variability\n\n    # Component 3 – clustering dampening (local vs global)\n    clustering_factor = (1.0 + avg_cluster) / (1.0 + trans)\n\n    # Component 4 – triangle density boost\n    triangle_factor = triangle_ratio + 0.1\n\n    # Component 5 – assortativity influence\n    assort_factor = 1.0 + abs(assort)\n\n    # Component 6 – size scaling\n    size_factor = n ** 0.5\n\n    # Combine all components multiplicatively\n    return (\n        size_edge_ratio *\n        degree_factor *\n        clustering_factor *\n        triangle_factor *\n        assort_factor *\n        size_factor\n    )",
        "island_id": 1,
        "generation": 9,
        "train_score": 0.7029531812725089,
        "val_score": 0.4606304153733223,
        "simplicity_score": 0.12250856077870916,
        "novelty_bonus": 0.185688142203555
      }
    ],
    "2": [
      {
        "id": "g15_i2_p4_284573368",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a dictionary of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            n (int)                     – number of nodes\n            m (int)                     – number of edges\n            density (float)             – edge density\n            avg_degree (float)          – average degree\n            max_degree (int)            – maximum degree\n            min_degree (int)            – minimum degree\n            std_degree (float)          – standard deviation of degrees\n            avg_clustering (float)      – average clustering coefficient\n            transitivity (float)        – global transitivity\n            degree_assortativity (float)- degree assortativity coefficient\n            num_triangles (int)         – total number of triangles\n            degrees (list[int])         – sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    if n <= 1:\n        return 0.0\n\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 1)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    tri        = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # Core connectivity term: higher density and average degree shorten paths\n    denom_conn = max(avg_deg, 1e-6) * max(density, 1e-6)\n    base = n / denom_conn\n\n    # Shortcuts from clustering and transitivity\n    base *= (1.0 + avg_clust + trans)\n\n    # Effect of assortativity (magnitude only)\n    base *= (1.0 + abs(assort))\n\n    # Triangle density adjustment\n    if m > 0:\n        base *= (1.0 + tri / m)\n\n    # Normalise by degree heterogeneity\n    base /= (1.0 + std_deg / max(avg_deg, 1e-6))\n    base /= (1.0 + min_deg / max(avg_deg, 1e-6))\n\n    # Penalise very high maximum degree\n    base /= (max_deg + 1.0)\n\n    # Median degree adjustment – captures skewness of the degree distribution\n    if degrees:\n        median_deg = degrees[len(degrees) // 2]\n        base *= (1.0 + (avg_deg - median_deg) / max(avg_deg, 1e-6))\n\n    return base",
        "island_id": 2,
        "generation": 15,
        "train_score": 0.9772388955582233,
        "val_score": 0.5706469319419225,
        "simplicity_score": 0.22113343699055302,
        "novelty_bonus": 0.18877249943814667
      },
      {
        "id": "g19_i2_p4_486891567",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a dictionary of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            n (int)                     – number of nodes\n            m (int)                     – number of edges\n            density (float)             – edge density\n            avg_degree (float)          – average degree\n            max_degree (int)            – maximum degree\n            min_degree (int)            – minimum degree\n            std_degree (float)          – standard deviation of degrees\n            avg_clustering (float)      – average clustering coefficient\n            transitivity (float)        – global transitivity\n            degree_assortativity (float)- degree assortativity coefficient\n            num_triangles (int)         – total number of triangles\n            degrees (list[int])         – sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    if n <= 1:\n        return 0.0\n\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 1)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    tri        = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # Core connectivity term: more edges or higher density shortens paths\n    denom_conn = max(avg_deg, 1e-6) * max(density, 1e-6)\n    base = n / denom_conn\n\n    # Shortcuts from clustering and transitivity\n    base *= 1.0 + avg_clust + trans\n\n    # Effect of assortativity (magnitude only, dampened)\n    base *= 1.0 + abs(assort) * 0.5\n\n    # Triangle density adjustment\n    if m > 0:\n        base *= 1.0 + tri / m\n\n    # Normalize by degree heterogeneity\n    base /= 1.0 + std_deg / max(avg_deg, 1e-6)\n    base /= 1.0 + min_deg / max(avg_deg, 1e-6)\n\n    # Penalise very high maximum degree\n    base /= (max_deg + 1.0)\n\n    # Median degree adjustment – captures skewness of the degree distribution\n    if degrees:\n        median_deg = degrees[len(degrees) // 2]\n        base *= 1.0 + (avg_deg - median_deg) / max(avg_deg, 1e-6)\n\n    # Edge‑count scaling – more edges generally reduce path length\n    base *= 1.0 + (m ** 0.5) / (n + 1e-6)\n\n    return base",
        "island_id": 2,
        "generation": 19,
        "train_score": 0.9741656662665067,
        "val_score": 0.5690325827376294,
        "simplicity_score": 0.22051463019207068,
        "novelty_bonus": 0.19244158923238974
      },
      {
        "id": "g18_i2_p0_448558859",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a dictionary of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            n (int)                     – number of nodes\n            m (int)                     – number of edges\n            density (float)             – edge density\n            avg_degree (float)          – average degree\n            max_degree (int)            – maximum degree\n            min_degree (int)            – minimum degree\n            std_degree (float)          – standard deviation of degrees\n            avg_clustering (float)      – average clustering coefficient\n            transitivity (float)        – global transitivity\n            degree_assortativity (float)- degree assortativity coefficient\n            num_triangles (int)         – total number of triangles\n            degrees (list[int])         – sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    if n <= 1:\n        return 0.0\n\n    m = s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_deg = max(s.get('avg_degree', 0.0), 1e-6)\n\n    # Core connectivity term\n    base = n / (avg_deg * density + 1e-6)\n\n    # Shortcuts from clustering and transitivity\n    base *= 1.0 + s.get('avg_clustering', 0.0) + s.get('transitivity', 0.0)\n\n    # Effect of assortativity (magnitude only)\n    base *= 1.0 + abs(s.get('degree_assortativity', 0.0))\n\n    # Triangle density adjustment\n    tri = s.get('num_triangles', 0)\n    if m > 0:\n        base *= 1.0 + tri / m\n\n    # Normalize by degree heterogeneity\n    std_deg = s.get('std_degree', 0.0)\n    base /= 1.0 + std_deg / avg_deg\n    min_deg = s.get('min_degree', 0)\n    base /= 1.0 + min_deg / avg_deg\n\n    # Penalise very high maximum degree\n    max_deg = max(s.get('max_degree', 1), 1)\n    base /= (max_deg + 1.0)\n\n    # Median degree adjustment – captures skewness of the degree distribution\n    degrees = s.get('degrees', [])\n    if degrees:\n        median_deg = degrees[len(degrees) // 2]\n        base *= 1.0 + (avg_deg - median_deg) / avg_deg\n\n    # Edge‑count scaling – more edges generally reduce path length\n    base *= 1.0 + (m ** 0.5) / (n + 1e-6)\n\n    return base",
        "island_id": 2,
        "generation": 18,
        "train_score": 0.9760864345738295,
        "val_score": 0.5679812533719109,
        "simplicity_score": 0.2214354802823629,
        "novelty_bonus": 0.18032055788563106
      },
      {
        "id": "g19_i2_p3_670658885",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a dictionary of pre‑computed\n    graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            n (int)                     – number of nodes\n            m (int)                     – number of edges\n            density (float)             – edge density\n            avg_degree (float)          – average degree\n            max_degree (int)            – maximum degree\n            min_degree (int)            – minimum degree\n            std_degree (float)          – standard deviation of degrees\n            avg_clustering (float)      – average clustering coefficient\n            transitivity (float)        – global transitivity\n            degree_assortativity (float)- degree assortativity coefficient\n            num_triangles (int)         – total number of triangles\n            degrees (list[int])         – sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    if n <= 1:\n        return 0.0\n\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 0.0), 1e-6)\n    max_deg    = max(s.get('max_degree', 1), 1)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    tri        = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # Core connectivity: higher density and average degree shorten paths\n    base = n / (avg_deg * max(density, 1e-6) + 1e-6)\n\n    # Shortcuts from clustering and transitivity\n    base *= 1.0 + avg_clust + trans\n\n    # Effect of assortativity (magnitude only)\n    base *= 1.0 + abs(assort)\n\n    # Triangle density adjustment\n    if m > 0:\n        base *= 1.0 + tri / m\n\n    # Normalise by degree heterogeneity\n    base /= 1.0 + std_deg / avg_deg\n    base /= 1.0 + min_deg / avg_deg\n\n    # Penalise very high maximum degree\n    base /= (max_deg + 1.0)\n\n    # Median degree adjustment – captures skewness of the degree distribution\n    if degrees:\n        median_deg = degrees[len(degrees) // 2]\n        base *= 1.0 + (avg_deg - median_deg) / avg_deg\n\n    # Edge‑count scaling – more edges generally reduce path length\n    base *= 1.0 + (m ** 0.5) / (n + 1e-6)\n\n    return base",
        "island_id": 2,
        "generation": 19,
        "train_score": 0.9760864345738295,
        "val_score": 0.5678687722890087,
        "simplicity_score": 0.22087307486785207,
        "novelty_bonus": 0.18032055788563106
      },
      {
        "id": "g19_i2_p2_576627228",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a dictionary of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            n (int)                     – number of nodes\n            m (int)                     – number of edges\n            density (float)             – edge density\n            avg_degree (float)          – average degree\n            max_degree (int)            – maximum degree\n            min_degree (int)            – minimum degree\n            std_degree (float)          – standard deviation of degrees\n            avg_clustering (float)      – average clustering coefficient\n            transitivity (float)        – global transitivity\n            degree_assortativity (float)- degree assortativity coefficient\n            num_triangles (int)         – total number of triangles\n            degrees (list[int])         – sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic parameters with safe defaults\n    n = s.get('n', 1)\n    if n <= 1:\n        return 0.0\n\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 0.0), 1e-6)\n    max_deg    = max(s.get('max_degree', 1), 1)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    tri        = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Core connectivity: larger density/avg degree → shorter paths\n    base = n / (avg_deg * max(density, 1e-6) + 1e-6)\n\n    # 2. Shortcuts from clustering and transitivity\n    base *= 1.0 + avg_clust + trans\n\n    # 3. Effect of assortativity (use magnitude only)\n    base *= 1.0 + abs(assort)\n\n    # 4. Triangle density adjustment\n    if m > 0:\n        base *= 1.0 + tri / m\n\n    # 5. Normalize by degree heterogeneity\n    base /= 1.0 + std_deg / avg_deg\n    base /= 1.0 + min_deg / avg_deg\n\n    # 6. Penalise very high maximum degree\n    base /= (max_deg + 1.0)\n\n    # 7. Median degree adjustment (skewness)\n    if degrees:\n        median_deg = degrees[len(degrees) // 2]\n        base *= 1.0 + (avg_deg - median_deg) / avg_deg\n\n    # 8. Edge‑count scaling – more edges usually reduce path length\n    base *= 1.0 + pow(m, 0.5) / (n + 1e-6)\n\n    return base",
        "island_id": 2,
        "generation": 19,
        "train_score": 0.9760864345738295,
        "val_score": 0.567863113641667,
        "simplicity_score": 0.22084478163114366,
        "novelty_bonus": 0.18032055788563106
      }
    ],
    "3": [
      {
        "id": "g5_i2_p4_26965764",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The formula starts with the graph size divided by a connectivity term and\n    then applies multiplicative adjustments for clustering, assortativity,\n    triangle density, and normalises by degree heterogeneity and maximum\n    degree.  No external libraries are required.\n    \"\"\"\n    n = s.get('n', 1)\n    if n <= 1:\n        return 0.0\n\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 1)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    tri        = s.get('num_triangles', 0)\n\n    # Connectivity denominator – higher density and average degree shorten paths\n    denom_conn = max(avg_deg, 1e-6) * max(density, 1e-6)\n    base = n / denom_conn\n\n    # Clustering creates shortcuts\n    base *= (1.0 + avg_clust)\n\n    # Assortativity affects path length – treat magnitude symmetrically\n    base *= (1.0 + abs(assort))\n\n    # Triangle density – more triangles usually reduce average distance\n    if m > 0:\n        base *= (1.0 + tri / m)\n\n    # Degree heterogeneity – highly heterogeneous networks (hubs) typically\n    # have shorter paths, so we divide by the spread\n    base /= (1.0 + std_deg / max(avg_deg, 1e-6))\n    base /= (1.0 + min_deg / max(avg_deg, 1e-6))\n\n    # Penalise very high maximum degree (few hubs) to avoid over‑shortening\n    base /= (max_deg + 1.0)\n\n    return base",
        "island_id": 2,
        "generation": 5,
        "train_score": 0.9677310924369749,
        "val_score": 0.5676243841107219,
        "simplicity_score": 0.22335485883721273,
        "novelty_bonus": 0.20045697311756405
      },
      {
        "id": "g19_i3_p3_423842923",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only the supplied\n    statistics.  The estimator is a hand‑crafted nonlinear combination of\n    size, connectivity, degree heterogeneity, clustering, assortativity\n    and triangle density.  No external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph descriptors.  Expected keys are\n        (all optional – defaults are provided where appropriate):\n          n                      int      number of nodes\n          m                      int      number of edges\n          density                float    2m/(n*(n-1))\n          avg_degree             float    average degree\n          max_degree             int\n          min_degree             int\n          std_degree             float    std deviation of degrees\n          avg_clustering         float    average local clustering\n          transitivity           float    global transitivity\n          degree_assortativity   float    assortativity coefficient\n          num_triangles          int      triangle count\n          degrees                list[int] sorted degree sequence\n\n    Returns\n    -------\n    float\n        Proxy value for the average shortest‑path length.\n    \"\"\"\n    eps = 1e-12  # guard against division by zero\n\n    # --- basic scalars ----------------------------------------------------\n    n   = float(s.get('n', 1))\n    m   = float(s.get('m', 0))\n    dens = float(s.get('density', 0.0))\n    avg_deg  = float(s.get('avg_degree', 0.0))\n    max_deg  = float(s.get('max_degree', 0))\n    min_deg  = float(s.get('min_degree', 0))\n    std_deg  = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans    = float(s.get('transitivity', 0.0))\n    assort   = float(s.get('degree_assortativity', 0.0))\n    num_tri  = float(s.get('num_triangles', 0))\n    degs     = s.get('degrees', [])\n\n    # --- derived structural terms -----------------------------------------\n    # triangle density ratio\n    if n >= 3:\n        possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n        tri_ratio = num_tri / (possible_tri + eps)\n    else:\n        tri_ratio = 0.0\n\n    # harmonic mean of degrees (captures the burden of many low‑degree nodes)\n    if degs:\n        inv_sum = 0.0\n        for d in degs:\n            inv_sum += 1.0 / (float(d) + eps)\n        h_mean = n / (inv_sum + eps)\n    else:\n        h_mean = 0.0\n\n    # median degree for a quick skew check\n    dlen = len(degs)\n    if dlen > 0:\n        if dlen % 2 == 1:\n            median_deg = float(degs[dlen // 2])\n        else:\n            median_deg = (float(degs[dlen // 2 - 1]) +\n                          float(degs[dlen // 2])) * 0.5\n    else:\n        median_deg = 0.0\n\n    # --- base scaling -----------------------------------------------------\n    # Larger graphs with sparser connectivity produce longer paths.\n    # The power 0.6 on n provides sub‑linear growth, while the denominator\n    # combines average degree with a density term to shorten the base.\n    base = (n ** 0.6) / ((avg_deg + eps) * (1.0 + dens))\n\n    # --- modulate by structural features ---------------------------------\n    # Clustering and transitivity give shortcuts, so we *increase* the\n    # base in proportion to them.\n    base *= (1.0 + avg_clust + eps)\n    base *= (1.0 + trans + eps)\n\n    # More triangles -> shorter paths: shrink the base according to tri_ratio.\n    base *= (1.0 - 0.35 * tri_ratio)\n\n    # Assortativity magnitude typically lengthens paths; treat positive\n    # and negative values symmetrically.\n    base *= (1.0 + abs(assort) * 0.25)\n\n    # Degree dispersion: a larger std deviation (many hubs) shortens paths.\n    base /= (1.0 + std_deg / (avg_deg + eps))\n\n    # Max and min degree influence connectivity.  High max degree implies\n    # fewer hubs relative to the graph size, so we mildly penalise it.\n    base /= (1.0 + max_deg / (n * avg_deg + eps))\n\n    # A small minimum degree hints at dangling nodes; we give a gentle\n    # penalty for very low min_deg.\n    if min_deg > 0:\n        base *= (1.0 + (avg_deg / min_deg - 1.0) * 0.15)\n\n    # Harmonic mean bonus: more low‑degree nodes inflate distances.\n    base += h_mean * 0.02\n\n    # Median‑degree check: if the median is below the mean, paths are\n    # likely longer than predicted by the mean alone.\n    if avg_deg > 0:\n        base *= (1.0 + (median_deg / avg_deg - 1.0) * 0.1)\n\n    # Final sanity check – the estimate must be non‑negative.\n    return base if base > 0.0 else 0.0",
        "island_id": 3,
        "generation": 19,
        "train_score": 0.9464105642256901,
        "val_score": 0.5059607763630505,
        "simplicity_score": 0.13685456449863564,
        "novelty_bonus": 0.1826167278073174
      },
      {
        "id": "g16_i3_p1_35770155",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of\n    pre‑computed graph statistics.  The estimator is a handcrafted\n    non‑linear combination of size, density, degree, clustering,\n    triangles, assortativity, and degree heterogeneity.  It uses only\n    basic Python operations (no external imports, no graph traversal).\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph descriptors with keys:\n        - 'n'                   : int      number of vertices\n        - 'm'                   : int      number of edges\n        - 'density'             : float    edge density\n        - 'avg_degree'          : float    average degree\n        - 'max_degree'          : int\n        - 'min_degree'          : int\n        - 'std_degree'          : float\n        - 'avg_clustering'      : float\n        - 'transitivity'        : float\n        - 'degree_assortativity': float\n        - 'num_triangles'       : int\n        - 'degrees'             : list[int] sorted degree sequence\n\n    Returns\n    -------\n    float\n        A proxy that grows monotonically with the true average shortest‑path length.\n    \"\"\"\n    # Extract features as floats\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']\n\n    eps = 1e-12  # to avoid divisions by zero\n\n    # --------------------\n    # 1. Core scaling\n    #    In sparse or very large graphs the distance is large.\n    #    We use the square‑root of the size and divide by density\n    #    and average degree, which are classic ingredients for path length\n    #    in random graph theory.\n    # --------------------\n    base = (n ** 0.5) / ((density + eps) * (avg_deg + eps))\n\n    # --------------------\n    # 2. Modulators that lengthen or shorten paths\n    # --------------------\n    # 2a. Clustering / transitivity usually provide shortcuts:\n    #     we let them *increase* the base value (making it larger) and then\n    #     scale it by the same factor, effectively reducing the final output.\n    base *= (1 + avg_clust + eps)\n    base *= (1 + trans + eps)\n\n    # 2b. Assortativity magnitude tends to increase distances,\n    #     irrespective of its sign, so we multiply by a factor\n    #     that grows with |assort|.\n    base *= (1 + abs(assort) + eps)\n\n    # 2c. Triangles create many local cycles; the more abundant\n    #     they are relative to the edge count, the shorter the global\n    #     distance tends to be.  We therefore shrink the base in\n    #     proportion to the triangle-to‑edge ratio.\n    if m > 0:\n        tri_ratio = num_tri / (m + eps)\n        base *= (1 - 0.3 * tri_ratio)  # 0.3 is an empirically chosen weight\n\n    # --------------------\n    # 3. Heterogeneity corrections\n    # --------------------\n    # High degree variance (hubs) typically reduce distances.\n    base /= (1 + std_deg / (avg_deg + eps))\n\n    # The presence of very high or very low degrees also influences\n    # connectivity.  We penalise a high maximum degree (fewer hubs)\n    # and reward a higher minimum degree (fewer isolated nodes).\n    base /= (1 + max_deg / (avg_deg + eps))\n    base *= (1 + min_deg / (avg_deg + eps))\n\n    # --------------------\n    # 4. Harmonic‑mean bonus\n    # --------------------\n    # A large harmonic mean indicates many low‑degree nodes, which tends\n    # to increase distances.  We add a small scaled bonus to capture this.\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            if d > 0:\n                inv_sum += 1.0 / (d + eps)\n        h_mean = n / (inv_sum + eps)\n        base += 0.05 * h_mean\n\n    # Ensure a non‑negative return\n    return max(base, 0.0)",
        "island_id": 3,
        "generation": 16,
        "train_score": 0.7233909910812949,
        "val_score": 0.49546376938844383,
        "simplicity_score": 0.1569801800935419,
        "novelty_bonus": 0.18714239576370129
      },
      {
        "id": "g7_i3_p2_321199476",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a collection of\n    pre‑computed graph statistics.  The formula is a non‑linear\n    combination of size, density, clustering, triangles, assortativity,\n    and degree heterogeneity.  It uses only basic Python operations\n    (no imports, no graph traversal, no external libraries).\n\n    Parameters\n    ----------\n    s : dict\n        Graph features.  Expected keys:\n            n                     (int)      number of vertices\n            m                     (int)      number of edges\n            density               (float)    2m/(n(n-1))\n            avg_degree            (float)    average vertex degree\n            max_degree            (int)\n            min_degree            (int)\n            std_degree            (float)\n            avg_clustering        (float)    average local clustering\n            transitivity          (float)    global transitivity\n            degree_assortativity  (float)    assortativity coefficient\n            num_triangles         (int)      count of triangles\n            degrees               (list[int]) sorted degree sequence\n\n    Returns\n    -------\n    float\n        A scalar proxy for the average shortest‑path length.\n    \"\"\"\n    eps = 1e-12  # prevents divisions by zero\n\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    avg_deg = float(s['avg_degree'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    std_deg = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n    degs = s['degrees']\n\n    # ------------------------------------------------------------------\n    # 1. Harmonic mean of degrees (captures how many low‑degree nodes exist)\n    # ------------------------------------------------------------------\n    if degs:\n        inv_sum = 0.0\n        for d in degs:\n            if d > 0:\n                inv_sum += 1.0 / (d + eps)\n        harmonic_mean = n / (inv_sum + eps)\n    else:\n        harmonic_mean = 0.0\n\n    # ------------------------------------------------------------------\n    # 2. Triangle density factor (non‑linear, bell‑shaped influence)\n    # ------------------------------------------------------------------\n    if n >= 3:\n        possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n        tri_frac = num_tri / (possible_tri + eps)\n    else:\n        tri_frac = 0.0\n    tri_term = tri_frac * (1.0 - tri_frac)  # maximised near tri_frac≈0.5\n\n    # ------------------------------------------------------------------\n    # 3. Core multiplicative base: relates size & connectivity\n    # ------------------------------------------------------------------\n    base = (1.0 + n * density) / (1.0 + avg_deg + harmonic_mean)\n\n    # ------------------------------------------------------------------\n    # 4. Modulate with structural features\n    # ------------------------------------------------------------------\n    base *= (1.0 + tri_term) ** 0.6\n    base *= (1.0 - avg_clust) ** 0.4\n    base *= (1.0 - trans) ** 0.3\n    base *= (1.0 - assort) ** 0.2\n\n    # ------------------------------------------------------------------\n    # 5. Dispersion correction: captures heterogeneity in degrees\n    # ------------------------------------------------------------------\n    if degs:\n        mean_sq = sum(d * d for d in degs) / n\n    else:\n        mean_sq = 0.0\n    disp_term = (std_deg / (max_deg + eps)) * (mean_sq / (max_deg + eps))\n    base += disp_term\n\n    return base",
        "island_id": 3,
        "generation": 7,
        "train_score": 0.5928931572629051,
        "val_score": 0.4439060289952909,
        "simplicity_score": 0.21895565682377716,
        "novelty_bonus": 0.1920152829090549
      },
      {
        "id": "g15_i2_p4_284573368",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a dictionary of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            n (int)                     – number of nodes\n            m (int)                     – number of edges\n            density (float)             – edge density\n            avg_degree (float)          – average degree\n            max_degree (int)            – maximum degree\n            min_degree (int)            – minimum degree\n            std_degree (float)          – standard deviation of degrees\n            avg_clustering (float)      – average clustering coefficient\n            transitivity (float)        – global transitivity\n            degree_assortativity (float)- degree assortativity coefficient\n            num_triangles (int)         – total number of triangles\n            degrees (list[int])         – sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    if n <= 1:\n        return 0.0\n\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 1)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    tri        = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # Core connectivity term: higher density and average degree shorten paths\n    denom_conn = max(avg_deg, 1e-6) * max(density, 1e-6)\n    base = n / denom_conn\n\n    # Shortcuts from clustering and transitivity\n    base *= (1.0 + avg_clust + trans)\n\n    # Effect of assortativity (magnitude only)\n    base *= (1.0 + abs(assort))\n\n    # Triangle density adjustment\n    if m > 0:\n        base *= (1.0 + tri / m)\n\n    # Normalise by degree heterogeneity\n    base /= (1.0 + std_deg / max(avg_deg, 1e-6))\n    base /= (1.0 + min_deg / max(avg_deg, 1e-6))\n\n    # Penalise very high maximum degree\n    base /= (max_deg + 1.0)\n\n    # Median degree adjustment – captures skewness of the degree distribution\n    if degrees:\n        median_deg = degrees[len(degrees) // 2]\n        base *= (1.0 + (avg_deg - median_deg) / max(avg_deg, 1e-6))\n\n    return base",
        "island_id": 2,
        "generation": 15,
        "train_score": 0.9772388955582233,
        "val_score": 0.5706469319419225,
        "simplicity_score": 0.22113343699055302,
        "novelty_bonus": 0.18877249943814667
      }
    ]
  }
}