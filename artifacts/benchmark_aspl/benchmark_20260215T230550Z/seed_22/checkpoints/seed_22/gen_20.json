{
  "experiment_id": "seed_22",
  "generation": 20,
  "rng_seed": 22,
  "rng_state": {
    "bit_generator": "PCG64",
    "state": {
      "state": 271037118921978862075268098222607868910,
      "inc": 188221490827988801950180874055372779863
    },
    "has_uint32": 1,
    "uinteger": 1399671670
  },
  "best_val_score": 0.5711878370419312,
  "no_improve_count": 2,
  "island_stagnation": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_prompt_mode": {
    "0": "free",
    "1": "free",
    "2": "free",
    "3": "free"
  },
  "island_constrained_generations": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_recent_failures": {
    "0": [
      "below_novelty_threshold: novelty_bonus=0.101399",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "no_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`"
    ],
    "1": [
      "below_novelty_threshold: novelty_bonus=0.123869",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "no_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`"
    ],
    "2": [
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_novelty_threshold: novelty_bonus=0.031009",
      "below_novelty_threshold: novelty_bonus=0.085950"
    ],
    "3": [
      "below_novelty_threshold: novelty_bonus=0.107422",
      "below_novelty_threshold: novelty_bonus=0.048614",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ]
  },
  "islands": {
    "0": [
      {
        "id": "g3_i3_p4_640731440",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv",
        "island_id": 3,
        "generation": 3,
        "train_score": 0.6675150060024009,
        "val_score": 0.5050074307461163,
        "simplicity_score": 0.24795247661365372,
        "novelty_bonus": 0.38647566189154714
      },
      {
        "id": "g9_i0_p1_469045582",
        "code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj",
        "island_id": 0,
        "generation": 9,
        "train_score": 0.6852821128451381,
        "val_score": 0.4227865215943897,
        "simplicity_score": 0.12280850557015646,
        "novelty_bonus": 0.15809933534953824
      },
      {
        "id": "g17_i3_p1_635457581",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    only.  The expression combines size, degree distribution, assortativity,\n    clustering, density, triangle prevalence, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n, m\n        - density\n        - avg_degree\n        - max_degree, min_degree\n        - std_degree\n        - avg_clustering\n        - transitivity\n        - degree_assortativity\n        - num_triangles\n        - degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    num_tri  = float(s['num_triangles'])\n    degrees  = s['degrees']\n\n    # Harmonic mean of positive degrees (avoid division by zero)\n    positive_degrees = [d for d in degrees if d > 0]\n    if positive_degrees:\n        hm_den = sum(1.0 / d for d in positive_degrees)\n        harmonic = float(len(positive_degrees)) / hm_den\n    else:\n        harmonic = 0.1  # fallback for empty or all-zero degree lists\n\n    # Triangle ratio (fraction of possible triangles that exist)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n\n    # Degree heterogeneity adjustment (larger std or spread shortens paths)\n    heter = 1.0 + std_deg + (max_deg - min_deg) / (max_deg if max_deg > 0 else 1.0)\n\n    # Baseline: larger n or smaller connectivity yields longer paths\n    inv = n / (harmonic + 1.0)\n\n    # Positive assortativity tends to stretch paths\n    inv *= (1.0 + abs(assort))\n\n    # Local clustering tends to create detours\n    inv *= (1.0 + clust)\n\n    # Heterogeneity (hubs) shortens paths\n    inv /= heter\n\n    # Density reduces expected distance (cap at 0.05)\n    density_factor = max(0.05, 1.0 - density)\n    inv *= density_factor\n\n    # Triangle abundance shortens paths\n    inv /= (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    inv *= (1.0 + trans)\n\n    return inv",
        "island_id": 3,
        "generation": 17,
        "train_score": 0.876110444177671,
        "val_score": 0.5711878370419312,
        "simplicity_score": 0.24693498306801742,
        "novelty_bonus": 0.18294472497584757
      },
      {
        "id": "g15_i0_p2_147373253",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and\n    built‑in functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result",
        "island_id": 0,
        "generation": 15,
        "train_score": 0.6368787515006001,
        "val_score": 0.40071171245062676,
        "simplicity_score": 0.1900184737509212,
        "novelty_bonus": 0.21491187279681978
      },
      {
        "id": "g16_i0_p0_565227697",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and\n    built‑in functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result",
        "island_id": 0,
        "generation": 16,
        "train_score": 0.6368787515006001,
        "val_score": 0.40071171245062676,
        "simplicity_score": 0.1900184737509212,
        "novelty_bonus": 0.21491187279681978
      }
    ],
    "1": [
      {
        "id": "g9_i0_p1_469045582",
        "code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj",
        "island_id": 0,
        "generation": 9,
        "train_score": 0.6852821128451381,
        "val_score": 0.4227865215943897,
        "simplicity_score": 0.12280850557015646,
        "novelty_bonus": 0.15809933534953824
      },
      {
        "id": "g16_i1_p2_191877019",
        "code": "def new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom",
        "island_id": 1,
        "generation": 16,
        "train_score": 0.40004801920768307,
        "val_score": 0.2898756238737576,
        "simplicity_score": 0.14957237422515934,
        "novelty_bonus": 0.20360309007725186
      },
      {
        "id": "g18_i1_p0_22933025",
        "code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom",
        "island_id": 1,
        "generation": 18,
        "train_score": 0.40004801920768307,
        "val_score": 0.28986507947351237,
        "simplicity_score": 0.1495196522239334,
        "novelty_bonus": 0.20360309007725186
      },
      {
        "id": "g3_i3_p4_640731440",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv",
        "island_id": 3,
        "generation": 3,
        "train_score": 0.6675150060024009,
        "val_score": 0.5050074307461163,
        "simplicity_score": 0.24795247661365372,
        "novelty_bonus": 0.38647566189154714
      },
      {
        "id": "g18_i1_p2_289156802",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula combines a baseline size/degree term with multiplicative\n    adjustments for density, clustering, assortativity, degree heterogeneity,\n    hubs, and triangles.  It also adds a normalised degree‑squared term and an\n    extra term that couples clustering with transitivity.  The result is\n    normalised by a denominator that keeps the invariant bounded.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri +\n        abs(assort) + std_deg\n    )\n\n    return numerator / denom",
        "island_id": 1,
        "generation": 18,
        "train_score": 0.40004801920768307,
        "val_score": 0.28985810231983333,
        "simplicity_score": 0.14948476645553802,
        "novelty_bonus": 0.20360309007725186
      }
    ],
    "2": [
      {
        "id": "g12_i2_p0_580063942",
        "code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base",
        "island_id": 2,
        "generation": 12,
        "train_score": 0.8946458583433373,
        "val_score": 0.5655869739267355,
        "simplicity_score": 0.21999977568039208,
        "novelty_bonus": 0.16697410473657626
      },
      {
        "id": "g15_i2_p4_691908570",
        "code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and\n    subtle heterogeneity effects.  Only built‑in arithmetic operators\n    are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base",
        "island_id": 2,
        "generation": 15,
        "train_score": 0.8919567827130852,
        "val_score": 0.56514307410756,
        "simplicity_score": 0.21950110553726354,
        "novelty_bonus": 0.1711320180630589
      },
      {
        "id": "g14_i2_p1_570424635",
        "code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base",
        "island_id": 2,
        "generation": 14,
        "train_score": 0.8849459783913565,
        "val_score": 0.563681064469733,
        "simplicity_score": 0.21990166475003348,
        "novelty_bonus": 0.15962145387447446
      },
      {
        "id": "g18_i2_p4_476297302",
        "code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base",
        "island_id": 2,
        "generation": 18,
        "train_score": 0.8849459783913565,
        "val_score": 0.563681064469733,
        "simplicity_score": 0.21990166475003348,
        "novelty_bonus": 0.15962145387447446
      },
      {
        "id": "g16_i2_p2_48183479",
        "code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is then adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and a\n    subtle heterogeneity term.  No external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base",
        "island_id": 2,
        "generation": 16,
        "train_score": 0.8849459783913565,
        "val_score": 0.5636569618651329,
        "simplicity_score": 0.2197811517270328,
        "novelty_bonus": 0.15962145387447446
      }
    ],
    "3": [
      {
        "id": "g17_i3_p1_635457581",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    only.  The expression combines size, degree distribution, assortativity,\n    clustering, density, triangle prevalence, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n, m\n        - density\n        - avg_degree\n        - max_degree, min_degree\n        - std_degree\n        - avg_clustering\n        - transitivity\n        - degree_assortativity\n        - num_triangles\n        - degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    num_tri  = float(s['num_triangles'])\n    degrees  = s['degrees']\n\n    # Harmonic mean of positive degrees (avoid division by zero)\n    positive_degrees = [d for d in degrees if d > 0]\n    if positive_degrees:\n        hm_den = sum(1.0 / d for d in positive_degrees)\n        harmonic = float(len(positive_degrees)) / hm_den\n    else:\n        harmonic = 0.1  # fallback for empty or all-zero degree lists\n\n    # Triangle ratio (fraction of possible triangles that exist)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n\n    # Degree heterogeneity adjustment (larger std or spread shortens paths)\n    heter = 1.0 + std_deg + (max_deg - min_deg) / (max_deg if max_deg > 0 else 1.0)\n\n    # Baseline: larger n or smaller connectivity yields longer paths\n    inv = n / (harmonic + 1.0)\n\n    # Positive assortativity tends to stretch paths\n    inv *= (1.0 + abs(assort))\n\n    # Local clustering tends to create detours\n    inv *= (1.0 + clust)\n\n    # Heterogeneity (hubs) shortens paths\n    inv /= heter\n\n    # Density reduces expected distance (cap at 0.05)\n    density_factor = max(0.05, 1.0 - density)\n    inv *= density_factor\n\n    # Triangle abundance shortens paths\n    inv /= (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    inv *= (1.0 + trans)\n\n    return inv",
        "island_id": 3,
        "generation": 17,
        "train_score": 0.876110444177671,
        "val_score": 0.5711878370419312,
        "simplicity_score": 0.24693498306801742,
        "novelty_bonus": 0.18294472497584757
      },
      {
        "id": "g15_i3_p2_723124771",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base",
        "island_id": 3,
        "generation": 15,
        "train_score": 0.8541176470588233,
        "val_score": 0.5628569525897064,
        "simplicity_score": 0.22276519780937393,
        "novelty_bonus": 0.19250133063328534
      },
      {
        "id": "g18_i3_p2_351801839",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics provided in the dictionary `s`.  The formula is a\n    product‑sum of terms that capture how size, connectivity, degree\n    heterogeneity, clustering, assortativity, density, triangles and\n    transitivity influence expected path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys:\n            n, avg_degree, std_degree, avg_clustering,\n            degree_assortativity, density, max_degree,\n            num_triangles, transitivity\n\n    Returns\n    -------\n    float\n        An approximation of the average shortest‑path length.\n    \"\"\"\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    num_tri    = float(s['num_triangles'])\n    trans      = float(s['transitivity'])\n\n    # 1. Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1.0)\n\n    # 2. Clustering tends to create detours\n    base *= (1.0 + clust)\n\n    # 3. Positive assortativity typically lengthens paths\n    base *= (1.0 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Higher density reduces expected distance\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0.0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Effect of the most connected nodes as central hubs\n    hub_factor = 1.0 + max_deg / (n * (avg_deg + 1e-6))\n    base *= hub_factor\n\n    return base",
        "island_id": 3,
        "generation": 18,
        "train_score": 0.8541176470588233,
        "val_score": 0.5627764779382297,
        "simplicity_score": 0.22236282455199058,
        "novelty_bonus": 0.19250133063328534
      },
      {
        "id": "g18_i3_p3_466817927",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    # Basic scalars extracted once\n    n            = float(s['n'])\n    avg_deg      = float(s['avg_degree'])\n    std_deg      = float(s['std_degree'])\n    max_deg      = float(s['max_degree'])\n    clust        = float(s['avg_clustering'])\n    trans        = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    density      = float(s['density'])\n    num_tri      = float(s['num_triangles'])\n\n    # 1. Baseline: grows with graph size, shrinks with connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Positive assortativity tends to elongate paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours – scale up\n    base *= (1.0 + clust)\n\n    # 4. Degree heterogeneity (large variance → hubs → shorter paths)\n    base /= (1.0 + std_deg)\n\n    # 5. Density effect – denser graphs have shorter paths\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 6. Triangle abundance provides local shortcuts\n    # Compute triangle ratio: triangles / possible triangles\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0:\n        possible_tri = 1.0  # avoid division by zero\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity further shortens distances\n    base *= (1.0 + trans)\n\n    # 8. Extra contribution from the most connected nodes\n    # Very large hubs act as a backbone shortening overall distance\n    hub_factor = max_deg / (n * (avg_deg + 1e-6))\n    base *= (1.0 + hub_factor)\n\n    return base",
        "island_id": 3,
        "generation": 18,
        "train_score": 0.8541176470588233,
        "val_score": 0.5627764779382297,
        "simplicity_score": 0.22236282455199058,
        "novelty_bonus": 0.19250133063328534
      },
      {
        "id": "g12_i2_p0_580063942",
        "code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base",
        "island_id": 2,
        "generation": 12,
        "train_score": 0.8946458583433373,
        "val_score": 0.5655869739267355,
        "simplicity_score": 0.21999977568039208,
        "novelty_bonus": 0.16697410473657626
      }
    ]
  }
}