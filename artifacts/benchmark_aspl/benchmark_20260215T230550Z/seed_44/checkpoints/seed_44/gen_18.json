{
  "experiment_id": "seed_44",
  "generation": 18,
  "rng_seed": 44,
  "rng_state": {
    "bit_generator": "PCG64",
    "state": {
      "state": 78791268882876159795089581165035759724,
      "inc": 762441968459946881146668352658223677
    },
    "has_uint32": 1,
    "uinteger": 2624385527
  },
  "best_val_score": 0.534056960060647,
  "no_improve_count": 0,
  "island_stagnation": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_prompt_mode": {
    "0": "free",
    "1": "free",
    "2": "free",
    "3": "free"
  },
  "island_constrained_generations": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_recent_failures": {
    "0": [
      "below_novelty_threshold: novelty_bonus=0.052551",
      "below_train_threshold: train_signal=0.161585",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ],
    "1": [
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_train_threshold: train_signal=0.151212",
      "below_train_threshold: train_signal=0.055942"
    ],
    "2": [
      "below_train_threshold: train_signal=0.118944",
      "below_novelty_threshold: novelty_bonus=0.033737",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ],
    "3": [
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_novelty_threshold: novelty_bonus=0.126360",
      "below_novelty_threshold: novelty_bonus=0.034259"
    ]
  },
  "islands": {
    "0": [
      {
        "id": "g8_i3_p3_315365990",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    global graph statistics.  The formula is a non‑trivial combination of\n    size, density, clustering, degree heterogeneity, assortativity,\n    triangle density, and a harmonic‑mean degree factor – but it never\n    returns a single feature nor performs any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the following keys (missing keys default to a neutral\n        value):\n        - 'n'                 : number of nodes\n        - 'avg_degree'        : average degree\n        - 'std_degree'        : standard deviation of the degree sequence\n        - 'avg_clustering'    : average local clustering coefficient\n        - 'transitivity'      : global transitivity\n        - 'degree_assortativity' : degree assortativity coefficient\n        - 'num_triangles'     : number of triangles\n        - 'degrees'           : list of degrees (unsorted is also fine)\n\n    Returns\n    -------\n    float\n        A dimensionless estimate that correlates with the true\n        average shortest‑path length.  The value is positive for any\n        feasible input.\n    \"\"\"\n    # Basic scaling: distances grow roughly like sqrt(n)\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n    val = n ** 0.5\n\n    # Local cohesion: reward high clustering and transitivity\n    val *= (1.0 + s.get('avg_clustering', 0.0))\n    val *= (1.0 + s.get('transitivity', 0.0))\n\n    # Normalise by overall density (avg_degree)\n    avg_deg = s.get('avg_degree', 0.0)\n    denom = avg_deg + 1.0        # +1 avoids division by zero\n    val /= denom\n\n    # Degree heterogeneity (coefficient of variation)\n    std_deg = s.get('std_degree', 0.0)\n    val *= 1.0 + std_deg / max(avg_deg, 1e-6)\n\n    # Assortativity adjustment (positive assortativity can stretch paths)\n    assort = s.get('degree_assortativity', 0.0)\n    val /= 1.0 + abs(assort)\n\n    # Triangle density factor\n    tri = s.get('num_triangles', 0)\n    if n > 2:\n        max_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_dens = tri / max_tri\n    else:\n        tri_dens = 0.0\n    val *= 1.0 + tri_dens\n\n    # Harmonic‑mean degree factor: encourages many low‑degree nodes\n    degrees = s.get('degrees', [])\n    if degrees:\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0:\n            h_mean = len(degrees) / inv_sum\n            val *= h_mean / max(avg_deg, 1.0)\n\n    return float(val)",
        "island_id": 3,
        "generation": 8,
        "train_score": 0.7600960384153662,
        "val_score": 0.5314567841791523,
        "simplicity_score": 0.17087250571055487,
        "novelty_bonus": 0.23553705835967698
      },
      {
        "id": "g15_i0_p0_567658385",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    global graph statistics.  The formula is a compact, non‑trivial\n    combination of size, density, clustering, degree heterogeneity,\n    assortativity, triangle density, leaf ratio, degree extremes,\n    and the harmonic mean of the degree distribution.  No graph\n    traversal or single‑feature return is used.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the following keys (missing keys default to a\n        neutral value):\n        - 'n'                 : number of nodes\n        - 'm'                 : number of edges\n        - 'density'           : edge density (2m/(n(n-1)))\n        - 'avg_degree'        : average degree\n        - 'max_degree'        : maximum degree\n        - 'min_degree'        : minimum degree\n        - 'std_degree'        : standard deviation of the degree sequence\n        - 'avg_clustering'    : average local clustering coefficient\n        - 'transitivity'      : global transitivity\n        - 'degree_assortativity' : degree assortativity coefficient\n        - 'num_triangles'     : number of triangles\n        - 'degrees'           : list of degrees (unsorted is also fine)\n\n    Returns\n    -------\n    float\n        A positive, dimensionless estimate that correlates with the\n        true average shortest‑path length.\n    \"\"\"\n    # Basic sanity checks\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    # Extract features with safe defaults\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n    max_deg    = s.get('max_degree', 0)\n    min_deg    = s.get('min_degree', 0)\n\n    eps = 1e-6  # small constant to avoid division by zero\n\n    # 1. Size factor – distances grow roughly like sqrt(n)\n    size_factor = n ** 0.5\n\n    # 2. Density factor – denser graphs have shorter paths\n    density_factor = 1.0 / (density + eps)\n\n    # 3. Sparsity factor – normalises by average degree\n    sparsity_factor = (m + 1.0) / (n * avg_deg + 1.0)\n\n    # 4. Cohesion factor – clustering, transitivity, triangle density\n    tri_dens = 0.0\n    if n > 2:\n        max_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_dens = num_tri / max_tri\n    cohesion_factor = (1.0 + avg_clust) * (1.0 + trans) * (1.0 + 2.0 * tri_dens)\n\n    # 5. Heterogeneity factor – coefficient of variation\n    hetero_factor = 1.0 + std_deg / (avg_deg + eps)\n\n    # 6. Assortativity factor – positive assortativity tends to stretch paths\n    assort_factor = 1.0 + 1.5 * abs(assort)\n\n    # 7. Leaf ratio – many leaves increase path lengths\n    leaf_ratio = 0.0\n    if degrees:\n        leaf_count = sum(1 for d in degrees if d == 1)\n        leaf_ratio = leaf_count / n\n    leaf_factor = 1.0 + 0.3 * leaf_ratio\n\n    # 8. Max‑degree (hub) factor – a very high hub shortens paths\n    max_deg_factor = 1.0 - 0.07 * (max_deg / (avg_deg + eps))\n    if max_deg_factor < 0.9:\n        max_deg_factor = 0.9\n\n    # 9. Min‑degree factor – a higher minimum degree reduces distances\n    min_deg_factor = 1.0 + 0.12 * (min_deg / (avg_deg + eps))\n\n    # 10. Harmonic‑mean degree factor – many low‑degree nodes increase paths\n    h_mean_factor = 1.0\n    if degrees:\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0:\n            h_mean = len(degrees) / inv_sum\n            h_mean_factor = h_mean / (avg_deg + eps)\n\n    # 11. Combine all factors multiplicatively\n    val = (size_factor * density_factor * sparsity_factor *\n           cohesion_factor * hetero_factor * assort_factor *\n           leaf_factor * max_deg_factor * min_deg_factor *\n           h_mean_factor)\n\n    # Ensure a sensible lower bound\n    if val < 1.0:\n        val = 1.0\n\n    return float(val)",
        "island_id": 0,
        "generation": 15,
        "train_score": 0.7237935174069627,
        "val_score": 0.4840019593012528,
        "simplicity_score": 0.1660981089059753,
        "novelty_bonus": 0.2523090342645887
      },
      {
        "id": "g16_i0_p0_376536732",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    global graph statistics.  The formula is a compact, non‑trivial\n    combination of size, density, clustering, degree heterogeneity,\n    assortativity, triangle density, leaf ratio, degree extremes,\n    and the harmonic mean of the degree distribution.  No graph\n    traversal or single‑feature return is used.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the following keys (missing keys default to a\n        neutral value):\n        - 'n'                 : number of nodes\n        - 'm'                 : number of edges\n        - 'density'           : edge density (2m/(n(n-1)))\n        - 'avg_degree'        : average degree\n        - 'max_degree'        : maximum degree\n        - 'min_degree'        : minimum degree\n        - 'std_degree'        : standard deviation of the degree sequence\n        - 'avg_clustering'    : average local clustering coefficient\n        - 'transitivity'      : global transitivity\n        - 'degree_assortativity' : degree assortativity coefficient\n        - 'num_triangles'     : number of triangles\n        - 'degrees'           : list of degrees (unsorted is also fine)\n\n    Returns\n    -------\n    float\n        A positive, dimensionless estimate that correlates with the\n        true average shortest‑path length.\n    \"\"\"\n    # Basic sanity check\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    # Extract features with safe defaults\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n    max_deg    = s.get('max_degree', 0)\n    min_deg    = s.get('min_degree', 0)\n\n    eps = 1e-6  # small constant to avoid division by zero\n\n    # 1. Size and density scaling\n    size_factor = n ** 0.45\n    density_factor = 1.0 / (density + eps)\n    sparsity_factor = (m + 1.0) / (n * avg_deg + 1.0)\n\n    # 2. Cohesion (clustering, transitivity, triangles)\n    tri_dens = 0.0\n    if n > 2:\n        max_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_dens = num_tri / max_tri\n    cohesion_factor = (1.0 + avg_clust) * (1.0 + trans) * (1.0 + tri_dens)\n\n    # 3. Heterogeneity and assortativity\n    hetero_factor = 1.0 + std_deg / (avg_deg + eps)\n    assort_factor = 1.0 + abs(assort)\n\n    # 4. Degree extremes and leaf ratio\n    leaf_ratio = 0.0\n    if degrees:\n        leaf_count = sum(1 for d in degrees if d == 1)\n        leaf_ratio = leaf_count / n\n    leaf_factor = 1.0 + leaf_ratio * 0.25\n\n    max_deg_factor = 1.0 - (max_deg / (avg_deg + 1.0)) * 0.07\n    if max_deg_factor < 0.9:\n        max_deg_factor = 0.9\n\n    min_deg_factor = 1.0 + (min_deg / (avg_deg + eps)) * 0.08\n\n    # 5. Harmonic‑mean degree factor\n    h_mean_factor = 1.0\n    if degrees:\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0:\n            h_mean = len(degrees) / inv_sum\n            h_mean_factor = h_mean / (avg_deg + eps)\n\n    # 6. Combine all factors multiplicatively\n    val = (size_factor * density_factor * sparsity_factor *\n           cohesion_factor * hetero_factor * assort_factor *\n           leaf_factor * max_deg_factor * min_deg_factor *\n           h_mean_factor)\n\n    # Ensure a sensible lower bound\n    if val < 1.0:\n        val = 1.0\n\n    return float(val)",
        "island_id": 0,
        "generation": 16,
        "train_score": 0.7421368547418967,
        "val_score": 0.4757659945005204,
        "simplicity_score": 0.16620515092735175,
        "novelty_bonus": 0.2110541136559816
      },
      {
        "id": "g17_i0_p1_937404241",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    global graph statistics.  The formula is a compact, non‑trivial\n    combination of size, density, clustering, degree heterogeneity,\n    assortativity, triangle density, leaf ratio, degree extremes,\n    and the harmonic mean of the degree distribution.  No graph\n    traversal or single‑feature return is used.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the following keys (missing keys default to a\n        neutral value):\n        - 'n'                 : number of nodes\n        - 'm'                 : number of edges\n        - 'density'           : edge density (2m/(n(n-1)))\n        - 'avg_degree'        : average degree\n        - 'max_degree'        : maximum degree\n        - 'min_degree'        : minimum degree\n        - 'std_degree'        : standard deviation of the degree sequence\n        - 'avg_clustering'    : average local clustering coefficient\n        - 'transitivity'      : global transitivity\n        - 'degree_assortativity' : degree assortativity coefficient\n        - 'num_triangles'     : number of triangles\n        - 'degrees'           : list of degrees (sorted or unsorted)\n\n    Returns\n    -------\n    float\n        A positive, dimensionless estimate that correlates with the\n        true average shortest‑path length.\n    \"\"\"\n    # Basic sanity check\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    # Extract features with safe defaults\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n    max_deg    = s.get('max_degree', 0)\n    min_deg    = s.get('min_degree', 0)\n\n    eps = 1e-6  # small constant to avoid division by zero\n\n    # 1. Size and density scaling\n    size_factor = n ** 0.45\n    density_factor = 1.0 / (density + eps)\n    sparsity_factor = (m + 1.0) / (n * avg_deg + 1.0)\n\n    # 2. Cohesion (clustering, transitivity, triangles)\n    tri_dens = 0.0\n    if n > 2:\n        max_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_dens = num_tri / max_tri\n    cohesion_factor = (1.0 + avg_clust) * (1.0 + trans) * (1.0 + tri_dens)\n\n    # 3. Heterogeneity and assortativity\n    hetero_factor = 1.0 + std_deg / (avg_deg + eps)\n    assort_factor = 1.0 + abs(assort)\n\n    # 4. Degree extremes and leaf ratio\n    leaf_ratio = 0.0\n    if degrees:\n        leaf_count = sum(1 for d in degrees if d == 1)\n        leaf_ratio = leaf_count / n\n    leaf_factor = 1.0 + leaf_ratio * 0.25\n\n    max_deg_factor = 1.0 - (max_deg / (avg_deg + 1.0)) * 0.07\n    if max_deg_factor < 0.9:\n        max_deg_factor = 0.9\n\n    min_deg_factor = 1.0 + (min_deg / (avg_deg + eps)) * 0.08\n\n    # 5. Harmonic‑mean degree factor\n    h_mean_factor = 1.0\n    if degrees:\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0:\n            h_mean = len(degrees) / inv_sum\n            h_mean_factor = h_mean / (avg_deg + eps)\n\n    # 6. Combine all factors multiplicatively\n    val = (size_factor * density_factor * sparsity_factor *\n           cohesion_factor * hetero_factor * assort_factor *\n           leaf_factor * max_deg_factor * min_deg_factor *\n           h_mean_factor)\n\n    # Ensure a sensible lower bound\n    if val < 1.0:\n        val = 1.0\n\n    return float(val)",
        "island_id": 0,
        "generation": 17,
        "train_score": 0.7421368547418967,
        "val_score": 0.4757659945005204,
        "simplicity_score": 0.16620515092735175,
        "novelty_bonus": 0.2110541136559816
      },
      {
        "id": "g17_i0_p2_398126195",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    global graph statistics.  The formula is a compact, non‑trivial\n    combination of size, density, clustering, degree heterogeneity,\n    assortativity, triangle density, leaf ratio, degree extremes,\n    and the harmonic mean of the degree distribution.  No graph\n    traversal or single‑feature return is used.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the following keys (missing keys default to a\n        neutral value):\n        - 'n'                 : number of nodes\n        - 'm'                 : number of edges\n        - 'density'           : edge density (2m/(n(n-1)))\n        - 'avg_degree'        : average degree\n        - 'max_degree'        : maximum degree\n        - 'min_degree'        : minimum degree\n        - 'std_degree'        : standard deviation of the degree sequence\n        - 'avg_clustering'    : average local clustering coefficient\n        - 'transitivity'      : global transitivity\n        - 'degree_assortativity' : degree assortativity coefficient\n        - 'num_triangles'     : number of triangles\n        - 'degrees'           : list of degrees (unsorted is also fine)\n\n    Returns\n    -------\n    float\n        A positive, dimensionless estimate that correlates with the\n        true average shortest‑path length.\n    \"\"\"\n    # Basic sanity check\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    # Extract features with safe defaults\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n    max_deg    = s.get('max_degree', 0)\n    min_deg    = s.get('min_degree', 0)\n\n    eps = 1e-6  # small constant to avoid division by zero\n\n    # 1. Size and density scaling\n    size_factor = n ** 0.45\n    density_factor = 1.0 / (density + eps)\n    sparsity_factor = (m + 1.0) / (n * avg_deg + 1.0)\n\n    # 2. Cohesion (clustering, transitivity, triangles)\n    tri_dens = 0.0\n    if n > 2:\n        max_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_dens = num_tri / max_tri\n    cohesion_factor = (1.0 + avg_clust) * (1.0 + trans) * (1.0 + tri_dens)\n\n    # 3. Heterogeneity and assortativity\n    hetero_factor = 1.0 + std_deg / (avg_deg + eps)\n    assort_factor = 1.0 + abs(assort)\n\n    # 4. Degree extremes and leaf ratio\n    leaf_ratio = 0.0\n    if degrees:\n        leaf_count = sum(1 for d in degrees if d == 1)\n        leaf_ratio = leaf_count / n\n    leaf_factor = 1.0 + leaf_ratio * 0.25\n\n    max_deg_factor = 1.0 - (max_deg / (avg_deg + 1.0)) * 0.07\n    if max_deg_factor < 0.9:\n        max_deg_factor = 0.9\n\n    min_deg_factor = 1.0 + (min_deg / (avg_deg + eps)) * 0.08\n\n    # 5. Harmonic‑mean degree factor\n    h_mean_factor = 1.0\n    if degrees:\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0:\n            h_mean = len(degrees) / inv_sum\n            h_mean_factor = h_mean / (avg_deg + eps)\n\n    # 6. Combine all factors multiplicatively\n    val = (size_factor * density_factor * sparsity_factor *\n           cohesion_factor * hetero_factor * assort_factor *\n           leaf_factor * max_deg_factor * min_deg_factor *\n           h_mean_factor)\n\n    # Ensure a sensible lower bound\n    if val < 1.0:\n        val = 1.0\n\n    return float(val)",
        "island_id": 0,
        "generation": 17,
        "train_score": 0.7421368547418967,
        "val_score": 0.4757659945005204,
        "simplicity_score": 0.16620515092735175,
        "novelty_bonus": 0.2110541136559816
      }
    ],
    "1": [
      {
        "id": "g11_i1_p0_80843620",
        "code": "def new_invariant(s):\n    \"\"\"\n    Graph invariant combining size‑connectivity, degree heterogeneity,\n    log‑like scaling (via sqrt), clustering adjustment, heterogeneity,\n    transitivity, assortativity, and density moderation.\n    All operations use only built‑in Python functions.\n    \"\"\"\n    # Size vs. connectivity\n    size_connectivity = s['n'] / (s['m'] + 1)\n\n    # Degree heterogeneity\n    degree_ratio = s['avg_degree'] / max(s['max_degree'], 1)\n\n    # Log‑like scaling (sqrt(n) approximates log(n) for large n)\n    sqrt_n = pow(s['n'], 0.5)\n\n    # Clustering adjustment\n    clustering_adjust = 1 + s['avg_clustering']\n\n    # Additional heterogeneity factor\n    heterogeneity_factor = 1 + s['std_degree'] / max(s['avg_degree'], 1)\n\n    # Transitivity factor\n    transitivity_factor = 1 + s['transitivity']\n\n    # Degree assortativity adjustment (use absolute value to keep positive)\n    assortativity_factor = 1 + abs(s['degree_assortativity'])\n\n    # Density moderation\n    density_factor = 1 / (1 + s['density'])\n\n    # Combine all components multiplicatively\n    return (\n        size_connectivity\n        * degree_ratio\n        * sqrt_n\n        / clustering_adjust\n        * heterogeneity_factor\n        * transitivity_factor\n        * assortativity_factor\n        * density_factor\n    )",
        "island_id": 1,
        "generation": 11,
        "train_score": 0.9170228091236493,
        "val_score": 0.5179691115536831,
        "simplicity_score": 0.12236862084499239,
        "novelty_bonus": 0.2017910447761193
      },
      {
        "id": "g10_i1_p2_546994111",
        "code": "def new_invariant(s):\n    # Size vs. connectivity\n    size_connectivity = s['n'] / (s['m'] + 1)\n\n    # Degree heterogeneity\n    degree_ratio = s['avg_degree'] / max(s['max_degree'], 1)\n\n    # Log‑like scaling (sqrt(n))\n    scale_factor = s['n'] ** 0.5\n\n    # Clustering adjustment\n    clustering_adjust = 1 + s['avg_clustering']\n\n    # Degree dispersion factor\n    heterogeneity_factor = 1 + s['std_degree'] / max(s['avg_degree'], 1)\n\n    # Transitivity boost\n    transitivity_factor = 1 + s['transitivity']\n\n    # Assortativity correction\n    assortativity_factor = 1 + abs(s['degree_assortativity'])\n\n    # Density moderation\n    density_factor = 1 / (1 + s['density'])\n\n    # Combine all components multiplicatively\n    return (\n        size_connectivity\n        * degree_ratio\n        * scale_factor\n        / clustering_adjust\n        * heterogeneity_factor\n        * transitivity_factor\n        * assortativity_factor\n        * density_factor\n    )",
        "island_id": 1,
        "generation": 10,
        "train_score": 0.9170228091236493,
        "val_score": 0.5179110377541946,
        "simplicity_score": 0.12207825184754989,
        "novelty_bonus": 0.2017910447761193
      },
      {
        "id": "g11_i1_p4_802325685",
        "code": "def new_invariant(s):\n    \"\"\"\n    Graph invariant combining size‑connectivity, degree heterogeneity,\n    sqrt‑like scaling, clustering adjustment, heterogeneity, transitivity,\n    assortativity, and density moderation.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n\n    Returns\n    -------\n    float\n        The computed invariant value.\n    \"\"\"\n    # Size vs. connectivity\n    size_connectivity = s['n'] / (s['m'] + 1)\n\n    # Degree heterogeneity ratio\n    degree_ratio = s['avg_degree'] / max(s['max_degree'], 1)\n\n    # sqrt‑like scaling (approximates log‑like growth)\n    scale_factor = s['n'] ** 0.5\n\n    # Clustering adjustment\n    clustering_adjust = 1 + s['avg_clustering']\n\n    # Additional heterogeneity factor\n    heterogeneity_factor = 1 + s['std_degree'] / max(s['avg_degree'], 1)\n\n    # Transitivity factor\n    transitivity_factor = 1 + s['transitivity']\n\n    # Degree assortativity adjustment (absolute value to keep positive)\n    assortativity_factor = 1 + abs(s['degree_assortativity'])\n\n    # Density moderation\n    density_factor = 1 / (1 + s['density'])\n\n    # Combine all components multiplicatively and adjust for clustering\n    return (\n        size_connectivity\n        * degree_ratio\n        * scale_factor\n        * heterogeneity_factor\n        * transitivity_factor\n        * assortativity_factor\n        * density_factor\n    ) / clustering_adjust",
        "island_id": 1,
        "generation": 11,
        "train_score": 0.9170228091236493,
        "val_score": 0.5178840937373761,
        "simplicity_score": 0.12194353176345743,
        "novelty_bonus": 0.2017910447761193
      },
      {
        "id": "g13_i1_p1_124542230",
        "code": "def new_invariant(s):\n    \"\"\"\n    Graph invariant combining several structural features:\n    - Size vs. connectivity (n / (m + 1))\n    - Degree heterogeneity (avg_degree / max_degree)\n    - Scale factor (sqrt(n))\n    - Clustering adjustment (1 + avg_clustering)\n    - Degree dispersion (1 + std_degree / avg_degree)\n    - Transitivity boost (1 + transitivity)\n    - Assortativity correction (1 + |degree_assortativity|)\n    - Density moderation (1 / (1 + density))\n\n    The final value is the product of all factors, divided by the clustering adjustment.\n    \"\"\"\n    size_connectivity = s['n'] / (s['m'] + 1)\n    degree_ratio = s['avg_degree'] / max(s['max_degree'], 1)\n    scale_factor = s['n'] ** 0.5\n    clustering_adjust = 1 + s['avg_clustering']\n    heterogeneity_factor = 1 + s['std_degree'] / max(s['avg_degree'], 1)\n    transitivity_factor = 1 + s['transitivity']\n    assortativity_factor = 1 + abs(s['degree_assortativity'])\n    density_factor = 1 / (1 + s['density'])\n\n    return (\n        size_connectivity\n        * degree_ratio\n        * scale_factor\n        * heterogeneity_factor\n        * transitivity_factor\n        * assortativity_factor\n        * density_factor\n    ) / clustering_adjust",
        "island_id": 1,
        "generation": 13,
        "train_score": 0.9170228091236493,
        "val_score": 0.5178840937373761,
        "simplicity_score": 0.12194353176345743,
        "novelty_bonus": 0.2017910447761193
      },
      {
        "id": "g14_i1_p3_382245144",
        "code": "def new_invariant(s):\n    \"\"\"\n    Graph invariant that blends several structural characteristics:\n    - Size versus connectivity (n / (m + 1))\n    - Degree heterogeneity (avg_degree / max_degree)\n    - Log‑like scaling via sqrt(n)\n    - Clustering penalty (1 + avg_clustering)\n    - Degree dispersion (1 + std_degree / avg_degree)\n    - Transitivity boost (1 + transitivity)\n    - Assortativity correction (1 + |degree_assortativity|)\n    - Density moderation (1 / (1 + density))\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with keys:\n        n, m, density, avg_degree, max_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity\n\n    Returns\n    -------\n    float\n        The computed invariant value.\n    \"\"\"\n    # Size vs. connectivity\n    size_connectivity = s['n'] / (s['m'] + 1)\n\n    # Degree heterogeneity ratio\n    degree_ratio = s['avg_degree'] / max(s['max_degree'], 1)\n\n    # sqrt‑like scaling (approximates log‑like growth)\n    scale_factor = s['n'] ** 0.5\n\n    # Clustering adjustment\n    clustering_adjust = 1 + s['avg_clustering']\n\n    # Additional heterogeneity factor\n    heterogeneity_factor = 1 + s['std_degree'] / max(s['avg_degree'], 1)\n\n    # Transitivity factor\n    transitivity_factor = 1 + s['transitivity']\n\n    # Degree assortativity adjustment (absolute value to keep positive)\n    assortativity_factor = 1 + abs(s['degree_assortativity'])\n\n    # Density moderation\n    density_factor = 1 / (1 + s['density'])\n\n    # Combine all components multiplicatively and adjust for clustering\n    return (\n        size_connectivity\n        * degree_ratio\n        * scale_factor\n        * heterogeneity_factor\n        * transitivity_factor\n        * assortativity_factor\n        * density_factor\n    ) / clustering_adjust",
        "island_id": 1,
        "generation": 14,
        "train_score": 0.9170228091236493,
        "val_score": 0.5178840937373761,
        "simplicity_score": 0.12194353176345743,
        "novelty_bonus": 0.2017910447761193
      }
    ],
    "2": [
      {
        "id": "g2_i1_p1_954936163",
        "code": "def new_invariant(s):\n    \"\"\"\n    Graph invariant combining size‑connectivity, degree heterogeneity,\n    log‑like scaling, clustering adjustment, and additional heterogeneity\n    and transitivity factors.  All operations are performed on the\n    pre‑computed feature dictionary `s`.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - avg_degree (float)\n        - max_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n\n    Returns\n    -------\n    float\n        The computed invariant value.\n    \"\"\"\n    # Size vs. connectivity\n    size_connectivity = s['n'] / (s['m'] + 1)\n\n    # Degree heterogeneity\n    degree_ratio = s['avg_degree'] / max(s['max_degree'], 1)\n\n    # Log‑like scaling (sqrt(n) approximates log(n) for large n)\n    log_like = s['n'] ** 0.5\n\n    # Clustering adjustment\n    clustering_adjust = 1 + s['avg_clustering']\n\n    # Additional heterogeneity factor\n    heterogeneity_factor = 1 + s['std_degree'] / max(s['avg_degree'], 1)\n\n    # Transitivity factor\n    transitivity_factor = 1 + s['transitivity']\n\n    # Degree assortativity adjustment (use absolute value to keep positive)\n    assortativity_factor = 1 + abs(s['degree_assortativity'])\n\n    # Combine all components\n    return (\n        size_connectivity\n        * degree_ratio\n        * log_like\n        / clustering_adjust\n        * heterogeneity_factor\n        * transitivity_factor\n        * assortativity_factor\n    )",
        "island_id": 1,
        "generation": 2,
        "train_score": 0.8995438175270108,
        "val_score": 0.5023257975710079,
        "simplicity_score": 0.12491707005709463,
        "novelty_bonus": 0.19229880747018668
      },
      {
        "id": "g15_i2_p4_919461425",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The core estimate is a log‑based ratio\n    (bit‑length of n+1 divided by bit‑length of avg_degree+1) with\n    several multiplicative adjustments that capture density, clustering,\n    transitivity, degree assortativity, heterogeneity, triangle abundance,\n    hub prominence, minimum degree, and median‑degree skew.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg = s['avg_degree']\n    # Rough log₂ approximations using bit_length (floor(log₂(x)))\n    n_log = (n + 1).bit_length() - 1          # ≈ floor(log₂(n+1))\n    k_log = (int(avg_deg) + 1).bit_length() - 1  # ≈ floor(log₂(avg_deg+1))\n\n    # Base estimate: log₂(n+1) / log₂(avg_degree+1)\n    base = (n_log + 1) / max(k_log + 1, 1)\n\n    # 1. Density – denser graphs tend to have shorter paths\n    base *= 1 - 0.07 * s['density']\n\n    # 2. Average clustering – high clustering reduces path length\n    base *= 1 - 0.10 * s['avg_clustering']\n\n    # 3. Transitivity – higher transitivity shortens paths\n    base *= 1 + 0.04 * s['transitivity']\n\n    # 4. Degree assortativity – positive assortativity can lengthen paths\n    base *= 1 + 0.08 * s['degree_assortativity']\n\n    # 5. Degree heterogeneity (std / max_degree)\n    base *= 1 + 0.05 * (s['std_degree'] / max(s['max_degree'], 1))\n\n    # 6. Triangle abundance – many triangles usually shrink path lengths\n    base *= 1 - min(0.3, 1e-7 * s['num_triangles'])\n\n    # 7. Hub prominence – large max_degree relative to n slightly increases length\n    base *= 1 + 0.02 * (s['max_degree'] / max(n, 1))\n\n    # 8. Minimum degree – very low min_degree increases length\n    base *= 1 + 0.04 * (1 - s['min_degree'] / max(avg_deg, 1))\n\n    # 9. Median‑degree skew – captures skewness in the degree distribution\n    degrees = s['degrees']\n    median_deg = degrees[len(degrees) // 2]\n    base *= 1 + 0.02 * ((median_deg - avg_deg) / max(avg_deg, 1))\n\n    return base",
        "island_id": 2,
        "generation": 15,
        "train_score": 0.7524129651860745,
        "val_score": 0.4680087364933718,
        "simplicity_score": 0.22131298568177266,
        "novelty_bonus": 0.20563445987327456
      },
      {
        "id": "g17_i2_p0_162101618",
        "code": "def new_invariant(s):\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg = s['avg_degree']\n\n    # approximate log₂(n+1) and log₂(avg_deg+1) using bit_length\n    n_log = (n + 1).bit_length() - 1\n    k_log = (int(avg_deg) + 1).bit_length() - 1\n\n    # base estimate: ratio of the two logarithms\n    base = (n_log + 1) / max(k_log + 1, 1)\n\n    # density – denser graphs have shorter paths\n    base *= 1 - 0.06 * s['density']\n\n    # average clustering – high clustering reduces path length\n    base *= 1 - 0.08 * s['avg_clustering']\n\n    # degree assortativity – positive assortativity can lengthen paths\n    base *= 1 + 0.07 * s['degree_assortativity']\n\n    # degree heterogeneity (std / max_degree)\n    base *= 1 + 0.04 * (s['std_degree'] / max(s['max_degree'], 1))\n\n    # triangle abundance – many triangles shrink path lengths\n    base *= 1 - 1e-7 * s['num_triangles']\n\n    # hub prominence – large max_degree relative to n slightly increases length\n    base *= 1 + 0.015 * (s['max_degree'] / max(n, 1))\n\n    # minimum degree – very low min_degree increases length\n    base *= 1 + 0.05 * (1 - s['min_degree'] / max(avg_deg, 1))\n\n    # median‑degree skew – captures skewness in the degree distribution\n    median_deg = s['degrees'][len(s['degrees']) // 2]\n    base *= 1 + 0.02 * ((median_deg - avg_deg) / max(avg_deg, 1))\n\n    # transitivity – slightly lengthens paths in very transitive graphs\n    base *= 1 + 0.02 * s['transitivity']\n\n    return base",
        "island_id": 2,
        "generation": 17,
        "train_score": 0.7473229291716686,
        "val_score": 0.46708249741042074,
        "simplicity_score": 0.22156029980918096,
        "novelty_bonus": 0.20314963936647856
      },
      {
        "id": "g15_i2_p2_763249194",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The core estimate is a log‑based ratio\n    (log₂(n+1) / log₂(avg_degree+1)) with a handful of multiplicative\n    adjustments that capture density, clustering, assortativity,\n    degree heterogeneity, triangle abundance, hub prominence,\n    minimum degree, median‑degree skew, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg = s['avg_degree']\n\n    # Rough log₂ approximations using bit_length (floor(log₂(x)))\n    n_log = (n + 1).bit_length() - 1          # ≈ floor(log₂(n+1))\n    k_log = (int(avg_deg) + 1).bit_length() - 1  # ≈ floor(log₂(avg_deg+1))\n\n    # Base estimate: log₂(n+1) / log₂(avg_degree+1)\n    base = (n_log + 1) / max(k_log + 1, 1)\n\n    # 1. Density – denser graphs tend to have shorter paths\n    base *= 1 - 0.06 * s['density']\n\n    # 2. Average clustering – high clustering reduces path length\n    base *= 1 - 0.08 * s['avg_clustering']\n\n    # 3. Degree assortativity – positive assortativity can lengthen paths\n    base *= 1 + 0.07 * s['degree_assortativity']\n\n    # 4. Degree heterogeneity (std / max_degree)\n    base *= 1 + 0.04 * (s['std_degree'] / max(s['max_degree'], 1))\n\n    # 5. Triangle abundance – many triangles usually shrink path lengths\n    base *= 1 - 1e-7 * s['num_triangles']\n\n    # 6. Hub prominence – large max_degree relative to n slightly increases length\n    base *= 1 + 0.015 * (s['max_degree'] / max(n, 1))\n\n    # 7. Minimum degree – very low min_degree increases length\n    base *= 1 + 0.05 * (1 - s['min_degree'] / max(avg_deg, 1))\n\n    # 8. Median‑degree skew – captures skewness in the degree distribution\n    median_deg = s['degrees'][len(s['degrees']) // 2]\n    base *= 1 + 0.02 * ((median_deg - avg_deg) / max(avg_deg, 1))\n\n    # 9. Transitivity – slightly lengthens paths in very transitive graphs\n    base *= 1 + 0.02 * s['transitivity']\n\n    return base",
        "island_id": 2,
        "generation": 15,
        "train_score": 0.7473229291716686,
        "val_score": 0.4670699563513278,
        "simplicity_score": 0.22149759451371628,
        "novelty_bonus": 0.20314963936647856
      },
      {
        "id": "g17_i2_p3_354085832",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The estimate is based on a log‑ratio of the\n    graph size to its average degree, with multiplicative corrections\n    for density, clustering, assortativity, heterogeneity, triangle\n    abundance, hub prominence, minimum degree, median‑degree skew and\n    transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg = s['avg_degree']\n\n    # Rough log₂ approximations using bit_length (floor(log₂(x)))\n    n_log = (n + 1).bit_length() - 1          # ≈ floor(log₂(n+1))\n    k_log = (int(avg_deg) + 1).bit_length() - 1  # ≈ floor(log₂(avg_deg+1))\n\n    # Base estimate: log₂(n+1) / log₂(avg_degree+1)\n    base = (n_log + 1) / max(k_log + 1, 1)\n\n    # 1. Density – denser graphs tend to have shorter paths\n    base *= 1 - 0.06 * s['density']\n\n    # 2. Average clustering – high clustering reduces path length\n    base *= 1 - 0.08 * s['avg_clustering']\n\n    # 3. Degree assortativity – positive assortativity can lengthen paths\n    base *= 1 + 0.07 * s['degree_assortativity']\n\n    # 4. Degree heterogeneity (std / max_degree)\n    base *= 1 + 0.04 * (s['std_degree'] / max(s['max_degree'], 1))\n\n    # 5. Triangle abundance – many triangles usually shrink path lengths\n    base *= 1 - min(0.3, 1e-7 * s['num_triangles'])\n\n    # 6. Hub prominence – large max_degree relative to n slightly increases length\n    base *= 1 + 0.015 * (s['max_degree'] / max(n, 1))\n\n    # 7. Minimum degree – very low min_degree increases length\n    base *= 1 + 0.05 * (1 - s['min_degree'] / max(avg_deg, 1))\n\n    # 8. Median‑degree skew – captures skewness in the degree distribution\n    median_deg = s['degrees'][len(s['degrees']) // 2]\n    base *= 1 + 0.02 * ((median_deg - avg_deg) / max(avg_deg, 1))\n\n    # 9. Transitivity – slightly lengthens paths in very transitive graphs\n    base *= 1 + 0.02 * s['transitivity']\n\n    return base",
        "island_id": 2,
        "generation": 17,
        "train_score": 0.7473229291716686,
        "val_score": 0.46704522689330064,
        "simplicity_score": 0.22137394722358028,
        "novelty_bonus": 0.20314963936647856
      }
    ],
    "3": [
      {
        "id": "g17_i3_p2_898326347",
        "code": "def new_invariant(s):\n    \"\"\"\n    Compute a closed‑form estimate of the average shortest‑path length\n    from a handful of pre‑computed global graph statistics.\n    The expression mixes logarithms, exponentials, polynomial\n    exponents, and ratios of complementary metrics so that it is\n    highly nonlinear and does not collapse to a single feature.\n\n    Parameters\n    ----------\n    s : dict\n        A dictionary that may contain the keys listed below. Missing\n        keys are treated as neutral values (0, 1 or empty list as\n        appropriate).\n\n        - n                       : int          number of nodes\n        - density                 : float        edge density (0‑1)\n        - avg_degree              : float\n        - max_degree              : int\n        - min_degree              : int\n        - std_degree              : float\n        - avg_clustering          : float\n        - transitivity            : float\n        - degree_assortativity    : float\n        - num_triangles           : int\n        - degrees                 : list[int]    degree sequence\n\n    Returns\n    -------\n    float\n        A dimensionless estimate that tracks the real average shortest‑path\n        length, but is derived purely algebraically from the supplied\n        statistics.\n    \"\"\"\n    # Helper: guard against missing keys\n    n                = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    density          = s.get('density', 0.0)\n    avg_degree       = s.get('avg_degree', 0.0)\n    max_degree       = s.get('max_degree', 0)\n    min_degree       = s.get('min_degree', 0)\n    std_degree       = s.get('std_degree', 0.0)\n    avg_clust        = s.get('avg_clustering', 0.0)\n    transitivity     = s.get('transitivity', 0.0)\n    assort           = s.get('degree_assortativity', 0.0)\n    num_tri          = s.get('num_triangles', 0)\n    degrees          = s.get('degrees', [])\n\n    # --- 1. Size scaling (√n) --------------------------------------------------\n    val = n ** 0.5\n\n    # --- 2. Cohesion boost ----------------------------------------------------\n    # Higher local and global clustering reduces path length\n    val *= (1.0 + avg_clust) ** 2.0\n    val *= (1.0 + transitivity) ** 1.5\n\n    # --- 3. Density / degree penalty -----------------------------------------\n    # Sparse graphs inflate distances; dense graphs compress them\n    val /= max(density, 1e-4)                  # avoid division by zero\n\n    # Logistic decrease with average degree\n    val *= (1.0 + avg_degree) ** (-1.0)\n    # Further attenuation for graphs with extremely low average degree\n    val *= (1.0 + avg_degree) ** (-0.5)\n\n    # --- 4. Heterogeneity amplification --------------------------------------\n    # Coefficient of variation raised to a power\n    cv = std_degree / max(avg_degree, 1e-4)\n    val *= (1.0 + cv) ** 1.2\n\n    # Influence of extremes in degree distribution\n    min_ratio = min_degree / max(max_degree, 1) if max_degree else 0.0\n    val *= (1.0 + min_ratio) ** 0.8\n\n    # --- 5. Assortativity modulation -----------------------------------------\n    val /= (1.0 + abs(assort) ** 2.0)          # penalise extreme assortativity\n\n    # --- 6. Triangle density factor -----------------------------------------\n    tri_max = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    tri_density = num_tri / max(tri_max, 1e-4)\n    val *= (1.0 + tri_density) ** 0.9\n\n    # --- 7. Harmonic mean degree influence ------------------------------------\n    if degrees:\n        # robust harmonic mean (skip zeros)\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0.0:\n            h_mean = len(degrees) / inv_sum\n            # low harmonic mean (many low‑degree nodes) increases distances\n            val *= (h_mean / max(avg_degree, 1.0)) ** 0.7\n\n    return float(val)",
        "island_id": 3,
        "generation": 17,
        "train_score": 0.9059783913565426,
        "val_score": 0.534056960060647,
        "simplicity_score": 0.16785415156178546,
        "novelty_bonus": 0.15318172152652532
      },
      {
        "id": "g16_i3_p2_491296809",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features\n    without any graph traversal or external libraries.  The expression\n    blends size, density, degree heterogeneity, clustering, assortativity,\n    triangle density, and a harmonic‑mean degree factor into a single\n    analytical formula.\n    \"\"\"\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    # Basic size scaling – distances grow roughly like √n\n    val = pow(n, 0.5)\n\n    # Cohesion contributions – higher clustering/transitivity shrink distances\n    val *= (1.0 + s.get('avg_clustering', 0.0))\n    val *= (1.0 + s.get('transitivity', 0.0))\n\n    # Normalize by average degree (density proxy); +1 avoids division by zero\n    avg_deg = s.get('avg_degree', 0.0)\n    val /= (avg_deg + 1.0)\n\n    # Degree heterogeneity amplifies the estimate\n    std_deg = s.get('std_degree', 0.0)\n    val *= (1.0 + std_deg / max(avg_deg, 1e-6))\n\n    # Assortativity penalty – high assortativity can lengthen paths\n    assort = s.get('degree_assortativity', 0.0)\n    val /= (1.0 + abs(assort))\n\n    # Triangle density – more triangles usually shorten distances\n    tri = s.get('num_triangles', 0)\n    max_tri = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    tri_dens = tri / max_tri\n    val *= (1.0 + tri_dens)\n\n    # Harmonic‑mean degree factor – low‑degree hubs influence distances\n    degrees = s.get('degrees', [])\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            if d > 0:\n                inv_sum += 1.0 / d\n        if inv_sum > 0.0:\n            h_mean = len(degrees) / inv_sum\n            val *= h_mean / max(avg_deg, 1.0)\n\n    return float(val)",
        "island_id": 3,
        "generation": 16,
        "train_score": 0.7600960384153662,
        "val_score": 0.5314901051692063,
        "simplicity_score": 0.17103911066082456,
        "novelty_bonus": 0.23553705835967698
      },
      {
        "id": "g17_i3_p3_332498068",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a dictionary of pre‑computed\n    graph statistics.  The estimate is a fully analytical combination of size,\n    density, clustering, degree distribution, assortativity, triangle density,\n    and a harmonic‑mean degree factor – no graph traversal or external libraries\n    are used.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys (missing keys are treated as neutral values):\n            - 'n'                 : int, number of nodes\n            - 'm'                 : int, number of edges\n            - 'density'           : float\n            - 'avg_degree'        : float\n            - 'max_degree'        : int\n            - 'min_degree'        : int\n            - 'std_degree'        : float\n            - 'avg_clustering'    : float\n            - 'transitivity'      : float\n            - 'degree_assortativity' : float\n            - 'num_triangles'     : int\n            - 'degrees'           : list[int], sorted degree sequence\n\n    Returns\n    -------\n    float\n        A dimensionless estimate that correlates with the true\n        average shortest‑path length.\n    \"\"\"\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    # Basic size scaling – distances grow roughly like √n\n    val = n ** 0.5\n\n    # Cohesion factors – higher clustering/transitivity imply tighter groups\n    val *= (1.0 + s.get('avg_clustering', 0.0))\n    val *= (1.0 + s.get('transitivity', 0.0))\n\n    # Normalise by overall density proxy (average degree)\n    avg_deg = s.get('avg_degree', 0.0)\n    val /= (avg_deg + 1.0)          # +1 avoids division by zero\n\n    # Degree heterogeneity (coefficient of variation)\n    std_deg = s.get('std_degree', 0.0)\n    val *= 1.0 + std_deg / max(avg_deg, 1e-6)\n\n    # Assortativity adjustment – high assortativity can stretch paths\n    assort = s.get('degree_assortativity', 0.0)\n    val /= 1.0 + abs(assort)\n\n    # Triangle density factor – more triangles tend to shorten paths\n    tri = s.get('num_triangles', 0)\n    if n > 2:\n        max_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_dens = tri / max_tri\n    else:\n        tri_dens = 0.0\n    val *= 1.0 + tri_dens\n\n    # Harmonic‑mean degree factor – low‑degree nodes influence distances\n    degrees = s.get('degrees', [])\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            if d > 0:\n                inv_sum += 1.0 / d\n        if inv_sum > 0.0:\n            h_mean = len(degrees) / inv_sum\n            val *= h_mean / max(avg_deg, 1.0)\n\n    return float(val)",
        "island_id": 3,
        "generation": 17,
        "train_score": 0.7600960384153662,
        "val_score": 0.531476676930495,
        "simplicity_score": 0.1709719694672685,
        "novelty_bonus": 0.23553705835967698
      },
      {
        "id": "g8_i3_p3_315365990",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    global graph statistics.  The formula is a non‑trivial combination of\n    size, density, clustering, degree heterogeneity, assortativity,\n    triangle density, and a harmonic‑mean degree factor – but it never\n    returns a single feature nor performs any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the following keys (missing keys default to a neutral\n        value):\n        - 'n'                 : number of nodes\n        - 'avg_degree'        : average degree\n        - 'std_degree'        : standard deviation of the degree sequence\n        - 'avg_clustering'    : average local clustering coefficient\n        - 'transitivity'      : global transitivity\n        - 'degree_assortativity' : degree assortativity coefficient\n        - 'num_triangles'     : number of triangles\n        - 'degrees'           : list of degrees (unsorted is also fine)\n\n    Returns\n    -------\n    float\n        A dimensionless estimate that correlates with the true\n        average shortest‑path length.  The value is positive for any\n        feasible input.\n    \"\"\"\n    # Basic scaling: distances grow roughly like sqrt(n)\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n    val = n ** 0.5\n\n    # Local cohesion: reward high clustering and transitivity\n    val *= (1.0 + s.get('avg_clustering', 0.0))\n    val *= (1.0 + s.get('transitivity', 0.0))\n\n    # Normalise by overall density (avg_degree)\n    avg_deg = s.get('avg_degree', 0.0)\n    denom = avg_deg + 1.0        # +1 avoids division by zero\n    val /= denom\n\n    # Degree heterogeneity (coefficient of variation)\n    std_deg = s.get('std_degree', 0.0)\n    val *= 1.0 + std_deg / max(avg_deg, 1e-6)\n\n    # Assortativity adjustment (positive assortativity can stretch paths)\n    assort = s.get('degree_assortativity', 0.0)\n    val /= 1.0 + abs(assort)\n\n    # Triangle density factor\n    tri = s.get('num_triangles', 0)\n    if n > 2:\n        max_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_dens = tri / max_tri\n    else:\n        tri_dens = 0.0\n    val *= 1.0 + tri_dens\n\n    # Harmonic‑mean degree factor: encourages many low‑degree nodes\n    degrees = s.get('degrees', [])\n    if degrees:\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0:\n            h_mean = len(degrees) / inv_sum\n            val *= h_mean / max(avg_deg, 1.0)\n\n    return float(val)",
        "island_id": 3,
        "generation": 8,
        "train_score": 0.7600960384153662,
        "val_score": 0.5314567841791523,
        "simplicity_score": 0.17087250571055487,
        "novelty_bonus": 0.23553705835967698
      },
      {
        "id": "g9_i3_p3_849562246",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a dictionary of pre‑computed\n    graph statistics.  The formula is a fully analytical combination of\n    size, clustering, density, degree distribution, assortativity,\n    triangle density, and a harmonic‑mean degree factor – no traversal\n    or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            - 'n'                 : int, number of nodes\n            - 'm'                 : int, number of edges\n            - 'density'           : float\n            - 'avg_degree'        : float\n            - 'max_degree'        : int\n            - 'min_degree'        : int\n            - 'std_degree'        : float\n            - 'avg_clustering'    : float\n            - 'transitivity'      : float\n            - 'degree_assortativity' : float\n            - 'num_triangles'     : int\n            - 'degrees'           : list[int], sorted degree sequence\n\n    Returns\n    -------\n    float\n        A dimensionless estimate that correlates with the true\n        average shortest‑path length.\n    \"\"\"\n    # Basic size scaling – distances grow roughly with √n\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n    val = n ** 0.5\n\n    # Local cohesion: higher clustering and transitivity imply tighter\n    # groups, which can reduce average distances\n    val *= (1.0 + s.get('avg_clustering', 0.0))\n    val *= (1.0 + s.get('transitivity', 0.0))\n\n    # Normalise by average degree: denser graphs tend to have shorter paths\n    avg_deg = s.get('avg_degree', 0.0)\n    val /= (avg_deg + 1.0)\n\n    # Degree heterogeneity (coefficient of variation) amplifies the estimate\n    std_deg = s.get('std_degree', 0.0)\n    val *= (1.0 + std_deg / max(avg_deg, 1e-6))\n\n    # Assortativity adjustment – high assortativity can stretch paths\n    assort = s.get('degree_assortativity', 0.0)\n    val /= (1.0 + abs(assort))\n\n    # Triangle density factor – more triangles tend to shorten paths\n    tri = s.get('num_triangles', 0)\n    max_tri = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 0\n    tri_dens = tri / max_tri if max_tri > 0 else 0.0\n    val *= (1.0 + tri_dens)\n\n    # Harmonic‑mean degree factor – encourages the presence of low‑degree nodes\n    degrees = s.get('degrees', [])\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            if d > 0:\n                inv_sum += 1.0 / d\n        if inv_sum > 0.0:\n            h_mean = len(degrees) / inv_sum\n            val *= h_mean / max(avg_deg, 1.0)\n\n    return float(val)",
        "island_id": 3,
        "generation": 9,
        "train_score": 0.7600960384153662,
        "val_score": 0.531450218650288,
        "simplicity_score": 0.17083967806623332,
        "novelty_bonus": 0.23553705835967698
      }
    ]
  }
}