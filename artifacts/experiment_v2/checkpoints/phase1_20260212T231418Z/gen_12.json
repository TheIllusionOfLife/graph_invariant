{
  "experiment_id": "phase1_20260212T231418Z",
  "generation": 12,
  "rng_seed": 42,
  "rng_state": {
    "bit_generator": "PCG64",
    "state": {
      "state": 45290591498872138020568586061395462870,
      "inc": 332724090758049132448979897138935081983
    },
    "has_uint32": 1,
    "uinteger": 386752617
  },
  "best_val_score": 0.5491013268732999,
  "no_improve_count": 10,
  "island_stagnation": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_prompt_mode": {
    "0": "free",
    "1": "free",
    "2": "free",
    "3": "free"
  },
  "island_constrained_generations": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_recent_failures": {
    "0": [
      "below_novelty_threshold: novelty_bonus=0.056040",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_novelty_threshold: novelty_bonus=0.043167"
    ],
    "1": [
      "below_train_threshold: train_signal=0.090900",
      "below_novelty_threshold: novelty_bonus=0.107083",
      "below_novelty_threshold: novelty_bonus=0.121359"
    ],
    "2": [
      "below_novelty_threshold: novelty_bonus=0.135127",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_novelty_threshold: novelty_bonus=0.133768"
    ],
    "3": [
      "below_novelty_threshold: novelty_bonus=0.015219",
      "below_novelty_threshold: novelty_bonus=0.046182",
      "below_train_threshold: train_signal=0.149772"
    ]
  },
  "islands": {
    "0": [
      {
        "id": "g6_i0_p1_226909348",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features.\n    The formula is a weighted product of factors that tend to shorten or lengthen\n    paths, with coefficients tuned to keep the expression compact while\n    capturing the main structural influences.\n    \"\"\"\n    # Basic quantities\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    density    = s['density']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    degrees    = s['degrees']          # sorted list\n\n    # Base estimate: larger n and smaller avg_degree → longer paths\n    val = n / (avg_deg + 1)\n\n    # Factors that tend to shorten paths\n    val *= (1 + 1.3 * density)\n    val *= (1 + 1.1 * clustering)\n    val *= (1 + 1.2 * trans)\n\n    # Positive assortativity clusters similar‑degree nodes, often shortening paths\n    val /= (1 + 0.5 * abs(assort))\n\n    # Triangles provide local shortcuts; dampen large counts with a square root\n    val *= (1 + (num_tri ** 0.5) / (n ** 2 + 1))\n\n    # Degree spread and variability can increase path length\n    val *= (1 + 0.3 * (max_deg - min_deg) / (max_deg + 1))\n    val *= (1 + 0.3 * std_deg / (avg_deg + 1))\n\n    # Median degree captures the central tendency of the degree distribution\n    mid = len(degrees) // 2\n    median_deg = degrees[mid] if len(degrees) % 2 else (degrees[mid - 1] + degrees[mid]) / 2\n    val *= (1 + 0.2 * median_deg / (avg_deg + 1))\n\n    return val",
        "island_id": 0,
        "generation": 6,
        "train_score": 0.7511644657863146,
        "val_score": 0.507842254236618,
        "simplicity_score": 0.24783440638124699,
        "novelty_bonus": 0.31979642891023075
      },
      {
        "id": "g6_i0_p2_564499893",
        "code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n\n    val = n / (avg_deg + 1)\n    val *= (1 + 1.3 * density)\n    val *= (1 + 1.1 * trans)\n    val *= (1 + 1.0 * clustering)\n    val /= (1 + 0.4 * abs(assort))\n    val *= (1 + 0.3 * (num_tri ** 0.5) / (n + 1))\n    val *= (1 + 0.4 * (max_deg - min_deg) / (max_deg + 1))\n    val *= (1 + 0.4 * std_deg / (avg_deg + 1))\n    return val",
        "island_id": 0,
        "generation": 6,
        "train_score": 0.7615366146458583,
        "val_score": 0.4958723368726672,
        "simplicity_score": 0.25062504096016025,
        "novelty_bonus": 0.3677885587751666
      },
      {
        "id": "g6_i0_p3_669813994",
        "code": "def new_invariant(s):\n    # unpack features\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    degrees    = s['degrees']\n\n    # Base estimate: larger n and smaller avg_degree → longer paths\n    val = n / (avg_deg + 1)\n\n    # Factors that tend to shorten paths\n    val *= (1 + 1.1 * density) * (1 + 1.1 * trans) * (1 + 1.0 * clustering)\n\n    # Positive assortativity clusters similar‑degree nodes, often shortening paths\n    val /= (1 + 0.4 * abs(assort))\n\n    # Triangles provide local shortcuts; dampen large counts with sqrt\n    val *= (1 + 0.4 * (num_tri ** 0.5) / (n**2 + 1))\n\n    # Degree spread and variability can increase path length\n    val *= (1 + 0.3 * (max_deg - min_deg) / (max_deg + 1))\n    val *= (1 + 0.3 * std_deg / (avg_deg + 1))\n\n    # Edge density expressed as ratio of actual to possible edges\n    max_edges = n * (n - 1) // 2\n    val *= (1 + m / (max_edges + 1))\n\n    # Median degree captures the central tendency of the degree distribution\n    mid = len(degrees) // 2\n    median_deg = degrees[mid] if len(degrees) % 2 else (degrees[mid - 1] + degrees[mid]) / 2\n    val *= (1 + 0.2 * median_deg / (avg_deg + 1))\n\n    # Sum of squared degrees captures higher‑order degree effects\n    sum_sq = sum(d * d for d in degrees)\n    val *= (1 + 0.2 * sum_sq / (n * (avg_deg ** 2 + 1)))\n\n    return val",
        "island_id": 0,
        "generation": 6,
        "train_score": 0.7527971188475389,
        "val_score": 0.49508617938920296,
        "simplicity_score": 0.2458419268201938,
        "novelty_bonus": 0.3733806540711546
      },
      {
        "id": "g10_i0_p0_982738393",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features.\n    The expression is a compact product of factors that capture the main\n    structural influences on path length.  All operations use only built‑in\n    Python functions; no external imports are required.\n    \"\"\"\n    # Basic quantities\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    density    = s['density']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    degrees    = s['degrees']          # sorted list\n\n    # Base estimate: larger n and smaller avg_degree → longer paths\n    val = n / (avg_deg + 1)\n\n    # Factors that tend to shorten paths\n    val *= (1 + 1.2 * density)\n    val *= (1 + 1.0 * clustering)\n    val *= (1 + 1.1 * trans)\n\n    # Positive assortativity clusters similar‑degree nodes, often shortening paths\n    val /= (1 + 0.4 * abs(assort))\n\n    # Triangles provide local shortcuts; dampen large counts with a square root\n    val *= (1 + 0.3 * (num_tri ** 0.5) / (n + 1))\n\n    # Degree spread and variability can increase path length\n    val *= (1 + 0.3 * (max_deg - min_deg) / (max_deg + 1))\n    val *= (1 + 0.3 * std_deg / (avg_deg + 1))\n\n    # Median degree captures the central tendency of the degree distribution\n    mid = len(degrees) // 2\n    if len(degrees) % 2 == 0:\n        median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n    else:\n        median_deg = degrees[mid]\n    val *= (1 + 0.2 * median_deg / (avg_deg + 1))\n\n    return val",
        "island_id": 0,
        "generation": 10,
        "train_score": 0.7378151260504201,
        "val_score": 0.49456827935872105,
        "simplicity_score": 0.24766122955523237,
        "novelty_bonus": 0.3717377350393678
      },
      {
        "id": "g5_i0_p4_744762155",
        "code": "def new_invariant(s):\n    # unpack features\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    density    = s['density']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    degrees    = s['degrees']          # already sorted\n\n    # Base estimate: larger n and smaller avg_degree → longer paths\n    val = n / (avg_deg + 1)\n\n    # Factors that tend to shorten paths\n    val *= (1 + 1.5 * density)\n    val *= (1 + 1.2 * clustering)\n    val *= (1 + trans)\n\n    # Positive assortativity tends to cluster similar‑degree nodes, often shortening paths\n    val /= (1 + 0.5 * abs(assort))\n\n    # Triangles provide local shortcuts; moderate their influence\n    val *= (1 + 0.5 * (num_tri ** 0.5) / (n ** 2 + 1))\n\n    # Degree spread can increase path length; moderate its effect\n    val *= (1 + 0.5 * (max_deg - min_deg) / (max_deg + 1))\n\n    # Degree variability often increases path length; moderate its effect\n    val *= (1 + 0.5 * std_deg / (avg_deg + 1))\n\n    # Median degree captures the central tendency of the degree distribution\n    mid = len(degrees) // 2\n    if len(degrees) % 2 == 1:\n        median_deg = degrees[mid]\n    else:\n        median_deg = (degrees[mid - 1] + degrees[mid]) / 2\n    val *= (1 + 0.5 * median_deg / (avg_deg + 1))\n\n    # Sum of squared degrees captures higher‑order degree effects\n    sum_sq = sum(d * d for d in degrees)\n    val *= (1 + 0.5 * sum_sq / (n * (avg_deg ** 2 + 1)))\n\n    return val",
        "island_id": 0,
        "generation": 5,
        "train_score": 0.7438655462184873,
        "val_score": 0.4933254659359554,
        "simplicity_score": 0.24656480581498377,
        "novelty_bonus": 0.3336725934608116
      }
    ],
    "1": [
      {
        "id": "g6_i0_p1_226909348",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features.\n    The formula is a weighted product of factors that tend to shorten or lengthen\n    paths, with coefficients tuned to keep the expression compact while\n    capturing the main structural influences.\n    \"\"\"\n    # Basic quantities\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    density    = s['density']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    degrees    = s['degrees']          # sorted list\n\n    # Base estimate: larger n and smaller avg_degree → longer paths\n    val = n / (avg_deg + 1)\n\n    # Factors that tend to shorten paths\n    val *= (1 + 1.3 * density)\n    val *= (1 + 1.1 * clustering)\n    val *= (1 + 1.2 * trans)\n\n    # Positive assortativity clusters similar‑degree nodes, often shortening paths\n    val /= (1 + 0.5 * abs(assort))\n\n    # Triangles provide local shortcuts; dampen large counts with a square root\n    val *= (1 + (num_tri ** 0.5) / (n ** 2 + 1))\n\n    # Degree spread and variability can increase path length\n    val *= (1 + 0.3 * (max_deg - min_deg) / (max_deg + 1))\n    val *= (1 + 0.3 * std_deg / (avg_deg + 1))\n\n    # Median degree captures the central tendency of the degree distribution\n    mid = len(degrees) // 2\n    median_deg = degrees[mid] if len(degrees) % 2 else (degrees[mid - 1] + degrees[mid]) / 2\n    val *= (1 + 0.2 * median_deg / (avg_deg + 1))\n\n    return val",
        "island_id": 0,
        "generation": 6,
        "train_score": 0.7511644657863146,
        "val_score": 0.507842254236618,
        "simplicity_score": 0.24783440638124699,
        "novelty_bonus": 0.31979642891023075
      },
      {
        "id": "g10_i1_p1_34692964",
        "code": "def new_invariant(s):\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Base factors combining the two top formulas\n    base1 = n / (avg_deg + 1)\n    base2 = n / (m + 1)\n    base = base1 * base2\n\n    # Degree balance\n    deg_factor = (avg_deg + 1) / (max_deg + 1)\n\n    # Structural cohesion\n    struct_factor = (density + clustering) * (1 + trans)\n\n    # Size scaling\n    sqrt_factor = n ** 0.5\n\n    # Assortativity penalty\n    assort_factor = 1 / (1 + 0.5 * abs(assort))\n\n    # Triangle influence (both raw and normalized)\n    max_triangles = max(1, n * (n - 1) / 2)\n    tri_factor1 = 1 + (triangles ** 0.5) / (n ** 2 + 1)\n    tri_factor2 = 1 + triangles / max_triangles\n    triangle_factor = tri_factor1 * tri_factor2\n\n    # Degree variance penalty\n    std_factor = (1 / (1 + std_deg)) * (1 + 0.3 * std_deg / (avg_deg + 1))\n\n    # Minimum degree encouragement\n    min_factor = (min_deg + 1) / (avg_deg + 1)\n\n    # Degree spread factor\n    spread_factor = 1 + (max_deg - min_deg) / (max_deg + 1)\n\n    # Degree range factor\n    degree_range_factor = 1 + (max_deg - min_deg + 1) / (avg_deg + 1)\n\n    # Median degree factor\n    mid = len(degrees) // 2\n    if len(degrees) % 2 == 0:\n        median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n    else:\n        median_deg = degrees[mid]\n    median_factor = (median_deg + 1) / (avg_deg + 1)\n\n    # Combine all multiplicatively\n    val = (base * deg_factor * struct_factor * sqrt_factor *\n           assort_factor * triangle_factor * std_factor *\n           min_factor * spread_factor * degree_range_factor *\n           median_factor)\n\n    return val",
        "island_id": 1,
        "generation": 10,
        "train_score": 0.6265066026410564,
        "val_score": 0.502691141133517,
        "simplicity_score": 0.24434197266276908,
        "novelty_bonus": 0.2827537777062503
      },
      {
        "id": "g11_i1_p3_409186442",
        "code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Base size factor\n    val = n / (m + 1)\n\n    # Size scaling\n    val *= n ** 0.5\n\n    # Cohesion factors\n    val *= (1 + density)\n    val *= (1 + avg_clustering)\n    val *= (1 + transitivity)\n\n    # Triangle factor\n    max_triangles = max(1, n * (n - 1) / 2.0)\n    val *= (1 + num_triangles / max_triangles)\n\n    # Degree spread and variability\n    degree_range = max_degree - min_degree\n    val *= (1 + degree_range / (max_degree + 1))\n    val *= (1 + std_degree / (avg_degree + 1))\n\n    # Assortativity effect\n    val *= (1 + abs(degree_assortativity))\n\n    # Median degree\n    mid = len(degrees) // 2\n    if len(degrees) % 2 == 0:\n        median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n    else:\n        median_deg = degrees[mid]\n    val *= (1 + median_deg / (avg_degree + 1))\n\n    # Minimum and maximum degree encouragement\n    val *= (1 + min_degree / (avg_degree + 1))\n    val *= (1 + max_degree / (avg_degree + 1))\n\n    return val",
        "island_id": 1,
        "generation": 11,
        "train_score": 0.7202400960384154,
        "val_score": 0.4379262986799698,
        "simplicity_score": 0.24658881504507985,
        "novelty_bonus": 0.3777972523697515
      },
      {
        "id": "g11_i1_p1_996106906",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features.\n    The expression combines several structural factors multiplicatively, each\n    designed to capture a different aspect of graph connectivity.\n    \"\"\"\n    # Basic size / density factor\n    val = s['n'] / (s['m'] + 1)\n\n    # Structural cohesion factors\n    val *= (1 + s['density'])\n    val *= (1 + s['avg_clustering'])\n    val *= (1 + s['transitivity'])\n\n    # Triangle density relative to the maximum possible\n    max_triangles = max(1, s['n'] * (s['n'] - 1) / 2.0)\n    val *= (1 + s['num_triangles'] / max_triangles)\n\n    # Degree spread and variability\n    degree_range = s['max_degree'] - s['min_degree']\n    val *= (1 + degree_range / (s['max_degree'] + 1))\n    val *= (1 + s['std_degree'] / (s['avg_degree'] + 1))\n\n    # Assortativity effect (penalise large absolute values)\n    val *= (1 / (1 + abs(s['degree_assortativity'])))\n\n    # Median degree factor\n    degrees = s['degrees']\n    mid = len(degrees) // 2\n    if len(degrees) % 2 == 0:\n        median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n    else:\n        median_deg = degrees[mid]\n    val *= (1 + median_deg / (s['avg_degree'] + 1))\n\n    return val",
        "island_id": 1,
        "generation": 11,
        "train_score": 0.6305402160864346,
        "val_score": 0.4188743097973794,
        "simplicity_score": 0.24884422855652805,
        "novelty_bonus": 0.2787261494590507
      },
      {
        "id": "g11_i1_p2_664313540",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features.\n    The expression combines several structural factors multiplicatively, each\n    designed to capture a different aspect of graph connectivity.\n    \"\"\"\n    # Basic size / density factor\n    val = s['n'] / (s['m'] + 1)\n\n    # Structural cohesion factors\n    val *= (1 + s['density'])\n    val *= (1 + s['avg_clustering'])\n    val *= (1 + s['transitivity'])\n\n    # Triangle density relative to the maximum possible\n    max_triangles = max(1, s['n'] * (s['n'] - 1) / 2.0)\n    val *= (1 + s['num_triangles'] / max_triangles)\n\n    # Degree spread and variability\n    degree_range = s['max_degree'] - s['min_degree']\n    val *= (1 + degree_range / (s['max_degree'] + 1))\n    val *= (1 + s['std_degree'] / (s['avg_degree'] + 1))\n\n    # Assortativity effect\n    val *= (1 + abs(s['degree_assortativity']))\n\n    # Median degree factor\n    degrees = s['degrees']\n    mid = len(degrees) // 2\n    if len(degrees) % 2 == 0:\n        median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n    else:\n        median_deg = degrees[mid]\n    val *= (1 + median_deg / (s['avg_degree'] + 1))\n\n    return val",
        "island_id": 1,
        "generation": 11,
        "train_score": 0.665594237695078,
        "val_score": 0.40436578468778905,
        "simplicity_score": 0.24894726141771692,
        "novelty_bonus": 0.3145440983224703
      }
    ],
    "2": [
      {
        "id": "g1_i2_p4_735752370",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The formula combines random‑graph theory with corrections for clustering,\n    degree heterogeneity, density, and assortativity.  All operations are\n    safeguarded against division by zero and missing values.\n    \"\"\"\n    # Basic graph statistics (safe defaults)\n    n          = s.get('n', 0)\n    avg_deg    = s.get('avg_degree', 0.0) or 1.0          # avoid zero\n    trans      = s.get('transitivity', 0.0) or 0.0\n    avg_clust  = s.get('avg_clustering', 0.0) or 0.0\n    std_deg    = s.get('std_degree', 0.0) or 1.0\n    density    = s.get('density', 0.0) or 1e-6            # avoid zero\n    assort     = s.get('degree_assortativity', 0.0) or 0.0\n\n    eps = 1e-6\n\n    # 1. Random‑graph baseline: log(n)/log(avg_deg+1)\n    base = np.log(max(n, 2)) / np.log(max(avg_deg + 1.0, 2.0))\n\n    # 2. Clustering adjustment: more triangles → longer paths\n    clustering_adj = 1.0 + 0.5 * (trans + avg_clust)\n\n    # 3. Degree variance adjustment: higher variance → shorter paths\n    variance_adj = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Density adjustment: sparser graphs tend to have longer paths\n    density_adj = np.sqrt(1.0 / (density + eps))\n\n    # 5. Assortativity adjustment: positive assortativity can lengthen paths\n    assort_adj = 1.0 + 0.5 * assort  # range roughly [0.5, 1.5]\n\n    return base * clustering_adj * variance_adj * density_adj * assort_adj",
        "island_id": 2,
        "generation": 1,
        "train_score": 0.9221128451380551,
        "val_score": 0.5491013268732999,
        "simplicity_score": 0.13119988577898903,
        "novelty_bonus": 0.1811952881995048
      },
      {
        "id": "g3_i2_p0_858291293",
        "code": "def new_invariant(s):\n    # Basic statistics with safe defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    if avg_deg <= 0:\n        avg_deg = 1.0\n\n    trans      = s.get('transitivity', 0.0)\n    std_deg    = s.get('std_degree', 1.0)\n    if std_deg <= 0:\n        std_deg = 1.0\n\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n\n    # 1. Baseline distance estimate (scales with sqrt(n))\n    base = (n ** 0.5) / (avg_deg + 1)\n\n    # 2. Adjust for clustering – more triangles → longer paths\n    clustering_adj = 1 + trans\n\n    # 3. Adjust for degree variance – higher variance → shorter paths\n    variance_adj = 1 / (1 + std_deg / (avg_deg + 1))\n\n    # 4. Adjust for density – denser graphs → shorter paths\n    density_adj = 1 / (1 + density)\n\n    # 5. Adjust for assortativity – positive assortativity can lengthen paths\n    assort_adj = 1 + 0.5 * assort\n\n    # Combined estimate\n    return base * clustering_adj * variance_adj * density_adj * assort_adj",
        "island_id": 2,
        "generation": 3,
        "train_score": 0.9177911164465786,
        "val_score": 0.5483243163606503,
        "simplicity_score": 0.13343273744596368,
        "novelty_bonus": 0.15721743043576064
      },
      {
        "id": "g9_i2_p3_30817834",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The formula is a product of a base term and several multiplicative\n    adjustments that capture the influence of clustering, degree variance,\n    density, assortativity, and degree extremes.\n    \"\"\"\n    # Basic statistics with safe defaults\n    n          = s.get('n', 1)\n    m          = s.get('m', 1)\n    density    = s.get('density', 1e-6)\n    avg_deg    = s.get('avg_degree', 1.0)\n    if avg_deg <= 0: avg_deg = 1.0\n    max_deg    = s.get('max_degree', 1.0)\n    if max_deg <= 0: max_deg = 1.0\n    min_deg    = s.get('min_degree', 1.0)\n    if min_deg <= 0: min_deg = 1.0\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n\n    # Base estimate: grows with sqrt(n) and shrinks with average degree\n    base = (n ** 0.5) / (avg_deg + 1.0)\n\n    # 1. Clustering & transitivity: more triangles → longer paths\n    clustering_adj = 1.0 + 0.5 * (clustering + trans)\n\n    # 2. Degree variance: higher variance tends to shorten paths\n    var_adj = 1.0 / (1.0 + (std_deg * std_deg) / (avg_deg + 1.0))\n\n    # 3. Density: denser graphs have shorter paths\n    density_adj = 1.0 / (density + 1e-6)\n\n    # 4. Assortativity: positive assortativity can lengthen paths\n    assort_adj = 1.0 + 0.5 * assort\n\n    # 5. Max degree: very high maximum degree usually shortens paths\n    max_adj = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # 6. Minimum degree: very low minimum degree can lengthen paths\n    min_adj = 1.0 + 1.0 / (min_deg + 1e-6)\n\n    # 7. Triangle count relative to edges: more triangles → longer paths\n    tri_adj = 1.0 + triangles / (m + 1.0)\n\n    # Combined estimate\n    estimate = (base *\n                clustering_adj *\n                var_adj *\n                density_adj *\n                assort_adj *\n                max_adj *\n                min_adj *\n                tri_adj)\n\n    return estimate",
        "island_id": 2,
        "generation": 9,
        "train_score": 0.8884033613445379,
        "val_score": 0.5300391885637957,
        "simplicity_score": 0.17909397257846857,
        "novelty_bonus": 0.22039635324270634
      },
      {
        "id": "g11_i2_p0_406386861",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The estimate is a product of a base term and multiplicative adjustments that\n    capture the effects of clustering, degree variance, density, assortativity,\n    degree extremes, and triangle abundance.\n    \"\"\"\n    # Basic statistics with safe defaults\n    n          = s.get('n', 1)\n    m          = s.get('m', 1)\n    density    = s.get('density', 1e-6)\n    avg_deg    = s.get('avg_degree', 1.0)\n    if avg_deg <= 0:\n        avg_deg = 1.0\n    max_deg    = s.get('max_degree', 1.0)\n    if max_deg <= 0:\n        max_deg = 1.0\n    min_deg    = s.get('min_degree', 1.0)\n    if min_deg <= 0:\n        min_deg = 1.0\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n\n    # Base estimate: grows with sqrt(n) and shrinks with average degree\n    base = (n ** 0.5) / (avg_deg + 1.0)\n\n    # 1. Clustering & transitivity: more triangles → longer paths\n    clustering_adj = 1.0 + 0.5 * (clustering + trans)\n\n    # 2. Degree variance: higher variance tends to shorten paths\n    var_adj = 1.0 / (1.0 + (std_deg * std_deg) / (avg_deg + 1.0))\n\n    # 3. Density: denser graphs have shorter paths\n    density_adj = 1.0 / (density + 1e-6)\n\n    # 4. Assortativity: positive assortativity can lengthen paths\n    assort_adj = 1.0 + 0.5 * assort\n\n    # 5. Max degree: very high maximum degree usually shortens paths\n    max_adj = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # 6. Minimum degree: very low minimum degree can lengthen paths\n    min_adj = 1.0 + 1.0 / (min_deg + 1e-6)\n\n    # 7. Triangle count relative to edges: more triangles → longer paths\n    tri_adj = 1.0 + triangles / (m + 1.0)\n\n    # Combined estimate\n    estimate = (base *\n                clustering_adj *\n                var_adj *\n                density_adj *\n                assort_adj *\n                max_adj *\n                min_adj *\n                tri_adj)\n\n    return estimate",
        "island_id": 2,
        "generation": 11,
        "train_score": 0.8884033613445379,
        "val_score": 0.5300391885637957,
        "simplicity_score": 0.17909397257846857,
        "novelty_bonus": 0.22039635324270634
      },
      {
        "id": "g11_i2_p2_814020384",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    features.  The expression is a product of a simple base term and several\n    multiplicative adjustments that capture the influence of clustering,\n    degree heterogeneity, density, assortativity, and degree extremes.\n    All divisions are guarded against zero and missing values.\n    \"\"\"\n    # Basic statistics with safe defaults\n    n          = s.get('n', 1)\n    m          = s.get('m', 1)\n    density    = s.get('density', 1e-6)\n    avg_deg    = s.get('avg_degree', 1.0)\n    if avg_deg <= 0:          # avoid division by zero\n        avg_deg = 1.0\n    max_deg    = s.get('max_degree', 1.0)\n    if max_deg <= 0:\n        max_deg = 1.0\n    min_deg    = s.get('min_degree', 1.0)\n    if min_deg <= 0:\n        min_deg = 1.0\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n\n    # 1. Base estimate: grows with sqrt(n) and shrinks with average degree\n    base = (n ** 0.5) / (avg_deg + 1.0)\n\n    # 2. Clustering & transitivity adjustment: more triangles → longer paths\n    clustering_adj = 1.0 + 0.5 * (clustering + trans)\n\n    # 3. Degree variance adjustment: higher variance tends to shorten paths\n    var_adj = 1.0 / (1.0 + (std_deg * std_deg) / (avg_deg + 1.0))\n\n    # 4. Density adjustment: denser graphs have shorter paths\n    density_adj = 1.0 / (density + 1e-6)\n\n    # 5. Assortativity adjustment: positive assortativity can lengthen paths\n    assort_adj = 1.0 + 0.5 * assort\n\n    # 6. Max degree adjustment: very high maximum degree usually shortens paths\n    max_adj = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # 7. Minimum degree adjustment: very low minimum degree can lengthen paths\n    min_adj = 1.0 + 1.0 / (min_deg + 1e-6)\n\n    # 8. Triangle count adjustment: more triangles relative to edges → longer paths\n    tri_adj = 1.0 + triangles / (m + 1.0)\n\n    # Combine all factors\n    estimate = (base *\n                clustering_adj *\n                var_adj *\n                density_adj *\n                assort_adj *\n                max_adj *\n                min_adj *\n                tri_adj)\n\n    return estimate",
        "island_id": 2,
        "generation": 11,
        "train_score": 0.8884033613445379,
        "val_score": 0.5300391885637957,
        "simplicity_score": 0.17909397257846857,
        "novelty_bonus": 0.22039635324270634
      }
    ],
    "3": [
      {
        "id": "g1_i2_p4_735752370",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The formula combines random‑graph theory with corrections for clustering,\n    degree heterogeneity, density, and assortativity.  All operations are\n    safeguarded against division by zero and missing values.\n    \"\"\"\n    # Basic graph statistics (safe defaults)\n    n          = s.get('n', 0)\n    avg_deg    = s.get('avg_degree', 0.0) or 1.0          # avoid zero\n    trans      = s.get('transitivity', 0.0) or 0.0\n    avg_clust  = s.get('avg_clustering', 0.0) or 0.0\n    std_deg    = s.get('std_degree', 0.0) or 1.0\n    density    = s.get('density', 0.0) or 1e-6            # avoid zero\n    assort     = s.get('degree_assortativity', 0.0) or 0.0\n\n    eps = 1e-6\n\n    # 1. Random‑graph baseline: log(n)/log(avg_deg+1)\n    base = np.log(max(n, 2)) / np.log(max(avg_deg + 1.0, 2.0))\n\n    # 2. Clustering adjustment: more triangles → longer paths\n    clustering_adj = 1.0 + 0.5 * (trans + avg_clust)\n\n    # 3. Degree variance adjustment: higher variance → shorter paths\n    variance_adj = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Density adjustment: sparser graphs tend to have longer paths\n    density_adj = np.sqrt(1.0 / (density + eps))\n\n    # 5. Assortativity adjustment: positive assortativity can lengthen paths\n    assort_adj = 1.0 + 0.5 * assort  # range roughly [0.5, 1.5]\n\n    return base * clustering_adj * variance_adj * density_adj * assort_adj",
        "island_id": 2,
        "generation": 1,
        "train_score": 0.9221128451380551,
        "val_score": 0.5491013268732999,
        "simplicity_score": 0.13119988577898903,
        "novelty_bonus": 0.1811952881995048
      },
      {
        "id": "g11_i3_p1_106142582",
        "code": "def new_invariant(s):\n    \"\"\"\n    Composite invariant built only from arithmetic on the supplied\n    pre‑computed statistics.\n\n    The formula mixes sparsity (n/m), degree dispersion, triangle\n    density, clustering, assortativity, and the harmonic mean of the\n    degree sequence – all known to influence the average shortest‑path\n    length.\n\n    All operations are safe from division‑by‑zero errors by adding a\n    tiny epsilon where necessary.\n    \"\"\"\n    eps = 1e-6  # small constant for numerical stability\n\n    # Basic counts\n    n = s['n']\n    m = s['m']\n\n    # Degree‑related statistics\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    degrees = s['degrees']      # sorted list of degrees\n\n    # Triangle and clustering measures\n    num_tri = s['num_triangles']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n\n    # Assortativity\n    assort = s['degree_assortativity']\n\n    # 1. Sparsity factor – how many nodes per edge (plus 1 to avoid 0/0)\n    size_factor = (n + 1.0) / (m + 1.0)\n\n    # 2. Degree‑spread factor – captures heterogeneity in connectivity\n    spread_factor = (max_deg - min_deg + 1.0) / (std_deg + 1.0)\n\n    # 3. Triangle density – more triangles usually reduce average path length\n    tri_factor = (num_tri + 1.0) / (n + 1.0)\n\n    # 4. Clustering penalty – large clustering tends to increase path lengths\n    cluster_factor = (avg_clust ** 2 + trans ** 2) / 2.0\n\n    # 5. Assortativity penalty – strong assortative or disassortative mixing can\n    #    create bottlenecks, so penalise large absolute values.\n    assort_factor = (assort ** 2) + 1.0\n\n    # 6. Harmonic mean of degrees – higher harmonic mean usually means\n    #    more uniformly high degrees, which shortens paths.\n    sum_inv = 0.0\n    for d in degrees:\n        if d > 0:\n            sum_inv += 1.0 / d\n    harmonic = (len(degrees) / (sum_inv + eps)) if degrees else 1.0\n\n    # 7. Final composite invariant\n    invariant = (size_factor * spread_factor * tri_factor * harmonic) \\\n                / (cluster_factor * assort_factor + eps)\n\n    return invariant",
        "island_id": 3,
        "generation": 11,
        "train_score": 0.547563025210084,
        "val_score": 0.4174360237884459,
        "simplicity_score": 0.17560239116938964,
        "novelty_bonus": 0.32422104143419117
      },
      {
        "id": "g4_i3_p3_43803765",
        "code": "def new_invariant(s):\n    \"\"\"\n    Composite graph invariant that mixes size, sparsity, degree dispersion,\n    triangle abundance, clustering strength, and degree assortativity.\n    All operations use only built‑in arithmetic to avoid external imports.\n    \"\"\"\n    # Size to edge ratio – captures overall sparsity\n    size_edge = (s['n'] + 1.0) / (s['m'] + 1.0)\n\n    # Degree dispersion relative to variability – higher spread suggests\n    # longer paths through hubs\n    deg_disp = (s['max_degree'] - s['min_degree'] + 1.0) / (s['std_degree'] + 1.0)\n\n    # Triangle density – more triangles usually shorten paths\n    tri_dense = (s['num_triangles'] + 1.0) / (s['n'] + 1.0)\n\n    # Combined clustering factor – square to amplify the effect\n    cluster_factor = (s['avg_clustering'] ** 2 + s['transitivity'] ** 2) / 2.0\n\n    # Assortativity magnitude – strong correlation can create bottlenecks\n    assort_factor = (s['degree_assortativity'] ** 2 + 1.0)\n\n    # Final invariant: product of sparsity, dispersion, and triangle terms,\n    # divided by clustering and assortativity terms\n    invariant = (size_edge * deg_disp * tri_dense) / (cluster_factor * assort_factor)\n\n    return invariant",
        "island_id": 3,
        "generation": 4,
        "train_score": 0.7733580018501388,
        "val_score": 0.4168062307831738,
        "simplicity_score": 0.18156973355038536,
        "novelty_bonus": 0.40562853270443633
      },
      {
        "id": "g5_i3_p2_686478210",
        "code": "def new_invariant(s):\n    \"\"\"\n    A hand‑crafted composite invariant built only from arithmetic\n    operations on the supplied pre‑computed statistics.\n\n    The formula mixes size, sparsity, degree dispersion, triangle\n    abundance, clustering, and degree assortativity – all quantities\n    known to influence the average shortest‑path length.\n\n    Key assumptions:\n        • s contains the keys listed in the problem statement.\n        • No external modules may be imported; only built‑in\n          operations (addition, subtraction, multiplication,\n          division, pow, min, max, etc.) are used.\n\n    The structure is:\n\n        invariant = (size_factor * degree_factor * triangle_factor)\n                    / (clustering_factor * assortativity_factor)\n\n    The \"+ 1\" terms in denominators guarantee numerical stability\n    for very small or zero values.\n    \"\"\"\n\n    # 1. Size‑to‑edge ratio: captures overall sparsity.\n    size_factor = (s['n'] + 1.0) / (s['m'] + 1.0)\n\n    # 2. Degree spread relative to its standard deviation.\n    #    Larger spread tends to create longer paths, especially when\n    #    combined with a high variance of degrees.\n    degree_factor = (s['max_degree'] - s['min_degree'] + 1.0) / (s['std_degree'] + 1.0)\n\n    # 3. Triangle density (shifted to avoid division by zero).\n    triangle_factor = (s['num_triangles'] + 1.0) / (s['n'] + 1.0)\n\n    # 4. Clustering influence.  Square both local and global clustering\n    #    before averaging to give more weight to high‑clustering graphs.\n    clustering_factor = (pow(s['avg_clustering'], 2) + pow(s['transitivity'], 2)) / 2.0\n\n    # 5. Assortativity influence.  Strong positive or negative assortativity\n    #    usually creates bottlenecks, so we penalise large absolute values.\n    assortativity_factor = pow(s['degree_assortativity'], 2) + 1.0\n\n    # 6. Combine all pieces.  We multiply the first three terms – each\n    #    known to *shorten* paths – and divide by the last two, which\n    #    typically *enlarge* the average shortest path.\n    invariant = (size_factor * degree_factor * triangle_factor) / (clustering_factor * assortativity_factor)\n\n    return invariant",
        "island_id": 3,
        "generation": 5,
        "train_score": 0.7733580018501388,
        "val_score": 0.41675922015805367,
        "simplicity_score": 0.18133468042478507,
        "novelty_bonus": 0.40562853270443633
      },
      {
        "id": "g3_i3_p3_700522966",
        "code": "def new_invariant(s):\n    \"\"\"\n    A composite invariant that mixes several pre‑computed graph statistics\n    to produce a value correlated with the average shortest‑path length.\n    It uses only arithmetic, comparisons, and basic Python built‑ins.\n\n    Keys required from the dictionary `s`:\n        - n                 (int) number of nodes\n        - m                 (int) number of edges\n        - density           (float) edge density\n        - avg_degree        (float) average degree\n        - max_degree        (int) maximum degree\n        - min_degree        (int) minimum degree\n        - std_degree        (float) degree standard deviation\n        - avg_clustering    (float) average local clustering coefficient\n        - transitivity      (float) global transitivity (overall clustering)\n        - degree_assortativity (float) degree assortativity coefficient\n        - num_triangles     (int) number of triangles\n        - degrees           (list[int]) sorted degree sequence\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 1. Size to sparsity ratio\n    size_edge_ratio = (s['n'] + 1.0) / (s['m'] + 1.0)\n\n    # 2. Degree dispersion: relative spread compared to variation\n    degree_spread = (s['max_degree'] - s['min_degree'] + 1.0)\n    degree_variation = s['std_degree'] + 1.0\n    degree_dispersion = degree_spread / degree_variation\n\n    # 3. Triangle density: triangles per node (shifted to avoid zero)\n    triangle_density = (s['num_triangles'] + 1.0) / (s['n'] + 1.0)\n\n    # 4. Local triangle power: square of clustering and transitivity\n    clustering_power = (s['avg_clustering'] ** 2 + s['transitivity'] ** 2) / 2.0\n\n    # 5. Assortativity magnitude: square to make always positive\n    assort_magnitude = s['degree_assortativity'] ** 2 + 1.0\n\n    # ------------------------------------------------------------------\n    # Combine everything into one scalar\n    # The product of the first three components emphasizes sparsity,\n    # degree spread, and triangle abundance – all of which can affect\n    # path lengths.  Dividing by the clustering and assortativity terms\n    # dampens the effect of very high clustering or strong degree\n    # correlations.\n    invariant = (\n        size_edge_ratio\n        * degree_dispersion\n        * triangle_density\n    ) / (\n        clustering_power\n        * assort_magnitude\n    )\n\n    return invariant",
        "island_id": 3,
        "generation": 3,
        "train_score": 0.7733580018501388,
        "val_score": 0.41665460973069646,
        "simplicity_score": 0.18081162828799893,
        "novelty_bonus": 0.40562853270443633
      }
    ]
  }
}