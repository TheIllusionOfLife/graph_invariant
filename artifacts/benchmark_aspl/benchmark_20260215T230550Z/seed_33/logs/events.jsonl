{"timestamp": "2026-02-16T12:38:36.804085+00:00", "event_type": "phase1_started", "payload": {"experiment_id": "seed_33", "resume": null, "model_name": "gpt-oss:20b", "dataset_fingerprint": "675a0bf926b7bcc6c0b9b06b3a697e2a54b33853af11ec201ba62fcef94908bd"}}
{"timestamp": "2026-02-16T12:39:15.963005+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:39:15.963720+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:44:01.451348+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.010552", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:44:01.451868+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 0, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:44:47.782362+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.033269", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:44:47.783091+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.033269", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:45:26.048560+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.126905", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:45:26.049060+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:45:50.237650+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:45:50.238625+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:46:40.201525+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g0_i0_p2_878937726", "generation": 0, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5291236494597839, "fitness_mode": "correlation", "simplicity_score": 0.23136712559863704, "novelty_bonus": 0.18111796506111555, "total_score": 0.4213940842698029, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\nNone yet.\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.010552\nbelow_novelty_threshold: novelty_bonus=0.033269\nbelow_novelty_threshold: novelty_bonus=0.126905\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a simple analytic\n    combination of pre‑computed graph statistics.\n\n    The formula is inspired by the classic random‑graph estimate\n    L ≈ log(n) / log(⟨k⟩) and is modulated by clustering and degree\n    assortativity to capture small‑world and assortative effects.\n    \"\"\"\n    n = s['n']\n    # Avoid division by zero or log(0) when the graph is very sparse\n    avg_deg = max(s['avg_degree'], 1.001)\n\n    # Core random‑graph estimate\n    log_term = np.log(n) / np.log(avg_deg)\n\n    # Increase the estimate when clustering is high (small‑world effect)\n    clustering_factor = 1.0 + s['avg_clustering']\n\n    # Reduce the estimate when the graph is highly assortative\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    return log_term * clustering_factor / assort_factor\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    # Basic estimate: sqrt(n) divided by sqrt of average degree (avoid division by zero)\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n    # Increase estimate when clustering is high (small‑world effect)\n    base *= (1 + clustering)\n    # Reduce estimate when graph is highly assortative\n    base /= (1 + abs(assort))\n    # Add a small adjustment based on the number of triangles\n    base += triangles / (n**2 + 1)\n    return base", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    # Basic estimate: sqrt(n) divided by sqrt of average degree (avoid division by zero)\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n    # Increase estimate when clustering is high (small‑world effect)\n    base *= (1 + clustering)\n    # Reduce estimate when graph is highly assortative\n    base /= (1 + abs(assort))\n    # Add a small adjustment based on the number of triangles\n    base += triangles / (n**2 + 1)\n    return base", "spearman": 0.6415705392634816, "pearson": 0.5756343073791448, "rmse": 1.0268472486428966, "mae": 0.9073155686413594}}
{"timestamp": "2026-02-16T12:46:40.202795+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 0, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:47:30.448680+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.015339", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:47:30.449110+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.015339", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:49:38.359418+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.012068", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:49:38.360174+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:50:29.608481+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.020416", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:50:29.609040+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.020416", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:50:51.176497+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:50:51.177522+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 0, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:50:59.654465+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:50:59.655151+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:54:20.415268+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.104286", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:54:20.416941+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:54:51.857718+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.049296", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:54:51.858168+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.049296", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:55:13.059685+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.072828", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:55:13.060229+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 1, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:55:30.243556+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:55:30.245051+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:55:54.638663+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.038764", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:55:54.639142+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:56:15.949936+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.001291", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:56:15.950483+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.001291", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:56:59.957905+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.051261", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:56:59.958494+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 1, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:57:46.810849+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:57:46.811886+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:58:36.787559+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: __import__", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:58:36.788904+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 1, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:59:05.451634+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:59:05.452656+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:59:38.092326+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.022154", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:59:38.093061+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 2, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:00:03.850618+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:00:03.851493+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:00:16.865995+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:00:16.866404+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:00:55.781847+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.247347", "model_name": "gpt-oss:20b", "train_signal": 0.24734693877551017}}
{"timestamp": "2026-02-16T13:01:35.986067+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.089295", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:01:35.986606+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.089295", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:02:04.220057+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.015424", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:02:04.220424+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 2, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:02:23.682013+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:02:23.683072+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:02:47.775504+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.087888", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:02:47.775987+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 2, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:03:35.420753+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:03:35.421779+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:04:12.628247+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g0_i3_p0_443642236", "generation": 0, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.34367346938775506, "fitness_mode": "correlation", "simplicity_score": 0.24658881504507985, "novelty_bonus": 0.17230250871398334, "total_score": 0.2646071055879601, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\nNone yet.\nRecent failures:\nNone.\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    A novel invariant approximating the average shortest‑path length from\n    pre‑computed graph statistics.  \n    The formula combines several structural cues:\n      • Heterogeneity of degrees (variance to mean ratio)\n      • Sparsity (1 – density)\n      • Degree asymmetry between the top and bottom 5 nodes\n      • Clustering (average clustering + transitivity)\n      • Assortativity\n      • Triangular motifs\n      • Logarithmic size scaling (log n)\n    \"\"\"\n    import numpy as np\n\n    # Basic safeguards against division by zero\n    avg_d   = max(s['avg_degree'], 1.0)\n    max_d   = max(s['max_degree'],   1.0)\n    min_d   = max(s['min_degree'],   0.01)  # avoid exact zero\n\n    # Degree heterogeneity (variance/mean)\n    hetero = (s['std_degree'] ** 2) / avg_d\n\n    # Sparsity factor – more sparse graphs tend to have longer paths\n    sparsity = 1.0 - s['density']\n\n    # Triangular motif penalty – dense clustering via triangles usually shortens paths\n    tri_fac = 1.0 + s['num_triangles'] / max(s['n'], 1.0)\n\n    # Clustering penalty\n    cluster_pen = 1.0 + s['avg_clustering'] + s['transitivity']\n\n    # Assortativity adjustment – negative assortativity typically elongates paths\n    assort_adj = 1.0 + abs(s['degree_assortativity'])\n\n    # Degree‑gap between the 5 highest and 5 lowest degree nodes\n    k = min(5, len(s['degrees']))\n    if k == 0:\n        deg_gap = 1.0\n    else:\n        top_sum = sum(s['degrees'][-k:])\n        bottom_sum = sum(s['degrees'][:k])\n        deg_gap = (top_sum - bottom_sum) / max(top_sum, 1.0)\n\n    # Logarithmic size scaling\n    size_factor = np.log(s['n'] + 1.0)\n\n    # Assemble the invariant\n    inv = (size_factor *\n           hetero *\n           sparsity *\n           deg_gap) / (cluster_pen * assort_adj * tri_fac)\n\n    return inv\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A novel estimate for the average shortest‑path length based solely on\n    pre‑computed graph statistics.  The formula is a combination of:\n\n        • Graph size (sqrt(n))\n        • Degree heterogeneity (variance over mean degree)\n        • Sparsity (1 – density)\n        • Degree asymmetry (gap between the top and bottom 5 degrees)\n        • Clustering (sum of avg_clustering and transitivity)\n        • Assortativity adjustment (absolute value)\n        • Triangular motif penalty\n\n    All divisions are protected against zero by adding small constants.\n    \"\"\"\n    # Small epsilon to avoid division by zero\n    eps = 1e-6\n\n    # Basic statistics with safe fallbacks\n    n           = float(s.get('n', 0))\n    avg_deg     = max(float(s.get('avg_degree', 0)), 1.0)\n    std_deg     = float(s.get('std_degree', 0))\n    density     = float(s.get('density', 0))\n    max_deg     = max(float(s.get('max_degree', 0)), 1.0)\n    min_deg     = float(s.get('min_degree', 0)) + eps\n    tri_cnt     = float(s.get('num_triangles', 0))\n    degs        = list(s.get('degrees', []))\n\n    # Degree heterogeneity (variance/mean)\n    hetero = (std_deg ** 2) / avg_deg\n\n    # Sparsity factor\n    sparsity = 1.0 - density\n\n    # Degree gap between the 5 largest and 5 smallest degrees\n    k = min(5, len(degs))\n    if k == 0:\n        deg_gap = 1.0\n    else:\n        top_sum = sum(degs[-k:])\n        bottom_sum = sum(degs[:k])\n        deg_gap = (top_sum - bottom_sum) / max(top_sum, eps)\n\n    # Clustering penalty\n    clustering = max(float(s.get('avg_clustering', 0)), 0.0)\n    transi      = max(float(s.get('transitivity', 0)), 0.0)\n    cluster_pen = 1.0 + clustering + transi\n\n    # Assortativity adjustment\n    assort_adj = 1.0 + abs(float(s.get('degree_assortativity', 0)))\n\n    # Triangle penalty (dense triangles usually shorten paths)\n    tri_pen = 1.0 + tri_cnt / max(n, 1.0)\n\n    # Size scaling (sqrt(n))\n    size_scale = (n + 1) ** 0.5\n\n    # Assemble the invariant\n    inv = (size_scale *\n           hetero *\n           sparsity *\n           deg_gap) / (cluster_pen * assort_adj * tri_pen)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A novel estimate for the average shortest‑path length based solely on\n    pre‑computed graph statistics.  The formula is a combination of:\n\n        • Graph size (sqrt(n))\n        • Degree heterogeneity (variance over mean degree)\n        • Sparsity (1 – density)\n        • Degree asymmetry (gap between the top and bottom 5 degrees)\n        • Clustering (sum of avg_clustering and transitivity)\n        • Assortativity adjustment (absolute value)\n        • Triangular motif penalty\n\n    All divisions are protected against zero by adding small constants.\n    \"\"\"\n    # Small epsilon to avoid division by zero\n    eps = 1e-6\n\n    # Basic statistics with safe fallbacks\n    n           = float(s.get('n', 0))\n    avg_deg     = max(float(s.get('avg_degree', 0)), 1.0)\n    std_deg     = float(s.get('std_degree', 0))\n    density     = float(s.get('density', 0))\n    max_deg     = max(float(s.get('max_degree', 0)), 1.0)\n    min_deg     = float(s.get('min_degree', 0)) + eps\n    tri_cnt     = float(s.get('num_triangles', 0))\n    degs        = list(s.get('degrees', []))\n\n    # Degree heterogeneity (variance/mean)\n    hetero = (std_deg ** 2) / avg_deg\n\n    # Sparsity factor\n    sparsity = 1.0 - density\n\n    # Degree gap between the 5 largest and 5 smallest degrees\n    k = min(5, len(degs))\n    if k == 0:\n        deg_gap = 1.0\n    else:\n        top_sum = sum(degs[-k:])\n        bottom_sum = sum(degs[:k])\n        deg_gap = (top_sum - bottom_sum) / max(top_sum, eps)\n\n    # Clustering penalty\n    clustering = max(float(s.get('avg_clustering', 0)), 0.0)\n    transi      = max(float(s.get('transitivity', 0)), 0.0)\n    cluster_pen = 1.0 + clustering + transi\n\n    # Assortativity adjustment\n    assort_adj = 1.0 + abs(float(s.get('degree_assortativity', 0)))\n\n    # Triangle penalty (dense triangles usually shorten paths)\n    tri_pen = 1.0 + tri_cnt / max(n, 1.0)\n\n    # Size scaling (sqrt(n))\n    size_scale = (n + 1) ** 0.5\n\n    # Assemble the invariant\n    inv = (size_scale *\n           hetero *\n           sparsity *\n           deg_gap) / (cluster_pen * assort_adj * tri_pen)\n\n    return inv", "spearman": 0.32719717992949826, "pearson": 0.3308182715220409, "rmse": 4.210891574709739, "mae": 2.7352665858821883}}
{"timestamp": "2026-02-16T13:04:12.629302+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 3, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:04:54.119358+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.130443", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:04:54.120219+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.130443", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:05:19.035921+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g0_i3_p1_380029512", "generation": 0, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.723409363745498, "fitness_mode": "correlation", "simplicity_score": 0.15212136744551355, "novelty_bonus": 0.28251533227363423, "total_score": 0.4276291844289744, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\nNone yet.\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.130443\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    A novel structural feature that is correlated with the average shortest path length.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics containing keys:\n        - n : number of nodes\n        - m : number of edges\n        - avg_clustering : average clustering coefficient\n        - transitivity : global transitivity\n        - degree_assortativity : degree assortativity coefficient\n        - std_degree : standard deviation of the degree distribution\n\n    Returns\n    -------\n    float\n        The computed invariant value.\n    \"\"\"\n    # Guard against division by zero for extremely sparse graphs\n    denom_edges = s['m'] + 1.0\n\n    # Basic density/degree component, amplified by local clustering\n    val = (s['n'] * (1.0 + s['avg_clustering'])) / denom_edges\n\n    # Increase the value in the presence of global transitivity\n    val *= (1.0 + s['transitivity'])\n\n    # Positive or negative degree assortativity widens the range; use absolute value\n    val *= (1.0 + abs(s['degree_assortativity']))\n\n    # Normalize by the spread of the degree distribution\n    val /= (1.0 + s['std_degree'])\n\n    return val\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser", "spearman": 0.6249006225155629, "pearson": 0.5572351588577394, "rmse": 2.4060377721513055, "mae": 2.2774445486739143}}
{"timestamp": "2026-02-16T13:05:19.036726+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 3, "population_idx": 1, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:05:54.348343+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.045810", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:05:54.348877+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.045810", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:06:21.914194+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 2, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.226026", "model_name": "gpt-oss:20b", "train_signal": 0.22602641056422568}}
{"timestamp": "2026-02-16T13:06:21.915106+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 3, "population_idx": 2, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:07:03.205562+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:07:03.206287+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:07:40.130174+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g0_i3_p3_568491191", "generation": 0, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6221848739495797, "fitness_mode": "correlation", "simplicity_score": 0.15773726422862405, "novelty_bonus": 0.27423912572796283, "total_score": 0.43637600448446173, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\nNone yet.\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.130443\nbelow_novelty_threshold: novelty_bonus=0.045810\nbelow_train_threshold: train_signal=0.226026\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length derived from global graph statistics.\n\n    The formulation combines:\n    • size–density balance via a log‑ratio of vertex count to average degree,\n    • degree concentration in the top 10 % of nodes,\n    • the difference between local clustering and global transitivity,\n    • degree assortativity,\n    • and the square‑root of triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed graph features:\n        n (int), m (int), density (float), avg_degree (float), max_degree (int),\n        min_degree (int), std_degree (float), avg_clustering (float),\n        transitivity (float), degree_assortativity (float), num_triangles (int),\n        degrees (list of ints, sorted non‑decreasing).\n\n    Returns\n    -------\n    float\n        A composite score intended as a proxy for the average shortest path length.\n    \"\"\"\n    import numpy as np\n\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = np.asarray(s['degrees'])\n\n    # 1. Fraction of degree “stubs” that belong to the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = np.sum(degrees[-top_k:])\n    high_deg_ratio = high_deg_sum / (2 * m + 1e-12)  # +ε to avoid division by zero\n\n    # 2. Size‑to‑density log‑ratio (captures how many hops are needed\n    #    to connect a random pair of nodes)\n    size_log_ratio = np.log(n + 1e-12) / (np.log(avg_deg + 1.0) + 1e-12)\n\n    # 3. Clustering difference factor – higher local clustering relative to\n    #    global transitivity tends to shorten paths.\n    clus_diff_factor = 1.0 + 0.5 * (clustering - transitivity)\n\n    # 4. Assortativity multiplier – disassortative networks often have\n    #    longer paths, so we amplify the estimate with the absolute value.\n    assort_factor = 1.0 + abs(assortativity)\n\n    # 5. Triangle‑density adjustment – triangles create shortcuts.\n    tri_factor = np.sqrt(num_triangles / (n + 1e-12))\n\n    # Composite estimate: combine components multiplicatively and add a small\n    # correction that depends on triangle density and degree concentration.\n    estimate = (size_log_ratio * assort_factor * clus_diff_factor\n                + tri_factor * (1.0 - high_deg_ratio))\n\n    return float(estimate)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)", "spearman": 0.6451136278406961, "pearson": 0.620441981822184, "rmse": 2.005700275929157, "mae": 1.883622583515742}}
{"timestamp": "2026-02-16T13:07:40.130984+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 3, "population_idx": 3, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:08:09.966313+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:08:09.968121+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:08:42.530422+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.131466", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:08:42.531568+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 3, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:08:42.532483+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 1, "model_name": "gpt-oss:20b", "best_val_score": 0.43637600448446173, "no_improve_count": 0}}
{"timestamp": "2026-02-16T13:08:58.461644+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:08:58.462361+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:09:13.494103+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.045433", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:09:13.495123+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 0, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:10:04.853159+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.013493", "model_name": "gpt-oss:20b", "train_signal": 0.013493397358943579}}
{"timestamp": "2026-02-16T13:10:25.553331+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.293830", "model_name": "gpt-oss:20b", "train_signal": 0.29382953181272503}}
{"timestamp": "2026-02-16T13:11:04.491066+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:11:04.492015+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:11:24.708653+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.256855", "model_name": "gpt-oss:20b", "train_signal": 0.2568547418967587}}
{"timestamp": "2026-02-16T13:11:24.709632+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:11:54.387266+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.271261", "model_name": "gpt-oss:20b", "train_signal": 0.2712605042016807}}
{"timestamp": "2026-02-16T13:12:16.219571+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.121122", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:12:16.220118+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.121122", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:12:38.402519+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.131311", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:12:38.402807+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:12:53.765434+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:12:53.766124+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:13:14.523237+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.037655", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:13:14.523550+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:14:11.111353+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.041884", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:14:11.112037+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.041884", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:14:36.385907+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.244178", "model_name": "gpt-oss:20b", "train_signal": 0.24417767106842736}}
{"timestamp": "2026-02-16T13:14:36.386781+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:14:47.657243+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:14:47.657878+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:15:29.823444+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.068814", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:15:29.823941+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:16:20.052908+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.062874", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:16:20.053501+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.062874", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:16:37.054810+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:16:37.055493+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:17:15.319749+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:17:15.320762+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:17:43.886702+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.031037", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:17:43.887137+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 2, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:18:27.857977+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.054375", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:18:27.858587+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.054375", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:19:03.792562+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.244562", "model_name": "gpt-oss:20b", "train_signal": 0.24456182472989194}}
{"timestamp": "2026-02-16T13:19:03.793403+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:19:28.605628+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:19:28.606456+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:19:57.062504+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.026879", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:19:57.062835+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 2, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:20:45.637105+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.036552", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:20:45.637353+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.036552", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:21:09.357543+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.089971", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:21:09.357985+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 2, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:21:45.294916+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:21:45.295939+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:22:25.354966+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.032219", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:22:25.355634+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 2, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:22:59.071383+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i3_p0_830864120", "generation": 1, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5761824729891956, "fitness_mode": "correlation", "simplicity_score": 0.15784697605891346, "novelty_bonus": 0.26564102111961563, "total_score": 0.35556605915660766, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    A novel estimate for the average shortest‑path length based solely on\n    pre‑computed graph statistics.  The formula is a combination of:\n\n        • Graph size (sqrt(n))\n        • Degree heterogeneity (variance over mean degree)\n        • Sparsity (1 – density)\n        • Degree asymmetry (gap between the top and bottom 5 degrees)\n        • Clustering (sum of avg_clustering and transitivity)\n        • Assortativity adjustment (absolute value)\n        • Triangular motif penalty\n\n    All divisions are protected against zero by adding small constants.\n    \"\"\"\n    # Small epsilon to avoid division by zero\n    eps = 1e-6\n\n    # Basic statistics with safe fallbacks\n    n           = float(s.get('n', 0))\n    avg_deg     = max(float(s.get('avg_degree', 0)), 1.0)\n    std_deg     = float(s.get('std_degree', 0))\n    density     = float(s.get('density', 0))\n    max_deg     = max(float(s.get('max_degree', 0)), 1.0)\n    min_deg     = float(s.get('min_degree', 0)) + eps\n    tri_cnt     = float(s.get('num_triangles', 0))\n    degs        = list(s.get('degrees', []))\n\n    # Degree heterogeneity (variance/mean)\n    hetero = (std_deg ** 2) / avg_deg\n\n    # Sparsity factor\n    sparsity = 1.0 - density\n\n    # Degree gap between the 5 largest and 5 smallest degrees\n    k = min(5, len(degs))\n    if k == 0:\n        deg_gap = 1.0\n    else:\n        top_sum = sum(degs[-k:])\n        bottom_sum = sum(degs[:k])\n        deg_gap = (top_sum - bottom_sum) / max(top_sum, eps)\n\n    # Clustering penalty\n    clustering = max(float(s.get('avg_clustering', 0)), 0.0)\n    transi      = max(float(s.get('transitivity', 0)), 0.0)\n    cluster_pen = 1.0 + clustering + transi\n\n    # Assortativity adjustment\n    assort_adj = 1.0 + abs(float(s.get('degree_assortativity', 0)))\n\n    # Triangle penalty (dense triangles usually shorten paths)\n    tri_pen = 1.0 + tri_cnt / max(n, 1.0)\n\n    # Size scaling (sqrt(n))\n    size_scale = (n + 1) ** 0.5\n\n    # Assemble the invariant\n    inv = (size_scale *\n           hetero *\n           sparsity *\n           deg_gap) / (cluster_pen * assort_adj * tri_pen)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.226026\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.131466\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest path length from global graph statistics.\n    The expression mixes several graph‑theoretic features without using any\n    traversal algorithm.  All divisions are guarded by a tiny epsilon\n    to avoid division‑by‑zero errors.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n    \n    Returns\n    -------\n    float\n        A scalar that is expected to correlate with the average shortest\n        path length.  The combination uses multiplicative and additive\n        factors to introduce non‑linearity while staying purely\n        analytical.\n    \"\"\"\n    eps = 1e-6\n\n    # Basic statistics with safe fallbacks\n    n            = float(s.get('n', 0))\n    m            = float(s.get('m', 0))\n    avg_deg      = max(float(s.get('avg_degree', 0)), eps)\n    std_deg      = float(s.get('std_degree', 0))\n    avg_clus     = max(float(s.get('avg_clustering', 0)), 0.0)\n    trans        = max(float(s.get('transitivity', 0)), 0.0)\n    assort       = float(s.get('degree_assortativity', 0))\n    num_tri      = float(s.get('num_triangles', 0))\n\n    # 1. Size‑to‑edge baseline (node / edge ratio)\n    base_ratio = (n + 1.0) / (m + 1.0)\n\n    # 2. Degree heterogeneity factor (relative dispersion)\n    hetero_factor = (std_deg + eps) / (avg_deg + eps)\n\n    # 3. Clustering suppression factor\n    clustering_factor = 1.0 / (1.0 + avg_clus)\n\n    # 4. Transitivity suppression factor\n    transitivity_factor = 1.0 / (1.0 + trans)\n\n    # 5. Assortativity boost\n    assort_factor = 1.0 + abs(assort)\n\n    # 6. Triangle influence (denser triangles tend to shorten paths)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)\n\n    # Assemble the invariant multiplicatively\n    estimate = (\n        base_ratio\n        * hetero_factor\n        * clustering_factor\n        * transitivity_factor\n        * assort_factor\n        * tri_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest path length from global graph statistics.\n    The expression mixes several graph‑theoretic features without using any\n    traversal algorithm.  All divisions are guarded by a tiny epsilon\n    to avoid division‑by‑zero errors.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n    \n    Returns\n    -------\n    float\n        A scalar that is expected to correlate with the average shortest\n        path length.  The combination uses multiplicative and additive\n        factors to introduce non‑linearity while staying purely\n        analytical.\n    \"\"\"\n    eps = 1e-6\n\n    # Basic statistics with safe fallbacks\n    n            = float(s.get('n', 0))\n    m            = float(s.get('m', 0))\n    avg_deg      = max(float(s.get('avg_degree', 0)), eps)\n    std_deg      = float(s.get('std_degree', 0))\n    avg_clus     = max(float(s.get('avg_clustering', 0)), 0.0)\n    trans        = max(float(s.get('transitivity', 0)), 0.0)\n    assort       = float(s.get('degree_assortativity', 0))\n    num_tri      = float(s.get('num_triangles', 0))\n\n    # 1. Size‑to‑edge baseline (node / edge ratio)\n    base_ratio = (n + 1.0) / (m + 1.0)\n\n    # 2. Degree heterogeneity factor (relative dispersion)\n    hetero_factor = (std_deg + eps) / (avg_deg + eps)\n\n    # 3. Clustering suppression factor\n    clustering_factor = 1.0 / (1.0 + avg_clus)\n\n    # 4. Transitivity suppression factor\n    transitivity_factor = 1.0 / (1.0 + trans)\n\n    # 5. Assortativity boost\n    assort_factor = 1.0 + abs(assort)\n\n    # 6. Triangle influence (denser triangles tend to shorten paths)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)\n\n    # Assemble the invariant multiplicatively\n    estimate = (\n        base_ratio\n        * hetero_factor\n        * clustering_factor\n        * transitivity_factor\n        * assort_factor\n        * tri_factor\n    )\n\n    return float(estimate)", "spearman": 0.4886087152178805, "pearson": 0.44580783579213035, "rmse": 2.5074417782884644, "mae": 2.3868312862557057}}
{"timestamp": "2026-02-16T13:23:37.695927+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.095008", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:23:37.696547+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.095008", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:24:12.357741+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:24:12.358734+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 3, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:25:07.238437+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.270780", "model_name": "gpt-oss:20b", "train_signal": 0.27078031212484993}}
{"timestamp": "2026-02-16T13:25:40.494259+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.037175", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:25:40.494580+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.037175", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:26:21.266841+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:26:21.267431+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 3, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:26:43.315825+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.068478", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:26:43.316413+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.068478", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:27:35.806966+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "runtime_exception: AttributeError: 'float' object has no attribute 'bit_length'", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:27:35.807662+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 3, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:27:35.809224+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 2, "model_name": "gpt-oss:20b", "best_val_score": 0.43637600448446173, "no_improve_count": 1}}
{"timestamp": "2026-02-16T13:28:58.367982+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.214886", "model_name": "gpt-oss:20b", "train_signal": 0.21488595438175268}}
{"timestamp": "2026-02-16T13:29:41.752510+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:29:41.753407+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:31:32.934510+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.058773", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:31:32.935110+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:31:54.256644+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.032893", "model_name": "gpt-oss:20b", "train_signal": 0.03289315726290516}}
{"timestamp": "2026-02-16T13:32:14.141255+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i0_p3_908103774", "generation": 2, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.6351500600240095, "fitness_mode": "correlation", "simplicity_score": 0.22899240535792836, "novelty_bonus": 0.20328796052803788, "total_score": 0.4601644537196093, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    # Basic estimate: sqrt(n) divided by sqrt of average degree (avoid division by zero)\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n    # Increase estimate when clustering is high (small‑world effect)\n    base *= (1 + clustering)\n    # Reduce estimate when graph is highly assortative\n    base /= (1 + abs(assort))\n    # Add a small adjustment based on the number of triangles\n    base += triangles / (n**2 + 1)\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.058773\nbelow_train_threshold: train_signal=0.032893\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base", "spearman": 0.7067591689792245, "pearson": 0.6283045230984865, "rmse": 0.6828356497199517, "mae": 0.44360983544314186}}
{"timestamp": "2026-02-16T13:33:12.801988+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i0_p4_299957175", "generation": 2, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5891476590636254, "fitness_mode": "correlation", "simplicity_score": 0.2231526783758297, "novelty_bonus": 0.39878782084007913, "total_score": 0.44083479612504467, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    # Basic estimate: sqrt(n) divided by sqrt of average degree (avoid division by zero)\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n    # Increase estimate when clustering is high (small‑world effect)\n    base *= (1 + clustering)\n    # Reduce estimate when graph is highly assortative\n    base /= (1 + abs(assort))\n    # Add a small adjustment based on the number of triangles\n    base += triangles / (n**2 + 1)\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.058773\nbelow_train_threshold: train_signal=0.032893\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    trans = s['transitivity']\n\n    # Base estimate based on size and average degree\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Adjust for density and maximum degree (high density or hubs reduce path length)\n    base /= (1 + density)\n    base /= (1 + max_deg / n)\n\n    # Adjust for minimum degree and degree dispersion (low min degree or high variance increase path length)\n    if avg_deg > 0:\n        min_factor = 1 + (1 - min_deg / avg_deg)\n        std_factor = 1 + std_deg / avg_deg\n    else:\n        min_factor = 1\n        std_factor = 1\n    base *= min_factor\n    base *= std_factor\n\n    # Adjust for clustering and transitivity (high clustering reduces path length)\n    base *= (1 + (clustering + trans) / 2)\n\n    # Adjust for assortativity (high assortativity tends to increase path length)\n    base /= (1 + abs(assort)**0.5)\n\n    # Small additive term for the number of triangles\n    base += triangles / (n**1.5 + 1)\n\n    return base", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    trans = s['transitivity']\n\n    # Base estimate based on size and average degree\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Adjust for density and maximum degree (high density or hubs reduce path length)\n    base /= (1 + density)\n    base /= (1 + max_deg / n)\n\n    # Adjust for minimum degree and degree dispersion (low min degree or high variance increase path length)\n    if avg_deg > 0:\n        min_factor = 1 + (1 - min_deg / avg_deg)\n        std_factor = 1 + std_deg / avg_deg\n    else:\n        min_factor = 1\n        std_factor = 1\n    base *= min_factor\n    base *= std_factor\n\n    # Adjust for clustering and transitivity (high clustering reduces path length)\n    base *= (1 + (clustering + trans) / 2)\n\n    # Adjust for assortativity (high assortativity tends to increase path length)\n    base /= (1 + abs(assort)**0.5)\n\n    # Small additive term for the number of triangles\n    base += triangles / (n**1.5 + 1)\n\n    return base", "spearman": 0.55313582839571, "pearson": 0.5068573273167236, "rmse": 3.0941295788577663, "mae": 2.708871098053172}}
{"timestamp": "2026-02-16T13:33:35.837733+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.144258", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:33:35.838246+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.144258", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:34:01.692826+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i1_p0_254249553", "generation": 2, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.6989195678271308, "fitness_mode": "correlation", "simplicity_score": 0.1470171400981797, "novelty_bonus": 0.21751044906022476, "total_score": 0.38950693399698494, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\nNone yet.\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.068814\nbelow_novelty_threshold: novelty_bonus=0.062874\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.144258\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    # Basic components\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_clust = 1 + avg_clustering\n    denom_deg = max_degree + 1\n\n    # Combine the strengths of the top two formulas:\n    #   1. n/(m+1)  – captures sparsity\n    #   2. sqrt(n)/(1+avg_clustering) – captures size and clustering\n    #   3. avg_degree/(max_degree+1) – captures degree distribution\n    part1 = n / denom_m\n    part2 = n ** 0.5 / denom_clust\n    part3 = avg_degree / denom_deg\n\n    return part1 * part2 * part3\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    # Extract basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n\n    # Optional features that may be missing in some datasets\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Basic building blocks (avoid division by zero)\n    part1 = n / (m + 1)                     # captures sparsity\n    part2 = n ** 0.5 / (1 + avg_clustering) # captures size & clustering\n    part3 = avg_degree / (max_degree + 1)   # captures degree spread\n\n    # Incorporate higher‑order structure\n    part4 = 1 + degree_assortativity        # shift to keep positive\n    part5 = 1 + transitivity                # shift to keep positive\n\n    # Combine all components multiplicatively\n    return part1 * part2 * part3 * part4 * part5\n```", "extracted_code": "def new_invariant(s):\n    # Extract basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n\n    # Optional features that may be missing in some datasets\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Basic building blocks (avoid division by zero)\n    part1 = n / (m + 1)                     # captures sparsity\n    part2 = n ** 0.5 / (1 + avg_clustering) # captures size & clustering\n    part3 = avg_degree / (max_degree + 1)   # captures degree spread\n\n    # Incorporate higher‑order structure\n    part4 = 1 + degree_assortativity        # shift to keep positive\n    part5 = 1 + transitivity                # shift to keep positive\n\n    # Combine all components multiplicatively\n    return part1 * part2 * part3 * part4 * part5", "spearman": 0.5897007425185631, "pearson": 0.5162941536710095, "rmse": 1.7881957365537857, "mae": 1.630152838401814}}
{"timestamp": "2026-02-16T13:34:01.693354+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 1, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:35:09.926675+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.128445", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:35:09.927152+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.128445", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:35:45.855296+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i1_p1_530402172", "generation": 2, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8479711884753901, "fitness_mode": "correlation", "simplicity_score": 0.12218335304251024, "novelty_bonus": 0.21257526541872818, "total_score": 0.5174022300586162, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\nNone yet.\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.062874\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.144258\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.128445\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    # Extract useful features\n    n = s['n']\n    m = s['m']\n    avg_clust = s['avg_clustering']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n\n    # Compute auxiliary ratios\n    tri_ratio = num_tri / (m + 1)          # triangles per edge (avoids division by zero)\n    deg_variance = std_deg ** 2           # variance of degrees\n\n    # Composite invariant combining multiple aspects\n    return (n / (m + 1)) * (1 + avg_clust) * (1 + abs(assort)) * (1 + tri_ratio) / (1 + deg_variance)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )", "spearman": 0.8583859596489914, "pearson": 0.8350082292035506, "rmse": 228.00928826985196, "mae": 157.91698757107602}}
{"timestamp": "2026-02-16T13:35:45.856398+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 1, "population_idx": 1, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:36:14.692247+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.290276", "model_name": "gpt-oss:20b", "train_signal": 0.29027611044417767}}
{"timestamp": "2026-02-16T13:36:34.265057+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:36:34.265364+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:37:36.247402+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.060716", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:37:36.247892+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 1, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:38:00.236929+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.137575", "model_name": "gpt-oss:20b", "train_signal": 0.13757503001200477}}
{"timestamp": "2026-02-16T13:38:48.382897+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.027979", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:38:48.383404+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.027979", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:39:17.594359+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.021345", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:39:17.594783+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 2, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:39:45.227286+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:39:45.228000+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:40:03.180864+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:40:03.181515+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:40:39.379174+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.029775", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:40:39.379825+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.029775", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:41:00.320110+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.061617", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:41:00.320588+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 2, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:41:38.332174+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:41:38.332856+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:41:56.097941+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.037428", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:41:56.098322+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 2, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:42:24.073319+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:42:24.074445+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:42:54.923343+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.125176", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:42:54.924224+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 2, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:44:03.055957+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: non-whitelisted call detected: isinstance", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:44:03.057177+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: non-whitelisted call detected: isinstance", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:44:36.819354+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i3_p0_588781270", "generation": 2, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5795438175270108, "fitness_mode": "correlation", "simplicity_score": 0.15347854925790205, "novelty_bonus": 0.3012191971386249, "total_score": 0.35016519658635775, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest path length from global graph statistics.\n    The expression mixes several graph‑theoretic features without using any\n    traversal algorithm.  All divisions are guarded by a tiny epsilon\n    to avoid division‑by‑zero errors.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n    \n    Returns\n    -------\n    float\n        A scalar that is expected to correlate with the average shortest\n        path length.  The combination uses multiplicative and additive\n        factors to introduce non‑linearity while staying purely\n        analytical.\n    \"\"\"\n    eps = 1e-6\n\n    # Basic statistics with safe fallbacks\n    n            = float(s.get('n', 0))\n    m            = float(s.get('m', 0))\n    avg_deg      = max(float(s.get('avg_degree', 0)), eps)\n    std_deg      = float(s.get('std_degree', 0))\n    avg_clus     = max(float(s.get('avg_clustering', 0)), 0.0)\n    trans        = max(float(s.get('transitivity', 0)), 0.0)\n    assort       = float(s.get('degree_assortativity', 0))\n    num_tri      = float(s.get('num_triangles', 0))\n\n    # 1. Size‑to‑edge baseline (node / edge ratio)\n    base_ratio = (n + 1.0) / (m + 1.0)\n\n    # 2. Degree heterogeneity factor (relative dispersion)\n    hetero_factor = (std_deg + eps) / (avg_deg + eps)\n\n    # 3. Clustering suppression factor\n    clustering_factor = 1.0 / (1.0 + avg_clus)\n\n    # 4. Transitivity suppression factor\n    transitivity_factor = 1.0 / (1.0 + trans)\n\n    # 5. Assortativity boost\n    assort_factor = 1.0 + abs(assort)\n\n    # 6. Triangle influence (denser triangles tend to shorten paths)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)\n\n    # Assemble the invariant multiplicatively\n    estimate = (\n        base_ratio\n        * hetero_factor\n        * clustering_factor\n        * transitivity_factor\n        * assort_factor\n        * tri_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.068478\nno_valid_train_predictions: runtime_exception: AttributeError: 'float' object has no attribute 'bit_length'\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: non-whitelisted call detected: isinstance\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only global graph\n    statistics.  The formula mixes multiplicative and additive terms that\n    capture sparsity, degree heterogeneity, clustering, assortativity,\n    triangle density, and concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        An invariant intended to correlate with the average shortest path length.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 1. Basic values with float conversion and safe defaults\n    # ------------------------------------------------------------------\n    n               = float(s.get('n', 0))\n    m               = float(s.get('m', 0))\n    density         = float(s.get('density', 0))\n    avg_degree      = float(s.get('avg_degree', 0))\n    max_degree      = float(s.get('max_degree', 0))\n    min_degree      = float(s.get('min_degree', 0))\n    std_degree      = float(s.get('std_degree', 0))\n    avg_clustering  = float(s.get('avg_clustering', 0))\n    transitivity    = float(s.get('transitivity', 0))\n    assortativity   = float(s.get('degree_assortativity', 0))\n    num_triangles   = float(s.get('num_triangles', 0))\n    degrees         = s.get('degrees', [])\n    degrees = sorted(degrees) if isinstance(degrees, list) else []\n\n    eps = 1e-6  # guard against division by zero\n\n    # ------------------------------------------------------------------\n    # 2. Core multiplicative components\n    # ------------------------------------------------------------------\n    # Base sparsity factor: node/edge ratio (shifted by 1)\n    base = (n + 1.0) / (m + 1.0)\n\n    # Heterogeneity: dispersion relative to mean\n    hetero = (std_degree + eps) / (avg_degree + eps)\n\n    # Density boost (denser graphs usually have shorter paths)\n    dens_factor = 1.0 + density\n\n    # Clustering suppression: higher clustering often lengthens paths\n    cluster_factor = 1.0 / (1.0 + avg_clustering)\n\n    # Transitivity suppression: same rationale as clustering\n    trans_factor = 1.0 / (1.0 + transitivity)\n\n    # Assortativity boost: assortative mixing can reduce distances\n    assort_factor = 1.0 + abs(assortativity)\n\n    # Triangle influence: more triangles usually shorten distances\n    tri_factor = 1.0 + (num_triangles ** 0.5) / (n ** 0.5 + eps)\n\n    # ------------------------------------------------------------------\n    # 3. High‑degree concentration factor\n    # ------------------------------------------------------------------\n    top_k = max(1, int(0.05 * n))                    # top 5 %\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2.0 * m if m > 0 else eps\n    high_deg_ratio = high_deg_sum / (total_deg + eps)\n    top_factor = 1.0 + high_deg_ratio\n\n    # ------------------------------------------------------------------\n    # 4. Median degree influence\n    # ------------------------------------------------------------------\n    if degrees:\n        median = degrees[int(len(degrees) / 2)]\n        median_factor = 1.0 + median / (max_degree + eps)\n    else:\n        median_factor = 1.0\n\n    # ------------------------------------------------------------------\n    # 5. Combine all factors\n    # ------------------------------------------------------------------\n    estimate = (\n        base *\n        hetero *\n        dens_factor *\n        cluster_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        top_factor *\n        median_factor\n    )\n\n    return float(estimate)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph\n    statistics.  The expression mixes multiplicative and additive terms\n    that capture sparsity, degree heterogeneity, clustering, assortativity,\n    triangle density and concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics.  Expected keys are:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        An invariant intended to correlate with the average shortest path\n        length.\n    \"\"\"\n    # ---------- basic values ----------\n    n               = float(s.get('n', 0))\n    m               = float(s.get('m', 0))\n    density         = float(s.get('density', 0))\n    avg_degree      = float(s.get('avg_degree', 0))\n    max_degree      = float(s.get('max_degree', 0))\n    min_degree      = float(s.get('min_degree', 0))\n    std_degree      = float(s.get('std_degree', 0))\n    avg_clustering  = float(s.get('avg_clustering', 0))\n    transitivity    = float(s.get('transitivity', 0))\n    assortativity   = float(s.get('degree_assortativity', 0))\n    num_triangles   = float(s.get('num_triangles', 0))\n    degrees         = s.get('degrees', [])\n\n    eps = 1e-6  # small constant to avoid division by zero\n\n    # ---------- core multiplicative components ----------\n    base = (n + 1.0) / (m + 1.0)                     # node/edge ratio\n    hetero = (std_degree + eps) / (avg_degree + eps) # degree dispersion\n    dens_factor = 1.0 + density\n    cluster_factor = 1.0 / (1.0 + avg_clustering)     # higher clustering → longer paths\n    trans_factor = 1.0 / (1.0 + transitivity)         # same rationale\n    assort_factor = 1.0 + abs(assortativity)\n    tri_factor = 1.0 + (num_triangles ** 0.5) / (n ** 0.5 + eps)\n\n    # ---------- high‑degree concentration ----------\n    top_k = max(1, int(0.05 * n))                     # top 5 % nodes\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2.0 * m if m > 0 else eps\n    high_deg_ratio = high_deg_sum / (total_deg + eps)\n    top_factor = 1.0 + high_deg_ratio\n\n    # ---------- median degree influence ----------\n    if degrees:\n        median = degrees[int(len(degrees) / 2)]\n        median_factor = 1.0 + median / (max_degree + eps)\n    else:\n        median_factor = 1.0\n\n    # ---------- combine all factors ----------\n    estimate = (\n        base *\n        hetero *\n        dens_factor *\n        cluster_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        top_factor *\n        median_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph\n    statistics.  The expression mixes multiplicative and additive terms\n    that capture sparsity, degree heterogeneity, clustering, assortativity,\n    triangle density and concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics.  Expected keys are:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        An invariant intended to correlate with the average shortest path\n        length.\n    \"\"\"\n    # ---------- basic values ----------\n    n               = float(s.get('n', 0))\n    m               = float(s.get('m', 0))\n    density         = float(s.get('density', 0))\n    avg_degree      = float(s.get('avg_degree', 0))\n    max_degree      = float(s.get('max_degree', 0))\n    min_degree      = float(s.get('min_degree', 0))\n    std_degree      = float(s.get('std_degree', 0))\n    avg_clustering  = float(s.get('avg_clustering', 0))\n    transitivity    = float(s.get('transitivity', 0))\n    assortativity   = float(s.get('degree_assortativity', 0))\n    num_triangles   = float(s.get('num_triangles', 0))\n    degrees         = s.get('degrees', [])\n\n    eps = 1e-6  # small constant to avoid division by zero\n\n    # ---------- core multiplicative components ----------\n    base = (n + 1.0) / (m + 1.0)                     # node/edge ratio\n    hetero = (std_degree + eps) / (avg_degree + eps) # degree dispersion\n    dens_factor = 1.0 + density\n    cluster_factor = 1.0 / (1.0 + avg_clustering)     # higher clustering → longer paths\n    trans_factor = 1.0 / (1.0 + transitivity)         # same rationale\n    assort_factor = 1.0 + abs(assortativity)\n    tri_factor = 1.0 + (num_triangles ** 0.5) / (n ** 0.5 + eps)\n\n    # ---------- high‑degree concentration ----------\n    top_k = max(1, int(0.05 * n))                     # top 5 % nodes\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2.0 * m if m > 0 else eps\n    high_deg_ratio = high_deg_sum / (total_deg + eps)\n    top_factor = 1.0 + high_deg_ratio\n\n    # ---------- median degree influence ----------\n    if degrees:\n        median = degrees[int(len(degrees) / 2)]\n        median_factor = 1.0 + median / (max_degree + eps)\n    else:\n        median_factor = 1.0\n\n    # ---------- combine all factors ----------\n    estimate = (\n        base *\n        hetero *\n        dens_factor *\n        cluster_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        top_factor *\n        median_factor\n    )\n\n    return float(estimate)", "spearman": 0.45820745518637973, "pearson": 0.36987177203208355, "rmse": 2.3518729143355066, "mae": 2.2290234474235415}}
{"timestamp": "2026-02-16T13:44:36.820316+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 3, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:45:19.726426+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i3_p1_252218501", "generation": 2, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.35971188475390153, "fitness_mode": "correlation", "simplicity_score": 0.15563911672477482, "novelty_bonus": 0.5658839132977601, "total_score": 0.3691072026894169, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest path length from global graph statistics.\n    The expression mixes several graph‑theoretic features without using any\n    traversal algorithm.  All divisions are guarded by a tiny epsilon\n    to avoid division‑by‑zero errors.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n    \n    Returns\n    -------\n    float\n        A scalar that is expected to correlate with the average shortest\n        path length.  The combination uses multiplicative and additive\n        factors to introduce non‑linearity while staying purely\n        analytical.\n    \"\"\"\n    eps = 1e-6\n\n    # Basic statistics with safe fallbacks\n    n            = float(s.get('n', 0))\n    m            = float(s.get('m', 0))\n    avg_deg      = max(float(s.get('avg_degree', 0)), eps)\n    std_deg      = float(s.get('std_degree', 0))\n    avg_clus     = max(float(s.get('avg_clustering', 0)), 0.0)\n    trans        = max(float(s.get('transitivity', 0)), 0.0)\n    assort       = float(s.get('degree_assortativity', 0))\n    num_tri      = float(s.get('num_triangles', 0))\n\n    # 1. Size‑to‑edge baseline (node / edge ratio)\n    base_ratio = (n + 1.0) / (m + 1.0)\n\n    # 2. Degree heterogeneity factor (relative dispersion)\n    hetero_factor = (std_deg + eps) / (avg_deg + eps)\n\n    # 3. Clustering suppression factor\n    clustering_factor = 1.0 / (1.0 + avg_clus)\n\n    # 4. Transitivity suppression factor\n    transitivity_factor = 1.0 / (1.0 + trans)\n\n    # 5. Assortativity boost\n    assort_factor = 1.0 + abs(assort)\n\n    # 6. Triangle influence (denser triangles tend to shorten paths)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)\n\n    # Assemble the invariant multiplicatively\n    estimate = (\n        base_ratio\n        * hetero_factor\n        * clustering_factor\n        * transitivity_factor\n        * assort_factor\n        * tri_factor\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.068478\nno_valid_train_predictions: runtime_exception: AttributeError: 'float' object has no attribute 'bit_length'\nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimator for the average shortest‑path length that relies solely on\n    pre‑computed global statistics.  The formula is a mixture of\n    multiplicative and divisive factors that encode density, degree\n    heterogeneity, clustering, transitivity, assortativity, and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the following keys:\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity,\n        num_triangles, degrees (sorted degree list).\n\n    Returns\n    -------\n    float\n        An invariant that is expected to correlate with the graph’s\n        average shortest‑path length.\n    \"\"\"\n    # --- Safely extract features with defaults -------------------------------------------------\n    n                = float(s.get('n', 1))\n    m                = float(s.get('m', 0))\n    density          = float(s.get('density', 0.0))\n    avg_degree       = float(s.get('avg_degree', 0.0))\n    max_degree       = float(s.get('max_degree', 0))\n    min_degree       = float(s.get('min_degree', 1))\n    std_degree       = float(s.get('std_degree', 0.0))\n    avg_clustering   = float(s.get('avg_clustering', 0.0))\n    transitivity     = float(s.get('transitivity', 0.0))\n    assortativity    = float(s.get('degree_assortativity', 0.0))\n    num_triangles    = float(s.get('num_triangles', 0))\n\n    eps = 1e-6  # small number to avoid division by zero\n\n    # --- Base factor ---------------------------------------------------------------\n    base = n / (m + 1.0)\n\n    # --- Density factor -------------------------------------------------------------\n    density_factor = 1.0 / (1.0 + density)\n\n    # --- Degree‑related factors ------------------------------------------------------\n    degree_factor = (1.0 + avg_degree) ** 0.5\n    deg_ratio      = (max_degree + 1) / (min_degree + 1)\n\n    # --- Clustering / transitivity / assortativity ---------------------------------\n    cluster_factor = 1.0 / (1.0 + avg_clustering)\n    trans_factor   = 1.0 + transitivity\n    assort_factor  = 1.0 + abs(assortativity)\n\n    # --- Triangle influence ---------------------------------------------------------\n    tri_factor = 1.0 + (num_triangles ** 0.5) / (n ** 0.5 + eps)\n\n    # --- Degree heterogeneity -------------------------------------------------------\n    hetero_factor = max(std_degree, eps) / max(avg_degree, eps)\n\n    # --- Combine all factors ---------------------------------------------------------\n    estimate = (base * density_factor * degree_factor * deg_ratio *\n                cluster_factor * trans_factor * assort_factor *\n                tri_factor * hetero_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimator for the average shortest‑path length that relies solely on\n    pre‑computed global statistics.  The formula is a mixture of\n    multiplicative and divisive factors that encode density, degree\n    heterogeneity, clustering, transitivity, assortativity, and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the following keys:\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity,\n        num_triangles, degrees (sorted degree list).\n\n    Returns\n    -------\n    float\n        An invariant that is expected to correlate with the graph’s\n        average shortest‑path length.\n    \"\"\"\n    # --- Safely extract features with defaults -------------------------------------------------\n    n                = float(s.get('n', 1))\n    m                = float(s.get('m', 0))\n    density          = float(s.get('density', 0.0))\n    avg_degree       = float(s.get('avg_degree', 0.0))\n    max_degree       = float(s.get('max_degree', 0))\n    min_degree       = float(s.get('min_degree', 1))\n    std_degree       = float(s.get('std_degree', 0.0))\n    avg_clustering   = float(s.get('avg_clustering', 0.0))\n    transitivity     = float(s.get('transitivity', 0.0))\n    assortativity    = float(s.get('degree_assortativity', 0.0))\n    num_triangles    = float(s.get('num_triangles', 0))\n\n    eps = 1e-6  # small number to avoid division by zero\n\n    # --- Base factor ---------------------------------------------------------------\n    base = n / (m + 1.0)\n\n    # --- Density factor -------------------------------------------------------------\n    density_factor = 1.0 / (1.0 + density)\n\n    # --- Degree‑related factors ------------------------------------------------------\n    degree_factor = (1.0 + avg_degree) ** 0.5\n    deg_ratio      = (max_degree + 1) / (min_degree + 1)\n\n    # --- Clustering / transitivity / assortativity ---------------------------------\n    cluster_factor = 1.0 / (1.0 + avg_clustering)\n    trans_factor   = 1.0 + transitivity\n    assort_factor  = 1.0 + abs(assortativity)\n\n    # --- Triangle influence ---------------------------------------------------------\n    tri_factor = 1.0 + (num_triangles ** 0.5) / (n ** 0.5 + eps)\n\n    # --- Degree heterogeneity -------------------------------------------------------\n    hetero_factor = max(std_degree, eps) / max(avg_degree, eps)\n\n    # --- Combine all factors ---------------------------------------------------------\n    estimate = (base * density_factor * degree_factor * deg_ratio *\n                cluster_factor * trans_factor * assort_factor *\n                tri_factor * hetero_factor)\n\n    return float(estimate)", "spearman": 0.3364284107102678, "pearson": 0.413546373848791, "rmse": 5.62925662857027, "mae": 3.087514987054652}}
{"timestamp": "2026-02-16T13:45:43.704571+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:45:43.705151+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:46:05.482751+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i3_p2_359123320", "generation": 2, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5761824729891956, "fitness_mode": "correlation", "simplicity_score": 0.15834379502348617, "novelty_bonus": 0.26564102111961563, "total_score": 0.3556654229495222, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest path length from global graph statistics.\n    The expression mixes several graph‑theoretic features without using any\n    traversal algorithm.  All divisions are guarded by a tiny epsilon\n    to avoid division‑by‑zero errors.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n    \n    Returns\n    -------\n    float\n        A scalar that is expected to correlate with the average shortest\n        path length.  The combination uses multiplicative and additive\n        factors to introduce non‑linearity while staying purely\n        analytical.\n    \"\"\"\n    eps = 1e-6\n\n    # Basic statistics with safe fallbacks\n    n            = float(s.get('n', 0))\n    m            = float(s.get('m', 0))\n    avg_deg      = max(float(s.get('avg_degree', 0)), eps)\n    std_deg      = float(s.get('std_degree', 0))\n    avg_clus     = max(float(s.get('avg_clustering', 0)), 0.0)\n    trans        = max(float(s.get('transitivity', 0)), 0.0)\n    assort       = float(s.get('degree_assortativity', 0))\n    num_tri      = float(s.get('num_triangles', 0))\n\n    # 1. Size‑to‑edge baseline (node / edge ratio)\n    base_ratio = (n + 1.0) / (m + 1.0)\n\n    # 2. Degree heterogeneity factor (relative dispersion)\n    hetero_factor = (std_deg + eps) / (avg_deg + eps)\n\n    # 3. Clustering suppression factor\n    clustering_factor = 1.0 / (1.0 + avg_clus)\n\n    # 4. Transitivity suppression factor\n    transitivity_factor = 1.0 / (1.0 + trans)\n\n    # 5. Assortativity boost\n    assort_factor = 1.0 + abs(assort)\n\n    # 6. Triangle influence (denser triangles tend to shorten paths)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)\n\n    # Assemble the invariant multiplicatively\n    estimate = (\n        base_ratio\n        * hetero_factor\n        * clustering_factor\n        * transitivity_factor\n        * assort_factor\n        * tri_factor\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.068478\nno_valid_train_predictions: runtime_exception: AttributeError: 'float' object has no attribute 'bit_length'\nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport math\n\ndef new_invariant(s: dict) -> float:\n    \"\"\"\n    Estimator for the average shortest‑path length that uses only\n    pre‑computed global statistics.  No traversal is performed, and\n    only safe built‑in math operations are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with pre‑computed statistics.  Keys that may be used\n        include:\n          - n, m              # node and edge counts\n          - density, avg_degree, max_degree, min_degree, std_degree\n          - avg_clustering, transitivity\n          - degree_assortativity\n          - num_triangles\n          - degrees            # sorted degree list (not directly used here)\n\n    Returns\n    -------\n    float\n        A scalar that is intended to correlate with the network's\n        average shortest‑path length.\n    \"\"\"\n    # --- Safety defaults ----------------------------------------------------\n    n   = float(s.get('n', 0))\n    m   = float(s.get('m', 0))\n    avg = float(s.get('avg_degree', 0))\n    std = float(s.get('std_degree', 0))\n    clus = float(s.get('avg_clustering', 0))\n    trans = float(s.get('transitivity', 0))\n    assort = float(s.get('degree_assortativity', 0))\n    tri   = float(s.get('num_triangles', 0))\n\n    # guard against division by zero\n    eps = 1e-12\n\n    # --- Core components ----------------------------------------------------\n    # 1. Node/edge baseline\n    base = (n + 1.0) / (m + 1.0)\n\n    # 2. Degree heterogeneity (relative dispersion)\n    hetero = (std + eps) / (avg + eps)\n\n    # 3. Clustering suppression\n    cluster_factor = 1.0 / (1.0 + clus)\n\n    # 4. Transitivity suppression\n    trans_factor = 1.0 / (1.0 + trans)\n\n    # 5. Assortativity boost\n    assort_factor = 1.0 + abs(assort)\n\n    # 6. Triangle influence (denser triangles tend to shorten paths)\n    tri_factor = 1.0 + math.sqrt(tri) / (math.sqrt(n) + eps)\n\n    # --- Assemble ------------------------------------------------------------------\n    estimate = (\n        base *\n        hetero *\n        cluster_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor\n    )\n\n    return float(estimate)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from pre‑computed global graph\n    statistics.  No graph traversal is performed and only built‑in arithmetic\n    operations are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed statistics.  Accepted keys are:\n        n, m, avg_degree, std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles.\n\n    Returns\n    -------\n    float\n        A scalar that is intended to correlate with the network's\n        average shortest‑path length.\n    \"\"\"\n    # Safe defaults\n    n = float(s.get('n', 0))\n    m = float(s.get('m', 0))\n    avg = float(s.get('avg_degree', 0))\n    std = float(s.get('std_degree', 0))\n    clus = float(s.get('avg_clustering', 0))\n    trans = float(s.get('transitivity', 0))\n    assort = float(s.get('degree_assortativity', 0))\n    tri = float(s.get('num_triangles', 0))\n\n    eps = 1e-12  # small constant to avoid division by zero\n\n    # Node/edge baseline\n    base = (n + 1.0) / (m + 1.0)\n\n    # Degree heterogeneity (relative dispersion)\n    hetero = (std + eps) / (avg + eps)\n\n    # Clustering suppression\n    cluster_factor = 1.0 / (1.0 + clus)\n\n    # Transitivity suppression\n    trans_factor = 1.0 / (1.0 + trans)\n\n    # Assortativity boost\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle influence (triangles tend to shorten paths)\n    tri_factor = 1.0 + (tri ** 0.5) / ((n ** 0.5) + eps)\n\n    # Combine all components multiplicatively\n    estimate = (\n        base *\n        hetero *\n        cluster_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor\n    )\n\n    return float(estimate)", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from pre‑computed global graph\n    statistics.  No graph traversal is performed and only built‑in arithmetic\n    operations are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed statistics.  Accepted keys are:\n        n, m, avg_degree, std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles.\n\n    Returns\n    -------\n    float\n        A scalar that is intended to correlate with the network's\n        average shortest‑path length.\n    \"\"\"\n    # Safe defaults\n    n = float(s.get('n', 0))\n    m = float(s.get('m', 0))\n    avg = float(s.get('avg_degree', 0))\n    std = float(s.get('std_degree', 0))\n    clus = float(s.get('avg_clustering', 0))\n    trans = float(s.get('transitivity', 0))\n    assort = float(s.get('degree_assortativity', 0))\n    tri = float(s.get('num_triangles', 0))\n\n    eps = 1e-12  # small constant to avoid division by zero\n\n    # Node/edge baseline\n    base = (n + 1.0) / (m + 1.0)\n\n    # Degree heterogeneity (relative dispersion)\n    hetero = (std + eps) / (avg + eps)\n\n    # Clustering suppression\n    cluster_factor = 1.0 / (1.0 + clus)\n\n    # Transitivity suppression\n    trans_factor = 1.0 / (1.0 + trans)\n\n    # Assortativity boost\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle influence (triangles tend to shorten paths)\n    tri_factor = 1.0 + (tri ** 0.5) / ((n ** 0.5) + eps)\n\n    # Combine all components multiplicatively\n    estimate = (\n        base *\n        hetero *\n        cluster_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor\n    )\n\n    return float(estimate)", "spearman": 0.4886087152178805, "pearson": 0.44580780264226705, "rmse": 2.5074418111660917, "mae": 2.386831316688204}}
{"timestamp": "2026-02-16T13:46:05.483553+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 3, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:46:36.708611+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: disallowed syntax: Lambda", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:46:36.709859+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: disallowed syntax: Lambda", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:47:05.099277+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:47:05.100117+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 3, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:47:30.886293+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i3_p4_927237731", "generation": 2, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5761824729891956, "fitness_mode": "correlation", "simplicity_score": 0.15834379502348617, "novelty_bonus": 0.26564102111961563, "total_score": 0.3556654229495222, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest path length from global graph statistics.\n    The expression mixes several graph‑theoretic features without using any\n    traversal algorithm.  All divisions are guarded by a tiny epsilon\n    to avoid division‑by‑zero errors.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n    \n    Returns\n    -------\n    float\n        A scalar that is expected to correlate with the average shortest\n        path length.  The combination uses multiplicative and additive\n        factors to introduce non‑linearity while staying purely\n        analytical.\n    \"\"\"\n    eps = 1e-6\n\n    # Basic statistics with safe fallbacks\n    n            = float(s.get('n', 0))\n    m            = float(s.get('m', 0))\n    avg_deg      = max(float(s.get('avg_degree', 0)), eps)\n    std_deg      = float(s.get('std_degree', 0))\n    avg_clus     = max(float(s.get('avg_clustering', 0)), 0.0)\n    trans        = max(float(s.get('transitivity', 0)), 0.0)\n    assort       = float(s.get('degree_assortativity', 0))\n    num_tri      = float(s.get('num_triangles', 0))\n\n    # 1. Size‑to‑edge baseline (node / edge ratio)\n    base_ratio = (n + 1.0) / (m + 1.0)\n\n    # 2. Degree heterogeneity factor (relative dispersion)\n    hetero_factor = (std_deg + eps) / (avg_deg + eps)\n\n    # 3. Clustering suppression factor\n    clustering_factor = 1.0 / (1.0 + avg_clus)\n\n    # 4. Transitivity suppression factor\n    transitivity_factor = 1.0 / (1.0 + trans)\n\n    # 5. Assortativity boost\n    assort_factor = 1.0 + abs(assort)\n\n    # 6. Triangle influence (denser triangles tend to shorten paths)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)\n\n    # Assemble the invariant multiplicatively\n    estimate = (\n        base_ratio\n        * hetero_factor\n        * clustering_factor\n        * transitivity_factor\n        * assort_factor\n        * tri_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: disallowed syntax: Lambda\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The formula is a multiplicative combination of\n    basic global measures that capture sparsity, degree dispersion,\n    clustering, assortativity and triangle density.  No graph traversal\n    or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with pre‑computed graph statistics.  Required keys\n        are:\n          - n, m\n          - avg_degree, std_degree\n          - avg_clustering, transitivity\n          - degree_assortativity\n          - num_triangles\n\n    Returns\n    -------\n    float\n        A scalar that correlates with the average shortest path length.\n    \"\"\"\n    eps = 1e-6\n\n    n = float(s.get('n', 0))\n    m = float(s.get('m', 0))\n    avg_deg = float(s.get('avg_degree', 0)) + eps\n    std_deg = float(s.get('std_degree', 0))\n    avg_clus = float(s.get('avg_clustering', 0))\n    trans = float(s.get('transitivity', 0))\n    assort = float(s.get('degree_assortativity', 0))\n    tri = float(s.get('num_triangles', 0))\n\n    # 1. Node/edge ratio (baseline)\n    base_ratio = (n + 1.0) / (m + 1.0)\n\n    # 2. Degree heterogeneity\n    heter = (std_deg + eps) / avg_deg\n\n    # 3. Clustering suppression\n    cluster_f = 1.0 / (1.0 + avg_clus)\n\n    # 4. Transitivity suppression\n    trans_f = 1.0 / (1.0 + trans)\n\n    # 5. Assortativity boost\n    assort_f = 1.0 + abs(assort)\n\n    # 6. Triangle influence\n    tri_f = 1.0 + (tri ** 0.5) / (n ** 0.5 + eps)\n\n    estimate = (\n        base_ratio *\n        heter *\n        cluster_f *\n        trans_f *\n        assort_f *\n        tri_f\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The formula is a multiplicative combination of\n    basic global measures that capture sparsity, degree dispersion,\n    clustering, assortativity and triangle density.  No graph traversal\n    or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with pre‑computed graph statistics.  Required keys\n        are:\n          - n, m\n          - avg_degree, std_degree\n          - avg_clustering, transitivity\n          - degree_assortativity\n          - num_triangles\n\n    Returns\n    -------\n    float\n        A scalar that correlates with the average shortest path length.\n    \"\"\"\n    eps = 1e-6\n\n    n = float(s.get('n', 0))\n    m = float(s.get('m', 0))\n    avg_deg = float(s.get('avg_degree', 0)) + eps\n    std_deg = float(s.get('std_degree', 0))\n    avg_clus = float(s.get('avg_clustering', 0))\n    trans = float(s.get('transitivity', 0))\n    assort = float(s.get('degree_assortativity', 0))\n    tri = float(s.get('num_triangles', 0))\n\n    # 1. Node/edge ratio (baseline)\n    base_ratio = (n + 1.0) / (m + 1.0)\n\n    # 2. Degree heterogeneity\n    heter = (std_deg + eps) / avg_deg\n\n    # 3. Clustering suppression\n    cluster_f = 1.0 / (1.0 + avg_clus)\n\n    # 4. Transitivity suppression\n    trans_f = 1.0 / (1.0 + trans)\n\n    # 5. Assortativity boost\n    assort_f = 1.0 + abs(assort)\n\n    # 6. Triangle influence\n    tri_f = 1.0 + (tri ** 0.5) / (n ** 0.5 + eps)\n\n    estimate = (\n        base_ratio *\n        heter *\n        cluster_f *\n        trans_f *\n        assort_f *\n        tri_f\n    )\n\n    return float(estimate)", "spearman": 0.4886087152178805, "pearson": 0.44580783579213035, "rmse": 2.5074417782884644, "mae": 2.3868312862557057}}
{"timestamp": "2026-02-16T13:47:30.890940+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 3, "model_name": "gpt-oss:20b", "best_val_score": 0.5174022300586162, "no_improve_count": 0}}
{"timestamp": "2026-02-16T13:51:22.365473+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i0_p0_756373616", "generation": 3, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.37642256902761095, "fitness_mode": "correlation", "simplicity_score": 0.22303413472535122, "novelty_bonus": 0.5468371760348694, "total_score": 0.394086615471424, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    trans = s['transitivity']\n\n    # Base estimate based on size and average degree\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Adjust for density and maximum degree (high density or hubs reduce path length)\n    base /= (1 + density)\n    base /= (1 + max_deg / n)\n\n    # Adjust for minimum degree and degree dispersion (low min degree or high variance increase path length)\n    if avg_deg > 0:\n        min_factor = 1 + (1 - min_deg / avg_deg)\n        std_factor = 1 + std_deg / avg_deg\n    else:\n        min_factor = 1\n        std_factor = 1\n    base *= min_factor\n    base *= std_factor\n\n    # Adjust for clustering and transitivity (high clustering reduces path length)\n    base *= (1 + (clustering + trans) / 2)\n\n    # Adjust for assortativity (high assortativity tends to increase path length)\n    base /= (1 + abs(assort)**0.5)\n\n    # Small additive term for the number of triangles\n    base += triangles / (n**1.5 + 1)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    # Basic estimate: sqrt(n) divided by sqrt of average degree (avoid division by zero)\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n    # Increase estimate when clustering is high (small‑world effect)\n    base *= (1 + clustering)\n    # Reduce estimate when graph is highly assortative\n    base /= (1 + abs(assort))\n    # Add a small adjustment based on the number of triangles\n    base += triangles / (n**2 + 1)\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.058773\nbelow_train_threshold: train_signal=0.032893\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    triangles = s['num_triangles']\n    m = s['m']\n\n    # Base estimate: sqrt(n) divided by sqrt(avg_degree + 1)\n    base = n**0.5 / ((avg_deg + 1)**0.5)\n\n    # Reduce path length for high density and hubs\n    base /= (1 + density)\n    base /= (1 + max_deg / n)\n\n    # Increase path length for low min degree or high variance\n    if avg_deg > 0:\n        base *= (1 + (avg_deg - min_deg) / avg_deg)\n        base *= (1 + std_deg / avg_deg)\n\n    # Shorten paths with higher clustering and transitivity\n    base *= (1 + (clustering + trans) / 2)\n\n    # Lengthen paths when assortativity is high\n    base /= (1 + abs(assort)**0.5)\n\n    # Small additive corrections\n    base += triangles / (n**1.5 + 1)\n    base += m / (n**1.5 + 1)\n\n    return base", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    triangles = s['num_triangles']\n    m = s['m']\n\n    # Base estimate: sqrt(n) divided by sqrt(avg_degree + 1)\n    base = n**0.5 / ((avg_deg + 1)**0.5)\n\n    # Reduce path length for high density and hubs\n    base /= (1 + density)\n    base /= (1 + max_deg / n)\n\n    # Increase path length for low min degree or high variance\n    if avg_deg > 0:\n        base *= (1 + (avg_deg - min_deg) / avg_deg)\n        base *= (1 + std_deg / avg_deg)\n\n    # Shorten paths with higher clustering and transitivity\n    base *= (1 + (clustering + trans) / 2)\n\n    # Lengthen paths when assortativity is high\n    base /= (1 + abs(assort)**0.5)\n\n    # Small additive corrections\n    base += triangles / (n**1.5 + 1)\n    base += m / (n**1.5 + 1)\n\n    return base", "spearman": 0.3708572714317858, "pearson": 0.31213768499045913, "rmse": 3.191344741439154, "mae": 2.833677340981377}}
{"timestamp": "2026-02-16T13:51:40.827462+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i0_p1_854318776", "generation": 3, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5891476590636254, "fitness_mode": "correlation", "simplicity_score": 0.22565861162015377, "novelty_bonus": 0.39878782084007913, "total_score": 0.44133598277390945, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    trans = s['transitivity']\n\n    # Base estimate based on size and average degree\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Adjust for density and maximum degree (high density or hubs reduce path length)\n    base /= (1 + density)\n    base /= (1 + max_deg / n)\n\n    # Adjust for minimum degree and degree dispersion (low min degree or high variance increase path length)\n    if avg_deg > 0:\n        min_factor = 1 + (1 - min_deg / avg_deg)\n        std_factor = 1 + std_deg / avg_deg\n    else:\n        min_factor = 1\n        std_factor = 1\n    base *= min_factor\n    base *= std_factor\n\n    # Adjust for clustering and transitivity (high clustering reduces path length)\n    base *= (1 + (clustering + trans) / 2)\n\n    # Adjust for assortativity (high assortativity tends to increase path length)\n    base /= (1 + abs(assort)**0.5)\n\n    # Small additive term for the number of triangles\n    base += triangles / (n**1.5 + 1)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    # Basic estimate: sqrt(n) divided by sqrt of average degree (avoid division by zero)\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n    # Increase estimate when clustering is high (small‑world effect)\n    base *= (1 + clustering)\n    # Reduce estimate when graph is highly assortative\n    base /= (1 + abs(assort))\n    # Add a small adjustment based on the number of triangles\n    base += triangles / (n**2 + 1)\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.058773\nbelow_train_threshold: train_signal=0.032893\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic scaling: larger graphs tend to have longer paths,\n    # but higher average degree shortens them.\n    n = s['n']\n    avg_deg = s['avg_degree']\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Density and hubs reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Low minimum degree or high degree variance increase path length\n    if avg_deg > 0:\n        base *= (1 + (1 - s['min_degree'] / avg_deg))\n        base *= (1 + s['std_degree'] / avg_deg)\n    else:\n        base *= 1\n\n    # Small‑world effect: clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity'])**0.5)\n\n    # Minor additive contribution from triangles\n    base += s['num_triangles'] / (n**1.5 + 1)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    # Basic scaling: larger graphs tend to have longer paths,\n    # but higher average degree shortens them.\n    n = s['n']\n    avg_deg = s['avg_degree']\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Density and hubs reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Low minimum degree or high degree variance increase path length\n    if avg_deg > 0:\n        base *= (1 + (1 - s['min_degree'] / avg_deg))\n        base *= (1 + s['std_degree'] / avg_deg)\n    else:\n        base *= 1\n\n    # Small‑world effect: clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity'])**0.5)\n\n    # Minor additive contribution from triangles\n    base += s['num_triangles'] / (n**1.5 + 1)\n\n    return base", "spearman": 0.55313582839571, "pearson": 0.5068573273167236, "rmse": 3.0941295788577663, "mae": 2.708871098053172}}
{"timestamp": "2026-02-16T13:52:03.508166+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:52:03.508918+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:52:26.288455+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i0_p2_543058861", "generation": 3, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5891476590636254, "fitness_mode": "correlation", "simplicity_score": 0.22323284751129324, "novelty_bonus": 0.39878782084007913, "total_score": 0.44085082995213737, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    trans = s['transitivity']\n\n    # Base estimate based on size and average degree\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Adjust for density and maximum degree (high density or hubs reduce path length)\n    base /= (1 + density)\n    base /= (1 + max_deg / n)\n\n    # Adjust for minimum degree and degree dispersion (low min degree or high variance increase path length)\n    if avg_deg > 0:\n        min_factor = 1 + (1 - min_deg / avg_deg)\n        std_factor = 1 + std_deg / avg_deg\n    else:\n        min_factor = 1\n        std_factor = 1\n    base *= min_factor\n    base *= std_factor\n\n    # Adjust for clustering and transitivity (high clustering reduces path length)\n    base *= (1 + (clustering + trans) / 2)\n\n    # Adjust for assortativity (high assortativity tends to increase path length)\n    base /= (1 + abs(assort)**0.5)\n\n    # Small additive term for the number of triangles\n    base += triangles / (n**1.5 + 1)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    # Basic estimate: sqrt(n) divided by sqrt of average degree (avoid division by zero)\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n    # Increase estimate when clustering is high (small‑world effect)\n    base *= (1 + clustering)\n    # Reduce estimate when graph is highly assortative\n    base /= (1 + abs(assort))\n    # Add a small adjustment based on the number of triangles\n    base += triangles / (n**2 + 1)\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.058773\nbelow_train_threshold: train_signal=0.032893\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree, clustering, assortativity,\n    density, and triangle counts.  It is intentionally simple and avoids any\n    explicit shortest‑path computation.\n    \"\"\"\n    import math\n\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    triangles  = s['num_triangles']\n\n    # Base estimate: sqrt(n) divided by sqrt of average degree (avoid division by zero)\n    base = math.sqrt(n) / (math.sqrt(avg_deg) if avg_deg > 0 else 1.0)\n\n    # Reduce the estimate for high density and for the presence of hubs\n    base /= (1.0 + density)\n    base /= (1.0 + max_deg / n)\n\n    # Increase the estimate when the minimum degree is low or the degree variance is high\n    if avg_deg > 0:\n        min_factor = 1.0 + (1.0 - min_deg / avg_deg)   # low min_deg → larger factor\n        std_factor = 1.0 + std_deg / avg_deg           # high variance → larger factor\n    else:\n        min_factor = 1.0\n        std_factor = 1.0\n    base *= min_factor * std_factor\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + (clustering + trans) / 2.0)\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1.0 + abs(assort) ** 0.5)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 1.5 + 1.0)\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    triangles = s['num_triangles']\n\n    # Base estimate: sqrt(n) divided by sqrt of average degree (avoid division by zero)\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1.0)\n\n    # Reduce the estimate for high density and for the presence of hubs\n    base /= (1.0 + density)\n    base /= (1.0 + max_deg / n)\n\n    # Increase the estimate when the minimum degree is low or the degree variance is high\n    if avg_deg > 0:\n        min_factor = 1.0 + (1.0 - min_deg / avg_deg)   # low min_deg → larger factor\n        std_factor = 1.0 + std_deg / avg_deg           # high variance → larger factor\n    else:\n        min_factor = 1.0\n        std_factor = 1.0\n    base *= min_factor * std_factor\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + (clustering + trans) / 2.0)\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1.0 + abs(assort)**0.5)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n**1.5 + 1.0)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    triangles = s['num_triangles']\n\n    # Base estimate: sqrt(n) divided by sqrt of average degree (avoid division by zero)\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1.0)\n\n    # Reduce the estimate for high density and for the presence of hubs\n    base /= (1.0 + density)\n    base /= (1.0 + max_deg / n)\n\n    # Increase the estimate when the minimum degree is low or the degree variance is high\n    if avg_deg > 0:\n        min_factor = 1.0 + (1.0 - min_deg / avg_deg)   # low min_deg → larger factor\n        std_factor = 1.0 + std_deg / avg_deg           # high variance → larger factor\n    else:\n        min_factor = 1.0\n        std_factor = 1.0\n    base *= min_factor * std_factor\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + (clustering + trans) / 2.0)\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1.0 + abs(assort)**0.5)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n**1.5 + 1.0)\n\n    return base", "spearman": 0.55313582839571, "pearson": 0.5068573273167236, "rmse": 3.0941295788577663, "mae": 2.708871098053172}}
{"timestamp": "2026-02-16T13:52:26.289847+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 0, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:53:36.826994+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i0_p3_377866921", "generation": 3, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5891476590636254, "fitness_mode": "correlation", "simplicity_score": 0.22386530400955612, "novelty_bonus": 0.39878782084007913, "total_score": 0.44097732125178996, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    trans = s['transitivity']\n\n    # Base estimate based on size and average degree\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Adjust for density and maximum degree (high density or hubs reduce path length)\n    base /= (1 + density)\n    base /= (1 + max_deg / n)\n\n    # Adjust for minimum degree and degree dispersion (low min degree or high variance increase path length)\n    if avg_deg > 0:\n        min_factor = 1 + (1 - min_deg / avg_deg)\n        std_factor = 1 + std_deg / avg_deg\n    else:\n        min_factor = 1\n        std_factor = 1\n    base *= min_factor\n    base *= std_factor\n\n    # Adjust for clustering and transitivity (high clustering reduces path length)\n    base *= (1 + (clustering + trans) / 2)\n\n    # Adjust for assortativity (high assortativity tends to increase path length)\n    base /= (1 + abs(assort)**0.5)\n\n    # Small additive term for the number of triangles\n    base += triangles / (n**1.5 + 1)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    # Basic estimate: sqrt(n) divided by sqrt of average degree (avoid division by zero)\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n    # Increase estimate when clustering is high (small‑world effect)\n    base *= (1 + clustering)\n    # Reduce estimate when graph is highly assortative\n    base /= (1 + abs(assort))\n    # Add a small adjustment based on the number of triangles\n    base += triangles / (n**2 + 1)\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.058773\nbelow_train_threshold: train_signal=0.032893\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n\n    # Base estimate: sqrt(n) divided by sqrt of average degree\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Reduce path length when graph is dense or has high-degree hubs\n    base /= (1 + density)\n    base /= (1 + max_deg / n)\n\n    # Increase path length when minimum degree is low or degree variance is high\n    if avg_deg > 0:\n        base *= (1 + (avg_deg - min_deg) / avg_deg)\n        base *= (1 + std_deg / avg_deg)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1 + (clustering + trans) / 2)\n\n    # Assortativity tends to lengthen paths\n    base /= (1 + abs(assort)**0.5)\n\n    # Minor additive contribution from triangles\n    base += triangles / (n**1.5 + 1)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n\n    # Base estimate: sqrt(n) divided by sqrt of average degree\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Reduce path length when graph is dense or has high-degree hubs\n    base /= (1 + density)\n    base /= (1 + max_deg / n)\n\n    # Increase path length when minimum degree is low or degree variance is high\n    if avg_deg > 0:\n        base *= (1 + (avg_deg - min_deg) / avg_deg)\n        base *= (1 + std_deg / avg_deg)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1 + (clustering + trans) / 2)\n\n    # Assortativity tends to lengthen paths\n    base /= (1 + abs(assort)**0.5)\n\n    # Minor additive contribution from triangles\n    base += triangles / (n**1.5 + 1)\n\n    return base", "spearman": 0.55313582839571, "pearson": 0.5068573273167236, "rmse": 3.0941295788577663, "mae": 2.708871098053172}}
{"timestamp": "2026-02-16T13:54:27.315891+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.043597", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:54:27.316469+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.043597", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:54:44.460935+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i0_p4_202084457", "generation": 3, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5852100840336134, "fitness_mode": "correlation", "simplicity_score": 0.22404398051287003, "novelty_bonus": 0.29029540515742847, "total_score": 0.5141699744637229, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    trans = s['transitivity']\n\n    # Base estimate based on size and average degree\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Adjust for density and maximum degree (high density or hubs reduce path length)\n    base /= (1 + density)\n    base /= (1 + max_deg / n)\n\n    # Adjust for minimum degree and degree dispersion (low min degree or high variance increase path length)\n    if avg_deg > 0:\n        min_factor = 1 + (1 - min_deg / avg_deg)\n        std_factor = 1 + std_deg / avg_deg\n    else:\n        min_factor = 1\n        std_factor = 1\n    base *= min_factor\n    base *= std_factor\n\n    # Adjust for clustering and transitivity (high clustering reduces path length)\n    base *= (1 + (clustering + trans) / 2)\n\n    # Adjust for assortativity (high assortativity tends to increase path length)\n    base /= (1 + abs(assort)**0.5)\n\n    # Small additive term for the number of triangles\n    base += triangles / (n**1.5 + 1)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    # Basic estimate: sqrt(n) divided by sqrt of average degree (avoid division by zero)\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n    # Increase estimate when clustering is high (small‑world effect)\n    base *= (1 + clustering)\n    # Reduce estimate when graph is highly assortative\n    base /= (1 + abs(assort))\n    # Add a small adjustment based on the number of triangles\n    base += triangles / (n**2 + 1)\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.058773\nbelow_train_threshold: train_signal=0.032893\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.043597\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n\n    # Base estimate: size scaled by average degree\n    base = (n**0.5) * (avg_deg + 1)\n\n    # Reduce length for dense graphs and hubs\n    base /= (1 + density * (max_deg / (n + 1)))\n\n    # Increase length when degree spread is large\n    base *= (1 + (avg_deg - min_deg) / (avg_deg + 1))\n    base *= (1 + std_deg / (avg_deg + 1))\n\n    # Small‑world effect: clustering and transitivity shorten paths\n    base *= (1 + (clustering + trans) / 2)\n\n    # Assortativity tends to lengthen paths\n    base /= (1 + abs(assort))\n\n    # Minor additive contribution from triangles\n    base += triangles / (n**1.5 + 1)\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base", "spearman": 0.7645451136278407, "pearson": 0.7235486314870165, "rmse": 3.7546492969815093, "mae": 3.5404028333115094}}
{"timestamp": "2026-02-16T13:54:44.461351+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 0, "population_idx": 4, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:55:09.214227+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i1_p0_672944949", "generation": 3, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.720720288115246, "fitness_mode": "correlation", "simplicity_score": 0.11948492391459337, "novelty_bonus": 0.3100874326886496, "total_score": 0.47608544364523997, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )\n\ndef new_invariant(s):\n    # Extract basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n\n    # Optional features that may be missing in some datasets\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Basic building blocks (avoid division by zero)\n    part1 = n / (m + 1)                     # captures sparsity\n    part2 = n ** 0.5 / (1 + avg_clustering) # captures size & clustering\n    part3 = avg_degree / (max_degree + 1)   # captures degree spread\n\n    # Incorporate higher‑order structure\n    part4 = 1 + degree_assortativity        # shift to keep positive\n    part5 = 1 + transitivity                # shift to keep positive\n\n    # Combine all components multiplicatively\n    return part1 * part2 * part3 * part4 * part5\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.060716\nbelow_train_threshold: train_signal=0.137575\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_clust  = s['avg_clustering']\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s['num_triangles']\n    std_deg    = s['std_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    avg_deg    = s['avg_degree']\n\n    # Avoid division by zero\n    denom_density = max(density, 1e-6)\n    denom_edges   = max(m, 1)\n    denom_std     = max(std_deg, 0.0)\n\n    # Derived ratios and factors\n    tri_per_edge  = num_tri / denom_edges\n    deg_ratio     = (max_deg + 1) / (min_deg + 1)\n    avg_to_max    = (1 + avg_deg) / (max_deg + 1)\n\n    # Composite invariant – multiplicative combination of all parts\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + trans)\n        * (1 + tri_per_edge)\n        * deg_ratio\n        * avg_to_max\n        / (1 + denom_std ** 2)\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_clust  = s['avg_clustering']\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s['num_triangles']\n    std_deg    = s['std_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    avg_deg    = s['avg_degree']\n\n    # Avoid division by zero\n    denom_density = max(density, 1e-6)\n    denom_edges   = max(m, 1)\n    denom_std     = max(std_deg, 0.0)\n\n    # Derived ratios and factors\n    tri_per_edge  = num_tri / denom_edges\n    deg_ratio     = (max_deg + 1) / (min_deg + 1)\n    avg_to_max    = (1 + avg_deg) / (max_deg + 1)\n\n    # Composite invariant – multiplicative combination of all parts\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + trans)\n        * (1 + tri_per_edge)\n        * deg_ratio\n        * avg_to_max\n        / (1 + denom_std ** 2)\n    )", "spearman": 0.7183244581114528, "pearson": 0.6649644702211084, "rmse": 119.1680576521796, "mae": 81.46880182301176}}
{"timestamp": "2026-02-16T13:55:55.351974+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.223679", "model_name": "gpt-oss:20b", "train_signal": 0.22367883989256124}}
{"timestamp": "2026-02-16T13:56:19.443253+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:56:19.444252+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:56:46.808683+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i1_p2_516105285", "generation": 3, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.11832138111927311, "novelty_bonus": 0.17722193054826363, "total_score": 0.5111232126972665, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )\n\ndef new_invariant(s):\n    # Extract basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n\n    # Optional features that may be missing in some datasets\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Basic building blocks (avoid division by zero)\n    part1 = n / (m + 1)                     # captures sparsity\n    part2 = n ** 0.5 / (1 + avg_clustering) # captures size & clustering\n    part3 = avg_degree / (max_degree + 1)   # captures degree spread\n\n    # Incorporate higher‑order structure\n    part4 = 1 + degree_assortativity        # shift to keep positive\n    part5 = 1 + transitivity                # shift to keep positive\n\n    # Combine all components multiplicatively\n    return part1 * part2 * part3 * part4 * part5\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.060716\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport math\n\ndef new_invariant(s):\n    \"\"\"\n    Composite graph invariant combining sparsity, size, clustering,\n    degree distribution, assortativity, transitivity, triangles,\n    density, degree variance and min/max degree ratio.\n    \"\"\"\n    # Basic statistics\n    n          = s['n']\n    m          = s['m']\n    density    = s.get('density', 1e-6)          # avoid zero\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    max_deg    = s.get('max_degree', 0)\n    min_deg    = s.get('min_degree', 0)\n    avg_deg    = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Component terms\n    sparsity          = n / (denom_edges + 1)                     # captures sparsity\n    size_clust        = math.sqrt(n) / (1 + avg_clust)            # size & clustering\n    degree_spread     = avg_deg / (max_deg + 1)                    # degree spread\n    assort_factor     = 1 + abs(assort)                            # assortativity\n    trans_factor      = 1 + trans                                   # transitivity\n    triangle_factor   = 1 + num_tri / denom_edges                  # triangles per edge\n    density_factor    = 1 / denom_density                          # inverse density\n    variance_factor   = 1 / (1 + std_deg ** 2)                     # degree variance\n    minmax_ratio      = (max_deg + 1) / (min_deg + 1)              # min/max degree ratio\n\n    # Combine multiplicatively\n    return (\n        sparsity *\n        size_clust *\n        degree_spread *\n        assort_factor *\n        trans_factor *\n        triangle_factor *\n        density_factor *\n        variance_factor *\n        minmax_ratio\n    )\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Component terms\n    sparsity = n / (denom_edges + 1)                     # captures sparsity\n    size_clust = n**0.5 / (1 + avg_clust)                # size & clustering\n    degree_spread = avg_deg / (max_deg + 1)              # degree spread\n    assort_factor = 1 + abs(assort)                      # assortativity\n    trans_factor = 1 + trans                              # transitivity\n    triangle_factor = 1 + num_tri / denom_edges          # triangles per edge\n    density_factor = 1 / denom_density                   # inverse density\n    variance_factor = 1 / (1 + std_deg**2)               # degree variance\n    minmax_ratio = (max_deg + 1) / (min_deg + 1)          # min/max degree ratio\n\n    # Combine multiplicatively\n    return (\n        sparsity *\n        size_clust *\n        degree_spread *\n        assort_factor *\n        trans_factor *\n        triangle_factor *\n        density_factor *\n        variance_factor *\n        minmax_ratio\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Component terms\n    sparsity = n / (denom_edges + 1)                     # captures sparsity\n    size_clust = n**0.5 / (1 + avg_clust)                # size & clustering\n    degree_spread = avg_deg / (max_deg + 1)              # degree spread\n    assort_factor = 1 + abs(assort)                      # assortativity\n    trans_factor = 1 + trans                              # transitivity\n    triangle_factor = 1 + num_tri / denom_edges          # triangles per edge\n    density_factor = 1 / denom_density                   # inverse density\n    variance_factor = 1 / (1 + std_deg**2)               # degree variance\n    minmax_ratio = (max_deg + 1) / (min_deg + 1)          # min/max degree ratio\n\n    # Combine multiplicatively\n    return (\n        sparsity *\n        size_clust *\n        degree_spread *\n        assort_factor *\n        trans_factor *\n        triangle_factor *\n        density_factor *\n        variance_factor *\n        minmax_ratio\n    )", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T13:56:46.810565+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 1, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:57:31.506194+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i1_p3_242055891", "generation": 3, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.19495781068249596, "novelty_bonus": 0.17722193054826363, "total_score": 0.526450498609911, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )\n\ndef new_invariant(s):\n    # Extract basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n\n    # Optional features that may be missing in some datasets\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Basic building blocks (avoid division by zero)\n    part1 = n / (m + 1)                     # captures sparsity\n    part2 = n ** 0.5 / (1 + avg_clustering) # captures size & clustering\n    part3 = avg_degree / (max_degree + 1)   # captures degree spread\n\n    # Incorporate higher‑order structure\n    part4 = 1 + degree_assortativity        # shift to keep positive\n    part5 = 1 + transitivity                # shift to keep positive\n\n    # Combine all components multiplicatively\n    return part1 * part2 * part3 * part4 * part5\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n```", "extracted_code": "def new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T13:58:04.381227+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i1_p4_507127380", "generation": 3, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.5045378151260504, "fitness_mode": "correlation", "simplicity_score": 0.13463304238815207, "novelty_bonus": 0.4266223205911934, "total_score": 0.38224323790331965, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )\n\ndef new_invariant(s):\n    # Extract basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n\n    # Optional features that may be missing in some datasets\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Basic building blocks (avoid division by zero)\n    part1 = n / (m + 1)                     # captures sparsity\n    part2 = n ** 0.5 / (1 + avg_clustering) # captures size & clustering\n    part3 = avg_degree / (max_degree + 1)   # captures degree spread\n\n    # Incorporate higher‑order structure\n    part4 = 1 + degree_assortativity        # shift to keep positive\n    part5 = 1 + transitivity                # shift to keep positive\n\n    # Combine all components multiplicatively\n    return part1 * part2 * part3 * part4 * part5\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)          # avoid division by zero\n    std_deg = s.get('std_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (m + 1)                     # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust)    # size & clustering\n    part3 = deg_ratio                       # degree spread\n    part4 = 1 + abs(assort)                 # assortativity\n    part5 = 1 + trans                       # transitivity\n    part6 = 1 + tri_per_edge                # triangle density\n    part7 = 1 + density                     # overall density\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)          # avoid division by zero\n    std_deg = s.get('std_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (m + 1)                     # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust)    # size & clustering\n    part3 = deg_ratio                       # degree spread\n    part4 = 1 + abs(assort)                 # assortativity\n    part5 = 1 + trans                       # transitivity\n    part6 = 1 + tri_per_edge                # triangle density\n    part7 = 1 + density                     # overall density\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7", "spearman": 0.45465986649666246, "pearson": 0.5504161846382787, "rmse": 31.144467547301186, "mae": 22.68907652980441}}
{"timestamp": "2026-02-16T13:58:34.916363+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:58:34.916953+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:59:14.148746+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.083602", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:59:14.149326+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 2, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:59:33.800853+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.049823", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:59:33.801117+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.049823", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:59:55.258330+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.108537", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T13:59:55.258895+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:00:15.874671+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:00:15.875459+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:00:26.782131+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 2, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:00:26.783053+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 2, "population_idx": 2, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:01:19.809214+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.118079", "model_name": "gpt-oss:20b", "train_signal": 0.11807923169267706}}
{"timestamp": "2026-02-16T14:01:43.253317+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:01:43.253966+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:02:16.454169+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i2_p4_49571574", "generation": 3, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7672989195678271, "fitness_mode": "correlation", "simplicity_score": 0.14018940896602589, "novelty_bonus": 0.17691482373033196, "total_score": 0.4735506398700787, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\nNone yet.\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.108537\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.118079\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport math\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends the classic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: log(n) / log(avg_degree)\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)           # avoid division by zero\n    rand_est = math.log(n) / math.log(avg_deg)\n\n    # Corrections\n    # 1. Clustering: higher clustering tends to increase path lengths\n    clustering_factor = 1.0 + s['avg_clustering']\n\n    # 2. Density: denser graphs have shorter paths\n    density_factor = 1.0 / (1.0 + s['density'])\n\n    # 3. Degree heterogeneity: more heterogeneous degrees (larger std)\n    #    usually reduce the average path length (hubs act as shortcuts)\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])\n\n    # Combine the components\n    return rand_est * clustering_factor * density_factor * hetero_factor\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor", "spearman": 0.784876621915548, "pearson": 0.7029372324659497, "rmse": 1.493284761683947, "mae": 1.0176213252960176}}
{"timestamp": "2026-02-16T14:02:16.454915+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 2, "population_idx": 4, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:02:45.290176+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i3_p0_56711212", "generation": 3, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6121968787515005, "fitness_mode": "correlation", "simplicity_score": 0.1570480950316068, "novelty_bonus": 0.33488368034527183, "total_score": 0.37929165853328856, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimator for the average shortest‑path length that relies solely on\n    pre‑computed global statistics.  The formula is a mixture of\n    multiplicative and divisive factors that encode density, degree\n    heterogeneity, clustering, transitivity, assortativity, and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the following keys:\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity,\n        num_triangles, degrees (sorted degree list).\n\n    Returns\n    -------\n    float\n        An invariant that is expected to correlate with the graph’s\n        average shortest‑path length.\n    \"\"\"\n    # --- Safely extract features with defaults -------------------------------------------------\n    n                = float(s.get('n', 1))\n    m                = float(s.get('m', 0))\n    density          = float(s.get('density', 0.0))\n    avg_degree       = float(s.get('avg_degree', 0.0))\n    max_degree       = float(s.get('max_degree', 0))\n    min_degree       = float(s.get('min_degree', 1))\n    std_degree       = float(s.get('std_degree', 0.0))\n    avg_clustering   = float(s.get('avg_clustering', 0.0))\n    transitivity     = float(s.get('transitivity', 0.0))\n    assortativity    = float(s.get('degree_assortativity', 0.0))\n    num_triangles    = float(s.get('num_triangles', 0))\n\n    eps = 1e-6  # small number to avoid division by zero\n\n    # --- Base factor ---------------------------------------------------------------\n    base = n / (m + 1.0)\n\n    # --- Density factor -------------------------------------------------------------\n    density_factor = 1.0 / (1.0 + density)\n\n    # --- Degree‑related factors ------------------------------------------------------\n    degree_factor = (1.0 + avg_degree) ** 0.5\n    deg_ratio      = (max_degree + 1) / (min_degree + 1)\n\n    # --- Clustering / transitivity / assortativity ---------------------------------\n    cluster_factor = 1.0 / (1.0 + avg_clustering)\n    trans_factor   = 1.0 + transitivity\n    assort_factor  = 1.0 + abs(assortativity)\n\n    # --- Triangle influence ---------------------------------------------------------\n    tri_factor = 1.0 + (num_triangles ** 0.5) / (n ** 0.5 + eps)\n\n    # --- Degree heterogeneity -------------------------------------------------------\n    hetero_factor = max(std_degree, eps) / max(avg_degree, eps)\n\n    # --- Combine all factors ---------------------------------------------------------\n    estimate = (base * density_factor * degree_factor * deg_ratio *\n                cluster_factor * trans_factor * assort_factor *\n                tri_factor * hetero_factor)\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: disallowed syntax: Lambda\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a set of global graph\n    statistics.  The formula mixes a size‑to‑density baseline with factors\n    that reflect degree concentration, clustering, assortativity, triangle\n    density and degree heterogeneity.  No graph traversal is performed.\n    \"\"\"\n    # Extract features with safe defaults\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    avg_clustering = float(s.get('avg_clustering', 0.0))\n    degree_assortativity = float(s.get('degree_assortativity', 0.0))\n    num_triangles = float(s.get('num_triangles', 0))\n    std_degree = float(s.get('std_degree', 0.0))\n    avg_degree = float(s.get('avg_degree', 0.0))\n    degrees = s.get('degrees', [])\n\n    # Base factor: node/edge ratio (regularised)\n    base = n / (m + 1.0)\n\n    # High‑degree concentration (top 10 % nodes)\n    top_k = max(1, int(0.1 * n))\n    top_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_degree = 2 * m\n    high_deg_ratio = top_sum / (total_degree + 1.0)\n\n    # Clustering / transitivity adjustment\n    cluster_factor = 1.0 / (1.0 + avg_clustering)\n\n    # Assortativity multiplier\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # Triangle density factor (square‑root scaling)\n    tri_factor = 1.0 + (num_triangles ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree heterogeneity factor\n    hetero_factor = max(std_degree, 1e-6) / (max(avg_degree, 1e-6))\n\n    # Combine all components\n    estimate = (\n        base\n        * (1.0 + high_deg_ratio)\n        * cluster_factor\n        * assort_factor\n        * tri_factor\n        * hetero_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a set of global graph\n    statistics.  The formula mixes a size‑to‑density baseline with factors\n    that reflect degree concentration, clustering, assortativity, triangle\n    density and degree heterogeneity.  No graph traversal is performed.\n    \"\"\"\n    # Extract features with safe defaults\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    avg_clustering = float(s.get('avg_clustering', 0.0))\n    degree_assortativity = float(s.get('degree_assortativity', 0.0))\n    num_triangles = float(s.get('num_triangles', 0))\n    std_degree = float(s.get('std_degree', 0.0))\n    avg_degree = float(s.get('avg_degree', 0.0))\n    degrees = s.get('degrees', [])\n\n    # Base factor: node/edge ratio (regularised)\n    base = n / (m + 1.0)\n\n    # High‑degree concentration (top 10 % nodes)\n    top_k = max(1, int(0.1 * n))\n    top_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_degree = 2 * m\n    high_deg_ratio = top_sum / (total_degree + 1.0)\n\n    # Clustering / transitivity adjustment\n    cluster_factor = 1.0 / (1.0 + avg_clustering)\n\n    # Assortativity multiplier\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # Triangle density factor (square‑root scaling)\n    tri_factor = 1.0 + (num_triangles ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree heterogeneity factor\n    hetero_factor = max(std_degree, 1e-6) / (max(avg_degree, 1e-6))\n\n    # Combine all components\n    estimate = (\n        base\n        * (1.0 + high_deg_ratio)\n        * cluster_factor\n        * assort_factor\n        * tri_factor\n        * hetero_factor\n    )\n\n    return float(estimate)", "spearman": 0.4948338708467713, "pearson": 0.46362382063394475, "rmse": 2.400794911461062, "mae": 2.2769788898583023}}
{"timestamp": "2026-02-16T14:03:18.385468+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.240198", "model_name": "gpt-oss:20b", "train_signal": 0.24019784395504326}}
{"timestamp": "2026-02-16T14:03:54.485477+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i3_p2_112918420", "generation": 3, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.544969987995198, "fitness_mode": "correlation", "simplicity_score": 0.15571872759642574, "novelty_bonus": 0.38257556438910967, "total_score": 0.39992976516977646, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimator for the average shortest‑path length that relies solely on\n    pre‑computed global statistics.  The formula is a mixture of\n    multiplicative and divisive factors that encode density, degree\n    heterogeneity, clustering, transitivity, assortativity, and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the following keys:\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity,\n        num_triangles, degrees (sorted degree list).\n\n    Returns\n    -------\n    float\n        An invariant that is expected to correlate with the graph’s\n        average shortest‑path length.\n    \"\"\"\n    # --- Safely extract features with defaults -------------------------------------------------\n    n                = float(s.get('n', 1))\n    m                = float(s.get('m', 0))\n    density          = float(s.get('density', 0.0))\n    avg_degree       = float(s.get('avg_degree', 0.0))\n    max_degree       = float(s.get('max_degree', 0))\n    min_degree       = float(s.get('min_degree', 1))\n    std_degree       = float(s.get('std_degree', 0.0))\n    avg_clustering   = float(s.get('avg_clustering', 0.0))\n    transitivity     = float(s.get('transitivity', 0.0))\n    assortativity    = float(s.get('degree_assortativity', 0.0))\n    num_triangles    = float(s.get('num_triangles', 0))\n\n    eps = 1e-6  # small number to avoid division by zero\n\n    # --- Base factor ---------------------------------------------------------------\n    base = n / (m + 1.0)\n\n    # --- Density factor -------------------------------------------------------------\n    density_factor = 1.0 / (1.0 + density)\n\n    # --- Degree‑related factors ------------------------------------------------------\n    degree_factor = (1.0 + avg_degree) ** 0.5\n    deg_ratio      = (max_degree + 1) / (min_degree + 1)\n\n    # --- Clustering / transitivity / assortativity ---------------------------------\n    cluster_factor = 1.0 / (1.0 + avg_clustering)\n    trans_factor   = 1.0 + transitivity\n    assort_factor  = 1.0 + abs(assortativity)\n\n    # --- Triangle influence ---------------------------------------------------------\n    tri_factor = 1.0 + (num_triangles ** 0.5) / (n ** 0.5 + eps)\n\n    # --- Degree heterogeneity -------------------------------------------------------\n    hetero_factor = max(std_degree, eps) / max(avg_degree, eps)\n\n    # --- Combine all factors ---------------------------------------------------------\n    estimate = (base * density_factor * degree_factor * deg_ratio *\n                cluster_factor * trans_factor * assort_factor *\n                tri_factor * hetero_factor)\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: disallowed syntax: Lambda\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_train_threshold: train_signal=0.240198\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using only\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        A scalar that is expected to correlate with the graph’s\n        average shortest‑path length.\n    \"\"\"\n    # Extract features with safe defaults\n    n                = float(s.get('n', 1))\n    m                = float(s.get('m', 0))\n    density          = float(s.get('density', 0.0))\n    avg_deg          = float(s.get('avg_degree', 0.0))\n    max_deg          = float(s.get('max_degree', 0))\n    min_deg          = float(s.get('min_degree', 1))\n    std_deg          = float(s.get('std_degree', 0.0))\n    avg_clust        = float(s.get('avg_clustering', 0.0))\n    trans            = float(s.get('transitivity', 0.0))\n    assort           = float(s.get('degree_assortativity', 0.0))\n    num_tri          = float(s.get('num_triangles', 0))\n    # degrees list is not needed for this estimator but retained for completeness\n    _ = s.get('degrees', [])\n\n    # Base density‑adjusted factor\n    base = (n + 1.0) / (m + 1.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Degree heterogeneity factor\n    hetero = (1.0 + std_deg) / (1.0 + avg_deg) if avg_deg != 0 else 1.0\n\n    # Clustering influence\n    cluster_factor = 1.0 / (1.0 + avg_clust)\n\n    # Transitivity multiplier\n    trans_factor = 1.0 + trans\n\n    # Assortativity multiplier\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle density influence\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range factor (captures extreme hubs)\n    deg_range_factor = (max_deg + 1) / (min_deg + 1)\n\n    # Combine all factors multiplicatively\n    estimate = (\n        base\n        * density_factor\n        * hetero\n        * cluster_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using only\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        A scalar that is expected to correlate with the graph’s\n        average shortest‑path length.\n    \"\"\"\n    # Extract features with safe defaults\n    n                = float(s.get('n', 1))\n    m                = float(s.get('m', 0))\n    density          = float(s.get('density', 0.0))\n    avg_deg          = float(s.get('avg_degree', 0.0))\n    max_deg          = float(s.get('max_degree', 0))\n    min_deg          = float(s.get('min_degree', 1))\n    std_deg          = float(s.get('std_degree', 0.0))\n    avg_clust        = float(s.get('avg_clustering', 0.0))\n    trans            = float(s.get('transitivity', 0.0))\n    assort           = float(s.get('degree_assortativity', 0.0))\n    num_tri          = float(s.get('num_triangles', 0))\n    # degrees list is not needed for this estimator but retained for completeness\n    _ = s.get('degrees', [])\n\n    # Base density‑adjusted factor\n    base = (n + 1.0) / (m + 1.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Degree heterogeneity factor\n    hetero = (1.0 + std_deg) / (1.0 + avg_deg) if avg_deg != 0 else 1.0\n\n    # Clustering influence\n    cluster_factor = 1.0 / (1.0 + avg_clust)\n\n    # Transitivity multiplier\n    trans_factor = 1.0 + trans\n\n    # Assortativity multiplier\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle density influence\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range factor (captures extreme hubs)\n    deg_range_factor = (max_deg + 1) / (min_deg + 1)\n\n    # Combine all factors multiplicatively\n    estimate = (\n        base\n        * density_factor\n        * hetero\n        * cluster_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range_factor\n    )\n\n    return float(estimate)", "spearman": 0.5080267006675168, "pearson": 0.4938470397832582, "rmse": 2.57917331127282, "mae": 1.7710150099685384}}
{"timestamp": "2026-02-16T14:04:22.592324+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:04:22.593457+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:04:55.355167+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 3, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.094917", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:04:55.355664+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 3, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:05:44.871897+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.114406", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:05:44.872855+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.114406", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:06:28.538009+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 3, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:06:28.538863+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 3, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:06:28.541696+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 4, "model_name": "gpt-oss:20b", "best_val_score": 0.526450498609911, "no_improve_count": 0}}
{"timestamp": "2026-02-16T14:08:12.094528+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i0_p0_342788113", "generation": 4, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.4554621848739495, "fitness_mode": "correlation", "simplicity_score": 0.22485723984397193, "novelty_bonus": 0.4814228477537146, "total_score": 0.4187870370132768, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling: larger graphs tend to have longer paths,\n    # but higher average degree shortens them.\n    n = s['n']\n    avg_deg = s['avg_degree']\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Density and hubs reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Low minimum degree or high degree variance increase path length\n    if avg_deg > 0:\n        base *= (1 + (1 - s['min_degree'] / avg_deg))\n        base *= (1 + s['std_degree'] / avg_deg)\n    else:\n        base *= 1\n\n    # Small‑world effect: clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity'])**0.5)\n\n    # Minor additive contribution from triangles\n    base += s['num_triangles'] / (n**1.5 + 1)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.032893\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.043597\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n\n    # Base estimate: size grows with sqrt(n), average degree shrinks the path length\n    base = (n ** 0.5) / (avg_deg ** 0.5 if avg_deg > 0 else 1)\n\n    # Dense graphs and hubs reduce the average shortest‑path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Uneven degree distribution (low min or high variance) lengthens paths\n    base *= (1 + (avg_deg - s['min_degree']) / (avg_deg + 1))\n    base *= (1 + s['std_degree'] / (avg_deg + 1))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity tends to lengthen paths\n    base /= (1 + abs(s['degree_assortativity']) ** 0.5)\n\n    # Minor additive contributions from triangles and edge density\n    base += s['num_triangles'] / (n ** 1.5 + 1)\n    base += s['m'] / (n ** 2 + 1)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n\n    # Base estimate: size grows with sqrt(n), average degree shrinks the path length\n    base = (n ** 0.5) / (avg_deg ** 0.5 if avg_deg > 0 else 1)\n\n    # Dense graphs and hubs reduce the average shortest‑path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Uneven degree distribution (low min or high variance) lengthens paths\n    base *= (1 + (avg_deg - s['min_degree']) / (avg_deg + 1))\n    base *= (1 + s['std_degree'] / (avg_deg + 1))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity tends to lengthen paths\n    base /= (1 + abs(s['degree_assortativity']) ** 0.5)\n\n    # Minor additive contributions from triangles and edge density\n    base += s['num_triangles'] / (n ** 1.5 + 1)\n    base += s['m'] / (n ** 2 + 1)\n\n    return base", "spearman": 0.458777469436736, "pearson": 0.36533185722660155, "rmse": 2.6279148841988498, "mae": 2.291376443182273}}
{"timestamp": "2026-02-16T14:08:52.389947+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i0_p1_120927738", "generation": 4, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5261464585834333, "fitness_mode": "correlation", "simplicity_score": 0.22056848796131304, "novelty_bonus": 0.40964674116852906, "total_score": 0.3798255403883325, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling: larger graphs tend to have longer paths,\n    # but higher average degree shortens them.\n    n = s['n']\n    avg_deg = s['avg_degree']\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Density and hubs reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Low minimum degree or high degree variance increase path length\n    if avg_deg > 0:\n        base *= (1 + (1 - s['min_degree'] / avg_deg))\n        base *= (1 + s['std_degree'] / avg_deg)\n    else:\n        base *= 1\n\n    # Small‑world effect: clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity'])**0.5)\n\n    # Minor additive contribution from triangles\n    base += s['num_triangles'] / (n**1.5 + 1)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.032893\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.043597\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity, transitivity, and triangle counts.\n    It also uses the median degree to capture the central tendency of the\n    degree distribution without requiring additional statistics.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']          # sorted degree list\n\n    # Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5 if avg_deg > 0 else 1)\n\n    # Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density)\n    base /= (1.0 + max_deg / (n + 1.0))\n\n    # Increase the estimate when the degree distribution is uneven\n    if avg_deg > 0:\n        base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n        base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 1.5 + 1.0)\n\n    # Incorporate the median degree to capture central tendency\n    if n > 0:\n        mid = n // 2\n        median_deg = degrees[mid] if n % 2 == 1 else (degrees[mid - 1] + degrees[mid]) / 2.0\n        if avg_deg > 0:\n            base *= (1.0 + (median_deg - avg_deg) / (avg_deg + 1.0))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity, transitivity, and triangle counts.\n    It also uses the median degree to capture the central tendency of the\n    degree distribution without requiring additional statistics.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']          # sorted degree list\n\n    # Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5 if avg_deg > 0 else 1)\n\n    # Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density)\n    base /= (1.0 + max_deg / (n + 1.0))\n\n    # Increase the estimate when the degree distribution is uneven\n    if avg_deg > 0:\n        base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n        base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 1.5 + 1.0)\n\n    # Incorporate the median degree to capture central tendency\n    if n > 0:\n        mid = n // 2\n        median_deg = degrees[mid] if n % 2 == 1 else (degrees[mid - 1] + degrees[mid]) / 2.0\n        if avg_deg > 0:\n            base *= (1.0 + (median_deg - avg_deg) / (avg_deg + 1.0))\n\n    return base", "spearman": 0.42563564089102235, "pearson": 0.38471070115451866, "rmse": 4.035622406055705, "mae": 3.599556245749019}}
{"timestamp": "2026-02-16T14:09:31.358454+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i0_p2_944621608", "generation": 4, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.47265306122448975, "fitness_mode": "correlation", "simplicity_score": 0.22455965402780156, "novelty_bonus": 0.44703645631936806, "total_score": 0.41833060039468817, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling: larger graphs tend to have longer paths,\n    # but higher average degree shortens them.\n    n = s['n']\n    avg_deg = s['avg_degree']\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Density and hubs reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Low minimum degree or high degree variance increase path length\n    if avg_deg > 0:\n        base *= (1 + (1 - s['min_degree'] / avg_deg))\n        base *= (1 + s['std_degree'] / avg_deg)\n    else:\n        base *= 1\n\n    # Small‑world effect: clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity'])**0.5)\n\n    # Minor additive contribution from triangles\n    base += s['num_triangles'] / (n**1.5 + 1)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.032893\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.043597\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5 if avg_deg > 0 else 1)\n\n    # Density and hubs reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Degree heterogeneity tends to increase path length\n    if avg_deg > 0:\n        base *= (1 + (avg_deg - s['min_degree']) / (avg_deg + 1))\n        base *= (1 + s['std_degree'] / (avg_deg + 1))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Minor additive contribution from triangles\n    base += s['num_triangles'] / (n ** 1.5 + 1)\n\n    # Edge count scaling: more edges generally shorten paths\n    base *= (1 + s['m'] / (n ** 2 + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5 if avg_deg > 0 else 1)\n\n    # Density and hubs reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Degree heterogeneity tends to increase path length\n    if avg_deg > 0:\n        base *= (1 + (avg_deg - s['min_degree']) / (avg_deg + 1))\n        base *= (1 + s['std_degree'] / (avg_deg + 1))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Minor additive contribution from triangles\n    base += s['num_triangles'] / (n ** 1.5 + 1)\n\n    # Edge count scaling: more edges generally shorten paths\n    base *= (1 + s['m'] / (n ** 2 + 1))\n\n    return base", "spearman": 0.4786154653866348, "pearson": 0.37685261816356036, "rmse": 3.5680329054400777, "mae": 3.234292192917872}}
{"timestamp": "2026-02-16T14:09:59.108323+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.140071", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:09:59.108891+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.140071", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:10:17.903118+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.001297", "model_name": "gpt-oss:20b", "train_signal": 0.0012965186074429772}}
{"timestamp": "2026-02-16T14:10:17.904183+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:12:38.741359+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.142711", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:12:38.742070+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.142711", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:13:16.251292+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 0, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:13:16.252302+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 0, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:13:59.393535+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p0_772622318", "generation": 4, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.11806691093725447, "novelty_bonus": 0.17722193054826363, "total_score": 0.5110723186608628, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )\n\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Component terms\n    sparsity = n / (denom_edges + 1)                     # captures sparsity\n    size_clust = n**0.5 / (1 + avg_clust)                # size & clustering\n    degree_spread = avg_deg / (max_deg + 1)              # degree spread\n    assort_factor = 1 + abs(assort)                      # assortativity\n    trans_factor = 1 + trans                              # transitivity\n    triangle_factor = 1 + num_tri / denom_edges          # triangles per edge\n    density_factor = 1 / denom_density                   # inverse density\n    variance_factor = 1 / (1 + std_deg**2)               # degree variance\n    minmax_ratio = (max_deg + 1) / (min_deg + 1)          # min/max degree ratio\n\n    # Combine multiplicatively\n    return (\n        sparsity *\n        size_clust *\n        degree_spread *\n        assort_factor *\n        trans_factor *\n        triangle_factor *\n        density_factor *\n        variance_factor *\n        minmax_ratio\n    )\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_max_degree = max(max_degree, 1)\n    denom_min_degree = min_degree + 1\n\n    # Component terms\n    sparsity = n / (denom_edges + 1)                     # captures sparsity\n    size_clust = n**0.5 / (1 + avg_clustering)           # size & clustering\n    degree_spread = avg_degree / denom_max_degree        # degree spread\n    assort_factor = 1 + abs(degree_assortativity)        # assortativity\n    trans_factor = 1 + transitivity                      # transitivity\n    triangle_factor = 1 + num_triangles / denom_edges    # triangles per edge\n    density_factor = 1 / denom_density                   # inverse density\n    variance_factor = 1 / (1 + std_degree**2)            # degree variance\n    minmax_ratio = denom_max_degree / denom_min_degree   # min/max degree ratio\n\n    # Combine multiplicatively\n    return (\n        sparsity *\n        size_clust *\n        degree_spread *\n        assort_factor *\n        trans_factor *\n        triangle_factor *\n        density_factor *\n        variance_factor *\n        minmax_ratio\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_max_degree = max(max_degree, 1)\n    denom_min_degree = min_degree + 1\n\n    # Component terms\n    sparsity = n / (denom_edges + 1)                     # captures sparsity\n    size_clust = n**0.5 / (1 + avg_clustering)           # size & clustering\n    degree_spread = avg_degree / denom_max_degree        # degree spread\n    assort_factor = 1 + abs(degree_assortativity)        # assortativity\n    trans_factor = 1 + transitivity                      # transitivity\n    triangle_factor = 1 + num_triangles / denom_edges    # triangles per edge\n    density_factor = 1 / denom_density                   # inverse density\n    variance_factor = 1 / (1 + std_degree**2)            # degree variance\n    minmax_ratio = denom_max_degree / denom_min_degree   # min/max degree ratio\n\n    # Combine multiplicatively\n    return (\n        sparsity *\n        size_clust *\n        degree_spread *\n        assort_factor *\n        trans_factor *\n        triangle_factor *\n        density_factor *\n        variance_factor *\n        minmax_ratio\n    )", "spearman": 0.8685847146178655, "pearson": 0.8329734689997877, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T14:14:36.884295+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p1_154501553", "generation": 4, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.11828903250872277, "novelty_bonus": 0.17722193054826363, "total_score": 0.5111167429751564, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )\n\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Component terms\n    sparsity = n / (denom_edges + 1)                     # captures sparsity\n    size_clust = n**0.5 / (1 + avg_clust)                # size & clustering\n    degree_spread = avg_deg / (max_deg + 1)              # degree spread\n    assort_factor = 1 + abs(assort)                      # assortativity\n    trans_factor = 1 + trans                              # transitivity\n    triangle_factor = 1 + num_tri / denom_edges          # triangles per edge\n    density_factor = 1 / denom_density                   # inverse density\n    variance_factor = 1 / (1 + std_deg**2)               # degree variance\n    minmax_ratio = (max_deg + 1) / (min_deg + 1)          # min/max degree ratio\n\n    # Combine multiplicatively\n    return (\n        sparsity *\n        size_clust *\n        degree_spread *\n        assort_factor *\n        trans_factor *\n        triangle_factor *\n        density_factor *\n        variance_factor *\n        minmax_ratio\n    )\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Component terms\n    sparsity      = n / (denom_edges + 1)                     # captures sparsity\n    size_clust    = pow(n, 0.5) / (1 + avg_clust)              # size & clustering\n    degree_spread = avg_deg / (max_deg + 1)                    # degree spread\n    assort_factor = 1 + abs(assort)                            # assortativity\n    trans_factor  = 1 + trans                                   # transitivity\n    triangle_factor = 1 + num_tri / denom_edges                # triangles per edge\n    density_factor = 1 / denom_density                         # inverse density\n    variance_factor = 1 / (1 + std_deg**2)                     # degree variance\n    minmax_ratio   = (max_deg + 1) / (min_deg + 1)              # min/max degree ratio\n\n    # Combine multiplicatively\n    return (\n        sparsity *\n        size_clust *\n        degree_spread *\n        assort_factor *\n        trans_factor *\n        triangle_factor *\n        density_factor *\n        variance_factor *\n        minmax_ratio\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Component terms\n    sparsity      = n / (denom_edges + 1)                     # captures sparsity\n    size_clust    = pow(n, 0.5) / (1 + avg_clust)              # size & clustering\n    degree_spread = avg_deg / (max_deg + 1)                    # degree spread\n    assort_factor = 1 + abs(assort)                            # assortativity\n    trans_factor  = 1 + trans                                   # transitivity\n    triangle_factor = 1 + num_tri / denom_edges                # triangles per edge\n    density_factor = 1 / denom_density                         # inverse density\n    variance_factor = 1 / (1 + std_deg**2)                     # degree variance\n    minmax_ratio   = (max_deg + 1) / (min_deg + 1)              # min/max degree ratio\n\n    # Combine multiplicatively\n    return (\n        sparsity *\n        size_clust *\n        degree_spread *\n        assort_factor *\n        trans_factor *\n        triangle_factor *\n        density_factor *\n        variance_factor *\n        minmax_ratio\n    )", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T14:18:51.287148+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p2_803641956", "generation": 4, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.9020408163265305, "fitness_mode": "correlation", "simplicity_score": 0.12875448898167324, "novelty_bonus": 0.15637140928523197, "total_score": 0.520535267405575, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )\n\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Component terms\n    sparsity = n / (denom_edges + 1)                     # captures sparsity\n    size_clust = n**0.5 / (1 + avg_clust)                # size & clustering\n    degree_spread = avg_deg / (max_deg + 1)              # degree spread\n    assort_factor = 1 + abs(assort)                      # assortativity\n    trans_factor = 1 + trans                              # transitivity\n    triangle_factor = 1 + num_tri / denom_edges          # triangles per edge\n    density_factor = 1 / denom_density                   # inverse density\n    variance_factor = 1 / (1 + std_deg**2)               # degree variance\n    minmax_ratio = (max_deg + 1) / (min_deg + 1)          # min/max degree ratio\n\n    # Combine multiplicatively\n    return (\n        sparsity *\n        size_clust *\n        degree_spread *\n        assort_factor *\n        trans_factor *\n        triangle_factor *\n        density_factor *\n        variance_factor *\n        minmax_ratio\n    )\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9", "spearman": 0.8957458936473414, "pearson": 0.8461321815324823, "rmse": 35.993662628650526, "mae": 21.959389587623395}}
{"timestamp": "2026-02-16T14:19:42.560412+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p3_575393570", "generation": 4, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.11776205608658773, "novelty_bonus": 0.17722193054826363, "total_score": 0.5110113476907294, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )\n\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Component terms\n    sparsity = n / (denom_edges + 1)                     # captures sparsity\n    size_clust = n**0.5 / (1 + avg_clust)                # size & clustering\n    degree_spread = avg_deg / (max_deg + 1)              # degree spread\n    assort_factor = 1 + abs(assort)                      # assortativity\n    trans_factor = 1 + trans                              # transitivity\n    triangle_factor = 1 + num_tri / denom_edges          # triangles per edge\n    density_factor = 1 / denom_density                   # inverse density\n    variance_factor = 1 / (1 + std_deg**2)               # degree variance\n    minmax_ratio = (max_deg + 1) / (min_deg + 1)          # min/max degree ratio\n\n    # Combine multiplicatively\n    return (\n        sparsity *\n        size_clust *\n        degree_spread *\n        assort_factor *\n        trans_factor *\n        triangle_factor *\n        density_factor *\n        variance_factor *\n        minmax_ratio\n    )\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Composite invariant combining sparsity, size, clustering, degree spread,\n    assortativity, transitivity, triangle density, density, variance, and\n    degree ratio. All operations are safe against division by zero.\n    \"\"\"\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Component terms\n    sparsity = n / (denom_edges + 1)                     # captures sparsity\n    size_clust = pow(n, 0.5) / (1 + avg_clust)           # size & clustering\n    degree_spread = avg_deg / (max_deg + 1)              # degree spread\n    assort_factor = 1 + abs(assort)                      # assortativity\n    trans_factor = 1 + trans                              # transitivity\n    triangle_factor = 1 + tri_per_edge                   # triangles per edge\n    density_factor = 1 / denom_density                   # inverse density\n    variance_factor = 1 / (1 + deg_variance)             # degree variance\n    minmax_ratio = deg_ratio                              # min/max degree ratio\n\n    # Combine multiplicatively\n    return (\n        sparsity *\n        size_clust *\n        degree_spread *\n        assort_factor *\n        trans_factor *\n        triangle_factor *\n        density_factor *\n        variance_factor *\n        minmax_ratio\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Composite invariant combining sparsity, size, clustering, degree spread,\n    assortativity, transitivity, triangle density, density, variance, and\n    degree ratio. All operations are safe against division by zero.\n    \"\"\"\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Component terms\n    sparsity = n / (denom_edges + 1)                     # captures sparsity\n    size_clust = pow(n, 0.5) / (1 + avg_clust)           # size & clustering\n    degree_spread = avg_deg / (max_deg + 1)              # degree spread\n    assort_factor = 1 + abs(assort)                      # assortativity\n    trans_factor = 1 + trans                              # transitivity\n    triangle_factor = 1 + tri_per_edge                   # triangles per edge\n    density_factor = 1 / denom_density                   # inverse density\n    variance_factor = 1 / (1 + deg_variance)             # degree variance\n    minmax_ratio = deg_ratio                              # min/max degree ratio\n\n    # Combine multiplicatively\n    return (\n        sparsity *\n        size_clust *\n        degree_spread *\n        assort_factor *\n        trans_factor *\n        triangle_factor *\n        density_factor *\n        variance_factor *\n        minmax_ratio\n    )", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T14:20:16.270523+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p4_20598092", "generation": 4, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.11865380802946207, "novelty_bonus": 0.17722193054826363, "total_score": 0.5111896980793043, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )\n\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_edges = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Component terms\n    sparsity = n / (denom_edges + 1)                     # captures sparsity\n    size_clust = n**0.5 / (1 + avg_clust)                # size & clustering\n    degree_spread = avg_deg / (max_deg + 1)              # degree spread\n    assort_factor = 1 + abs(assort)                      # assortativity\n    trans_factor = 1 + trans                              # transitivity\n    triangle_factor = 1 + num_tri / denom_edges          # triangles per edge\n    density_factor = 1 / denom_density                   # inverse density\n    variance_factor = 1 / (1 + std_deg**2)               # degree variance\n    minmax_ratio = (max_deg + 1) / (min_deg + 1)          # min/max degree ratio\n\n    # Combine multiplicatively\n    return (\n        sparsity *\n        size_clust *\n        degree_spread *\n        assort_factor *\n        trans_factor *\n        triangle_factor *\n        density_factor *\n        variance_factor *\n        minmax_ratio\n    )\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Component terms\n    sparsity = n / (m + 1)                           # sparsity\n    size_clust = n**0.5 / (1 + avg_clust)            # size & clustering\n    degree_spread = avg_deg / (max_deg + 1)          # degree spread\n    assort_factor = 1 + abs(assort)                  # assortativity\n    trans_factor = 1 + trans                         # transitivity\n    triangle_factor = 1 + num_tri / max(m, 1)        # triangles per edge\n    density_factor = 1 / max(density, 1e-6)          # inverse density\n    variance_factor = 1 / (1 + std_deg**2)           # degree variance\n    minmax_ratio = (max_deg + 1) / (min_deg + 1)     # min/max degree ratio\n\n    # Combine multiplicatively\n    return (sparsity * size_clust * degree_spread *\n            assort_factor * trans_factor * triangle_factor *\n            density_factor * variance_factor * minmax_ratio)\n```", "extracted_code": "def new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Component terms\n    sparsity = n / (m + 1)                           # sparsity\n    size_clust = n**0.5 / (1 + avg_clust)            # size & clustering\n    degree_spread = avg_deg / (max_deg + 1)          # degree spread\n    assort_factor = 1 + abs(assort)                  # assortativity\n    trans_factor = 1 + trans                         # transitivity\n    triangle_factor = 1 + num_tri / max(m, 1)        # triangles per edge\n    density_factor = 1 / max(density, 1e-6)          # inverse density\n    variance_factor = 1 / (1 + std_deg**2)           # degree variance\n    minmax_ratio = (max_deg + 1) / (min_deg + 1)     # min/max degree ratio\n\n    # Combine multiplicatively\n    return (sparsity * size_clust * degree_spread *\n            assort_factor * trans_factor * triangle_factor *\n            density_factor * variance_factor * minmax_ratio)", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T14:20:59.298424+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.133719", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:20:59.299207+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.133719", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:21:39.859563+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 2, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.094434", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:21:39.860277+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 2, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:22:21.666926+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.125562", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:22:21.667564+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.125562", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:22:44.932220+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.137076", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:22:44.932771+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:23:22.094268+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i2_p2_125122364", "generation": 4, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.3963025210084033, "fitness_mode": "correlation", "simplicity_score": 0.12877101770971044, "novelty_bonus": 0.40361911653767635, "total_score": 0.3715208055249206, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.094434\nbelow_novelty_threshold: novelty_bonus=0.125562\nbelow_novelty_threshold: novelty_bonus=0.137076\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The estimate starts from a basic random‑graph\n    intuition and is refined by small multiplicative corrections that\n    capture clustering, density, degree heterogeneity, assortativity\n    and the presence of high‑degree hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float, -1..1)\n        - 'max_degree' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections ---------------------------------------------------------\n    # 1. Clustering: more triangles tend to lengthen paths\n    clustering_factor = 1.0 + s['avg_clustering']\n\n    # 2. Density: denser graphs have shorter paths\n    density_factor = 1.0 / (1.0 + s['density'])\n\n    # 3. Degree heterogeneity: a wide spread in degrees can create\n    #    shortcuts (high‑degree hubs), shortening paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'] / avg_deg)\n\n    # 4. Degree assortativity: disassortative mixing (high‑degree nodes\n    #    connected to low‑degree nodes) typically reduces path length.\n    #    We use a simple linear correction that only activates for\n    #    positive assortativity.\n    assort = s['degree_assortativity']\n    if assort < 0.0:\n        assort_factor = 1.0\n    else:\n        assort_factor = 1.0 / (1.0 + assort)\n\n    # 5. High‑degree hubs: a large max_degree relative to avg_degree\n    #    shortens the network.  The factor is capped at 1.\n    max_factor = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1.0))\n\n    # Combine all corrections ---------------------------------------------\n    return (rand_est * clustering_factor * density_factor *\n            hetero_factor * assort_factor * max_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The estimate starts from a basic random‑graph\n    intuition and is refined by small multiplicative corrections that\n    capture clustering, density, degree heterogeneity, assortativity\n    and the presence of high‑degree hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float, -1..1)\n        - 'max_degree' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections ---------------------------------------------------------\n    # 1. Clustering: more triangles tend to lengthen paths\n    clustering_factor = 1.0 + s['avg_clustering']\n\n    # 2. Density: denser graphs have shorter paths\n    density_factor = 1.0 / (1.0 + s['density'])\n\n    # 3. Degree heterogeneity: a wide spread in degrees can create\n    #    shortcuts (high‑degree hubs), shortening paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'] / avg_deg)\n\n    # 4. Degree assortativity: disassortative mixing (high‑degree nodes\n    #    connected to low‑degree nodes) typically reduces path length.\n    #    We use a simple linear correction that only activates for\n    #    positive assortativity.\n    assort = s['degree_assortativity']\n    if assort < 0.0:\n        assort_factor = 1.0\n    else:\n        assort_factor = 1.0 / (1.0 + assort)\n\n    # 5. High‑degree hubs: a large max_degree relative to avg_degree\n    #    shortens the network.  The factor is capped at 1.\n    max_factor = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1.0))\n\n    # Combine all corrections ---------------------------------------------\n    return (rand_est * clustering_factor * density_factor *\n            hetero_factor * assort_factor * max_factor)", "spearman": 0.44936173404335117, "pearson": 0.3193124028221387, "rmse": 1.2401154303978892, "mae": 0.9507782426673677}}
{"timestamp": "2026-02-16T14:24:16.429069+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:24:16.430143+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:25:05.517222+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i2_p3_526174836", "generation": 4, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.3835294117647059, "fitness_mode": "correlation", "simplicity_score": 0.1301415430168102, "novelty_bonus": 0.20672316807920177, "total_score": 0.1935136457367903, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.094434\nbelow_novelty_threshold: novelty_bonus=0.125562\nbelow_novelty_threshold: novelty_bonus=0.137076\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a blend of\n    random‑graph heuristics and corrections derived from pre‑computed\n    structural statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys include:\n        - 'n'                : number of nodes\n        - 'avg_degree'       : average node degree\n        - 'avg_clustering'   : average clustering coefficient\n        - 'density'          : edge density\n        - 'std_degree'       : standard deviation of degrees\n        - 'max_degree'       : maximum degree\n        - 'min_degree'       : minimum degree\n        - 'degree_assortativity' : assortativity coefficient\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    import numpy as np\n\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1e-6)          # avoid division by zero\n\n    # Base estimate from random graph theory:  ℓ ≈ ln(n)/ln(avg_deg)\n    base = np.log(n) / (np.log(avg_deg + 1.0) + 1e-9)\n\n    # Corrections\n    # 1. Clustering tends to increase path lengths\n    clustering = 1.0 + s['avg_clustering']\n\n    # 2. Higher density shortens distances\n    density = 1.0 / (1.0 + s['density'])\n\n    # 3. Degree heterogeneity (presence of hubs) reduces distances\n    hetero = 1.0 / (1.0 + s['std_degree'] / (avg_deg + 1e-6))\n\n    # 4. A larger maximum degree usually shrinks the graph\n    max_factor = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1e-6))\n\n    # 5. A very small minimum degree can increase distances\n    min_factor = 1.0 + (1.0 - s['min_degree'] / (avg_deg + 1e-6))\n\n    # 6. Positive assortativity tends to increase path lengths\n    assort_factor = 1.0 + s['degree_assortativity']\n\n    # Combine all components multiplicatively\n    return base * clustering * density * hetero * max_factor * min_factor * assort_factor\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph\n    statistics only.  The formula blends a simple random‑graph baseline\n    with multiplicative corrections for clustering, density, degree\n    heterogeneity, maximum/minimum degree and assortativity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys include:\n        - 'n'                : number of nodes\n        - 'avg_degree'       : average node degree\n        - 'avg_clustering'   : average clustering coefficient\n        - 'density'          : edge density\n        - 'std_degree'       : standard deviation of degrees\n        - 'max_degree'       : maximum degree\n        - 'min_degree'       : minimum degree\n        - 'degree_assortativity' : assortativity coefficient\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic scale factor: larger graphs with lower connectivity tend to\n    # have longer paths.  Use the square root of n for a sub‑linear\n    # growth and normalize by the square root of (avg_degree+1).\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1e-6)          # avoid division by zero\n    base = pow(n, 0.5) / (pow(avg_deg + 1.0, 0.5) + 1e-9)\n\n    # Corrections\n    clustering = 1.0 + s['avg_clustering']                # higher clustering → longer paths\n    density = 1.0 / (1.0 + s['density'])                  # denser graphs → shorter paths\n    hetero = 1.0 / (1.0 + s['std_degree'] / (avg_deg + 1e-6))  # hubs reduce distances\n    max_factor = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1e-6))  # large max degree shrinks graph\n    min_factor = 1.0 + (1.0 - s['min_degree'] / (avg_deg + 1e-6))   # very small min degree increases distances\n    assort_factor = 1.0 + s['degree_assortativity']          # positive assortativity tends to lengthen paths\n\n    # Combine all components multiplicatively\n    return base * clustering * density * hetero * max_factor * min_factor * assort_factor\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph\n    statistics only.  The formula blends a simple random‑graph baseline\n    with multiplicative corrections for clustering, density, degree\n    heterogeneity, maximum/minimum degree and assortativity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys include:\n        - 'n'                : number of nodes\n        - 'avg_degree'       : average node degree\n        - 'avg_clustering'   : average clustering coefficient\n        - 'density'          : edge density\n        - 'std_degree'       : standard deviation of degrees\n        - 'max_degree'       : maximum degree\n        - 'min_degree'       : minimum degree\n        - 'degree_assortativity' : assortativity coefficient\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic scale factor: larger graphs with lower connectivity tend to\n    # have longer paths.  Use the square root of n for a sub‑linear\n    # growth and normalize by the square root of (avg_degree+1).\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1e-6)          # avoid division by zero\n    base = pow(n, 0.5) / (pow(avg_deg + 1.0, 0.5) + 1e-9)\n\n    # Corrections\n    clustering = 1.0 + s['avg_clustering']                # higher clustering → longer paths\n    density = 1.0 / (1.0 + s['density'])                  # denser graphs → shorter paths\n    hetero = 1.0 / (1.0 + s['std_degree'] / (avg_deg + 1e-6))  # hubs reduce distances\n    max_factor = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1e-6))  # large max degree shrinks graph\n    min_factor = 1.0 + (1.0 - s['min_degree'] / (avg_deg + 1e-6))   # very small min degree increases distances\n    assort_factor = 1.0 + s['degree_assortativity']          # positive assortativity tends to lengthen paths\n\n    # Combine all components multiplicatively\n    return base * clustering * density * hetero * max_factor * min_factor * assort_factor", "spearman": 0.2109367734193355, "pearson": 0.2557369212037971, "rmse": 1.7006009900542127, "mae": 1.4278063799231109}}
{"timestamp": "2026-02-16T14:25:05.517901+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 2, "population_idx": 3, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:25:42.405230+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i2_p4_702666615", "generation": 4, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8002400960384153, "fitness_mode": "correlation", "simplicity_score": 0.1357324342541018, "novelty_bonus": 0.18531510619014213, "total_score": 0.4983586591488741, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.125562\nbelow_novelty_threshold: novelty_bonus=0.137076\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor", "spearman": 0.8312352808820221, "pearson": 0.7687141623903143, "rmse": 1.0208403095878051, "mae": 0.8662542382399789}}
{"timestamp": "2026-02-16T14:26:33.404125+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i3_p0_431975930", "generation": 4, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5806962785114045, "fitness_mode": "correlation", "simplicity_score": 0.1548007963727991, "novelty_bonus": 0.32561614040351006, "total_score": 0.4044441463742373, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using only\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        A scalar that is expected to correlate with the graph’s\n        average shortest‑path length.\n    \"\"\"\n    # Extract features with safe defaults\n    n                = float(s.get('n', 1))\n    m                = float(s.get('m', 0))\n    density          = float(s.get('density', 0.0))\n    avg_deg          = float(s.get('avg_degree', 0.0))\n    max_deg          = float(s.get('max_degree', 0))\n    min_deg          = float(s.get('min_degree', 1))\n    std_deg          = float(s.get('std_degree', 0.0))\n    avg_clust        = float(s.get('avg_clustering', 0.0))\n    trans            = float(s.get('transitivity', 0.0))\n    assort           = float(s.get('degree_assortativity', 0.0))\n    num_tri          = float(s.get('num_triangles', 0))\n    # degrees list is not needed for this estimator but retained for completeness\n    _ = s.get('degrees', [])\n\n    # Base density‑adjusted factor\n    base = (n + 1.0) / (m + 1.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Degree heterogeneity factor\n    hetero = (1.0 + std_deg) / (1.0 + avg_deg) if avg_deg != 0 else 1.0\n\n    # Clustering influence\n    cluster_factor = 1.0 / (1.0 + avg_clust)\n\n    # Transitivity multiplier\n    trans_factor = 1.0 + trans\n\n    # Assortativity multiplier\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle density influence\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range factor (captures extreme hubs)\n    deg_range_factor = (max_deg + 1) / (min_deg + 1)\n\n    # Combine all factors multiplicatively\n    estimate = (\n        base\n        * density_factor\n        * hetero\n        * cluster_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range_factor\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.094917\nbelow_novelty_threshold: novelty_bonus=0.114406\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from global graph statistics\n    without performing any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys include:\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity, num_triangles,\n        degrees (sorted ascending list of degrees).\n\n    Returns\n    -------\n    float\n        A single numeric value intended to correlate with the true average\n        shortest‑path length of the graph.\n    \"\"\"\n    # Basic quantities\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # Derived ratios / factors\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # 1. Baseline from node/edge ratio\n    base = (n + 1.0) / (m + 1.0)\n\n    # 2. Adjust for overall density\n    dens_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity (std / mean)\n    het_factor = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # 4. Clustering suppresses long paths\n    clus_factor = 1.0 / (1.0 + avg_clust)\n\n    # 5. Transitivity encourages alternative routes\n    trans_factor = 1.0 + trans\n\n    # 6. Assortativity influences mixing of high‑degree nodes\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Triangle presence reduces distance\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # 8. Range between hubs and leaf nodes\n    deg_range = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 9. Fraction of total degree held by the top 10% nodes\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # 10. Combine all influences multiplicatively\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clus_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from global graph statistics\n    without performing any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys include:\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity, num_triangles,\n        degrees (sorted ascending list of degrees).\n\n    Returns\n    -------\n    float\n        A single numeric value intended to correlate with the true average\n        shortest‑path length of the graph.\n    \"\"\"\n    # Basic quantities\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # Derived ratios / factors\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # 1. Baseline from node/edge ratio\n    base = (n + 1.0) / (m + 1.0)\n\n    # 2. Adjust for overall density\n    dens_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity (std / mean)\n    het_factor = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # 4. Clustering suppresses long paths\n    clus_factor = 1.0 / (1.0 + avg_clust)\n\n    # 5. Transitivity encourages alternative routes\n    trans_factor = 1.0 + trans\n\n    # 6. Assortativity influences mixing of high‑degree nodes\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Triangle presence reduces distance\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # 8. Range between hubs and leaf nodes\n    deg_range = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 9. Fraction of total degree held by the top 10% nodes\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # 10. Combine all influences multiplicatively\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clus_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)", "spearman": 0.551598289957249, "pearson": 0.49785731961787527, "rmse": 9.825653177358184, "mae": 4.345392106197964}}
{"timestamp": "2026-02-16T14:27:23.190438+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i3_p1_149471512", "generation": 4, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.49723889555822326, "fitness_mode": "correlation", "simplicity_score": 0.15596369126479426, "novelty_bonus": 0.37732243306082636, "total_score": 0.39439921841496295, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using only\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        A scalar that is expected to correlate with the graph’s\n        average shortest‑path length.\n    \"\"\"\n    # Extract features with safe defaults\n    n                = float(s.get('n', 1))\n    m                = float(s.get('m', 0))\n    density          = float(s.get('density', 0.0))\n    avg_deg          = float(s.get('avg_degree', 0.0))\n    max_deg          = float(s.get('max_degree', 0))\n    min_deg          = float(s.get('min_degree', 1))\n    std_deg          = float(s.get('std_degree', 0.0))\n    avg_clust        = float(s.get('avg_clustering', 0.0))\n    trans            = float(s.get('transitivity', 0.0))\n    assort           = float(s.get('degree_assortativity', 0.0))\n    num_tri          = float(s.get('num_triangles', 0))\n    # degrees list is not needed for this estimator but retained for completeness\n    _ = s.get('degrees', [])\n\n    # Base density‑adjusted factor\n    base = (n + 1.0) / (m + 1.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Degree heterogeneity factor\n    hetero = (1.0 + std_deg) / (1.0 + avg_deg) if avg_deg != 0 else 1.0\n\n    # Clustering influence\n    cluster_factor = 1.0 / (1.0 + avg_clust)\n\n    # Transitivity multiplier\n    trans_factor = 1.0 + trans\n\n    # Assortativity multiplier\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle density influence\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range factor (captures extreme hubs)\n    deg_range_factor = (max_deg + 1) / (min_deg + 1)\n\n    # Combine all factors multiplicatively\n    estimate = (\n        base\n        * density_factor\n        * hetero\n        * cluster_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range_factor\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.094917\nbelow_novelty_threshold: novelty_bonus=0.114406\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using only pre‑computed\n    graph statistics.  The formula mixes several multiplicative and\n    divisive terms, with fractional powers to introduce non‑linearity.\n    It never performs any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics.  Expected keys are:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted).\n\n    Returns\n    -------\n    float\n        A scalar that is intended to correlate with the average\n        shortest‑path length of the graph.\n    \"\"\"\n    # Basic numeric values (safely cast to float and provide defaults)\n    n        = float(s.get('n', 1))\n    m        = float(s.get('m', 0))\n    dens     = float(s.get('density', 0.0))\n    avg_deg  = float(s.get('avg_degree', 0.0))\n    max_deg  = float(s.get('max_degree', 1))\n    min_deg  = float(s.get('min_degree', 1))\n    std_deg  = float(s.get('std_degree', 0.0))\n    avg_clst = float(s.get('avg_clustering', 0.0))\n    trans    = float(s.get('transitivity', 0.0))\n    assort   = float(s.get('degree_assortativity', 0.0))\n    num_tri  = float(s.get('num_triangles', 0.0))\n\n    # ----- component factors -----\n    # Size–edge baseline with fractional powers\n    base = (n + 1.0) ** 0.4 / (m + 1.0) ** 0.6\n\n    # Adjust for global density\n    dens_factor = 1.0 / (1.0 + dens)\n\n    # Degree heterogeneity (relative std. dev.)\n    hetero = (1.0 + std_deg) ** 0.5 / (1.0 + avg_deg)\n\n    # Clustering influence\n    clust_factor = (1.0 + avg_clst) ** 0.3\n\n    # Transitivity multiplier\n    trans_factor = 1.0 + trans\n\n    # Assortativity (absolute value to keep sign neutral)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle density effect\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree‑range factor (captures extreme hubs)\n    deg_range_factor = (max_deg + 1) / (min_deg + 1)\n\n    # ----- composite estimate -----\n    estimate = (base * dens_factor * hetero * clust_factor *\n                trans_factor * assort_factor * tri_factor *\n                deg_range_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using only pre‑computed\n    graph statistics.  The formula mixes several multiplicative and\n    divisive terms, with fractional powers to introduce non‑linearity.\n    It never performs any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics.  Expected keys are:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted).\n\n    Returns\n    -------\n    float\n        A scalar that is intended to correlate with the average\n        shortest‑path length of the graph.\n    \"\"\"\n    # Basic numeric values (safely cast to float and provide defaults)\n    n        = float(s.get('n', 1))\n    m        = float(s.get('m', 0))\n    dens     = float(s.get('density', 0.0))\n    avg_deg  = float(s.get('avg_degree', 0.0))\n    max_deg  = float(s.get('max_degree', 1))\n    min_deg  = float(s.get('min_degree', 1))\n    std_deg  = float(s.get('std_degree', 0.0))\n    avg_clst = float(s.get('avg_clustering', 0.0))\n    trans    = float(s.get('transitivity', 0.0))\n    assort   = float(s.get('degree_assortativity', 0.0))\n    num_tri  = float(s.get('num_triangles', 0.0))\n\n    # ----- component factors -----\n    # Size–edge baseline with fractional powers\n    base = (n + 1.0) ** 0.4 / (m + 1.0) ** 0.6\n\n    # Adjust for global density\n    dens_factor = 1.0 / (1.0 + dens)\n\n    # Degree heterogeneity (relative std. dev.)\n    hetero = (1.0 + std_deg) ** 0.5 / (1.0 + avg_deg)\n\n    # Clustering influence\n    clust_factor = (1.0 + avg_clst) ** 0.3\n\n    # Transitivity multiplier\n    trans_factor = 1.0 + trans\n\n    # Assortativity (absolute value to keep sign neutral)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle density effect\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree‑range factor (captures extreme hubs)\n    deg_range_factor = (max_deg + 1) / (min_deg + 1)\n\n    # ----- composite estimate -----\n    estimate = (base * dens_factor * hetero * clust_factor *\n                trans_factor * assort_factor * tri_factor *\n                deg_range_factor)\n\n    return float(estimate)", "spearman": 0.5000195004875123, "pearson": 0.5689789326231596, "rmse": 1.911586684649379, "mae": 1.7643623639543773}}
{"timestamp": "2026-02-16T14:28:16.963315+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i3_p2_401139408", "generation": 4, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.39476590636254505, "fitness_mode": "correlation", "simplicity_score": 0.1545742764327731, "novelty_bonus": 0.4949538738468461, "total_score": 0.3805185453788069, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using only\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        A scalar that is expected to correlate with the graph’s\n        average shortest‑path length.\n    \"\"\"\n    # Extract features with safe defaults\n    n                = float(s.get('n', 1))\n    m                = float(s.get('m', 0))\n    density          = float(s.get('density', 0.0))\n    avg_deg          = float(s.get('avg_degree', 0.0))\n    max_deg          = float(s.get('max_degree', 0))\n    min_deg          = float(s.get('min_degree', 1))\n    std_deg          = float(s.get('std_degree', 0.0))\n    avg_clust        = float(s.get('avg_clustering', 0.0))\n    trans            = float(s.get('transitivity', 0.0))\n    assort           = float(s.get('degree_assortativity', 0.0))\n    num_tri          = float(s.get('num_triangles', 0))\n    # degrees list is not needed for this estimator but retained for completeness\n    _ = s.get('degrees', [])\n\n    # Base density‑adjusted factor\n    base = (n + 1.0) / (m + 1.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Degree heterogeneity factor\n    hetero = (1.0 + std_deg) / (1.0 + avg_deg) if avg_deg != 0 else 1.0\n\n    # Clustering influence\n    cluster_factor = 1.0 / (1.0 + avg_clust)\n\n    # Transitivity multiplier\n    trans_factor = 1.0 + trans\n\n    # Assortativity multiplier\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle density influence\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range factor (captures extreme hubs)\n    deg_range_factor = (max_deg + 1) / (min_deg + 1)\n\n    # Combine all factors multiplicatively\n    estimate = (\n        base\n        * density_factor\n        * hetero\n        * cluster_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range_factor\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.094917\nbelow_novelty_threshold: novelty_bonus=0.114406\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based only on pre‑computed\n    structural statistics.\n\n    The estimate mixes several multiplicative factors that capture the\n    following aspects of the graph:\n      * global sparsity (node‑to‑edge ratio),\n      * degree heterogeneity,\n      * triangle abundance,\n      * local clustering vs. global transitivity,\n      * degree assortativity,\n      * concentration of high‑degree nodes,\n      * presence of extreme hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        A scalar that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Basic statistics with sensible defaults\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    max_deg = float(s.get('max_degree', 0))\n    min_deg = float(s.get('min_degree', 1))\n    std_deg = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    num_tri = float(s.get('num_triangles', 0))\n    degrees = s.get('degrees', [])\n\n    # ------------------------------------------------------------------\n    # 1. Base factor: node‑to‑edge ratio (regularised)\n    # ------------------------------------------------------------------\n    base = (n + 1.0) / (m + 1.0)\n\n    # ------------------------------------------------------------------\n    # 2. Degree heterogeneity: (max – min) / (avg + 1)\n    # ------------------------------------------------------------------\n    hetero = 1.0 + (max_deg - min_deg) / (avg_deg + 1.0)\n\n    # ------------------------------------------------------------------\n    # 3. Triangle density adjustment (√num_tri / √n)\n    # ------------------------------------------------------------------\n    tri_factor = 1.0 + pow(num_tri, 0.5) / (pow(n, 0.5) + 1e-6)\n\n    # ------------------------------------------------------------------\n    # 4. Clustering vs. transitivity contrast\n    # ------------------------------------------------------------------\n    trans_diff = abs(avg_clust - trans)\n    cluster_diff = 1.0 + 0.5 * trans_diff\n\n    # ------------------------------------------------------------------\n    # 5. Assortativity multiplier\n    # ------------------------------------------------------------------\n    assort_factor = 1.0 + abs(assort)\n\n    # ------------------------------------------------------------------\n    # 6. High‑degree concentration factor\n    #    (captures how much of the degree mass is in the top 20 %)\n    # ------------------------------------------------------------------\n    top_k = max(1, int(0.2 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_ratio = high_sum / (total_deg + 1e-6)\n    hub_factor = 1.0 + (1.0 - high_ratio)\n\n    # ------------------------------------------------------------------\n    # 7. Extreme‑hub range factor\n    # ------------------------------------------------------------------\n    deg_range_factor = (max_deg + 1.0) / (min_deg + 1.0)\n\n    # ------------------------------------------------------------------\n    # 8. Assemble the composite estimate\n    # ------------------------------------------------------------------\n    estimate = (base *\n                hetero *\n                tri_factor *\n                cluster_diff *\n                assort_factor *\n                hub_factor *\n                deg_range_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based only on pre‑computed\n    structural statistics.\n\n    The estimate mixes several multiplicative factors that capture the\n    following aspects of the graph:\n      * global sparsity (node‑to‑edge ratio),\n      * degree heterogeneity,\n      * triangle abundance,\n      * local clustering vs. global transitivity,\n      * degree assortativity,\n      * concentration of high‑degree nodes,\n      * presence of extreme hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        A scalar that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Basic statistics with sensible defaults\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    max_deg = float(s.get('max_degree', 0))\n    min_deg = float(s.get('min_degree', 1))\n    std_deg = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    num_tri = float(s.get('num_triangles', 0))\n    degrees = s.get('degrees', [])\n\n    # ------------------------------------------------------------------\n    # 1. Base factor: node‑to‑edge ratio (regularised)\n    # ------------------------------------------------------------------\n    base = (n + 1.0) / (m + 1.0)\n\n    # ------------------------------------------------------------------\n    # 2. Degree heterogeneity: (max – min) / (avg + 1)\n    # ------------------------------------------------------------------\n    hetero = 1.0 + (max_deg - min_deg) / (avg_deg + 1.0)\n\n    # ------------------------------------------------------------------\n    # 3. Triangle density adjustment (√num_tri / √n)\n    # ------------------------------------------------------------------\n    tri_factor = 1.0 + pow(num_tri, 0.5) / (pow(n, 0.5) + 1e-6)\n\n    # ------------------------------------------------------------------\n    # 4. Clustering vs. transitivity contrast\n    # ------------------------------------------------------------------\n    trans_diff = abs(avg_clust - trans)\n    cluster_diff = 1.0 + 0.5 * trans_diff\n\n    # ------------------------------------------------------------------\n    # 5. Assortativity multiplier\n    # ------------------------------------------------------------------\n    assort_factor = 1.0 + abs(assort)\n\n    # ------------------------------------------------------------------\n    # 6. High‑degree concentration factor\n    #    (captures how much of the degree mass is in the top 20 %)\n    # ------------------------------------------------------------------\n    top_k = max(1, int(0.2 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_ratio = high_sum / (total_deg + 1e-6)\n    hub_factor = 1.0 + (1.0 - high_ratio)\n\n    # ------------------------------------------------------------------\n    # 7. Extreme‑hub range factor\n    # ------------------------------------------------------------------\n    deg_range_factor = (max_deg + 1.0) / (min_deg + 1.0)\n\n    # ------------------------------------------------------------------\n    # 8. Assemble the composite estimate\n    # ------------------------------------------------------------------\n    estimate = (base *\n                hetero *\n                tri_factor *\n                cluster_diff *\n                assort_factor *\n                hub_factor *\n                deg_range_factor)\n\n    return float(estimate)", "spearman": 0.4022350558763969, "pearson": 0.4385491405447689, "rmse": 29.452220634182027, "mae": 18.156737057030778}}
{"timestamp": "2026-02-16T14:29:27.840098+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.172777", "model_name": "gpt-oss:20b", "train_signal": 0.17277725760700632}}
{"timestamp": "2026-02-16T14:30:11.910710+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.094358", "model_name": "gpt-oss:20b", "train_signal": 0.09435774309723889}}
{"timestamp": "2026-02-16T14:30:11.914553+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 5, "model_name": "gpt-oss:20b", "best_val_score": 0.526450498609911, "no_improve_count": 1}}
{"timestamp": "2026-02-16T14:30:42.346059+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i0_p0_856147299", "generation": 5, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5779111644657863, "fitness_mode": "correlation", "simplicity_score": 0.22516744754638907, "novelty_bonus": 0.3695448619332222, "total_score": 0.45394014916927156, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling: larger graphs tend to have longer paths,\n    # but higher average degree shortens them.\n    n = s['n']\n    avg_deg = s['avg_degree']\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Density and hubs reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Low minimum degree or high degree variance increase path length\n    if avg_deg > 0:\n        base *= (1 + (1 - s['min_degree'] / avg_deg))\n        base *= (1 + s['std_degree'] / avg_deg)\n    else:\n        base *= 1\n\n    # Small‑world effect: clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity'])**0.5)\n\n    # Minor additive contribution from triangles\n    base += s['num_triangles'] / (n**1.5 + 1)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.001297\nbelow_novelty_threshold: novelty_bonus=0.142711\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using a compact combination of\n    pre‑computed graph statistics.  The formula is deliberately simple\n    (no loops, no imports) but captures several key structural effects:\n    - Size and average degree (basic scaling)\n    - Density, maximum degree and minimum degree (hub / sparsity effects)\n    - Degree variance and assortativity (heterogeneity)\n    - Small‑world indicators (clustering, transitivity)\n    - Triangle count (local redundancy)\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    # Basic scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Reduce path length for dense graphs and for the presence of hubs\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Increase path length when the degree distribution is uneven\n    if avg_deg > 0:\n        base *= (1 + (s['max_degree'] - s['min_degree']) / (s['max_degree'] + 1))\n        base *= (1 + s['std_degree'] / (avg_deg + 1))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1 + s['avg_clustering'])\n    base *= (1 + s['transitivity'])\n\n    # Assortativity tends to lengthen paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Minor additive contribution from the number of triangles\n    base += s['num_triangles'] / (n**1.5 + 1)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using a compact combination of\n    pre‑computed graph statistics.  The formula is deliberately simple\n    (no loops, no imports) but captures several key structural effects:\n    - Size and average degree (basic scaling)\n    - Density, maximum degree and minimum degree (hub / sparsity effects)\n    - Degree variance and assortativity (heterogeneity)\n    - Small‑world indicators (clustering, transitivity)\n    - Triangle count (local redundancy)\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    # Basic scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Reduce path length for dense graphs and for the presence of hubs\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Increase path length when the degree distribution is uneven\n    if avg_deg > 0:\n        base *= (1 + (s['max_degree'] - s['min_degree']) / (s['max_degree'] + 1))\n        base *= (1 + s['std_degree'] / (avg_deg + 1))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1 + s['avg_clustering'])\n    base *= (1 + s['transitivity'])\n\n    # Assortativity tends to lengthen paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Minor additive contribution from the number of triangles\n    base += s['num_triangles'] / (n**1.5 + 1)\n\n    return base", "spearman": 0.5960864021600542, "pearson": 0.6031039503664523, "rmse": 5.323348424713115, "mae": 4.959985999728184}}
{"timestamp": "2026-02-16T14:34:45.649321+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i0_p1_71923380", "generation": 5, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5755102040816326, "fitness_mode": "correlation", "simplicity_score": 0.22327328117201903, "novelty_bonus": 0.16381338445746063, "total_score": 0.3576657682490589, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling: larger graphs tend to have longer paths,\n    # but higher average degree shortens them.\n    n = s['n']\n    avg_deg = s['avg_degree']\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Density and hubs reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Low minimum degree or high degree variance increase path length\n    if avg_deg > 0:\n        base *= (1 + (1 - s['min_degree'] / avg_deg))\n        base *= (1 + s['std_degree'] / avg_deg)\n    else:\n        base *= 1\n\n    # Small‑world effect: clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity'])**0.5)\n\n    # Minor additive contribution from triangles\n    base += s['num_triangles'] / (n**1.5 + 1)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.001297\nbelow_novelty_threshold: novelty_bonus=0.142711\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    assortativity, and triangle counts in a compact, interpretable way.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n\n    # Base estimate: larger graphs and lower average degree give longer paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce length for dense graphs\n    base /= (1.0 + s['density'])\n\n    # Reduce length for graphs with hubs (high max degree)\n    base /= (1.0 + s['max_degree'] / n)\n\n    # Increase length when minimum degree is low\n    base *= (1.0 + (1.0 - s['min_degree'] / avg_deg))\n\n    # Increase length when degree variance is high\n    base *= (1.0 + s['std_degree'] / avg_deg)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base /= (1.0 + s['avg_clustering'])\n    base /= (1.0 + s['transitivity'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base *= (1.0 + abs(s['degree_assortativity']))\n\n    # Minor additive contribution from triangles\n    base += s['num_triangles'] / (n ** 2 + 1.0)\n\n    # Harmonic mean of degrees: high harmonic mean (many high‑degree nodes)\n    # tends to shorten paths\n    degs = s['degrees']\n    if degs:\n        inv_sum = 0.0\n        for d in degs:\n            inv_sum += 1.0 / (d + 1.0)\n        harmonic = len(degs) / inv_sum\n        base /= (1.0 + harmonic / avg_deg)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    assortativity, and triangle counts in a compact, interpretable way.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n\n    # Base estimate: larger graphs and lower average degree give longer paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce length for dense graphs\n    base /= (1.0 + s['density'])\n\n    # Reduce length for graphs with hubs (high max degree)\n    base /= (1.0 + s['max_degree'] / n)\n\n    # Increase length when minimum degree is low\n    base *= (1.0 + (1.0 - s['min_degree'] / avg_deg))\n\n    # Increase length when degree variance is high\n    base *= (1.0 + s['std_degree'] / avg_deg)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base /= (1.0 + s['avg_clustering'])\n    base /= (1.0 + s['transitivity'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base *= (1.0 + abs(s['degree_assortativity']))\n\n    # Minor additive contribution from triangles\n    base += s['num_triangles'] / (n ** 2 + 1.0)\n\n    # Harmonic mean of degrees: high harmonic mean (many high‑degree nodes)\n    # tends to shorten paths\n    degs = s['degrees']\n    if degs:\n        inv_sum = 0.0\n        for d in degs:\n            inv_sum += 1.0 / (d + 1.0)\n        harmonic = len(degs) / inv_sum\n        base /= (1.0 + harmonic / avg_deg)\n\n    return base", "spearman": 0.5277341933548338, "pearson": 0.5107309834447955, "rmse": 1.7749788465930858, "mae": 1.242761118899471}}
{"timestamp": "2026-02-16T14:35:12.706960+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i0_p2_640793675", "generation": 5, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5852100840336134, "fitness_mode": "correlation", "simplicity_score": 0.22404398051287003, "novelty_bonus": 0.29029540515742847, "total_score": 0.5141699744637229, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling: larger graphs tend to have longer paths,\n    # but higher average degree shortens them.\n    n = s['n']\n    avg_deg = s['avg_degree']\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Density and hubs reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Low minimum degree or high degree variance increase path length\n    if avg_deg > 0:\n        base *= (1 + (1 - s['min_degree'] / avg_deg))\n        base *= (1 + s['std_degree'] / avg_deg)\n    else:\n        base *= 1\n\n    # Small‑world effect: clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity'])**0.5)\n\n    # Minor additive contribution from triangles\n    base += s['num_triangles'] / (n**1.5 + 1)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.001297\nbelow_novelty_threshold: novelty_bonus=0.142711\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, and triangle counts in a compact, interpretable\n    way.  No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    # Basic scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, and triangle counts in a compact, interpretable\n    way.  No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    # Basic scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base", "spearman": 0.7645451136278407, "pearson": 0.7235486314870165, "rmse": 3.7546492969815093, "mae": 3.5404028333115094}}
{"timestamp": "2026-02-16T14:35:55.782064+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i0_p3_940111966", "generation": 5, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.41042016806722686, "fitness_mode": "correlation", "simplicity_score": 0.22460841389224223, "novelty_bonus": 0.4984281714437879, "total_score": 0.4127393414417656, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling: larger graphs tend to have longer paths,\n    # but higher average degree shortens them.\n    n = s['n']\n    avg_deg = s['avg_degree']\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Density and hubs reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Low minimum degree or high degree variance increase path length\n    if avg_deg > 0:\n        base *= (1 + (1 - s['min_degree'] / avg_deg))\n        base *= (1 + s['std_degree'] / avg_deg)\n    else:\n        base *= 1\n\n    # Small‑world effect: clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity'])**0.5)\n\n    # Minor additive contribution from triangles\n    base += s['num_triangles'] / (n**1.5 + 1)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.001297\nbelow_novelty_threshold: novelty_bonus=0.142711\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree heterogeneity, density, hubs, small‑world\n    effects, assortativity and triangle counts.  All operations are simple\n    arithmetic; no external libraries are required.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # Base scaling: larger graphs → longer paths; higher avg degree → shorter paths.\n    base = (n ** 0.5) / (avg_deg ** 0.5 + density + max_deg / n)\n\n    # Degree heterogeneity: low min or high variance lengthen paths.\n    base *= (1.0 + (avg_deg - min_deg) / avg_deg + std_deg / avg_deg)\n\n    # Small‑world effect: higher clustering/transitivity shorten paths.\n    base *= (1.0 + (clustering + trans) / 2.0)\n\n    # Assortativity: highly assortative graphs tend to have longer paths.\n    base /= (1.0 + abs(assort) ** 0.5)\n\n    # Minor additive contribution from triangles (normalized by graph size).\n    base += triangles / (n ** 1.5 + 1.0)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree heterogeneity, density, hubs, small‑world\n    effects, assortativity and triangle counts.  All operations are simple\n    arithmetic; no external libraries are required.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # Base scaling: larger graphs → longer paths; higher avg degree → shorter paths.\n    base = (n ** 0.5) / (avg_deg ** 0.5 + density + max_deg / n)\n\n    # Degree heterogeneity: low min or high variance lengthen paths.\n    base *= (1.0 + (avg_deg - min_deg) / avg_deg + std_deg / avg_deg)\n\n    # Small‑world effect: higher clustering/transitivity shorten paths.\n    base *= (1.0 + (clustering + trans) / 2.0)\n\n    # Assortativity: highly assortative graphs tend to have longer paths.\n    base /= (1.0 + abs(assort) ** 0.5)\n\n    # Minor additive contribution from triangles (normalized by graph size).\n    base += triangles / (n ** 1.5 + 1.0)\n\n    return base", "spearman": 0.43657841446036155, "pearson": 0.3665110642224305, "rmse": 3.3614517058816835, "mae": 3.0468685986249113}}
{"timestamp": "2026-02-16T14:37:05.705283+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i0_p4_622909180", "generation": 5, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.4633373349339736, "fitness_mode": "correlation", "simplicity_score": 0.22382132804606963, "novelty_bonus": 0.3551215659386674, "total_score": 0.38163224367852133, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling: larger graphs tend to have longer paths,\n    # but higher average degree shortens them.\n    n = s['n']\n    avg_deg = s['avg_degree']\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Density and hubs reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Low minimum degree or high degree variance increase path length\n    if avg_deg > 0:\n        base *= (1 + (1 - s['min_degree'] / avg_deg))\n        base *= (1 + s['std_degree'] / avg_deg)\n    else:\n        base *= 1\n\n    # Small‑world effect: clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity'])**0.5)\n\n    # Minor additive contribution from triangles\n    base += s['num_triangles'] / (n**1.5 + 1)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.001297\nbelow_novelty_threshold: novelty_bonus=0.142711\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree heterogeneity, density, clustering,\n    assortativity, and triangle counts in a compact, interpretable way.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n\n    # Base scaling: larger graphs → longer paths, higher average degree → shorter paths\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Increase the estimate when the degree distribution is uneven\n    base *= (1 + (s['max_degree'] - avg_deg) / (avg_deg + 1))\n    base *= (1 + s['std_degree'] / (avg_deg + 1))\n    base *= (1 + (avg_deg - s['min_degree']) / (avg_deg + 1))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity tends to lengthen paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Minor additive contributions from triangles and edge density\n    base += s['num_triangles'] / (n**1.5 + 1)\n    base += s['m'] / (n**2 + 1)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree heterogeneity, density, clustering,\n    assortativity, and triangle counts in a compact, interpretable way.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n\n    # Base scaling: larger graphs → longer paths, higher average degree → shorter paths\n    base = n**0.5 / (avg_deg**0.5 if avg_deg > 0 else 1)\n\n    # Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Increase the estimate when the degree distribution is uneven\n    base *= (1 + (s['max_degree'] - avg_deg) / (avg_deg + 1))\n    base *= (1 + s['std_degree'] / (avg_deg + 1))\n    base *= (1 + (avg_deg - s['min_degree']) / (avg_deg + 1))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1 + (s['avg_clustering'] + s['transitivity']) / 2)\n\n    # Assortativity tends to lengthen paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Minor additive contributions from triangles and edge density\n    base += s['num_triangles'] / (n**1.5 + 1)\n    base += s['m'] / (n**2 + 1)\n\n    return base", "spearman": 0.4606630165754144, "pearson": 0.43479530970528146, "rmse": 13.91727237043685, "mae": 9.350072984663761}}
{"timestamp": "2026-02-16T14:37:50.192994+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i1_p0_296777574", "generation": 5, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.1289634878010235, "novelty_bonus": 0.17722193054826363, "total_score": 0.5132516340336165, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Extract features\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Safe denominators\n    denom_m = m + 1\n    denom_edges = max(m, 1)\n    denom_density = density if density > 0 else 1e-6\n    denom_min_deg = min_deg + 1\n    denom_max_deg = max_deg + 1\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg * std_deg\n    deg_ratio = denom_max_deg / denom_min_deg\n\n    # Composite parts\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clust)   # size & clustering\n    part3 = avg_deg / denom_max_deg         # degree spread\n    part4 = 1 + abs(assort)                 # assortativity\n    part5 = 1 + trans                       # transitivity\n    part6 = 1 + tri_per_edge                # triangles per edge\n    part7 = deg_ratio                       # degree ratio\n    part8 = 1 / (1 + deg_variance)          # degree variance penalty\n    part9 = 1 / denom_density               # density penalty\n\n    # Final invariant\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\n```", "extracted_code": "def new_invariant(s):\n    # Extract features\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Safe denominators\n    denom_m = m + 1\n    denom_edges = max(m, 1)\n    denom_density = density if density > 0 else 1e-6\n    denom_min_deg = min_deg + 1\n    denom_max_deg = max_deg + 1\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg * std_deg\n    deg_ratio = denom_max_deg / denom_min_deg\n\n    # Composite parts\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clust)   # size & clustering\n    part3 = avg_deg / denom_max_deg         # degree spread\n    part4 = 1 + abs(assort)                 # assortativity\n    part5 = 1 + trans                       # transitivity\n    part6 = 1 + tri_per_edge                # triangles per edge\n    part7 = deg_ratio                       # degree ratio\n    part8 = 1 / (1 + deg_variance)          # degree variance penalty\n    part9 = 1 / denom_density               # density penalty\n\n    # Final invariant\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T14:38:57.969321+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i1_p1_232838438", "generation": 5, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.9054021608643457, "fitness_mode": "correlation", "simplicity_score": 0.12858053794482588, "novelty_bonus": 0.15329783244581097, "total_score": 0.5195394031713547, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_max_degree = max(max_degree, 1)\n    denom_min_degree = max(min_degree, 1)\n\n    # Derived ratios\n    tri_per_edge = num_triangles / denom_m\n    deg_variance = std_degree ** 2\n    deg_ratio = (max_degree + 1) / (min_degree + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / denom_m\n    part2 = n**0.5 / denom_density\n    part3 = 1 + avg_clustering\n    part4 = 1 + abs(degree_assortativity)\n    part5 = 1 + transitivity\n    part6 = 1 + tri_per_edge\n    part7 = avg_degree / (max_degree + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_max_degree = max(max_degree, 1)\n    denom_min_degree = max(min_degree, 1)\n\n    # Derived ratios\n    tri_per_edge = num_triangles / denom_m\n    deg_variance = std_degree ** 2\n    deg_ratio = (max_degree + 1) / (min_degree + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / denom_m\n    part2 = n**0.5 / denom_density\n    part3 = 1 + avg_clustering\n    part4 = 1 + abs(degree_assortativity)\n    part5 = 1 + transitivity\n    part6 = 1 + tri_per_edge\n    part7 = avg_degree / (max_degree + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9", "spearman": 0.8956678916972926, "pearson": 0.8483101039460296, "rmse": 36.303746202513345, "mae": 22.168601133708645}}
{"timestamp": "2026-02-16T14:39:45.570440+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i1_p2_932230359", "generation": 5, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.9054021608643457, "fitness_mode": "correlation", "simplicity_score": 0.12911696625811495, "novelty_bonus": 0.15329783244581097, "total_score": 0.5196466888340125, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = n ** 0.5 / denom_density        # size & density\n    part3 = 1 + avg_clust                   # clustering\n    part4 = 1 + abs(assort)                 # assortativity\n    part5 = 1 + trans                       # transitivity\n    part6 = 1 + tri_per_edge                # triangles per edge\n    part7 = avg_deg / (max_deg + 1)         # average degree relative to max\n    part8 = deg_ratio                       # degree spread\n    part9 = 1 / (1 + deg_variance)          # degree variance penalty\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = n ** 0.5 / denom_density        # size & density\n    part3 = 1 + avg_clust                   # clustering\n    part4 = 1 + abs(assort)                 # assortativity\n    part5 = 1 + trans                       # transitivity\n    part6 = 1 + tri_per_edge                # triangles per edge\n    part7 = avg_deg / (max_deg + 1)         # average degree relative to max\n    part8 = deg_ratio                       # degree spread\n    part9 = 1 / (1 + deg_variance)          # degree variance penalty\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9", "spearman": 0.8956678916972926, "pearson": 0.8483101039460296, "rmse": 36.303746202513345, "mae": 22.168601133708645}}
{"timestamp": "2026-02-16T14:40:54.836773+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i1_p3_662157059", "generation": 5, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.12863800483186277, "novelty_bonus": 0.17722193054826363, "total_score": 0.5131865374397844, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n\n    # Optional features with defaults\n    density      = s.get('density', 1e-6)\n    avg_clust    = s.get('avg_clustering', 0.0)\n    trans        = s.get('transitivity', 0.0)\n    assort       = s.get('degree_assortativity', 0.0)\n    num_tri      = s.get('num_triangles', 0)\n    std_deg      = s.get('std_degree', 0.0)\n    max_deg      = s.get('max_degree', 0)\n    min_deg      = s.get('min_degree', 0)\n    avg_deg      = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m       = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges   = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge  = num_tri / denom_edges\n    deg_variance  = std_deg ** 2\n    deg_ratio     = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / denom_density           # size & density\n    part3 = 1 / (1 + avg_clust)                   # clustering penalty\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangle density\n    part7 = avg_deg / (max_deg + 1)               # degree spread\n    part8 = deg_ratio                             # degree ratio\n    part9 = 1 / (1 + deg_variance)                # degree variance penalty\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n\n    # Optional features with defaults\n    density      = s.get('density', 1e-6)\n    avg_clust    = s.get('avg_clustering', 0.0)\n    trans        = s.get('transitivity', 0.0)\n    assort       = s.get('degree_assortativity', 0.0)\n    num_tri      = s.get('num_triangles', 0)\n    std_deg      = s.get('std_degree', 0.0)\n    max_deg      = s.get('max_degree', 0)\n    min_deg      = s.get('min_degree', 0)\n    avg_deg      = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m       = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges   = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge  = num_tri / denom_edges\n    deg_variance  = std_deg ** 2\n    deg_ratio     = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / denom_density           # size & density\n    part3 = 1 / (1 + avg_clust)                   # clustering penalty\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangle density\n    part7 = avg_deg / (max_deg + 1)               # degree spread\n    part8 = deg_ratio                             # degree ratio\n    part9 = 1 / (1 + deg_variance)                # degree variance penalty\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T14:41:34.481908+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i1_p4_403531943", "generation": 5, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.9020408163265305, "fitness_mode": "correlation", "simplicity_score": 0.12930599035576518, "novelty_bonus": 0.15637140928523197, "total_score": 0.5206455676803934, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n\n    # Avoid division by zero\n    denom_edges   = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio    = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    return (\n        (n ** 0.5) / denom_density\n        * (1 + avg_clust)\n        * (1 + abs(assort))\n        * (1 + tri_per_edge)\n        * (1 + trans)\n        * deg_ratio\n        / (1 + deg_variance)\n    )\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )", "spearman": 0.8957458936473414, "pearson": 0.8461321815324823, "rmse": 35.993662628650526, "mae": 21.959389587623395}}
{"timestamp": "2026-02-16T14:42:12.592249+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i2_p0_105421529", "generation": 5, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.44432172869147657, "fitness_mode": "correlation", "simplicity_score": 0.1801179049216806, "novelty_bonus": 0.4171864893138574, "total_score": 0.39633440665046515, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The estimate starts from a basic random‑graph\n    intuition and is refined by small multiplicative corrections that\n    capture clustering, density, degree heterogeneity, assortativity\n    and the presence of high‑degree hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float, -1..1)\n        - 'max_degree' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections ---------------------------------------------------------\n    # 1. Clustering: more triangles tend to lengthen paths\n    clustering_factor = 1.0 + s['avg_clustering']\n\n    # 2. Density: denser graphs have shorter paths\n    density_factor = 1.0 / (1.0 + s['density'])\n\n    # 3. Degree heterogeneity: a wide spread in degrees can create\n    #    shortcuts (high‑degree hubs), shortening paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'] / avg_deg)\n\n    # 4. Degree assortativity: disassortative mixing (high‑degree nodes\n    #    connected to low‑degree nodes) typically reduces path length.\n    #    We use a simple linear correction that only activates for\n    #    positive assortativity.\n    assort = s['degree_assortativity']\n    if assort < 0.0:\n        assort_factor = 1.0\n    else:\n        assort_factor = 1.0 / (1.0 + assort)\n\n    # 5. High‑degree hubs: a large max_degree relative to avg_degree\n    #    shortens the network.  The factor is capped at 1.\n    max_factor = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1.0))\n\n    # Combine all corrections ---------------------------------------------\n    return (rand_est * clustering_factor * density_factor *\n            hetero_factor * assort_factor * max_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.125562\nbelow_novelty_threshold: novelty_bonus=0.137076\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The formula is intentionally simple: it starts\n    from a basic random‑graph intuition and applies multiplicative\n    corrections for clustering, density, degree heterogeneity,\n    assortativity and the presence of high‑degree hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics.  Expected keys include:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'degree_assortativity' (float, -1..1)\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Correction factors\n    # 1. Clustering: more triangles tend to lengthen paths\n    clustering = s['avg_clustering'] if s['avg_clustering'] is not None else 0.0\n    clustering_factor = 1.0 + clustering\n\n    # 2. Density: denser graphs have shorter paths\n    density = s['density'] if s['density'] is not None else 0.0\n    density_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity: a wide spread can create shortcuts\n    std_deg = s['std_degree'] if s['std_degree'] is not None else 0.0\n    hetero_factor = 1.0 / (1.0 + std_deg / avg_deg)\n\n    # 4. Degree assortativity: disassortative mixing shortens paths\n    assort = s['degree_assortativity'] if s['degree_assortativity'] is not None else 0.0\n    assort_factor = 1.0 if assort < 0.0 else 1.0 / (1.0 + assort)\n\n    # 5. High‑degree hubs: large max_degree relative to avg_degree shortens paths\n    max_deg = s['max_degree'] if s['max_degree'] is not None else 0\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # 6. Very low min_degree can lengthen paths\n    min_deg = s['min_degree'] if s['min_degree'] is not None else 0\n    min_factor = 1.0 / (1.0 + min_deg / avg_deg)\n\n    # Combine all corrections multiplicatively\n    estimate = (base * clustering_factor * density_factor *\n                hetero_factor * assort_factor * max_factor * min_factor)\n\n    return estimate", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The formula is intentionally simple: it starts\n    from a basic random‑graph intuition and applies multiplicative\n    corrections for clustering, density, degree heterogeneity,\n    assortativity and the presence of high‑degree hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics.  Expected keys include:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'degree_assortativity' (float, -1..1)\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Correction factors\n    # 1. Clustering: more triangles tend to lengthen paths\n    clustering = s['avg_clustering'] if s['avg_clustering'] is not None else 0.0\n    clustering_factor = 1.0 + clustering\n\n    # 2. Density: denser graphs have shorter paths\n    density = s['density'] if s['density'] is not None else 0.0\n    density_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity: a wide spread can create shortcuts\n    std_deg = s['std_degree'] if s['std_degree'] is not None else 0.0\n    hetero_factor = 1.0 / (1.0 + std_deg / avg_deg)\n\n    # 4. Degree assortativity: disassortative mixing shortens paths\n    assort = s['degree_assortativity'] if s['degree_assortativity'] is not None else 0.0\n    assort_factor = 1.0 if assort < 0.0 else 1.0 / (1.0 + assort)\n\n    # 5. High‑degree hubs: large max_degree relative to avg_degree shortens paths\n    max_deg = s['max_degree'] if s['max_degree'] is not None else 0\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # 6. Very low min_degree can lengthen paths\n    min_deg = s['min_degree'] if s['min_degree'] is not None else 0\n    min_factor = 1.0 / (1.0 + min_deg / avg_deg)\n\n    # Combine all corrections multiplicatively\n    estimate = (base * clustering_factor * density_factor *\n                hetero_factor * assort_factor * max_factor * min_factor)\n\n    return estimate", "spearman": 0.4703097577439436, "pearson": 0.3659337450537286, "rmse": 1.4200639068038812, "mae": 1.1439869296905798}}
{"timestamp": "2026-02-16T14:42:47.080543+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i2_p1_209561863", "generation": 5, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.6302521008403361, "fitness_mode": "correlation", "simplicity_score": 0.1265159966661264, "novelty_bonus": 0.1808103527356819, "total_score": 0.41016357058556574, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The estimate starts from a basic random‑graph\n    intuition and is refined by small multiplicative corrections that\n    capture clustering, density, degree heterogeneity, assortativity\n    and the presence of high‑degree hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float, -1..1)\n        - 'max_degree' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections ---------------------------------------------------------\n    # 1. Clustering: more triangles tend to lengthen paths\n    clustering_factor = 1.0 + s['avg_clustering']\n\n    # 2. Density: denser graphs have shorter paths\n    density_factor = 1.0 / (1.0 + s['density'])\n\n    # 3. Degree heterogeneity: a wide spread in degrees can create\n    #    shortcuts (high‑degree hubs), shortening paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'] / avg_deg)\n\n    # 4. Degree assortativity: disassortative mixing (high‑degree nodes\n    #    connected to low‑degree nodes) typically reduces path length.\n    #    We use a simple linear correction that only activates for\n    #    positive assortativity.\n    assort = s['degree_assortativity']\n    if assort < 0.0:\n        assort_factor = 1.0\n    else:\n        assort_factor = 1.0 / (1.0 + assort)\n\n    # 5. High‑degree hubs: a large max_degree relative to avg_degree\n    #    shortens the network.  The factor is capped at 1.\n    max_factor = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1.0))\n\n    # Combine all corrections ---------------------------------------------\n    return (rand_est * clustering_factor * density_factor *\n            hetero_factor * assort_factor * max_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.125562\nbelow_novelty_threshold: novelty_bonus=0.137076\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula is a simple heuristic: a basic random‑graph estimate multiplied\n    by multiplicative corrections for clustering, density, degree heterogeneity,\n    assortativity and the presence of hubs.  All terms are bounded to keep the\n    prediction stable for extreme values.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float, -1..1)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']                     # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])                   # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])                # more heterogeneous degrees → shorter paths\n\n    # Assortativity: only apply a penalty for positive assortativity\n    assort = s['degree_assortativity']\n    assort_factor = 1.0 if assort <= 0.0 else 1.0 / (1.0 + assort)\n\n    # Hubs: large max_degree shortens paths\n    max_factor = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1.0))\n\n    # Very low min_degree can lengthen paths\n    min_factor = 1.0 / (1.0 + s['min_degree'] / (avg_deg + 1.0))\n\n    return base * clustering_factor * density_factor * hetero_factor * assort_factor * max_factor * min_factor\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula is a simple heuristic: a basic random‑graph estimate multiplied\n    by multiplicative corrections for clustering, density, degree heterogeneity,\n    assortativity and the presence of hubs.  All terms are bounded to keep the\n    prediction stable for extreme values.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float, -1..1)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']                     # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])                   # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])                # more heterogeneous degrees → shorter paths\n\n    # Assortativity: only apply a penalty for positive assortativity\n    assort = s['degree_assortativity']\n    assort_factor = 1.0 if assort <= 0.0 else 1.0 / (1.0 + assort)\n\n    # Hubs: large max_degree shortens paths\n    max_factor = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1.0))\n\n    # Very low min_degree can lengthen paths\n    min_factor = 1.0 / (1.0 + s['min_degree'] / (avg_deg + 1.0))\n\n    return base * clustering_factor * density_factor * hetero_factor * assort_factor * max_factor * min_factor", "spearman": 0.6612345308632718, "pearson": 0.5037483267483438, "rmse": 2.080078076093076, "mae": 1.9426063988679225}}
{"timestamp": "2026-02-16T14:43:46.207115+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i2_p2_454399844", "generation": 5, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.4995438175270108, "fitness_mode": "correlation", "simplicity_score": 0.11953231772535011, "novelty_bonus": 0.55258102431907, "total_score": 0.4249279020190705, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The estimate starts from a basic random‑graph\n    intuition and is refined by small multiplicative corrections that\n    capture clustering, density, degree heterogeneity, assortativity\n    and the presence of high‑degree hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float, -1..1)\n        - 'max_degree' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections ---------------------------------------------------------\n    # 1. Clustering: more triangles tend to lengthen paths\n    clustering_factor = 1.0 + s['avg_clustering']\n\n    # 2. Density: denser graphs have shorter paths\n    density_factor = 1.0 / (1.0 + s['density'])\n\n    # 3. Degree heterogeneity: a wide spread in degrees can create\n    #    shortcuts (high‑degree hubs), shortening paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'] / avg_deg)\n\n    # 4. Degree assortativity: disassortative mixing (high‑degree nodes\n    #    connected to low‑degree nodes) typically reduces path length.\n    #    We use a simple linear correction that only activates for\n    #    positive assortativity.\n    assort = s['degree_assortativity']\n    if assort < 0.0:\n        assort_factor = 1.0\n    else:\n        assort_factor = 1.0 / (1.0 + assort)\n\n    # 5. High‑degree hubs: a large max_degree relative to avg_degree\n    #    shortens the network.  The factor is capped at 1.\n    max_factor = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1.0))\n\n    # Combine all corrections ---------------------------------------------\n    return (rand_est * clustering_factor * density_factor *\n            hetero_factor * assort_factor * max_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.125562\nbelow_novelty_threshold: novelty_bonus=0.137076\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph intuition with multiplicative corrections\n    for clustering, density, degree heterogeneity, assortativity, hub prominence,\n    minimum degree, transitivity, and the number of triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float, -1..1)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = max(s['max_degree'], 1.0)\n    min_deg = max(s['min_degree'], 1.0)\n    std_deg = max(s['std_degree'], 0.0)\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    tri = s['num_triangles']\n\n    # Basic random‑graph estimate\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering_factor = 1.0 + clustering\n    density_factor     = 1.0 / (1.0 + density)\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    assort_factor      = 1.0 / (1.0 + max(0.0, assort))\n    max_factor         = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    min_factor         = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n    trans_factor       = 1.0 + trans\n    tri_factor         = 1.0 + tri / (n * n)\n\n    return (base * clustering_factor * density_factor *\n            hetero_factor * assort_factor * max_factor *\n            min_factor * trans_factor * tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph intuition with multiplicative corrections\n    for clustering, density, degree heterogeneity, assortativity, hub prominence,\n    minimum degree, transitivity, and the number of triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float, -1..1)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = max(s['max_degree'], 1.0)\n    min_deg = max(s['min_degree'], 1.0)\n    std_deg = max(s['std_degree'], 0.0)\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    tri = s['num_triangles']\n\n    # Basic random‑graph estimate\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering_factor = 1.0 + clustering\n    density_factor     = 1.0 / (1.0 + density)\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    assort_factor      = 1.0 / (1.0 + max(0.0, assort))\n    max_factor         = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    min_factor         = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n    trans_factor       = 1.0 + trans\n    tri_factor         = 1.0 + tri / (n * n)\n\n    return (base * clustering_factor * density_factor *\n            hetero_factor * assort_factor * max_factor *\n            min_factor * trans_factor * tri_factor)", "spearman": 0.47049426235655895, "pearson": 0.445514716496793, "rmse": 1.0640494918044057, "mae": 0.747541689878586}}
{"timestamp": "2026-02-16T14:44:30.641256+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i2_p3_251116863", "generation": 5, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.4008163265306122, "fitness_mode": "correlation", "simplicity_score": 0.12239172490725561, "novelty_bonus": 0.5931034809391251, "total_score": 0.3869740033785416, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The estimate starts from a basic random‑graph\n    intuition and is refined by small multiplicative corrections that\n    capture clustering, density, degree heterogeneity, assortativity\n    and the presence of high‑degree hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float, -1..1)\n        - 'max_degree' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections ---------------------------------------------------------\n    # 1. Clustering: more triangles tend to lengthen paths\n    clustering_factor = 1.0 + s['avg_clustering']\n\n    # 2. Density: denser graphs have shorter paths\n    density_factor = 1.0 / (1.0 + s['density'])\n\n    # 3. Degree heterogeneity: a wide spread in degrees can create\n    #    shortcuts (high‑degree hubs), shortening paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'] / avg_deg)\n\n    # 4. Degree assortativity: disassortative mixing (high‑degree nodes\n    #    connected to low‑degree nodes) typically reduces path length.\n    #    We use a simple linear correction that only activates for\n    #    positive assortativity.\n    assort = s['degree_assortativity']\n    if assort < 0.0:\n        assort_factor = 1.0\n    else:\n        assort_factor = 1.0 / (1.0 + assort)\n\n    # 5. High‑degree hubs: a large max_degree relative to avg_degree\n    #    shortens the network.  The factor is capped at 1.\n    max_factor = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1.0))\n\n    # Combine all corrections ---------------------------------------------\n    return (rand_est * clustering_factor * density_factor *\n            hetero_factor * assort_factor * max_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.125562\nbelow_novelty_threshold: novelty_bonus=0.137076\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula starts from a random‑graph intuition and applies multiplicative\n    corrections that capture clustering, density, degree heterogeneity,\n    assortativity, hub influence, triangle density, and minimum degree.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys include:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float, -1..1)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']      # more clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])    # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'] / avg_deg)\n\n    assort = s['degree_assortativity']\n    assort_factor = 1.0 / (1.0 + max(0.0, assort))     # positive assortativity shortens paths\n\n    hub_ratio = s['max_degree'] / (avg_deg + 1.0)\n    hub_factor = 1.0 / (1.0 + hub_ratio)                # large hubs shorten paths\n\n    # Triangle density relative to the number of possible triangles\n    tri_possible = n * (n - 1) / 2.0\n    tri_ratio = s['num_triangles'] / (tri_possible + 1.0)\n    tri_factor = 1.0 + tri_ratio                         # more triangles lengthen paths\n\n    # Influence of very low‑degree nodes\n    min_ratio = s['min_degree'] / (avg_deg + 1.0)\n    min_factor = 1.0 / (1.0 + min_ratio)\n\n    # Combine all corrections\n    return (base * clustering_factor * density_factor *\n            hetero_factor * assort_factor * hub_factor *\n            tri_factor * min_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula starts from a random‑graph intuition and applies multiplicative\n    corrections that capture clustering, density, degree heterogeneity,\n    assortativity, hub influence, triangle density, and minimum degree.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys include:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float, -1..1)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']      # more clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])    # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'] / avg_deg)\n\n    assort = s['degree_assortativity']\n    assort_factor = 1.0 / (1.0 + max(0.0, assort))     # positive assortativity shortens paths\n\n    hub_ratio = s['max_degree'] / (avg_deg + 1.0)\n    hub_factor = 1.0 / (1.0 + hub_ratio)                # large hubs shorten paths\n\n    # Triangle density relative to the number of possible triangles\n    tri_possible = n * (n - 1) / 2.0\n    tri_ratio = s['num_triangles'] / (tri_possible + 1.0)\n    tri_factor = 1.0 + tri_ratio                         # more triangles lengthen paths\n\n    # Influence of very low‑degree nodes\n    min_ratio = s['min_degree'] / (avg_deg + 1.0)\n    min_factor = 1.0 / (1.0 + min_ratio)\n\n    # Combine all corrections\n    return (base * clustering_factor * density_factor *\n            hetero_factor * assort_factor * hub_factor *\n            tri_factor * min_factor)", "spearman": 0.3691292282307058, "pearson": 0.32757731273157525, "rmse": 1.2515047861688153, "mae": 0.9396913957330943}}
{"timestamp": "2026-02-16T14:45:01.754665+00:00", "event_type": "candidate_rejected", "payload": {"generation": 5, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.279424", "model_name": "gpt-oss:20b", "train_signal": 0.27942376950780307}}
{"timestamp": "2026-02-16T14:45:40.518214+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i3_p0_256075068", "generation": 5, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5582232893157262, "fitness_mode": "correlation", "simplicity_score": 0.15525540203309823, "novelty_bonus": 0.3440831020775518, "total_score": 0.39933638753929795, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from global graph statistics\n    without performing any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys include:\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity, num_triangles,\n        degrees (sorted ascending list of degrees).\n\n    Returns\n    -------\n    float\n        A single numeric value intended to correlate with the true average\n        shortest‑path length of the graph.\n    \"\"\"\n    # Basic quantities\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # Derived ratios / factors\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # 1. Baseline from node/edge ratio\n    base = (n + 1.0) / (m + 1.0)\n\n    # 2. Adjust for overall density\n    dens_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity (std / mean)\n    het_factor = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # 4. Clustering suppresses long paths\n    clus_factor = 1.0 / (1.0 + avg_clust)\n\n    # 5. Transitivity encourages alternative routes\n    trans_factor = 1.0 + trans\n\n    # 6. Assortativity influences mixing of high‑degree nodes\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Triangle presence reduces distance\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # 8. Range between hubs and leaf nodes\n    deg_range = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 9. Fraction of total degree held by the top 10% nodes\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # 10. Combine all influences multiplicatively\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clus_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.172777\nbelow_train_threshold: train_signal=0.094358\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A heuristic estimate for the average shortest‑path length based on a set\n    of global graph statistics.  The expression is purely algebraic and\n    does not perform any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted ascending).\n\n    Returns\n    -------\n    float\n        A scalar that should correlate with the true average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Basic counts\n    n = s.get('n', 1.0)\n    m = s.get('m', 0.0)\n\n    # Avoid division by zero\n    m_safe = m + 1.0\n    n_safe = n + 1.0\n\n    # 1. Node/edge baseline\n    base = n_safe / m_safe\n\n    # 2. Density damping: denser graphs tend to have shorter paths\n    dens = s.get('density', 0.0)\n    dens_factor = 1.0 / (1.0 + dens)\n\n    # 3. Degree heterogeneity factor\n    avg_deg = s.get('avg_degree', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    het_factor = 1.0 + std_deg / (avg_deg + 1.0)\n\n    # 4. Clustering suppresses long paths\n    avg_clust = s.get('avg_clustering', 0.0)\n    clus_factor = 1.0 / (1.0 + avg_clust)\n\n    # 5. Triangle abundance encourages shortcuts\n    num_tri = s.get('num_triangles', 0)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n_safe ** 0.5)\n\n    # 6. Assortativity influences the mix of high‑degree nodes\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Degree range between hubs and leaves\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)\n    range_factor = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 8. Fraction of total degree held by the top 10% nodes\n    degrees = s.get('degrees', [])\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m + 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Combine all components multiplicatively\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clus_factor\n        * tri_factor\n        * assort_factor\n        * range_factor\n        * top_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A heuristic estimate for the average shortest‑path length based on a set\n    of global graph statistics.  The expression is purely algebraic and\n    does not perform any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted ascending).\n\n    Returns\n    -------\n    float\n        A scalar that should correlate with the true average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Basic counts\n    n = s.get('n', 1.0)\n    m = s.get('m', 0.0)\n\n    # Avoid division by zero\n    m_safe = m + 1.0\n    n_safe = n + 1.0\n\n    # 1. Node/edge baseline\n    base = n_safe / m_safe\n\n    # 2. Density damping: denser graphs tend to have shorter paths\n    dens = s.get('density', 0.0)\n    dens_factor = 1.0 / (1.0 + dens)\n\n    # 3. Degree heterogeneity factor\n    avg_deg = s.get('avg_degree', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    het_factor = 1.0 + std_deg / (avg_deg + 1.0)\n\n    # 4. Clustering suppresses long paths\n    avg_clust = s.get('avg_clustering', 0.0)\n    clus_factor = 1.0 / (1.0 + avg_clust)\n\n    # 5. Triangle abundance encourages shortcuts\n    num_tri = s.get('num_triangles', 0)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n_safe ** 0.5)\n\n    # 6. Assortativity influences the mix of high‑degree nodes\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Degree range between hubs and leaves\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)\n    range_factor = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 8. Fraction of total degree held by the top 10% nodes\n    degrees = s.get('degrees', [])\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m + 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Combine all components multiplicatively\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clus_factor\n        * tri_factor\n        * assort_factor\n        * range_factor\n        * top_factor\n    )\n\n    return float(estimate)", "spearman": 0.5301207530188256, "pearson": 0.5128273203530219, "rmse": 22.060440018459637, "mae": 12.555110307234223}}
{"timestamp": "2026-02-16T14:46:28.079366+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i3_p1_247542846", "generation": 5, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5806962785114045, "fitness_mode": "correlation", "simplicity_score": 0.1548007963727991, "novelty_bonus": 0.32561614040351006, "total_score": 0.4044441463742373, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from global graph statistics\n    without performing any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys include:\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity, num_triangles,\n        degrees (sorted ascending list of degrees).\n\n    Returns\n    -------\n    float\n        A single numeric value intended to correlate with the true average\n        shortest‑path length of the graph.\n    \"\"\"\n    # Basic quantities\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # Derived ratios / factors\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # 1. Baseline from node/edge ratio\n    base = (n + 1.0) / (m + 1.0)\n\n    # 2. Adjust for overall density\n    dens_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity (std / mean)\n    het_factor = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # 4. Clustering suppresses long paths\n    clus_factor = 1.0 / (1.0 + avg_clust)\n\n    # 5. Transitivity encourages alternative routes\n    trans_factor = 1.0 + trans\n\n    # 6. Assortativity influences mixing of high‑degree nodes\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Triangle presence reduces distance\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # 8. Range between hubs and leaf nodes\n    deg_range = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 9. Fraction of total degree held by the top 10% nodes\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # 10. Combine all influences multiplicatively\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clus_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.172777\nbelow_train_threshold: train_signal=0.094358\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from global graph statistics.\n    The formula blends a node‑to‑edge baseline with corrections for density,\n    degree heterogeneity, clustering, transitivity, assortativity, triangle\n    density, degree range, and the concentration of high‑degree nodes.\n    \"\"\"\n    # Retrieve statistics with defaults\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # Base factor from node/edge ratio\n    base = (n + 1.0) / (m + 1.0)\n\n    # Density adjustment (higher density → shorter paths)\n    dens_adj = 1.0 / (1.0 + density)\n\n    # Degree heterogeneity adjustment\n    het_adj = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # Clustering tends to reduce effective distances\n    clust_adj = 1.0 / (1.0 + avg_clust)\n\n    # Transitivity (global clustering) can open alternative routes\n    trans_adj = 1.0 + trans\n\n    # Degree assortativity effect\n    assort_adj = 1.0 + abs(assort)\n\n    # Triangle density influence\n    tri_adj = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range factor (hubs vs leaves)\n    deg_range = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # Concentration of high‑degree nodes (top 10 %)\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    high_ratio = high_deg_sum / total_deg\n    high_adj = 1.0 + (1.0 - high_ratio) * het_adj\n\n    # Combine all influences multiplicatively\n    estimate = (\n        base\n        * dens_adj\n        * het_adj\n        * clust_adj\n        * trans_adj\n        * assort_adj\n        * tri_adj\n        * deg_range\n        * high_adj\n    )\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from global graph statistics.\n    The formula blends a node‑to‑edge baseline with corrections for density,\n    degree heterogeneity, clustering, transitivity, assortativity, triangle\n    density, degree range, and the concentration of high‑degree nodes.\n    \"\"\"\n    # Retrieve statistics with defaults\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # Base factor from node/edge ratio\n    base = (n + 1.0) / (m + 1.0)\n\n    # Density adjustment (higher density → shorter paths)\n    dens_adj = 1.0 / (1.0 + density)\n\n    # Degree heterogeneity adjustment\n    het_adj = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # Clustering tends to reduce effective distances\n    clust_adj = 1.0 / (1.0 + avg_clust)\n\n    # Transitivity (global clustering) can open alternative routes\n    trans_adj = 1.0 + trans\n\n    # Degree assortativity effect\n    assort_adj = 1.0 + abs(assort)\n\n    # Triangle density influence\n    tri_adj = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range factor (hubs vs leaves)\n    deg_range = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # Concentration of high‑degree nodes (top 10 %)\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    high_ratio = high_deg_sum / total_deg\n    high_adj = 1.0 + (1.0 - high_ratio) * het_adj\n\n    # Combine all influences multiplicatively\n    estimate = (\n        base\n        * dens_adj\n        * het_adj\n        * clust_adj\n        * trans_adj\n        * assort_adj\n        * tri_adj\n        * deg_range\n        * high_adj\n    )\n    return float(estimate)", "spearman": 0.551598289957249, "pearson": 0.49785731961787527, "rmse": 9.825653177358184, "mae": 4.345392106197964}}
{"timestamp": "2026-02-16T14:46:55.675732+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i3_p2_191624760", "generation": 5, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5631212484993998, "fitness_mode": "correlation", "simplicity_score": 0.15530523588408818, "novelty_bonus": 0.3407800195004874, "total_score": 0.3966453867853078, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from global graph statistics\n    without performing any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys include:\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity, num_triangles,\n        degrees (sorted ascending list of degrees).\n\n    Returns\n    -------\n    float\n        A single numeric value intended to correlate with the true average\n        shortest‑path length of the graph.\n    \"\"\"\n    # Basic quantities\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # Derived ratios / factors\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # 1. Baseline from node/edge ratio\n    base = (n + 1.0) / (m + 1.0)\n\n    # 2. Adjust for overall density\n    dens_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity (std / mean)\n    het_factor = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # 4. Clustering suppresses long paths\n    clus_factor = 1.0 / (1.0 + avg_clust)\n\n    # 5. Transitivity encourages alternative routes\n    trans_factor = 1.0 + trans\n\n    # 6. Assortativity influences mixing of high‑degree nodes\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Triangle presence reduces distance\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # 8. Range between hubs and leaf nodes\n    deg_range = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 9. Fraction of total degree held by the top 10% nodes\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # 10. Combine all influences multiplicatively\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clus_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.172777\nbelow_train_threshold: train_signal=0.094358\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using only pre‑computed graph statistics.\n    The expression blends several structural signals:\n    - overall size/edge balance (n / m)\n    - degree heterogeneity (std_degree, max/min_degree)\n    - clustering vs. transitivity contrast\n    - assortativity magnitude\n    - triangle density (sqrt(num_triangles))\n    - concentration of degree among the top 10 % nodes\n    No graph traversal or external imports are required.\n    \"\"\"\n    # Basic node/edge ratio, regularised to avoid division by zero\n    ratio = (s.get('n', 1) + 1.0) / (s.get('m', 0) + 1.0)\n\n    # Degree heterogeneity factor (larger std / mean → longer paths)\n    avg_deg = s.get('avg_degree', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    hetero = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # Clustering vs. transitivity effect\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    clust_factor = 1.0 + (avg_clust - trans) / (1.0 + avg_clust + trans)\n\n    # Assortativity magnitude influences mixing of hubs and leaves\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle density reduces effective distance\n    num_tri = s.get('num_triangles', 0)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (s.get('n', 1) ** 0.5)\n\n    # Degree range between the most connected and the least connected nodes\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)\n    range_factor = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # Concentration of degree in the top 10 % of nodes\n    degrees = s.get('degrees', [])\n    top_k = max(1, int(0.1 * len(degrees)))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * s.get('m', 0) if s.get('m', 0) > 0 else 1e-6\n    top_ratio = high_deg_sum / (total_deg + 1e-6)\n    top_factor = 1.0 + (1.0 - top_ratio)\n\n    # Combine all components multiplicatively\n    estimate = (\n        ratio\n        * hetero\n        * clust_factor\n        * assort_factor\n        * tri_factor\n        * range_factor\n        * top_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using only pre‑computed graph statistics.\n    The expression blends several structural signals:\n    - overall size/edge balance (n / m)\n    - degree heterogeneity (std_degree, max/min_degree)\n    - clustering vs. transitivity contrast\n    - assortativity magnitude\n    - triangle density (sqrt(num_triangles))\n    - concentration of degree among the top 10 % nodes\n    No graph traversal or external imports are required.\n    \"\"\"\n    # Basic node/edge ratio, regularised to avoid division by zero\n    ratio = (s.get('n', 1) + 1.0) / (s.get('m', 0) + 1.0)\n\n    # Degree heterogeneity factor (larger std / mean → longer paths)\n    avg_deg = s.get('avg_degree', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    hetero = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # Clustering vs. transitivity effect\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    clust_factor = 1.0 + (avg_clust - trans) / (1.0 + avg_clust + trans)\n\n    # Assortativity magnitude influences mixing of hubs and leaves\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle density reduces effective distance\n    num_tri = s.get('num_triangles', 0)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (s.get('n', 1) ** 0.5)\n\n    # Degree range between the most connected and the least connected nodes\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)\n    range_factor = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # Concentration of degree in the top 10 % of nodes\n    degrees = s.get('degrees', [])\n    top_k = max(1, int(0.1 * len(degrees)))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * s.get('m', 0) if s.get('m', 0) > 0 else 1e-6\n    top_ratio = high_deg_sum / (total_deg + 1e-6)\n    top_factor = 1.0 + (1.0 - top_ratio)\n\n    # Combine all components multiplicatively\n    estimate = (\n        ratio\n        * hetero\n        * clust_factor\n        * assort_factor\n        * tri_factor\n        * range_factor\n        * top_factor\n    )\n\n    return float(estimate)", "spearman": 0.526700667516688, "pearson": 0.5222812542533657, "rmse": 10.243655126568932, "mae": 5.339185748349786}}
{"timestamp": "2026-02-16T14:48:00.535533+00:00", "event_type": "candidate_rejected", "payload": {"generation": 5, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.129864", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:48:00.536091+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 5, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.129864", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:48:52.615856+00:00", "event_type": "candidate_rejected", "payload": {"generation": 5, "island_id": 3, "population_idx": 3, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.199232", "model_name": "gpt-oss:20b", "train_signal": 0.1992316926770708}}
{"timestamp": "2026-02-16T14:48:52.616673+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 5, "island_id": 3, "population_idx": 3, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:50:12.610535+00:00", "event_type": "candidate_rejected", "payload": {"generation": 5, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:50:12.611440+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 5, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:50:56.236317+00:00", "event_type": "candidate_rejected", "payload": {"generation": 5, "island_id": 3, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:50:56.236749+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 5, "island_id": 3, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T14:50:56.238639+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 6, "model_name": "gpt-oss:20b", "best_val_score": 0.526450498609911, "no_improve_count": 2}}
{"timestamp": "2026-02-16T14:53:00.776981+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i0_p0_804835982", "generation": 6, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.458343337334934, "fitness_mode": "correlation", "simplicity_score": 0.2234790387747198, "novelty_bonus": 0.46604354569436257, "total_score": 0.39308458585611256, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, and triangle counts in a compact, interpretable\n    way.  No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    # Basic scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.001297\nbelow_novelty_threshold: novelty_bonus=0.142711\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    # Basic scaling with size and average degree\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when degree distribution is uneven\n    base *= (1.0 + (max_deg - avg_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering ** 0.5)\n    base *= (1.0 + trans ** 0.5)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) ** 0.5)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 1.5 + 1.0)\n\n    return base", "extracted_code": "def new_invariant(s):\n    # Basic scaling with size and average degree\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when degree distribution is uneven\n    base *= (1.0 + (max_deg - avg_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering ** 0.5)\n    base *= (1.0 + trans ** 0.5)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) ** 0.5)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 1.5 + 1.0)\n\n    return base", "spearman": 0.4171514287857197, "pearson": 0.3635201525914333, "rmse": 8.033696877362416, "mae": 5.891389003282444}}
{"timestamp": "2026-02-16T14:54:25.658945+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i0_p1_486095807", "generation": 6, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.6306362545018007, "fitness_mode": "correlation", "simplicity_score": 0.22323284751129324, "novelty_bonus": 0.3554401273955696, "total_score": 0.4904430868329074, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, and triangle counts in a compact, interpretable\n    way.  No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    # Basic scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.001297\nbelow_novelty_threshold: novelty_bonus=0.142711\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula uses a compact combination of size, degree distribution,\n    density, clustering, transitivity, assortativity, and triangle counts.\n    No graph traversal is performed; only arithmetic on the supplied features.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Increase when degree distribution is uneven\n    base *= (1 + (avg_deg - s['min_degree']) / (avg_deg + 1))\n    base *= (1 + s['std_degree'] / (avg_deg + 1))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1 + s['avg_clustering'])\n    base *= (1 + s['transitivity'])\n\n    # Assortativity tends to lengthen paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Minor additive contribution from the number of triangles\n    base += s['num_triangles'] / (n ** 2 + 1)\n\n    # Optional median degree adjustment\n    degs = s['degrees']\n    if degs:\n        mid = len(degs) // 2\n        median = degs[mid]\n        base *= (1 + (median - avg_deg) / (avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula uses a compact combination of size, degree distribution,\n    density, clustering, transitivity, assortativity, and triangle counts.\n    No graph traversal is performed; only arithmetic on the supplied features.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / n)\n\n    # Increase when degree distribution is uneven\n    base *= (1 + (avg_deg - s['min_degree']) / (avg_deg + 1))\n    base *= (1 + s['std_degree'] / (avg_deg + 1))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1 + s['avg_clustering'])\n    base *= (1 + s['transitivity'])\n\n    # Assortativity tends to lengthen paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Minor additive contribution from the number of triangles\n    base += s['num_triangles'] / (n ** 2 + 1)\n\n    # Optional median degree adjustment\n    degs = s['degrees']\n    if degs:\n        mid = len(degs) // 2\n        median = degs[mid]\n        base *= (1 + (median - avg_deg) / (avg_deg + 1))\n\n    return base", "spearman": 0.6783289582239557, "pearson": 0.6253534205057872, "rmse": 3.2605328161649894, "mae": 2.988188511313572}}
{"timestamp": "2026-02-16T14:55:28.895654+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i0_p2_829257847", "generation": 6, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5852100840336134, "fitness_mode": "correlation", "simplicity_score": 0.22404398051287003, "novelty_bonus": 0.29029540515742847, "total_score": 0.5141699744637229, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, and triangle counts in a compact, interpretable\n    way.  No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    # Basic scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.001297\nbelow_novelty_threshold: novelty_bonus=0.142711\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed graph\n    statistics.  The formula is a compact, interpretable combination of size,\n    degree distribution, density, clustering, transitivity, assortativity,\n    and triangle counts.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed graph\n    statistics.  The formula is a compact, interpretable combination of size,\n    degree distribution, density, clustering, transitivity, assortativity,\n    and triangle counts.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base", "spearman": 0.7645451136278407, "pearson": 0.7235486314870165, "rmse": 3.7546492969815093, "mae": 3.5404028333115094}}
{"timestamp": "2026-02-16T14:56:17.137076+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i0_p3_664866957", "generation": 6, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5852100840336134, "fitness_mode": "correlation", "simplicity_score": 0.22377762324679887, "novelty_bonus": 0.29029540515742847, "total_score": 0.5141167030105087, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, and triangle counts in a compact, interpretable\n    way.  No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    # Basic scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    # Basic scaling with size and average degree\n    base = s['n'] ** 0.5 / (s['avg_degree'] ** 0.5 if s['avg_degree'] > 0 else 1)\n\n    # Small‑world effect: higher clustering shortens paths\n    base *= (1 + s['avg_clustering'])\n\n    # Assortativity: highly assortative graphs tend to have longer paths\n    base /= (1 + abs(s['degree_assortativity']))\n\n    # Density and maximum degree both help reduce path length\n    base /= (1 + s['density'])\n    base /= (1 + s['max_degree'] / s['n'])\n\n    # Minor adjustment for global transitivity\n    base += 0.5 * s['transitivity']\n\n    # Tiny contribution from the number of triangles\n    base += s['num_triangles'] / (s['n'] ** 2 + 1)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.001297\nbelow_novelty_threshold: novelty_bonus=0.142711\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula uses only arithmetic on the supplied features and avoids any\n    explicit graph traversal or external imports.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size grows with sqrt(n), average degree shortens paths\n    base = n ** 0.5 / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula uses only arithmetic on the supplied features and avoids any\n    explicit graph traversal or external imports.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size grows with sqrt(n), average degree shortens paths\n    base = n ** 0.5 / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base", "spearman": 0.7645451136278407, "pearson": 0.7235486314870165, "rmse": 3.7546492969815093, "mae": 3.5404028333115094}}
{"timestamp": "2026-02-16T14:56:41.218173+00:00", "event_type": "candidate_rejected", "payload": {"generation": 6, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.132581", "model_name": "gpt-oss:20b", "train_signal": 0.13258103241296518}}
{"timestamp": "2026-02-16T14:57:23.976871+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i1_p0_808377910", "generation": 6, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.1284952837503945, "novelty_bonus": 0.17722193054826363, "total_score": 0.5131579932234906, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Retrieve features with safe defaults\n    n = s.get('n', 0)\n    m = s.get('m', 0)\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = density if density > 1e-6 else 1e-6\n    denom_edges = m if m > 0 else 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / denom_edges\n    deg_variance = std_degree ** 2\n    deg_ratio = (max_degree + 1) / (min_degree + 1)\n\n    # Composite parts\n    part1 = n / denom_m\n    part2 = n ** 0.5 / (1 + avg_clustering)\n    part3 = avg_degree / (max_degree + 1)\n    part4 = 1 + abs(degree_assortativity)\n    part5 = 1 + transitivity\n    part6 = 1 + tri_per_edge\n    part7 = deg_ratio\n    part8 = 1 / (1 + deg_variance)\n    part9 = 1 / denom_density\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Retrieve features with safe defaults\n    n = s.get('n', 0)\n    m = s.get('m', 0)\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = density if density > 1e-6 else 1e-6\n    denom_edges = m if m > 0 else 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / denom_edges\n    deg_variance = std_degree ** 2\n    deg_ratio = (max_degree + 1) / (min_degree + 1)\n\n    # Composite parts\n    part1 = n / denom_m\n    part2 = n ** 0.5 / (1 + avg_clustering)\n    part3 = avg_degree / (max_degree + 1)\n    part4 = 1 + abs(degree_assortativity)\n    part5 = 1 + transitivity\n    part6 = 1 + tri_per_edge\n    part7 = deg_ratio\n    part8 = 1 / (1 + deg_variance)\n    part9 = 1 / denom_density\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T14:58:03.111409+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i1_p1_664886557", "generation": 6, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.9020408163265305, "fitness_mode": "correlation", "simplicity_score": 0.12875448898167324, "novelty_bonus": 0.15637140928523197, "total_score": 0.520535267405575, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant\n    part1 = n / (denom_m + 1)                 # sparsity\n    part2 = n ** 0.5 / denom_density          # size & density\n    part3 = 1 + avg_clust                     # clustering\n    part4 = 1 + abs(assort)                   # assortativity\n    part5 = 1 + trans                         # transitivity\n    part6 = 1 + tri_per_edge                  # triangles per edge\n    part7 = avg_deg / (max_deg + 1)           # degree spread\n    part8 = deg_ratio                         # degree ratio\n    part9 = 1 / (1 + deg_variance)            # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant\n    part1 = n / (denom_m + 1)                 # sparsity\n    part2 = n ** 0.5 / denom_density          # size & density\n    part3 = 1 + avg_clust                     # clustering\n    part4 = 1 + abs(assort)                   # assortativity\n    part5 = 1 + trans                         # transitivity\n    part6 = 1 + tri_per_edge                  # triangles per edge\n    part7 = avg_deg / (max_deg + 1)           # degree spread\n    part8 = deg_ratio                         # degree ratio\n    part9 = 1 / (1 + deg_variance)            # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )", "spearman": 0.8957458936473414, "pearson": 0.8461321815324823, "rmse": 35.993662628650526, "mae": 21.959389587623395}}
{"timestamp": "2026-02-16T14:58:35.177561+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i1_p2_280423674", "generation": 6, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8294357743097239, "fitness_mode": "correlation", "simplicity_score": 0.1288730965220392, "novelty_bonus": 0.23996399909997734, "total_score": 0.5196358658355711, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_triangles / denom_m\n    deg_variance = std_degree ** 2\n    deg_ratio = (max_degree + 1) / (min_degree + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = 1 + abs(degree_assortativity)       # assortativity\n    part4 = 1 + transitivity                    # transitivity\n    part5 = 1 + tri_per_edge                    # triangles per edge\n    part6 = avg_degree / (max_degree + 1)       # degree spread\n    part7 = deg_ratio                           # degree ratio\n    part8 = 1 / (1 + deg_variance)              # degree variance\n    part9 = pow(n, 0.5) / denom_density         # size & density\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_triangles / denom_m\n    deg_variance = std_degree ** 2\n    deg_ratio = (max_degree + 1) / (min_degree + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = 1 + abs(degree_assortativity)       # assortativity\n    part4 = 1 + transitivity                    # transitivity\n    part5 = 1 + tri_per_edge                    # triangles per edge\n    part6 = avg_degree / (max_degree + 1)       # degree spread\n    part7 = deg_ratio                           # degree ratio\n    part8 = 1 / (1 + deg_variance)              # degree variance\n    part9 = pow(n, 0.5) / denom_density         # size & density\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )", "spearman": 0.8437440936023402, "pearson": 0.7816562112683827, "rmse": 197.65527364479198, "mae": 124.36144343610599}}
{"timestamp": "2026-02-16T14:59:10.646830+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i1_p3_295780527", "generation": 6, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.12890308834926528, "novelty_bonus": 0.17722193054826363, "total_score": 0.5132395541432648, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clust)         # size & clustering\n    part3 = avg_deg / (max_deg + 1)               # degree spread\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = deg_ratio                             # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / denom_density                     # density\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clust)         # size & clustering\n    part3 = avg_deg / (max_deg + 1)               # degree spread\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = deg_ratio                             # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / denom_density                     # density\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T14:59:39.398306+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i1_p4_213595856", "generation": 6, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.1284671140406978, "novelty_bonus": 0.17722193054826363, "total_score": 0.5131523592815515, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Composite graph invariant combining sparsity, size, clustering,\n    degree distribution, assortativity, transitivity, triangle density,\n    degree ratio, variance and density.\n    \"\"\"\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)          # fallback to avoid zero division\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Safe denominators\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_max_degree = max(max_degree, 1)\n    denom_min_degree = min_degree + 1          # avoid division by zero\n\n    # Derived ratios\n    tri_per_edge = num_triangles / denom_m\n    deg_variance = std_degree ** 2\n    deg_ratio = (max_degree + 1) / denom_min_degree\n\n    # Individual components\n    part1 = n / (denom_m + 1)                 # sparsity\n    part2 = n ** 0.5 / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / (denom_max_degree + 1)  # degree spread\n    part4 = 1 + abs(degree_assortativity)     # assortativity\n    part5 = 1 + transitivity                  # transitivity\n    part6 = 1 + tri_per_edge                  # triangles per edge\n    part7 = deg_ratio                          # degree ratio\n    part8 = 1 / (1 + deg_variance)            # degree variance\n    part9 = 1 / denom_density                 # density\n\n    # Final invariant\n    return (part1 * part2 * part3 * part4 *\n            part5 * part6 * part7 * part8 * part9)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Composite graph invariant combining sparsity, size, clustering,\n    degree distribution, assortativity, transitivity, triangle density,\n    degree ratio, variance and density.\n    \"\"\"\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)          # fallback to avoid zero division\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Safe denominators\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_max_degree = max(max_degree, 1)\n    denom_min_degree = min_degree + 1          # avoid division by zero\n\n    # Derived ratios\n    tri_per_edge = num_triangles / denom_m\n    deg_variance = std_degree ** 2\n    deg_ratio = (max_degree + 1) / denom_min_degree\n\n    # Individual components\n    part1 = n / (denom_m + 1)                 # sparsity\n    part2 = n ** 0.5 / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / (denom_max_degree + 1)  # degree spread\n    part4 = 1 + abs(degree_assortativity)     # assortativity\n    part5 = 1 + transitivity                  # transitivity\n    part6 = 1 + tri_per_edge                  # triangles per edge\n    part7 = deg_ratio                          # degree ratio\n    part8 = 1 / (1 + deg_variance)            # degree variance\n    part9 = 1 / denom_density                 # density\n\n    # Final invariant\n    return (part1 * part2 * part3 * part4 *\n            part5 * part6 * part7 * part8 * part9)", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T15:00:29.381152+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i2_p0_537696106", "generation": 6, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.4995438175270108, "fitness_mode": "correlation", "simplicity_score": 0.1215711807596058, "novelty_bonus": 0.55258102431907, "total_score": 0.4253356746259216, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph intuition with multiplicative corrections\n    for clustering, density, degree heterogeneity, assortativity, hub prominence,\n    minimum degree, transitivity, and the number of triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float, -1..1)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = max(s['max_degree'], 1.0)\n    min_deg = max(s['min_degree'], 1.0)\n    std_deg = max(s['std_degree'], 0.0)\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    tri = s['num_triangles']\n\n    # Basic random‑graph estimate\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering_factor = 1.0 + clustering\n    density_factor     = 1.0 / (1.0 + density)\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    assort_factor      = 1.0 / (1.0 + max(0.0, assort))\n    max_factor         = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    min_factor         = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n    trans_factor       = 1.0 + trans\n    tri_factor         = 1.0 + tri / (n * n)\n\n    return (base * clustering_factor * density_factor *\n            hetero_factor * assort_factor * max_factor *\n            min_factor * trans_factor * tri_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.137076\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.279424\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula is a heuristic that blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, density, degree heterogeneity,\n    assortativity, hub prominence, and the presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float, -1..1)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Correction factors\n    clustering_factor = 1.0 + s['avg_clustering']                 # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])              # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'] / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 / (1.0 + max(0.0, s['degree_assortativity']))  # positive assortativity → slightly shorter paths\n    max_factor         = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1.0))  # very high hubs → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / (avg_deg + 1.0))  # very low min degree → longer paths\n    trans_factor       = 1.0 + s['transitivity']                     # higher transitivity → longer paths\n    tri_factor         = 1.0 + s['num_triangles'] / (n * n)           # many triangles → slightly longer paths\n\n    return (base * clustering_factor * density_factor *\n            hetero_factor * assort_factor * max_factor *\n            min_factor * trans_factor * tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula is a heuristic that blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, density, degree heterogeneity,\n    assortativity, hub prominence, and the presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float, -1..1)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Correction factors\n    clustering_factor = 1.0 + s['avg_clustering']                 # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])              # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'] / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 / (1.0 + max(0.0, s['degree_assortativity']))  # positive assortativity → slightly shorter paths\n    max_factor         = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1.0))  # very high hubs → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / (avg_deg + 1.0))  # very low min degree → longer paths\n    trans_factor       = 1.0 + s['transitivity']                     # higher transitivity → longer paths\n    tri_factor         = 1.0 + s['num_triangles'] / (n * n)           # many triangles → slightly longer paths\n\n    return (base * clustering_factor * density_factor *\n            hetero_factor * assort_factor * max_factor *\n            min_factor * trans_factor * tri_factor)", "spearman": 0.47049426235655895, "pearson": 0.445514716496793, "rmse": 1.0640494918044057, "mae": 0.747541689878586}}
{"timestamp": "2026-02-16T15:01:20.869828+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i2_p1_951438356", "generation": 6, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.5175030012004801, "fitness_mode": "correlation", "simplicity_score": 0.11567173129091879, "novelty_bonus": 0.5333808099123767, "total_score": 0.4414842976246066, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph intuition with multiplicative corrections\n    for clustering, density, degree heterogeneity, assortativity, hub prominence,\n    minimum degree, transitivity, and the number of triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float, -1..1)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = max(s['max_degree'], 1.0)\n    min_deg = max(s['min_degree'], 1.0)\n    std_deg = max(s['std_degree'], 0.0)\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    tri = s['num_triangles']\n\n    # Basic random‑graph estimate\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering_factor = 1.0 + clustering\n    density_factor     = 1.0 / (1.0 + density)\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    assort_factor      = 1.0 / (1.0 + max(0.0, assort))\n    max_factor         = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    min_factor         = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n    trans_factor       = 1.0 + trans\n    tri_factor         = 1.0 + tri / (n * n)\n\n    return (base * clustering_factor * density_factor *\n            hetero_factor * assort_factor * max_factor *\n            min_factor * trans_factor * tri_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.137076\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.279424\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a simple random‑graph intuition with multiplicative\n    corrections for clustering, density, degree heterogeneity, assortativity,\n    extreme degrees, transitivity, and triangle density.  The median degree\n    is also used as an additional heterogeneity cue.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float, -1..1)\n        - 'num_triangles' (int)\n        - 'degrees' (list[int]): sorted degree list\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Individual feature values\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    density = s['density']\n    std_deg = max(s['std_degree'], 0.0)\n    min_deg = max(s['min_degree'], 1.0)\n    max_deg = max(s['max_degree'], 1.0)\n    assort = s['degree_assortativity']\n    tri = s['num_triangles']\n\n    # Median degree from the sorted list\n    deg_list = s['degrees']\n    l = len(deg_list)\n    if l == 0:\n        median_deg = 0.0\n    elif l % 2 == 1:\n        median_deg = deg_list[l // 2]\n    else:\n        median_deg = (deg_list[l // 2 - 1] + deg_list[l // 2]) / 2.0\n\n    # Multiplicative corrections\n    clustering_factor = 1.0 + clustering\n    trans_factor      = 1.0 + trans\n    density_factor    = 1.0 / (1.0 + density)\n    hetero_factor     = 1.0 + std_deg / (avg_deg + 1.0)\n    median_factor     = 1.0 + median_deg / (avg_deg + 1.0)\n    min_factor        = 1.0 + min_deg / (avg_deg + 1.0)\n    max_factor        = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    assort_factor     = 1.0 / (1.0 + max(0.0, assort))\n    tri_factor        = 1.0 + tri / (n * n)\n\n    # Final estimate\n    return (base * clustering_factor * trans_factor * density_factor *\n            hetero_factor * median_factor * min_factor * max_factor *\n            assort_factor * tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a simple random‑graph intuition with multiplicative\n    corrections for clustering, density, degree heterogeneity, assortativity,\n    extreme degrees, transitivity, and triangle density.  The median degree\n    is also used as an additional heterogeneity cue.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float, -1..1)\n        - 'num_triangles' (int)\n        - 'degrees' (list[int]): sorted degree list\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Individual feature values\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    density = s['density']\n    std_deg = max(s['std_degree'], 0.0)\n    min_deg = max(s['min_degree'], 1.0)\n    max_deg = max(s['max_degree'], 1.0)\n    assort = s['degree_assortativity']\n    tri = s['num_triangles']\n\n    # Median degree from the sorted list\n    deg_list = s['degrees']\n    l = len(deg_list)\n    if l == 0:\n        median_deg = 0.0\n    elif l % 2 == 1:\n        median_deg = deg_list[l // 2]\n    else:\n        median_deg = (deg_list[l // 2 - 1] + deg_list[l // 2]) / 2.0\n\n    # Multiplicative corrections\n    clustering_factor = 1.0 + clustering\n    trans_factor      = 1.0 + trans\n    density_factor    = 1.0 / (1.0 + density)\n    hetero_factor     = 1.0 + std_deg / (avg_deg + 1.0)\n    median_factor     = 1.0 + median_deg / (avg_deg + 1.0)\n    min_factor        = 1.0 + min_deg / (avg_deg + 1.0)\n    max_factor        = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    assort_factor     = 1.0 / (1.0 + max(0.0, assort))\n    tri_factor        = 1.0 + tri / (n * n)\n\n    # Final estimate\n    return (base * clustering_factor * trans_factor * density_factor *\n            hetero_factor * median_factor * min_factor * max_factor *\n            assort_factor * tri_factor)", "spearman": 0.5166714167854197, "pearson": 0.4181485470758136, "rmse": 11.020826834602898, "mae": 9.929020872665012}}
{"timestamp": "2026-02-16T15:02:02.065369+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i2_p2_711844216", "generation": 6, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.4995438175270108, "fitness_mode": "correlation", "simplicity_score": 0.12130315031987507, "novelty_bonus": 0.55258102431907, "total_score": 0.42528206853797546, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph intuition with multiplicative corrections\n    for clustering, density, degree heterogeneity, assortativity, hub prominence,\n    minimum degree, transitivity, and the number of triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float, -1..1)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = max(s['max_degree'], 1.0)\n    min_deg = max(s['min_degree'], 1.0)\n    std_deg = max(s['std_degree'], 0.0)\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    tri = s['num_triangles']\n\n    # Basic random‑graph estimate\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering_factor = 1.0 + clustering\n    density_factor     = 1.0 / (1.0 + density)\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    assort_factor      = 1.0 / (1.0 + max(0.0, assort))\n    max_factor         = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    min_factor         = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n    trans_factor       = 1.0 + trans\n    tri_factor         = 1.0 + tri / (n * n)\n\n    return (base * clustering_factor * density_factor *\n            hetero_factor * assort_factor * max_factor *\n            min_factor * trans_factor * tri_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.137076\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.279424\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The expression blends a simple random‑graph\n    intuition with multiplicative corrections for clustering, density,\n    degree heterogeneity, assortativity, hub prominence, and triangle\n    density.  No external libraries are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'max_degree' (int or float)\n        - 'degree_assortativity' (float, –1..1)\n        - 'transitivity' (float, 0–1)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Corrections based on structural properties\n    clustering_factor = 1.0 + s['avg_clustering']                     # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])                  # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'] / (avg_deg + 1.0))  # higher degree variance → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / (avg_deg + 1.0))  # very low min degree can lengthen paths\n    max_factor         = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1.0))  # very high max degree can shorten paths\n    assort_factor      = 1.0 / (1.0 + max(0.0, s['degree_assortativity']))  # assortative mixing shortens paths\n    trans_factor       = 1.0 + s['transitivity']                    # higher transitivity → longer paths\n    tri_factor         = 1.0 + s['num_triangles'] / (n * n)          # more triangles → longer paths\n\n    return (base * clustering_factor * density_factor *\n            hetero_factor * min_factor * max_factor *\n            assort_factor * trans_factor * tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The expression blends a simple random‑graph\n    intuition with multiplicative corrections for clustering, density,\n    degree heterogeneity, assortativity, hub prominence, and triangle\n    density.  No external libraries are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'max_degree' (int or float)\n        - 'degree_assortativity' (float, –1..1)\n        - 'transitivity' (float, 0–1)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Corrections based on structural properties\n    clustering_factor = 1.0 + s['avg_clustering']                     # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])                  # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'] / (avg_deg + 1.0))  # higher degree variance → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / (avg_deg + 1.0))  # very low min degree can lengthen paths\n    max_factor         = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1.0))  # very high max degree can shorten paths\n    assort_factor      = 1.0 / (1.0 + max(0.0, s['degree_assortativity']))  # assortative mixing shortens paths\n    trans_factor       = 1.0 + s['transitivity']                    # higher transitivity → longer paths\n    tri_factor         = 1.0 + s['num_triangles'] / (n * n)          # more triangles → longer paths\n\n    return (base * clustering_factor * density_factor *\n            hetero_factor * min_factor * max_factor *\n            assort_factor * trans_factor * tri_factor)", "spearman": 0.47049426235655895, "pearson": 0.44551471649679286, "rmse": 1.064049491804406, "mae": 0.747541689878586}}
{"timestamp": "2026-02-16T15:02:32.018216+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i2_p3_794861729", "generation": 6, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.6717406962785114, "fitness_mode": "correlation", "simplicity_score": 0.14297284142629457, "novelty_bonus": 0.41136866145069884, "total_score": 0.48177116087032235, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph intuition with multiplicative corrections\n    for clustering, density, degree heterogeneity, assortativity, hub prominence,\n    minimum degree, transitivity, and the number of triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float, -1..1)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = max(s['max_degree'], 1.0)\n    min_deg = max(s['min_degree'], 1.0)\n    std_deg = max(s['std_degree'], 0.0)\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    tri = s['num_triangles']\n\n    # Basic random‑graph estimate\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering_factor = 1.0 + clustering\n    density_factor     = 1.0 / (1.0 + density)\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    assort_factor      = 1.0 / (1.0 + max(0.0, assort))\n    max_factor         = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    min_factor         = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n    trans_factor       = 1.0 + trans\n    tri_factor         = 1.0 + tri / (n * n)\n\n    return (base * clustering_factor * density_factor *\n            hetero_factor * assort_factor * max_factor *\n            min_factor * trans_factor * tri_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.137076\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.279424\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The formula is a lightweight heuristic that\n    combines a basic random‑graph intuition with multiplicative\n    corrections for clustering, transitivity, density, degree\n    heterogeneity and the spread of the degree distribution.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n\n    # Basic random‑graph estimate\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Feature‑based multiplicative corrections\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    density = s['density']\n    std_deg = max(s['std_degree'], 0.0)\n    max_deg = max(s['max_degree'], 1.0)\n    min_deg = max(s['min_degree'], 1.0)\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n\n    # Denominator collects factors that tend to shorten paths\n    denom = (1.0 + density +\n             std_deg / avg_deg +\n             max_deg / (avg_deg + 1.0) +\n             min_deg / (avg_deg + 1.0))\n\n    return base * f_clust * f_trans / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The formula is a lightweight heuristic that\n    combines a basic random‑graph intuition with multiplicative\n    corrections for clustering, transitivity, density, degree\n    heterogeneity and the spread of the degree distribution.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n\n    # Basic random‑graph estimate\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Feature‑based multiplicative corrections\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    density = s['density']\n    std_deg = max(s['std_degree'], 0.0)\n    max_deg = max(s['max_degree'], 1.0)\n    min_deg = max(s['min_degree'], 1.0)\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n\n    # Denominator collects factors that tend to shorten paths\n    denom = (1.0 + density +\n             std_deg / avg_deg +\n             max_deg / (avg_deg + 1.0) +\n             min_deg / (avg_deg + 1.0))\n\n    return base * f_clust * f_trans / denom", "spearman": 0.6595319882997076, "pearson": 0.6312977429169573, "rmse": 1.3686196791989513, "mae": 0.9823643582553825}}
{"timestamp": "2026-02-16T15:03:12.795662+00:00", "event_type": "candidate_rejected", "payload": {"generation": 6, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:03:12.796784+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 6, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:03:45.437347+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i2_p4_706660071", "generation": 6, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.6009603841536615, "fitness_mode": "correlation", "simplicity_score": 0.12359980708399809, "novelty_bonus": 0.46975317043063236, "total_score": 0.42833022965391704, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph intuition with multiplicative corrections\n    for clustering, density, degree heterogeneity, assortativity, hub prominence,\n    minimum degree, transitivity, and the number of triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float, -1..1)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = max(s['max_degree'], 1.0)\n    min_deg = max(s['min_degree'], 1.0)\n    std_deg = max(s['std_degree'], 0.0)\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    tri = s['num_triangles']\n\n    # Basic random‑graph estimate\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering_factor = 1.0 + clustering\n    density_factor     = 1.0 / (1.0 + density)\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    assort_factor      = 1.0 / (1.0 + max(0.0, assort))\n    max_factor         = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    min_factor         = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n    trans_factor       = 1.0 + trans\n    tri_factor         = 1.0 + tri / (n * n)\n\n    return (base * clustering_factor * density_factor *\n            hetero_factor * assort_factor * max_factor *\n            min_factor * trans_factor * tri_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.137076\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.279424\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport math\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The expression is a compact, multiplicative heuristic that blends a basic\n    random‑graph intuition with corrections for density, clustering,\n    degree heterogeneity, assortativity, triangle density, and the presence\n    of high‑degree hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float)\n            - 'transitivity' (float)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list[int], sorted ascending)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic parameters\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)\n    max_deg    = max(s['max_degree'], 1.0)\n    min_deg    = max(s['min_degree'], 1.0)\n    std_deg    = max(s['std_degree'], 0.0)\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    tri        = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Core random‑graph estimate (log‑scaled to temper growth)\n    base = math.log(n + 1) * (1.0 - density) / (avg_deg + 1.0)\n\n    # 2. Corrections\n    clustering_factor = 1.0 + clustering                # more triangles → longer paths\n    hetero_factor     = 1.0 + std_deg / (avg_deg + 1.0)   # high heterogeneity → shorter paths\n    assort_factor     = 1.0 + max(0.0, assort)           # assortative mixing → slightly longer paths\n    tri_factor        = 1.0 + tri / (n * (n - 1) / 2.0)   # relative triangle density\n    min_factor        = 1.0 + min_deg / (avg_deg + 1.0)   # very low minimum degree → longer paths\n\n    # 3. Hub prominence: average degree of the top 10% nodes\n    topk = max(1, len(degrees) // 10)\n    top_avg = sum(degrees[-topk:]) / topk\n    hub_factor = 1.0 + (top_avg / (avg_deg + 1.0))\n\n    # 4. Combine all multiplicative factors\n    return (base *\n            clustering_factor *\n            hetero_factor *\n            assort_factor *\n            tri_factor *\n            min_factor *\n            hub_factor)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    for clustering, density, degree heterogeneity, assortativity, triangle\n    density, minimum degree and hub prominence.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float)\n            - 'transitivity' (float)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list[int], sorted ascending)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    min_deg = max(s['min_degree'], 1.0)\n    std_deg = max(s['std_degree'], 0.0)\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: more nodes and lower average degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + clustering\n    hetero_factor     = 1.0 + std_deg / (avg_deg + 1.0)\n    assort_factor     = 1.0 + max(0.0, assort)\n    tri_factor        = 1.0 + tri / (n * (n - 1) / 2.0) if n > 1 else 1.0\n    min_factor        = 1.0 + min_deg / (avg_deg + 1.0)\n\n    # Hub prominence: average degree of the top 10% nodes\n    topk = max(1, len(degrees) // 10)\n    top_avg = sum(degrees[-topk:]) / topk\n    hub_factor = 1.0 + top_avg / (avg_deg + 1.0)\n\n    return (base *\n            clustering_factor *\n            hetero_factor *\n            assort_factor *\n            tri_factor *\n            min_factor *\n            hub_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    for clustering, density, degree heterogeneity, assortativity, triangle\n    density, minimum degree and hub prominence.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float)\n            - 'transitivity' (float)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list[int], sorted ascending)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    min_deg = max(s['min_degree'], 1.0)\n    std_deg = max(s['std_degree'], 0.0)\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: more nodes and lower average degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + clustering\n    hetero_factor     = 1.0 + std_deg / (avg_deg + 1.0)\n    assort_factor     = 1.0 + max(0.0, assort)\n    tri_factor        = 1.0 + tri / (n * (n - 1) / 2.0) if n > 1 else 1.0\n    min_factor        = 1.0 + min_deg / (avg_deg + 1.0)\n\n    # Hub prominence: average degree of the top 10% nodes\n    topk = max(1, len(degrees) // 10)\n    top_avg = sum(degrees[-topk:]) / topk\n    hub_factor = 1.0 + top_avg / (avg_deg + 1.0)\n\n    return (base *\n            clustering_factor *\n            hetero_factor *\n            assort_factor *\n            tri_factor *\n            min_factor *\n            hub_factor)", "spearman": 0.5253686342158554, "pearson": 0.5138235672043361, "rmse": 77.45145947096533, "mae": 60.23151395422201}}
{"timestamp": "2026-02-16T15:03:45.438126+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 6, "island_id": 2, "population_idx": 4, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:04:30.773719+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i3_p0_359189707", "generation": 6, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5652340936374549, "fitness_mode": "correlation", "simplicity_score": 0.15540610299599972, "novelty_bonus": 0.3426280657016425, "total_score": 0.3987447621877397, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from global graph statistics\n    without performing any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys include:\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity, num_triangles,\n        degrees (sorted ascending list of degrees).\n\n    Returns\n    -------\n    float\n        A single numeric value intended to correlate with the true average\n        shortest‑path length of the graph.\n    \"\"\"\n    # Basic quantities\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # Derived ratios / factors\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # 1. Baseline from node/edge ratio\n    base = (n + 1.0) / (m + 1.0)\n\n    # 2. Adjust for overall density\n    dens_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity (std / mean)\n    het_factor = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # 4. Clustering suppresses long paths\n    clus_factor = 1.0 / (1.0 + avg_clust)\n\n    # 5. Transitivity encourages alternative routes\n    trans_factor = 1.0 + trans\n\n    # 6. Assortativity influences mixing of high‑degree nodes\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Triangle presence reduces distance\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # 8. Range between hubs and leaf nodes\n    deg_range = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 9. Fraction of total degree held by the top 10% nodes\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # 10. Combine all influences multiplicatively\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clus_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_train_threshold: train_signal=0.199232\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a set of pre‑computed\n    graph statistics.  The formula blends several structural features\n    (density, degree heterogeneity, clustering, assortativity,\n    triangle density, hub prominence) into a single scalar that\n    is expected to correlate with the true average path length.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics containing at least the following keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees.\n    \n    Returns\n    -------\n    float\n        An invariant value intended to capture the typical path length\n        behaviour of the graph.\n    \"\"\"\n    # Basic quantities\n    n   = s.get('n', 1)\n    m   = s.get('m', 0)\n    avg_deg   = s.get('avg_degree', 0.0)\n    max_deg   = s.get('max_degree', 1)\n    min_deg   = s.get('min_degree', 1)\n    std_deg   = s.get('std_degree', 0.0)\n    clus      = s.get('avg_clustering', 0.0)\n    trans     = s.get('transitivity', 0.0)\n    assort    = s.get('degree_assortativity', 0.0)\n    num_tri   = s.get('num_triangles', 0)\n    degrees   = s.get('degrees', [])\n\n    # 1. Base from node/edge ratio (regularised by +1)\n    base = n / (m + 1.0)\n\n    # 2. Adjust for degree spread (std / mean)\n    deg_hom = (1.0 + std_deg) / (1.0 + avg_deg + 1e-6)\n\n    # 3. Clustering dampens long paths\n    clus_f = 1.0 / (1.0 + clus)\n\n    # 4. Transitivity can create shortcuts\n    trans_f = 1.0 + trans\n\n    # 5. Assortativity influences mixing of high‑degree nodes\n    assort_f = 1.0 + abs(assort)\n\n    # 6. Triangle presence reduces distance\n    tri_f = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # 7. Hub‑leaf range\n    hub_leaf_f = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 8. High‑degree concentration (top 10 % of nodes)\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    high_ratio = high_sum / total_deg\n    hub_f = 1.0 + (1.0 - high_ratio) * deg_hom\n\n    # 9. Composite product\n    estimate = (\n        base *\n        deg_hom *\n        clus_f *\n        trans_f *\n        assort_f *\n        tri_f *\n        hub_leaf_f *\n        hub_f\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a set of pre‑computed\n    graph statistics.  The formula blends several structural features\n    (density, degree heterogeneity, clustering, assortativity,\n    triangle density, hub prominence) into a single scalar that\n    is expected to correlate with the true average path length.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics containing at least the following keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees.\n    \n    Returns\n    -------\n    float\n        An invariant value intended to capture the typical path length\n        behaviour of the graph.\n    \"\"\"\n    # Basic quantities\n    n   = s.get('n', 1)\n    m   = s.get('m', 0)\n    avg_deg   = s.get('avg_degree', 0.0)\n    max_deg   = s.get('max_degree', 1)\n    min_deg   = s.get('min_degree', 1)\n    std_deg   = s.get('std_degree', 0.0)\n    clus      = s.get('avg_clustering', 0.0)\n    trans     = s.get('transitivity', 0.0)\n    assort    = s.get('degree_assortativity', 0.0)\n    num_tri   = s.get('num_triangles', 0)\n    degrees   = s.get('degrees', [])\n\n    # 1. Base from node/edge ratio (regularised by +1)\n    base = n / (m + 1.0)\n\n    # 2. Adjust for degree spread (std / mean)\n    deg_hom = (1.0 + std_deg) / (1.0 + avg_deg + 1e-6)\n\n    # 3. Clustering dampens long paths\n    clus_f = 1.0 / (1.0 + clus)\n\n    # 4. Transitivity can create shortcuts\n    trans_f = 1.0 + trans\n\n    # 5. Assortativity influences mixing of high‑degree nodes\n    assort_f = 1.0 + abs(assort)\n\n    # 6. Triangle presence reduces distance\n    tri_f = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # 7. Hub‑leaf range\n    hub_leaf_f = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 8. High‑degree concentration (top 10 % of nodes)\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    high_ratio = high_sum / total_deg\n    hub_f = 1.0 + (1.0 - high_ratio) * deg_hom\n\n    # 9. Composite product\n    estimate = (\n        base *\n        deg_hom *\n        clus_f *\n        trans_f *\n        assort_f *\n        tri_f *\n        hub_leaf_f *\n        hub_f\n    )\n\n    return float(estimate)", "spearman": 0.529750243756094, "pearson": 0.49667684851165733, "rmse": 10.08857414992412, "mae": 4.583922789726438}}
{"timestamp": "2026-02-16T15:05:08.006465+00:00", "event_type": "candidate_rejected", "payload": {"generation": 6, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.161681", "model_name": "gpt-oss:20b", "train_signal": 0.16168067226890756}}
{"timestamp": "2026-02-16T15:05:51.752148+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i3_p2_842428347", "generation": 6, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5539015606242498, "fitness_mode": "correlation", "simplicity_score": 0.1548007963727991, "novelty_bonus": 0.3244131103277581, "total_score": 0.40285620667574484, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from global graph statistics\n    without performing any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys include:\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity, num_triangles,\n        degrees (sorted ascending list of degrees).\n\n    Returns\n    -------\n    float\n        A single numeric value intended to correlate with the true average\n        shortest‑path length of the graph.\n    \"\"\"\n    # Basic quantities\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # Derived ratios / factors\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # 1. Baseline from node/edge ratio\n    base = (n + 1.0) / (m + 1.0)\n\n    # 2. Adjust for overall density\n    dens_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity (std / mean)\n    het_factor = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # 4. Clustering suppresses long paths\n    clus_factor = 1.0 / (1.0 + avg_clust)\n\n    # 5. Transitivity encourages alternative routes\n    trans_factor = 1.0 + trans\n\n    # 6. Assortativity influences mixing of high‑degree nodes\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Triangle presence reduces distance\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # 8. Range between hubs and leaf nodes\n    deg_range = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 9. Fraction of total degree held by the top 10% nodes\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # 10. Combine all influences multiplicatively\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clus_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_train_threshold: train_signal=0.161681\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics.\n    The formula is a multiplicative blend of factors that capture sparsity,\n    degree heterogeneity, clustering, assortativity, triangle density,\n    degree range, and the concentration of degree among the top 10 % nodes.\n    No graph traversal or external libraries are used.\n    \"\"\"\n\n    # ----- Pull statistics from the dict with sensible defaults -----\n    n = s.get('n', 1)                     # number of nodes\n    m = s.get('m', 0)                     # number of edges\n    density = s.get('density', 0.0)        # edge density\n    avg_deg = s.get('avg_degree', 0.0)     # average degree\n    max_deg = s.get('max_degree', 0)       # maximum degree\n    min_deg = s.get('min_degree', 1)       # minimum degree (avoid zero)\n    std_deg = s.get('std_degree', 0.0)     # std of degree\n    avg_clust = s.get('avg_clustering', 0.0)  # average local clustering\n    trans = s.get('transitivity', 0.0)     # global transitivity\n    assort = s.get('degree_assortativity', 0.0) # degree assortativity\n    num_tri = s.get('num_triangles', 0)    # number of triangles\n    degrees = s.get('degrees', [])         # sorted list of degrees\n\n    # ----- Individual factor construction -----\n\n    # 1. Base sparsity factor (node/edge ratio)\n    base = (n + 1.0) / (m + 1.0)\n\n    # 2. Adjust for density (denser graphs tend to have shorter paths)\n    dens_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity: high std relative to mean inflates distance\n    het_factor = 1.0 + std_deg / (avg_deg + 1e-6)\n\n    # 4. Clustering suppresses long paths\n    clus_factor = 1.0 / (1.0 + avg_clust)\n\n    # 5. Transitivity encourages alternative routes\n    trans_factor = 1.0 + trans\n\n    # 6. Assortativity: extreme mixing patterns affect reachability\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Triangle density: many triangles usually shorten distances\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # 8. Degree range: very disparate hubs and leaves can increase distance\n    deg_range_factor = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 9. Concentration of degree in top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # ----- Combine all factors multiplicatively -----\n    estimate = (\n        base *\n        dens_factor *\n        het_factor *\n        clus_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        deg_range_factor *\n        top_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics.\n    The formula is a multiplicative blend of factors that capture sparsity,\n    degree heterogeneity, clustering, assortativity, triangle density,\n    degree range, and the concentration of degree among the top 10 % nodes.\n    No graph traversal or external libraries are used.\n    \"\"\"\n\n    # ----- Pull statistics from the dict with sensible defaults -----\n    n = s.get('n', 1)                     # number of nodes\n    m = s.get('m', 0)                     # number of edges\n    density = s.get('density', 0.0)        # edge density\n    avg_deg = s.get('avg_degree', 0.0)     # average degree\n    max_deg = s.get('max_degree', 0)       # maximum degree\n    min_deg = s.get('min_degree', 1)       # minimum degree (avoid zero)\n    std_deg = s.get('std_degree', 0.0)     # std of degree\n    avg_clust = s.get('avg_clustering', 0.0)  # average local clustering\n    trans = s.get('transitivity', 0.0)     # global transitivity\n    assort = s.get('degree_assortativity', 0.0) # degree assortativity\n    num_tri = s.get('num_triangles', 0)    # number of triangles\n    degrees = s.get('degrees', [])         # sorted list of degrees\n\n    # ----- Individual factor construction -----\n\n    # 1. Base sparsity factor (node/edge ratio)\n    base = (n + 1.0) / (m + 1.0)\n\n    # 2. Adjust for density (denser graphs tend to have shorter paths)\n    dens_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity: high std relative to mean inflates distance\n    het_factor = 1.0 + std_deg / (avg_deg + 1e-6)\n\n    # 4. Clustering suppresses long paths\n    clus_factor = 1.0 / (1.0 + avg_clust)\n\n    # 5. Transitivity encourages alternative routes\n    trans_factor = 1.0 + trans\n\n    # 6. Assortativity: extreme mixing patterns affect reachability\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Triangle density: many triangles usually shorten distances\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # 8. Degree range: very disparate hubs and leaves can increase distance\n    deg_range_factor = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 9. Concentration of degree in top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # ----- Combine all factors multiplicatively -----\n    estimate = (\n        base *\n        dens_factor *\n        het_factor *\n        clus_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        deg_range_factor *\n        top_factor\n    )\n\n    return float(estimate)", "spearman": 0.5491442286057152, "pearson": 0.5427686926457578, "rmse": 31.314059254215714, "mae": 18.04281570397569}}
{"timestamp": "2026-02-16T15:06:29.579339+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i3_p3_269543149", "generation": 6, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.4672749099639856, "fitness_mode": "correlation", "simplicity_score": 0.15496444808976534, "novelty_bonus": 0.4479981999549988, "total_score": 0.38009946728239463, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from global graph statistics\n    without performing any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys include:\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity, num_triangles,\n        degrees (sorted ascending list of degrees).\n\n    Returns\n    -------\n    float\n        A single numeric value intended to correlate with the true average\n        shortest‑path length of the graph.\n    \"\"\"\n    # Basic quantities\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # Derived ratios / factors\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # 1. Baseline from node/edge ratio\n    base = (n + 1.0) / (m + 1.0)\n\n    # 2. Adjust for overall density\n    dens_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity (std / mean)\n    het_factor = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # 4. Clustering suppresses long paths\n    clus_factor = 1.0 / (1.0 + avg_clust)\n\n    # 5. Transitivity encourages alternative routes\n    trans_factor = 1.0 + trans\n\n    # 6. Assortativity influences mixing of high‑degree nodes\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Triangle presence reduces distance\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # 8. Range between hubs and leaf nodes\n    deg_range = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 9. Fraction of total degree held by the top 10% nodes\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # 10. Combine all influences multiplicatively\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clus_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_train_threshold: train_signal=0.161681\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using a composite formula\n    built from global structural statistics.  The expression mixes\n    multiplicative and additive terms, uses fractional powers for\n    non‑linearity, and deliberately avoids any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features with mandatory keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted ascending list).\n\n    Returns\n    -------\n    float\n        An invariant value expected to correlate with the true\n        average shortest‑path length of the graph.\n    \"\"\"\n    # Basic statistics (fallbacks are harmless if missing)\n    n   = s.get('n', 1)\n    m   = s.get('m', 0)\n    density          = s.get('density', 0.0)\n    avg_deg          = s.get('avg_degree', 0.0)\n    max_deg          = s.get('max_degree', 0)\n    min_deg          = s.get('min_degree', 1)\n    std_deg          = s.get('std_degree', 0.0)\n    avg_clust        = s.get('avg_clustering', 0.0)\n    trans            = s.get('transitivity', 0.0)\n    assort           = s.get('degree_assortativity', 0.0)\n    num_tri          = s.get('num_triangles', 0)\n    degrees          = s.get('degrees', [])\n\n    # --- 1. Size‑to‑edges baseline -----------------------------------------\n    base = (n + 1.0) / (m + 1.0)\n\n    # --- 2. Density adjustment (denser graphs usually have shorter paths) ---\n    dens_factor = 1.0 / (1.0 + density)\n\n    # --- 3. Clustering versus transitivity ----------------------------------\n    clus_factor = (1.0 + avg_clust) / (1.0 + trans)\n\n    # --- 4. Assortativity influence -----------------------------------------\n    assort_factor = 1.0 + abs(assort)\n\n    # --- 5. Triangle effect -------------------------------------------------\n    tri_factor = (pow(num_tri, 0.5) + 1.0) / (pow(n, 0.5) + 1.0)\n\n    # --- 6. Degree heterogeneity --------------------------------------------\n    het_factor = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # --- 7. Degree range impact ---------------------------------------------\n    deg_range_factor = (max_deg + 1.0) / (min_deg + 1.0e-6)\n\n    # --- 8. Hub dominance (top 10% degree share) ---------------------------\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    top_ratio = high_sum / (total_deg + 1e-6)\n    hub_factor = 1.0 + (1.0 - top_ratio)  # larger when few nodes hold much degree\n\n    # --- 9. Combine all effects multiplicatively ----------------------------\n    estimate = (\n        base\n        * dens_factor\n        * clus_factor\n        * assort_factor\n        * tri_factor\n        * het_factor\n        * deg_range_factor\n        * hub_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using a composite formula\n    built from global structural statistics.  The expression mixes\n    multiplicative and additive terms, uses fractional powers for\n    non‑linearity, and deliberately avoids any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features with mandatory keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted ascending list).\n\n    Returns\n    -------\n    float\n        An invariant value expected to correlate with the true\n        average shortest‑path length of the graph.\n    \"\"\"\n    # Basic statistics (fallbacks are harmless if missing)\n    n   = s.get('n', 1)\n    m   = s.get('m', 0)\n    density          = s.get('density', 0.0)\n    avg_deg          = s.get('avg_degree', 0.0)\n    max_deg          = s.get('max_degree', 0)\n    min_deg          = s.get('min_degree', 1)\n    std_deg          = s.get('std_degree', 0.0)\n    avg_clust        = s.get('avg_clustering', 0.0)\n    trans            = s.get('transitivity', 0.0)\n    assort           = s.get('degree_assortativity', 0.0)\n    num_tri          = s.get('num_triangles', 0)\n    degrees          = s.get('degrees', [])\n\n    # --- 1. Size‑to‑edges baseline -----------------------------------------\n    base = (n + 1.0) / (m + 1.0)\n\n    # --- 2. Density adjustment (denser graphs usually have shorter paths) ---\n    dens_factor = 1.0 / (1.0 + density)\n\n    # --- 3. Clustering versus transitivity ----------------------------------\n    clus_factor = (1.0 + avg_clust) / (1.0 + trans)\n\n    # --- 4. Assortativity influence -----------------------------------------\n    assort_factor = 1.0 + abs(assort)\n\n    # --- 5. Triangle effect -------------------------------------------------\n    tri_factor = (pow(num_tri, 0.5) + 1.0) / (pow(n, 0.5) + 1.0)\n\n    # --- 6. Degree heterogeneity --------------------------------------------\n    het_factor = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # --- 7. Degree range impact ---------------------------------------------\n    deg_range_factor = (max_deg + 1.0) / (min_deg + 1.0e-6)\n\n    # --- 8. Hub dominance (top 10% degree share) ---------------------------\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    top_ratio = high_sum / (total_deg + 1e-6)\n    hub_factor = 1.0 + (1.0 - top_ratio)  # larger when few nodes hold much degree\n\n    # --- 9. Combine all effects multiplicatively ----------------------------\n    estimate = (\n        base\n        * dens_factor\n        * clus_factor\n        * assort_factor\n        * tri_factor\n        * het_factor\n        * deg_range_factor\n        * hub_factor\n    )\n\n    return float(estimate)", "spearman": 0.4294142353558839, "pearson": 0.3855715781456677, "rmse": 2.2641182374249764, "mae": 1.6461491315250916}}
{"timestamp": "2026-02-16T15:07:11.084711+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i3_p4_764906298", "generation": 6, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5806962785114045, "fitness_mode": "correlation", "simplicity_score": 0.1568227341420188, "novelty_bonus": 0.32561614040351006, "total_score": 0.4048485339280813, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from global graph statistics\n    without performing any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys include:\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity, num_triangles,\n        degrees (sorted ascending list of degrees).\n\n    Returns\n    -------\n    float\n        A single numeric value intended to correlate with the true average\n        shortest‑path length of the graph.\n    \"\"\"\n    # Basic quantities\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # Derived ratios / factors\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # 1. Baseline from node/edge ratio\n    base = (n + 1.0) / (m + 1.0)\n\n    # 2. Adjust for overall density\n    dens_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity (std / mean)\n    het_factor = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # 4. Clustering suppresses long paths\n    clus_factor = 1.0 / (1.0 + avg_clust)\n\n    # 5. Transitivity encourages alternative routes\n    trans_factor = 1.0 + trans\n\n    # 6. Assortativity influences mixing of high‑degree nodes\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Triangle presence reduces distance\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # 8. Range between hubs and leaf nodes\n    deg_range = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 9. Fraction of total degree held by the top 10% nodes\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # 10. Combine all influences multiplicatively\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clus_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_train_threshold: train_signal=0.161681\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length using only\n    global graph statistics.  The formula combines a baseline\n    based on node/edge ratio with corrections for density,\n    degree heterogeneity, clustering, transitivity, assortativity,\n    triangle abundance, degree range and the concentration of\n    high‑degree nodes.  No graph traversal is performed.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted).\n\n    Returns\n    -------\n    float\n        A single scalar value intended to correlate with the true\n        average shortest‑path length.\n    \"\"\"\n    # Basic graph counts\n    n = s['n']\n    m = s['m']\n\n    # Avoid division by zero by adding 1 to denominators\n    base = (n + 1.0) / (m + 1.0)\n\n    # Correction for overall density: sparse graphs tend to have longer paths\n    dens_factor = 1.0 / (1.0 + s['density'])\n\n    # Degree heterogeneity: larger variance relative to the mean tends to reduce\n    # average path length by providing hubs.\n    het_factor = (1.0 + s['std_degree']) / (1.0 + s['avg_degree'])\n\n    # Clustering suppresses long paths; higher clustering usually shortens distances.\n    clust_factor = 1.0 / (1.0 + s['avg_clustering'])\n\n    # Transitivity increases alternative routes, slightly shortening paths.\n    trans_factor = 1.0 + s['transitivity']\n\n    # Assortativity measures mixing of high/low degree nodes; absolute value\n    # captures its influence regardless of sign.\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Triangle abundance lowers path lengths; sqrt gives diminishing returns.\n    tri_factor = 1.0 + (s['num_triangles'] ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range amplifies the effect of a few hubs versus many leaves.\n    deg_range = (s['max_degree'] + 1.0) / (s['min_degree'] + 1e-6)\n\n    # Concentration of high‑degree nodes: compute the fraction of total degree\n    # held by the top 10 % nodes.  A smaller fraction implies more dispersed hubs.\n    top_k = max(1, n // 10)                     # integer number of top nodes\n    high_sum = sum(s['degrees'][-top_k:]) if s['degrees'] else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Combine all factors multiplicatively to obtain the estimate\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clust_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length using only\n    global graph statistics.  The formula combines a baseline\n    based on node/edge ratio with corrections for density,\n    degree heterogeneity, clustering, transitivity, assortativity,\n    triangle abundance, degree range and the concentration of\n    high‑degree nodes.  No graph traversal is performed.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted).\n\n    Returns\n    -------\n    float\n        A single scalar value intended to correlate with the true\n        average shortest‑path length.\n    \"\"\"\n    # Basic graph counts\n    n = s['n']\n    m = s['m']\n\n    # Avoid division by zero by adding 1 to denominators\n    base = (n + 1.0) / (m + 1.0)\n\n    # Correction for overall density: sparse graphs tend to have longer paths\n    dens_factor = 1.0 / (1.0 + s['density'])\n\n    # Degree heterogeneity: larger variance relative to the mean tends to reduce\n    # average path length by providing hubs.\n    het_factor = (1.0 + s['std_degree']) / (1.0 + s['avg_degree'])\n\n    # Clustering suppresses long paths; higher clustering usually shortens distances.\n    clust_factor = 1.0 / (1.0 + s['avg_clustering'])\n\n    # Transitivity increases alternative routes, slightly shortening paths.\n    trans_factor = 1.0 + s['transitivity']\n\n    # Assortativity measures mixing of high/low degree nodes; absolute value\n    # captures its influence regardless of sign.\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Triangle abundance lowers path lengths; sqrt gives diminishing returns.\n    tri_factor = 1.0 + (s['num_triangles'] ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range amplifies the effect of a few hubs versus many leaves.\n    deg_range = (s['max_degree'] + 1.0) / (s['min_degree'] + 1e-6)\n\n    # Concentration of high‑degree nodes: compute the fraction of total degree\n    # held by the top 10 % nodes.  A smaller fraction implies more dispersed hubs.\n    top_k = max(1, n // 10)                     # integer number of top nodes\n    high_sum = sum(s['degrees'][-top_k:]) if s['degrees'] else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Combine all factors multiplicatively to obtain the estimate\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clust_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)", "spearman": 0.551598289957249, "pearson": 0.49785731961787527, "rmse": 9.825653177358184, "mae": 4.345392106197964}}
{"timestamp": "2026-02-16T15:07:11.087441+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 7, "model_name": "gpt-oss:20b", "best_val_score": 0.526450498609911, "no_improve_count": 3}}
{"timestamp": "2026-02-16T15:08:20.167507+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i0_p0_40939585", "generation": 7, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.428859543817527, "fitness_mode": "correlation", "simplicity_score": 0.22198301595492897, "novelty_bonus": 0.40560264006600155, "total_score": 0.3381534471120838, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, and triangle counts in a compact, interpretable\n    way.  No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    # Basic scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed graph\n    statistics.  The formula is a compact, interpretable combination of size,\n    degree distribution, density, clustering, transitivity, assortativity,\n    and triangle counts.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.142711\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.132581\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and median degree in a\n    compact, interpretable way.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for density and presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Additive contribution from triangles\n    base += triangles / (m + 1.0)\n\n    # Median degree adjustment (median is at index len//2 in sorted list)\n    median_deg = degrees[len(degrees)//2] if degrees else avg_deg\n    base *= (1.0 + (median_deg - min_deg) / (avg_deg + 1.0))\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and median degree in a\n    compact, interpretable way.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for density and presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Additive contribution from triangles\n    base += triangles / (m + 1.0)\n\n    # Median degree adjustment (median is at index len//2 in sorted list)\n    median_deg = degrees[len(degrees)//2] if degrees else avg_deg\n    base *= (1.0 + (median_deg - min_deg) / (avg_deg + 1.0))\n\n    return base", "spearman": 0.3441521038025951, "pearson": 0.36813810592030993, "rmse": 8.254884768186907, "mae": 7.495997467604696}}
{"timestamp": "2026-02-16T15:08:52.028192+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.012245", "model_name": "gpt-oss:20b", "train_signal": 0.012244897959183673}}
{"timestamp": "2026-02-16T15:10:38.289978+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.037791", "model_name": "gpt-oss:20b", "train_signal": 0.037791116446578635}}
{"timestamp": "2026-02-16T15:11:19.054794+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:11:19.056153+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 7, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:12:41.146483+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.110253", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:12:41.147150+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 7, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:13:36.647999+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i0_p4_514458785", "generation": 7, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.614501800720288, "fitness_mode": "correlation", "simplicity_score": 0.22104548362902313, "novelty_bonus": 0.2515378329317921, "total_score": 0.4768421258973246, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, and triangle counts in a compact, interpretable\n    way.  No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    # Basic scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed graph\n    statistics.  The formula is a compact, interpretable combination of size,\n    degree distribution, density, clustering, transitivity, assortativity,\n    and triangle counts.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.037791\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.110253\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and median degree.\n    No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # median degree (degrees is sorted)\n    L = len(degrees)\n    if L % 2:\n        median_deg = degrees[L // 2]\n    else:\n        median_deg = (degrees[L // 2 - 1] + degrees[L // 2]) / 2.0\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (max_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Median‑degree adjustment (captures skewness)\n    base *= (1.0 + (median_deg - avg_deg) / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and median degree.\n    No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # median degree (degrees is sorted)\n    L = len(degrees)\n    if L % 2:\n        median_deg = degrees[L // 2]\n    else:\n        median_deg = (degrees[L // 2 - 1] + degrees[L // 2]) / 2.0\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (max_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Median‑degree adjustment (captures skewness)\n    base *= (1.0 + (median_deg - avg_deg) / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base", "spearman": 0.7143433585839647, "pearson": 0.602160874393489, "rmse": 8.819582052911565, "mae": 7.288331191647983}}
{"timestamp": "2026-02-16T15:14:10.373935+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i1_p0_664444522", "generation": 7, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.12869598574827396, "novelty_bonus": 0.17722193054826363, "total_score": 0.5131981336230667, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / denom_m\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)   # size & clustering\n    part3 = avg_degree / denom_max_degree         # degree spread\n    part4 = 1 + abs(degree_assortativity)         # assortativity\n    part5 = 1 + transitivity                      # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = deg_ratio                             # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / denom_density                     # density\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / denom_m\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)   # size & clustering\n    part3 = avg_degree / denom_max_degree         # degree spread\n    part4 = 1 + abs(degree_assortativity)         # assortativity\n    part5 = 1 + transitivity                      # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = deg_ratio                             # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / denom_density                     # density\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T15:15:04.940593+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i1_p1_692705087", "generation": 7, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.13071975549633538, "novelty_bonus": 0.17722193054826363, "total_score": 0.5136028875726789, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_max_degree = max(max_degree, 1)\n    denom_min_degree = min_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / denom_m\n    deg_variance = std_degree ** 2\n    deg_ratio = (max_degree + 1) / denom_min_degree\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                                 # sparsity\n    part2 = n ** 0.5 / ((1 + avg_clustering) * denom_density)  # size, clustering, density\n    part3 = 1 + abs(degree_assortativity)                     # assortativity\n    part4 = 1 + transitivity                                 # transitivity\n    part5 = 1 + tri_per_edge                                 # triangles per edge\n    part6 = deg_ratio                                         # degree ratio\n    part7 = 1 / (1 + deg_variance)                           # degree variance\n    part8 = avg_degree / (max_degree + 1)                    # degree spread\n\n    # Final invariant\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_max_degree = max(max_degree, 1)\n    denom_min_degree = min_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / denom_m\n    deg_variance = std_degree ** 2\n    deg_ratio = (max_degree + 1) / denom_min_degree\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                                 # sparsity\n    part2 = n ** 0.5 / ((1 + avg_clustering) * denom_density)  # size, clustering, density\n    part3 = 1 + abs(degree_assortativity)                     # assortativity\n    part4 = 1 + transitivity                                 # transitivity\n    part5 = 1 + tri_per_edge                                 # triangles per edge\n    part6 = deg_ratio                                         # degree ratio\n    part7 = 1 / (1 + deg_variance)                           # degree variance\n    part8 = avg_degree / (max_degree + 1)                    # degree spread\n\n    # Final invariant\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.818633260644265, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T15:15:44.503351+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i1_p2_102633415", "generation": 7, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.12890308834926528, "novelty_bonus": 0.17722193054826363, "total_score": 0.5132395541432648, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant parts\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clust)         # size & clustering\n    part3 = avg_deg / (max_deg + 1)               # degree spread\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = deg_ratio                             # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / denom_density                     # density\n\n    # Final invariant\n    return (part1 * part2 * part3 * part4 *\n            part5 * part6 * part7 * part8 * part9)\n```", "extracted_code": "def new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant parts\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clust)         # size & clustering\n    part3 = avg_deg / (max_deg + 1)               # degree spread\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = deg_ratio                             # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / denom_density                     # density\n\n    # Final invariant\n    return (part1 * part2 * part3 * part4 *\n            part5 * part6 * part7 * part8 * part9)", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T15:16:24.698819+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i1_p3_764297791", "generation": 7, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.12872517154989366, "novelty_bonus": 0.17722193054826363, "total_score": 0.5132039707833905, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / denom_m\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = n ** 0.5 / (1 + avg_clustering)      # size & clustering\n    part3 = avg_degree / denom_max_degree         # degree spread\n    part4 = 1 + abs(degree_assortativity)         # assortativity\n    part5 = 1 + transitivity                      # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = deg_ratio                             # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / denom_density                     # density\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / denom_m\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = n ** 0.5 / (1 + avg_clustering)      # size & clustering\n    part3 = avg_degree / denom_max_degree         # degree spread\n    part4 = 1 + abs(degree_assortativity)         # assortativity\n    part5 = 1 + transitivity                      # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = deg_ratio                             # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / denom_density                     # density\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T15:17:03.076247+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i1_p4_39216143", "generation": 7, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.1292423793826832, "novelty_bonus": 0.17722193054826363, "total_score": 0.5133074123499485, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    std_degree = s['std_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    avg_degree = s['avg_degree']\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n    deg_variance = std_degree ** 2\n    tri_per_edge = num_triangles / denom_m\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    part1 = n / (denom_m + 1)\n    part2 = pow(n, 0.5) / (1 + avg_clustering)\n    part3 = avg_degree / denom_max_degree\n    part4 = 1 + abs(degree_assortativity)\n    part5 = 1 + transitivity\n    part6 = 1 + tri_per_edge\n    part7 = deg_ratio\n    part8 = 1 / (1 + deg_variance)\n    part9 = 1 / denom_density\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    std_degree = s['std_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    avg_degree = s['avg_degree']\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n    deg_variance = std_degree ** 2\n    tri_per_edge = num_triangles / denom_m\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    part1 = n / (denom_m + 1)\n    part2 = pow(n, 0.5) / (1 + avg_clustering)\n    part3 = avg_degree / denom_max_degree\n    part4 = 1 + abs(degree_assortativity)\n    part5 = 1 + transitivity\n    part6 = 1 + tri_per_edge\n    part7 = deg_ratio\n    part8 = 1 / (1 + deg_variance)\n    part9 = 1 / denom_density\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T15:17:45.839036+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i2_p0_192566892", "generation": 7, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.6632893157262905, "fitness_mode": "correlation", "simplicity_score": 0.13165006151528208, "novelty_bonus": 0.41620994927481136, "total_score": 0.4943205752749546, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The formula is a lightweight heuristic that\n    combines a basic random‑graph intuition with multiplicative\n    corrections for clustering, transitivity, density, degree\n    heterogeneity and the spread of the degree distribution.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n\n    # Basic random‑graph estimate\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Feature‑based multiplicative corrections\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    density = s['density']\n    std_deg = max(s['std_degree'], 0.0)\n    max_deg = max(s['max_degree'], 1.0)\n    min_deg = max(s['min_degree'], 1.0)\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n\n    # Denominator collects factors that tend to shorten paths\n    denom = (1.0 + density +\n             std_deg / avg_deg +\n             max_deg / (avg_deg + 1.0) +\n             min_deg / (avg_deg + 1.0))\n\n    return base * f_clust * f_trans / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.137076\nbelow_train_threshold: train_signal=0.279424\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic blends a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Extract features with sensible defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = max(s.get('std_degree', 0.0), 0.0)\n    max_deg = max(s.get('max_degree', 1), 1)\n    min_deg = max(s.get('min_degree', 1), 1)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density (triangles per possible triangle)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n\n    # Denominator collects factors that tend to shorten paths\n    denom = (1.0 + density +\n             assort +\n             std_deg / avg_deg +\n             max_deg / (avg_deg + 1.0) +\n             min_deg / (avg_deg + 1.0) +\n             tri_ratio)\n\n    # Final estimate\n    return base * (1.0 + clustering) * (1.0 + trans) / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic blends a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Extract features with sensible defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = max(s.get('std_degree', 0.0), 0.0)\n    max_deg = max(s.get('max_degree', 1), 1)\n    min_deg = max(s.get('min_degree', 1), 1)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density (triangles per possible triangle)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n\n    # Denominator collects factors that tend to shorten paths\n    denom = (1.0 + density +\n             assort +\n             std_deg / avg_deg +\n             max_deg / (avg_deg + 1.0) +\n             min_deg / (avg_deg + 1.0) +\n             tri_ratio)\n\n    # Final estimate\n    return base * (1.0 + clustering) * (1.0 + trans) / denom", "spearman": 0.6862551563789095, "pearson": 0.6203882757755557, "rmse": 1.2860206479309524, "mae": 0.9108912371194146}}
{"timestamp": "2026-02-16T15:18:37.675366+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.070685", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:18:37.676015+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 7, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.070685", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:19:17.203404+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:19:17.204298+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 7, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:19:57.316102+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i2_p2_71185593", "generation": 7, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.9012725090036015, "fitness_mode": "correlation", "simplicity_score": 0.13591331712960092, "novelty_bonus": 0.16448511212780315, "total_score": 0.5376982263149925, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The formula is a lightweight heuristic that\n    combines a basic random‑graph intuition with multiplicative\n    corrections for clustering, transitivity, density, degree\n    heterogeneity and the spread of the degree distribution.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n\n    # Basic random‑graph estimate\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Feature‑based multiplicative corrections\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    density = s['density']\n    std_deg = max(s['std_degree'], 0.0)\n    max_deg = max(s['max_degree'], 1.0)\n    min_deg = max(s['min_degree'], 1.0)\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n\n    # Denominator collects factors that tend to shorten paths\n    denom = (1.0 + density +\n             std_deg / avg_deg +\n             max_deg / (avg_deg + 1.0) +\n             min_deg / (avg_deg + 1.0))\n\n    return base * f_clust * f_trans / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\nRecent failures:\nbelow_train_threshold: train_signal=0.279424\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min", "spearman": 0.9223400585014627, "pearson": 0.8773389958654999, "rmse": 1.3051288019690377, "mae": 0.8723547541740444}}
{"timestamp": "2026-02-16T15:20:32.179714+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i2_p3_978006382", "generation": 7, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.32581032412965183, "fitness_mode": "correlation", "simplicity_score": 0.18048633785693102, "novelty_bonus": 0.18852613506549654, "total_score": 0.24579843667424978, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The formula is a lightweight heuristic that\n    combines a basic random‑graph intuition with multiplicative\n    corrections for clustering, transitivity, density, degree\n    heterogeneity and the spread of the degree distribution.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n\n    # Basic random‑graph estimate\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Feature‑based multiplicative corrections\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    density = s['density']\n    std_deg = max(s['std_degree'], 0.0)\n    max_deg = max(s['max_degree'], 1.0)\n    min_deg = max(s['min_degree'], 1.0)\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n\n    # Denominator collects factors that tend to shorten paths\n    denom = (1.0 + density +\n             std_deg / avg_deg +\n             max_deg / (avg_deg + 1.0) +\n             min_deg / (avg_deg + 1.0))\n\n    return base * f_clust * f_trans / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\nRecent failures:\nbelow_train_threshold: train_signal=0.279424\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, and the triangle count.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float, –1 to 1)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Feature‑based multiplicative corrections\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    density = s['density']\n    std_deg = max(s['std_degree'], 0.0)\n    assort = s['degree_assortativity']\n    min_deg = max(s['min_degree'], 0.0)\n    max_deg = max(s['max_degree'], 1.0)\n    num_tri = s['num_triangles']\n\n    # Factors that tend to increase path length\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_min = 1.0 + min_deg / avg_deg\n    f_tri = 1.0 + num_tri / max(n, 1)\n\n    # Factors that tend to shorten paths\n    f_density = 1.0 / (1.0 + density)\n    f_hetero = 1.0 / (1.0 + std_deg / avg_deg)\n    f_assort = 1.0 / (1.0 + abs(assort))\n    f_max = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # Combine everything\n    estimate = base * f_clust * f_trans * f_min * f_tri\n    estimate *= f_density * f_hetero * f_assort * f_max\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, and the triangle count.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float, –1 to 1)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Feature‑based multiplicative corrections\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    density = s['density']\n    std_deg = max(s['std_degree'], 0.0)\n    assort = s['degree_assortativity']\n    min_deg = max(s['min_degree'], 0.0)\n    max_deg = max(s['max_degree'], 1.0)\n    num_tri = s['num_triangles']\n\n    # Factors that tend to increase path length\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_min = 1.0 + min_deg / avg_deg\n    f_tri = 1.0 + num_tri / max(n, 1)\n\n    # Factors that tend to shorten paths\n    f_density = 1.0 / (1.0 + density)\n    f_hetero = 1.0 / (1.0 + std_deg / avg_deg)\n    f_assort = 1.0 / (1.0 + abs(assort))\n    f_max = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # Combine everything\n    estimate = base * f_clust * f_trans * f_min * f_tri\n    estimate *= f_density * f_hetero * f_assort * f_max\n\n    return estimate", "spearman": -0.3062866571664292, "pearson": -0.16458222391427466, "rmse": 35.155198845816074, "mae": 18.778409458669604}}
{"timestamp": "2026-02-16T15:21:16.545818+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.073628", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:21:16.546316+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 7, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.073628", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:21:48.729004+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i2_p4_504932355", "generation": 7, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.592797118847539, "fitness_mode": "correlation", "simplicity_score": 0.1818542592934614, "novelty_bonus": 0.16306408450591614, "total_score": 0.404417805403672, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The formula is a lightweight heuristic that\n    combines a basic random‑graph intuition with multiplicative\n    corrections for clustering, transitivity, density, degree\n    heterogeneity and the spread of the degree distribution.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n\n    # Basic random‑graph estimate\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Feature‑based multiplicative corrections\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    density = s['density']\n    std_deg = max(s['std_degree'], 0.0)\n    max_deg = max(s['max_degree'], 1.0)\n    min_deg = max(s['min_degree'], 1.0)\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n\n    # Denominator collects factors that tend to shorten paths\n    denom = (1.0 + density +\n             std_deg / avg_deg +\n             max_deg / (avg_deg + 1.0) +\n             min_deg / (avg_deg + 1.0))\n\n    return base * f_clust * f_trans / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only pre‑computed\n    graph statistics.  The formula is a heuristic that blends a basic\n    random‑graph estimate with corrections for clustering, density and\n    degree heterogeneity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    # Basic estimate: larger n and smaller avg_degree lead to longer paths\n    rand_est = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n\n    return rand_est * clustering_factor * density_factor * hetero_factor\nRecent failures:\nbelow_train_threshold: train_signal=0.279424\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.073628\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph intuition with multiplicative corrections\n    for clustering, transitivity, density, degree heterogeneity, assortativity,\n    degree spread, and triangle count.  All operations are elementary and\n    require no external imports.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature‑based multiplicative corrections\n    clustering_factor = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    transitivity_factor = 1.0 + s['transitivity']          # higher transitivity → longer paths\n    density_factor = 1.0 / (1.0 + s['density'])           # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    assort_factor = 1.0 + abs(s['degree_assortativity'])   # assortative mixing can increase path length\n\n    # Degree spread corrections\n    min_factor = 1.0 / (1.0 + s['min_degree'] / avg_deg)\n    max_factor = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1.0))\n\n    # Triangle correction (more triangles → more local clustering → slightly longer paths)\n    triangle_factor = 1.0 + s['num_triangles'] / (n + 1)\n\n    # Combine all factors\n    estimate = (\n        base\n        * clustering_factor\n        * transitivity_factor\n        * density_factor\n        * hetero_factor\n        * assort_factor\n        * min_factor\n        * max_factor\n        / triangle_factor\n    )\n\n    return estimate\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest path length from a set of\n    pre‑computed graph statistics.  The formula blends a simple\n    random‑graph baseline with multiplicative corrections that capture\n    clustering, density, degree heterogeneity, assortativity, degree\n    spread, triangle abundance and the overall scale of the average\n    degree.  No graph traversal or external libraries are required.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    m = s['m'] if s['m'] > 0 else 1\n\n    # Basic random‑graph baseline: more nodes and fewer edges → longer paths\n    base = n / (m + 1)\n\n    # Scale factor derived from the average degree (adds non‑linearity)\n    avg_deg = max(s['avg_degree'], 1.0)\n    sqrt_avg_deg = avg_deg ** 0.5\n\n    # Corrections that lengthen or shorten paths\n    clust_factor   = 1.0 + s['avg_clustering']          # clustering tends to increase path length\n    trans_factor   = 1.0 + s['transitivity']            # transitivity behaves similarly\n    density_factor = 1.0 + s['density']                 # denser graphs shorten paths\n    hetero_factor  = 1.0 + s['std_degree'] / avg_deg    # degree heterogeneity shortens paths\n    assort_factor  = 1.0 + abs(s['degree_assortativity'])  # assortative mixing can increase paths\n    min_factor     = 1.0 + s['min_degree'] / avg_deg\n    max_factor     = 1.0 + s['max_degree'] / avg_deg\n    tri_factor     = 1.0 + s['num_triangles'] / (n * (avg_deg + 1))\n\n    # Combine all components: multiplicative factors that tend to lengthen\n    # are in the numerator; those that tend to shorten are in the denominator.\n    estimate = (\n        base\n        * sqrt_avg_deg\n        * clust_factor\n        * trans_factor\n        * min_factor\n        * max_factor\n        / (density_factor * hetero_factor * assort_factor * tri_factor)\n    )\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest path length from a set of\n    pre‑computed graph statistics.  The formula blends a simple\n    random‑graph baseline with multiplicative corrections that capture\n    clustering, density, degree heterogeneity, assortativity, degree\n    spread, triangle abundance and the overall scale of the average\n    degree.  No graph traversal or external libraries are required.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    m = s['m'] if s['m'] > 0 else 1\n\n    # Basic random‑graph baseline: more nodes and fewer edges → longer paths\n    base = n / (m + 1)\n\n    # Scale factor derived from the average degree (adds non‑linearity)\n    avg_deg = max(s['avg_degree'], 1.0)\n    sqrt_avg_deg = avg_deg ** 0.5\n\n    # Corrections that lengthen or shorten paths\n    clust_factor   = 1.0 + s['avg_clustering']          # clustering tends to increase path length\n    trans_factor   = 1.0 + s['transitivity']            # transitivity behaves similarly\n    density_factor = 1.0 + s['density']                 # denser graphs shorten paths\n    hetero_factor  = 1.0 + s['std_degree'] / avg_deg    # degree heterogeneity shortens paths\n    assort_factor  = 1.0 + abs(s['degree_assortativity'])  # assortative mixing can increase paths\n    min_factor     = 1.0 + s['min_degree'] / avg_deg\n    max_factor     = 1.0 + s['max_degree'] / avg_deg\n    tri_factor     = 1.0 + s['num_triangles'] / (n * (avg_deg + 1))\n\n    # Combine all components: multiplicative factors that tend to lengthen\n    # are in the numerator; those that tend to shorten are in the denominator.\n    estimate = (\n        base\n        * sqrt_avg_deg\n        * clust_factor\n        * trans_factor\n        * min_factor\n        * max_factor\n        / (density_factor * hetero_factor * assort_factor * tri_factor)\n    )\n\n    return estimate", "spearman": 0.6382554563864098, "pearson": 0.5780981931736252, "rmse": 1.0837365399528234, "mae": 0.8033131864746784}}
{"timestamp": "2026-02-16T15:21:48.729543+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 7, "island_id": 2, "population_idx": 4, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:22:20.516990+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i3_p0_538399029", "generation": 7, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5806962785114045, "fitness_mode": "correlation", "simplicity_score": 0.15484711497506606, "novelty_bonus": 0.32561614040351006, "total_score": 0.4044534100946907, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length using only\n    global graph statistics.  The formula combines a baseline\n    based on node/edge ratio with corrections for density,\n    degree heterogeneity, clustering, transitivity, assortativity,\n    triangle abundance, degree range and the concentration of\n    high‑degree nodes.  No graph traversal is performed.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted).\n\n    Returns\n    -------\n    float\n        A single scalar value intended to correlate with the true\n        average shortest‑path length.\n    \"\"\"\n    # Basic graph counts\n    n = s['n']\n    m = s['m']\n\n    # Avoid division by zero by adding 1 to denominators\n    base = (n + 1.0) / (m + 1.0)\n\n    # Correction for overall density: sparse graphs tend to have longer paths\n    dens_factor = 1.0 / (1.0 + s['density'])\n\n    # Degree heterogeneity: larger variance relative to the mean tends to reduce\n    # average path length by providing hubs.\n    het_factor = (1.0 + s['std_degree']) / (1.0 + s['avg_degree'])\n\n    # Clustering suppresses long paths; higher clustering usually shortens distances.\n    clust_factor = 1.0 / (1.0 + s['avg_clustering'])\n\n    # Transitivity increases alternative routes, slightly shortening paths.\n    trans_factor = 1.0 + s['transitivity']\n\n    # Assortativity measures mixing of high/low degree nodes; absolute value\n    # captures its influence regardless of sign.\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Triangle abundance lowers path lengths; sqrt gives diminishing returns.\n    tri_factor = 1.0 + (s['num_triangles'] ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range amplifies the effect of a few hubs versus many leaves.\n    deg_range = (s['max_degree'] + 1.0) / (s['min_degree'] + 1e-6)\n\n    # Concentration of high‑degree nodes: compute the fraction of total degree\n    # held by the top 10 % nodes.  A smaller fraction implies more dispersed hubs.\n    top_k = max(1, n // 10)                     # integer number of top nodes\n    high_sum = sum(s['degrees'][-top_k:]) if s['degrees'] else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Combine all factors multiplicatively to obtain the estimate\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clust_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_train_threshold: train_signal=0.161681\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from pre‑computed graph statistics.\n    The formula blends a node/edge baseline with multiplicative adjustments that\n    capture density, degree heterogeneity, clustering, assortativity, triangle\n    abundance, degree range and the concentration of high‑degree vertices.\n    No traversal algorithm is used; only arithmetic on the provided features.\n    \"\"\"\n    # Basic node/edge ratio (regularised by +1)\n    n = s.get('n', 0.0)\n    m = s.get('m', 0.0)\n    base = (n + 1.0) / (m + 1.0)\n\n    # 1. Sparsity adjustment – sparse graphs usually have larger path lengths\n    dens_factor = 1.0 / (1.0 + s.get('density', 0.0))\n\n    # 2. Degree heterogeneity – high variance tends to shorten paths via hubs\n    avg_deg = s.get('avg_degree', 1.0)\n    std_deg = s.get('std_degree', 0.0)\n    het_factor = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # 3. Clustering suppression – more local triangles typically reduce path length\n    clus = s.get('avg_clustering', 0.0)\n    clust_factor = 1.0 / (1.0 + clus)\n\n    # 4. Transitivity boost – alternative routes lower distances\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + trans\n\n    # 5. Assortativity influence – absolute value accounts for both positive\n    #    and negative mixing\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # 6. Triangle abundance – sqrt gives diminishing returns\n    tri = s.get('num_triangles', 0.0)\n    tri_factor = 1.0 + (tri ** 0.5) / (n ** 0.5 + 1e-9)\n\n    # 7. Degree range amplification – many hubs vs many leaves\n    max_deg = s.get('max_degree', 1.0)\n    min_deg = s.get('min_degree', 1.0)\n    range_factor = (max_deg + 1.0) / (min_deg + 1e-9)\n\n    # 8. Concentration of high‑degree vertices\n    degrees = s.get('degrees', [])\n    if degrees:\n        top_k = max(1, int(0.1 * n))\n        high_sum = sum(degrees[-top_k:])\n        total_deg = 2.0 * m if m > 0 else 1e-9\n        high_ratio = high_sum / total_deg\n    else:\n        high_ratio = 0.0\n    top_factor = 1.0 + (1.0 - high_ratio) * het_factor\n\n    # Combine all components multiplicatively\n    estimate = (base * dens_factor * het_factor * clust_factor *\n                trans_factor * assort_factor * tri_factor *\n                range_factor * top_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from pre‑computed graph statistics.\n    The formula blends a node/edge baseline with multiplicative adjustments that\n    capture density, degree heterogeneity, clustering, assortativity, triangle\n    abundance, degree range and the concentration of high‑degree vertices.\n    No traversal algorithm is used; only arithmetic on the provided features.\n    \"\"\"\n    # Basic node/edge ratio (regularised by +1)\n    n = s.get('n', 0.0)\n    m = s.get('m', 0.0)\n    base = (n + 1.0) / (m + 1.0)\n\n    # 1. Sparsity adjustment – sparse graphs usually have larger path lengths\n    dens_factor = 1.0 / (1.0 + s.get('density', 0.0))\n\n    # 2. Degree heterogeneity – high variance tends to shorten paths via hubs\n    avg_deg = s.get('avg_degree', 1.0)\n    std_deg = s.get('std_degree', 0.0)\n    het_factor = (1.0 + std_deg) / (1.0 + avg_deg)\n\n    # 3. Clustering suppression – more local triangles typically reduce path length\n    clus = s.get('avg_clustering', 0.0)\n    clust_factor = 1.0 / (1.0 + clus)\n\n    # 4. Transitivity boost – alternative routes lower distances\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + trans\n\n    # 5. Assortativity influence – absolute value accounts for both positive\n    #    and negative mixing\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # 6. Triangle abundance – sqrt gives diminishing returns\n    tri = s.get('num_triangles', 0.0)\n    tri_factor = 1.0 + (tri ** 0.5) / (n ** 0.5 + 1e-9)\n\n    # 7. Degree range amplification – many hubs vs many leaves\n    max_deg = s.get('max_degree', 1.0)\n    min_deg = s.get('min_degree', 1.0)\n    range_factor = (max_deg + 1.0) / (min_deg + 1e-9)\n\n    # 8. Concentration of high‑degree vertices\n    degrees = s.get('degrees', [])\n    if degrees:\n        top_k = max(1, int(0.1 * n))\n        high_sum = sum(degrees[-top_k:])\n        total_deg = 2.0 * m if m > 0 else 1e-9\n        high_ratio = high_sum / total_deg\n    else:\n        high_ratio = 0.0\n    top_factor = 1.0 + (1.0 - high_ratio) * het_factor\n\n    # Combine all components multiplicatively\n    estimate = (base * dens_factor * het_factor * clust_factor *\n                trans_factor * assort_factor * tri_factor *\n                range_factor * top_factor)\n\n    return float(estimate)", "spearman": 0.551598289957249, "pearson": 0.49785734945824806, "rmse": 9.825663738709281, "mae": 4.345396367395921}}
{"timestamp": "2026-02-16T15:22:50.258699+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i3_p1_635432713", "generation": 7, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5806962785114045, "fitness_mode": "correlation", "simplicity_score": 0.15639387777225783, "novelty_bonus": 0.32561614040351006, "total_score": 0.4047627626541291, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length using only\n    global graph statistics.  The formula combines a baseline\n    based on node/edge ratio with corrections for density,\n    degree heterogeneity, clustering, transitivity, assortativity,\n    triangle abundance, degree range and the concentration of\n    high‑degree nodes.  No graph traversal is performed.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted).\n\n    Returns\n    -------\n    float\n        A single scalar value intended to correlate with the true\n        average shortest‑path length.\n    \"\"\"\n    # Basic graph counts\n    n = s['n']\n    m = s['m']\n\n    # Avoid division by zero by adding 1 to denominators\n    base = (n + 1.0) / (m + 1.0)\n\n    # Correction for overall density: sparse graphs tend to have longer paths\n    dens_factor = 1.0 / (1.0 + s['density'])\n\n    # Degree heterogeneity: larger variance relative to the mean tends to reduce\n    # average path length by providing hubs.\n    het_factor = (1.0 + s['std_degree']) / (1.0 + s['avg_degree'])\n\n    # Clustering suppresses long paths; higher clustering usually shortens distances.\n    clust_factor = 1.0 / (1.0 + s['avg_clustering'])\n\n    # Transitivity increases alternative routes, slightly shortening paths.\n    trans_factor = 1.0 + s['transitivity']\n\n    # Assortativity measures mixing of high/low degree nodes; absolute value\n    # captures its influence regardless of sign.\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Triangle abundance lowers path lengths; sqrt gives diminishing returns.\n    tri_factor = 1.0 + (s['num_triangles'] ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range amplifies the effect of a few hubs versus many leaves.\n    deg_range = (s['max_degree'] + 1.0) / (s['min_degree'] + 1e-6)\n\n    # Concentration of high‑degree nodes: compute the fraction of total degree\n    # held by the top 10 % nodes.  A smaller fraction implies more dispersed hubs.\n    top_k = max(1, n // 10)                     # integer number of top nodes\n    high_sum = sum(s['degrees'][-top_k:]) if s['degrees'] else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Combine all factors multiplicatively to obtain the estimate\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clust_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_train_threshold: train_signal=0.161681\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An invariant estimate of the average shortest path length that relies\n    only on pre‑computed global statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed graph features:\n        - n                 : int   (number of nodes)\n        - m                 : int   (number of edges)\n        - density           : float (edge density)\n        - avg_degree        : float (average degree)\n        - max_degree        : int   (maximum degree)\n        - min_degree        : int   (minimum degree)\n        - std_degree        : float (standard deviation of degrees)\n        - avg_clustering    : float (average clustering coefficient)\n        - transitivity      : float (global transitivity)\n        - degree_assortativity : float (degree assortativity coefficient)\n        - num_triangles     : int   (number of triangles)\n        - degrees           : list[int] (sorted degree list)\n\n    Returns\n    -------\n    float\n        A scalar value intended to correlate with the true average shortest\n        path length of the graph.\n    \"\"\"\n    # Basic ratios that capture size and sparsity\n    n = s['n']\n    m = s['m']\n    base = (n + 1.0) / (m + 1.0)                     # n/m baseline, +1 to avoid div0\n\n    # Sparsity adjustment: very sparse graphs typically have longer paths\n    sparsity_factor = 1.0 / (1.0 + s['density'])\n\n    # Degree heterogeneity: high variance relative to the mean tends to reduce\n    # average path length by providing hubs.\n    hetero_factor = (1.0 + s['std_degree']) / (1.0 + s['avg_degree'])\n\n    # Clustering tends to create local shortcuts; more clustering usually shortens\n    # average distances.\n    clustering_factor = 1.0 / (1.0 + s['avg_clustering'])\n\n    # Transitivity adds alternative routes, slightly shrinking path lengths\n    trans_factor = 1.0 + s['transitivity']\n\n    # Assortativity magnitude influences the spread of hubs across degrees\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Triangle abundance reduces path length (square‑root for diminishing returns)\n    tri_factor = 1.0 + pow(float(s['num_triangles']), 0.5) / (pow(float(n), 0.5) + 1e-6)\n\n    # Degree range captures presence of very high versus very low degree nodes\n    deg_range = (float(s['max_degree'] + 1)) / (float(s['min_degree']) + 1e-6)\n\n    # Concentration of top‑10% high‑degree nodes: a small top‑ratio implies more\n    # dispersed hubs which usually shortens paths.\n    top_k = max(1, n // 10)\n    high_sum = sum(s['degrees'][-top_k:]) if s['degrees'] else 0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * hetero_factor\n\n    # Combine all multiplicative effects to form the estimate\n    estimate = (base *\n                sparsity_factor *\n                hetero_factor *\n                clustering_factor *\n                trans_factor *\n                assort_factor *\n                tri_factor *\n                deg_range *\n                top_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An invariant estimate of the average shortest path length that relies\n    only on pre‑computed global statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed graph features:\n        - n                 : int   (number of nodes)\n        - m                 : int   (number of edges)\n        - density           : float (edge density)\n        - avg_degree        : float (average degree)\n        - max_degree        : int   (maximum degree)\n        - min_degree        : int   (minimum degree)\n        - std_degree        : float (standard deviation of degrees)\n        - avg_clustering    : float (average clustering coefficient)\n        - transitivity      : float (global transitivity)\n        - degree_assortativity : float (degree assortativity coefficient)\n        - num_triangles     : int   (number of triangles)\n        - degrees           : list[int] (sorted degree list)\n\n    Returns\n    -------\n    float\n        A scalar value intended to correlate with the true average shortest\n        path length of the graph.\n    \"\"\"\n    # Basic ratios that capture size and sparsity\n    n = s['n']\n    m = s['m']\n    base = (n + 1.0) / (m + 1.0)                     # n/m baseline, +1 to avoid div0\n\n    # Sparsity adjustment: very sparse graphs typically have longer paths\n    sparsity_factor = 1.0 / (1.0 + s['density'])\n\n    # Degree heterogeneity: high variance relative to the mean tends to reduce\n    # average path length by providing hubs.\n    hetero_factor = (1.0 + s['std_degree']) / (1.0 + s['avg_degree'])\n\n    # Clustering tends to create local shortcuts; more clustering usually shortens\n    # average distances.\n    clustering_factor = 1.0 / (1.0 + s['avg_clustering'])\n\n    # Transitivity adds alternative routes, slightly shrinking path lengths\n    trans_factor = 1.0 + s['transitivity']\n\n    # Assortativity magnitude influences the spread of hubs across degrees\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Triangle abundance reduces path length (square‑root for diminishing returns)\n    tri_factor = 1.0 + pow(float(s['num_triangles']), 0.5) / (pow(float(n), 0.5) + 1e-6)\n\n    # Degree range captures presence of very high versus very low degree nodes\n    deg_range = (float(s['max_degree'] + 1)) / (float(s['min_degree']) + 1e-6)\n\n    # Concentration of top‑10% high‑degree nodes: a small top‑ratio implies more\n    # dispersed hubs which usually shortens paths.\n    top_k = max(1, n // 10)\n    high_sum = sum(s['degrees'][-top_k:]) if s['degrees'] else 0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * hetero_factor\n\n    # Combine all multiplicative effects to form the estimate\n    estimate = (base *\n                sparsity_factor *\n                hetero_factor *\n                clustering_factor *\n                trans_factor *\n                assort_factor *\n                tri_factor *\n                deg_range *\n                top_factor)\n\n    return float(estimate)", "spearman": 0.551598289957249, "pearson": 0.49785731961787527, "rmse": 9.825653177358184, "mae": 4.345392106197964}}
{"timestamp": "2026-02-16T15:23:25.492655+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i3_p2_671254234", "generation": 7, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5833853541416567, "fitness_mode": "correlation", "simplicity_score": 0.154940803466983, "novelty_bonus": 0.326601665041626, "total_score": 0.40595058475399814, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length using only\n    global graph statistics.  The formula combines a baseline\n    based on node/edge ratio with corrections for density,\n    degree heterogeneity, clustering, transitivity, assortativity,\n    triangle abundance, degree range and the concentration of\n    high‑degree nodes.  No graph traversal is performed.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted).\n\n    Returns\n    -------\n    float\n        A single scalar value intended to correlate with the true\n        average shortest‑path length.\n    \"\"\"\n    # Basic graph counts\n    n = s['n']\n    m = s['m']\n\n    # Avoid division by zero by adding 1 to denominators\n    base = (n + 1.0) / (m + 1.0)\n\n    # Correction for overall density: sparse graphs tend to have longer paths\n    dens_factor = 1.0 / (1.0 + s['density'])\n\n    # Degree heterogeneity: larger variance relative to the mean tends to reduce\n    # average path length by providing hubs.\n    het_factor = (1.0 + s['std_degree']) / (1.0 + s['avg_degree'])\n\n    # Clustering suppresses long paths; higher clustering usually shortens distances.\n    clust_factor = 1.0 / (1.0 + s['avg_clustering'])\n\n    # Transitivity increases alternative routes, slightly shortening paths.\n    trans_factor = 1.0 + s['transitivity']\n\n    # Assortativity measures mixing of high/low degree nodes; absolute value\n    # captures its influence regardless of sign.\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Triangle abundance lowers path lengths; sqrt gives diminishing returns.\n    tri_factor = 1.0 + (s['num_triangles'] ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range amplifies the effect of a few hubs versus many leaves.\n    deg_range = (s['max_degree'] + 1.0) / (s['min_degree'] + 1e-6)\n\n    # Concentration of high‑degree nodes: compute the fraction of total degree\n    # held by the top 10 % nodes.  A smaller fraction implies more dispersed hubs.\n    top_k = max(1, n // 10)                     # integer number of top nodes\n    high_sum = sum(s['degrees'][-top_k:]) if s['degrees'] else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Combine all factors multiplicatively to obtain the estimate\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clust_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_train_threshold: train_signal=0.161681\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length from global graph statistics.\n    The estimator combines a node/edge ratio baseline with multiplicative\n    corrections for density, degree heterogeneity, clustering,\n    transitivity, assortativity, triangle abundance, degree range\n    and the concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        A single scalar intended to correlate with the true average\n        shortest‑path length.\n    \"\"\"\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_degree = s.get('avg_degree', 0.0)\n    max_degree = s.get('max_degree', 0.0)\n    min_degree = s.get('min_degree', 1.0)\n    std_degree = s.get('std_degree', 0.0)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # Base ratio of nodes to edges (regularised)\n    base = n / (m + 1.0)\n\n    # Correction for overall sparsity – sparse graphs tend to have longer paths\n    density_factor = 1.0 / (1.0 + density)\n\n    # Effect of degree heterogeneity – higher variance relative to mean reduces distance\n    het_factor = (std_degree + 1.0) / (avg_degree + 1.0)\n\n    # Clustering tends to create tightly knit communities; higher clustering can reduce path length\n    clustering_factor = 1.0 / (1.0 + avg_clustering)\n\n    # Transitivity (global clustering) adds alternative routes, slightly shortening distances\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity (absolute value) captures mixing of high/low degree nodes\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # Triangle abundance reduces path length; square‑root gives diminishing returns\n    tri_factor = 1.0 + (num_triangles ** 0.5) / ((n ** 0.5) + 1e-6)\n\n    # Degree range emphasises the presence of hubs versus leaves\n    deg_range_factor = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # Concentration of high‑degree vertices – smaller fraction means hubs are more spread out\n    top_k = max(1, n // 10)               # top 10 % of nodes\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Final multiplicative estimate\n    estimate = (\n        base *\n        density_factor *\n        het_factor *\n        clustering_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        deg_range_factor *\n        top_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length from global graph statistics.\n    The estimator combines a node/edge ratio baseline with multiplicative\n    corrections for density, degree heterogeneity, clustering,\n    transitivity, assortativity, triangle abundance, degree range\n    and the concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        A single scalar intended to correlate with the true average\n        shortest‑path length.\n    \"\"\"\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_degree = s.get('avg_degree', 0.0)\n    max_degree = s.get('max_degree', 0.0)\n    min_degree = s.get('min_degree', 1.0)\n    std_degree = s.get('std_degree', 0.0)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # Base ratio of nodes to edges (regularised)\n    base = n / (m + 1.0)\n\n    # Correction for overall sparsity – sparse graphs tend to have longer paths\n    density_factor = 1.0 / (1.0 + density)\n\n    # Effect of degree heterogeneity – higher variance relative to mean reduces distance\n    het_factor = (std_degree + 1.0) / (avg_degree + 1.0)\n\n    # Clustering tends to create tightly knit communities; higher clustering can reduce path length\n    clustering_factor = 1.0 / (1.0 + avg_clustering)\n\n    # Transitivity (global clustering) adds alternative routes, slightly shortening distances\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity (absolute value) captures mixing of high/low degree nodes\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # Triangle abundance reduces path length; square‑root gives diminishing returns\n    tri_factor = 1.0 + (num_triangles ** 0.5) / ((n ** 0.5) + 1e-6)\n\n    # Degree range emphasises the presence of hubs versus leaves\n    deg_range_factor = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # Concentration of high‑degree vertices – smaller fraction means hubs are more spread out\n    top_k = max(1, n // 10)               # top 10 % of nodes\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Final multiplicative estimate\n    estimate = (\n        base *\n        density_factor *\n        het_factor *\n        clustering_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        deg_range_factor *\n        top_factor\n    )\n\n    return float(estimate)", "spearman": 0.5539638490962274, "pearson": 0.49810058368566934, "rmse": 9.66865208350098, "mae": 4.26129780250592}}
{"timestamp": "2026-02-16T15:24:09.121074+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i3_p3_708032526", "generation": 7, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5806962785114045, "fitness_mode": "correlation", "simplicity_score": 0.15548282566842758, "novelty_bonus": 0.32561614040351006, "total_score": 0.40458055223336303, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length using only\n    global graph statistics.  The formula combines a baseline\n    based on node/edge ratio with corrections for density,\n    degree heterogeneity, clustering, transitivity, assortativity,\n    triangle abundance, degree range and the concentration of\n    high‑degree nodes.  No graph traversal is performed.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted).\n\n    Returns\n    -------\n    float\n        A single scalar value intended to correlate with the true\n        average shortest‑path length.\n    \"\"\"\n    # Basic graph counts\n    n = s['n']\n    m = s['m']\n\n    # Avoid division by zero by adding 1 to denominators\n    base = (n + 1.0) / (m + 1.0)\n\n    # Correction for overall density: sparse graphs tend to have longer paths\n    dens_factor = 1.0 / (1.0 + s['density'])\n\n    # Degree heterogeneity: larger variance relative to the mean tends to reduce\n    # average path length by providing hubs.\n    het_factor = (1.0 + s['std_degree']) / (1.0 + s['avg_degree'])\n\n    # Clustering suppresses long paths; higher clustering usually shortens distances.\n    clust_factor = 1.0 / (1.0 + s['avg_clustering'])\n\n    # Transitivity increases alternative routes, slightly shortening paths.\n    trans_factor = 1.0 + s['transitivity']\n\n    # Assortativity measures mixing of high/low degree nodes; absolute value\n    # captures its influence regardless of sign.\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Triangle abundance lowers path lengths; sqrt gives diminishing returns.\n    tri_factor = 1.0 + (s['num_triangles'] ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range amplifies the effect of a few hubs versus many leaves.\n    deg_range = (s['max_degree'] + 1.0) / (s['min_degree'] + 1e-6)\n\n    # Concentration of high‑degree nodes: compute the fraction of total degree\n    # held by the top 10 % nodes.  A smaller fraction implies more dispersed hubs.\n    top_k = max(1, n // 10)                     # integer number of top nodes\n    high_sum = sum(s['degrees'][-top_k:]) if s['degrees'] else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Combine all factors multiplicatively to obtain the estimate\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clust_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_train_threshold: train_signal=0.161681\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length derived solely from\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n (int)                : number of nodes\n        - m (int)                : number of edges\n        - density (float)        : edge density\n        - avg_degree (float)     : average degree\n        - max_degree (int)       : maximum degree\n        - min_degree (int)       : minimum degree\n        - std_degree (float)     : standard deviation of degrees\n        - avg_clustering (float) : average clustering coefficient\n        - transitivity (float)   : global transitivity\n        - degree_assortativity (float) : degree assortativity\n        - num_triangles (int)    : total number of triangles\n        - degrees (list[int])    : sorted ascending degree list\n\n    Returns\n    -------\n    float\n        A scalar value that is designed to correlate with the true\n        average shortest‑path length of the graph.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # ---------- Base term ----------\n    base = (n + 1.0) / (m + 1.0)                 # node/edge ratio, +1 to avoid division by zero\n\n    # ---------- Density factor ----------\n    dens_factor = 1.0 / (1.0 + density)          # sparser graphs tend to have larger path lengths\n\n    # ---------- Degree heterogeneity ----------\n    het_factor = (1.0 + std_degree) / (1.0 + avg_degree)\n\n    # ---------- Clustering & transitivity ----------\n    clust_factor = 1.0 / (1.0 + avg_clustering)   # higher clustering typically shortens paths\n    trans_factor = 1.0 + transitivity           # more triangles increase alternate routes\n\n    # ---------- Assortativity ----------\n    assort_factor = 1.0 + abs(degree_assortativity)   # absolute value captures influence in either direction\n\n    # ---------- Triangle abundance ----------\n    tri_factor = 1.0 + (num_triangles ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # ---------- Degree range ----------\n    deg_range = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # ---------- High‑degree concentration ----------\n    top_k = max(1, n // 10)                       # top 10 % of nodes\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # ---------- Combine all factors ----------\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clust_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length derived solely from\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n (int)                : number of nodes\n        - m (int)                : number of edges\n        - density (float)        : edge density\n        - avg_degree (float)     : average degree\n        - max_degree (int)       : maximum degree\n        - min_degree (int)       : minimum degree\n        - std_degree (float)     : standard deviation of degrees\n        - avg_clustering (float) : average clustering coefficient\n        - transitivity (float)   : global transitivity\n        - degree_assortativity (float) : degree assortativity\n        - num_triangles (int)    : total number of triangles\n        - degrees (list[int])    : sorted ascending degree list\n\n    Returns\n    -------\n    float\n        A scalar value that is designed to correlate with the true\n        average shortest‑path length of the graph.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # ---------- Base term ----------\n    base = (n + 1.0) / (m + 1.0)                 # node/edge ratio, +1 to avoid division by zero\n\n    # ---------- Density factor ----------\n    dens_factor = 1.0 / (1.0 + density)          # sparser graphs tend to have larger path lengths\n\n    # ---------- Degree heterogeneity ----------\n    het_factor = (1.0 + std_degree) / (1.0 + avg_degree)\n\n    # ---------- Clustering & transitivity ----------\n    clust_factor = 1.0 / (1.0 + avg_clustering)   # higher clustering typically shortens paths\n    trans_factor = 1.0 + transitivity           # more triangles increase alternate routes\n\n    # ---------- Assortativity ----------\n    assort_factor = 1.0 + abs(degree_assortativity)   # absolute value captures influence in either direction\n\n    # ---------- Triangle abundance ----------\n    tri_factor = 1.0 + (num_triangles ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # ---------- Degree range ----------\n    deg_range = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # ---------- High‑degree concentration ----------\n    top_k = max(1, n // 10)                       # top 10 % of nodes\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # ---------- Combine all factors ----------\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clust_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)", "spearman": 0.551598289957249, "pearson": 0.49785731961787527, "rmse": 9.825653177358184, "mae": 4.345392106197964}}
{"timestamp": "2026-02-16T15:24:47.537667+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i3_p4_556623543", "generation": 7, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5806962785114045, "fitness_mode": "correlation", "simplicity_score": 0.15636429386913944, "novelty_bonus": 0.32561614040351006, "total_score": 0.4047568458735054, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length using only\n    global graph statistics.  The formula combines a baseline\n    based on node/edge ratio with corrections for density,\n    degree heterogeneity, clustering, transitivity, assortativity,\n    triangle abundance, degree range and the concentration of\n    high‑degree nodes.  No graph traversal is performed.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted).\n\n    Returns\n    -------\n    float\n        A single scalar value intended to correlate with the true\n        average shortest‑path length.\n    \"\"\"\n    # Basic graph counts\n    n = s['n']\n    m = s['m']\n\n    # Avoid division by zero by adding 1 to denominators\n    base = (n + 1.0) / (m + 1.0)\n\n    # Correction for overall density: sparse graphs tend to have longer paths\n    dens_factor = 1.0 / (1.0 + s['density'])\n\n    # Degree heterogeneity: larger variance relative to the mean tends to reduce\n    # average path length by providing hubs.\n    het_factor = (1.0 + s['std_degree']) / (1.0 + s['avg_degree'])\n\n    # Clustering suppresses long paths; higher clustering usually shortens distances.\n    clust_factor = 1.0 / (1.0 + s['avg_clustering'])\n\n    # Transitivity increases alternative routes, slightly shortening paths.\n    trans_factor = 1.0 + s['transitivity']\n\n    # Assortativity measures mixing of high/low degree nodes; absolute value\n    # captures its influence regardless of sign.\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Triangle abundance lowers path lengths; sqrt gives diminishing returns.\n    tri_factor = 1.0 + (s['num_triangles'] ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range amplifies the effect of a few hubs versus many leaves.\n    deg_range = (s['max_degree'] + 1.0) / (s['min_degree'] + 1e-6)\n\n    # Concentration of high‑degree nodes: compute the fraction of total degree\n    # held by the top 10 % nodes.  A smaller fraction implies more dispersed hubs.\n    top_k = max(1, n // 10)                     # integer number of top nodes\n    high_sum = sum(s['degrees'][-top_k:]) if s['degrees'] else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Combine all factors multiplicatively to obtain the estimate\n    estimate = (\n        base\n        * dens_factor\n        * het_factor\n        * clust_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range\n        * top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_train_threshold: train_signal=0.161681\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from global graph\n    statistics only.  The formula is a multiplicative combination of\n    factors that reflect sparsity, degree heterogeneity, clustering,\n    transitivity, assortativity, triangle abundance and the\n    concentration of hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with the following keys:\n        n (int), m (int), density (float),\n        avg_degree (float), max_degree (int), min_degree (int),\n        std_degree (float), avg_clustering (float),\n        transitivity (float), degree_assortativity (float),\n        num_triangles (int), degrees (list[int] – sorted ascending).\n\n    Returns\n    -------\n    float\n        A scalar value intended to correlate with the true\n        average shortest‑path length.  No traversal or additional\n        libraries are used.\n    \"\"\"\n    # Basic counts\n    n = s['n']\n    m = s['m']\n\n    # 1. Node/edge baseline (regularised by +1)\n    base = (n + 1.0) / (m + 1.0)\n\n    # 2. Sparsity adjustment – very sparse graphs have long paths\n    sparse_factor = 1.0 / (1.0 + s['density'])\n\n    # 3. Degree heterogeneity – high variance tends to shorten paths via hubs\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 0.1\n    heterogeneity_factor = (1.0 + s['std_degree']) / (1.0 + avg_deg)\n\n    # 4. Clustering effect – higher clustering usually shortens distances\n    clustering_factor = 1.0 / (1.0 + s['avg_clustering'])\n\n    # 5. Transitivity – more triangles provide alternate routes\n    trans_factor = 1.0 + s['transitivity']\n\n    # 6. Assortativity – its magnitude influences connectivity\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # 7. Triangle abundance – use a diminishing‑returns sqrt\n    tri_factor = 1.0 + (s['num_triangles'] ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # 8. Degree range – ratio of max to min degree amplifies hub influence\n    deg_range_factor = (s['max_degree'] + 1.0) / (s['min_degree'] + 1e-6)\n\n    # 9. Concentration of high‑degree nodes – top 10% of nodes\n    top_k = max(1, n // 10)\n    high_sum = sum(s['degrees'][-top_k:]) if s['degrees'] else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * heterogeneity_factor\n\n    # Combine all factors multiplicatively\n    estimate = (base * sparse_factor * heterogeneity_factor *\n                clustering_factor * trans_factor * assort_factor *\n                tri_factor * deg_range_factor * top_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from global graph\n    statistics only.  The formula is a multiplicative combination of\n    factors that reflect sparsity, degree heterogeneity, clustering,\n    transitivity, assortativity, triangle abundance and the\n    concentration of hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with the following keys:\n        n (int), m (int), density (float),\n        avg_degree (float), max_degree (int), min_degree (int),\n        std_degree (float), avg_clustering (float),\n        transitivity (float), degree_assortativity (float),\n        num_triangles (int), degrees (list[int] – sorted ascending).\n\n    Returns\n    -------\n    float\n        A scalar value intended to correlate with the true\n        average shortest‑path length.  No traversal or additional\n        libraries are used.\n    \"\"\"\n    # Basic counts\n    n = s['n']\n    m = s['m']\n\n    # 1. Node/edge baseline (regularised by +1)\n    base = (n + 1.0) / (m + 1.0)\n\n    # 2. Sparsity adjustment – very sparse graphs have long paths\n    sparse_factor = 1.0 / (1.0 + s['density'])\n\n    # 3. Degree heterogeneity – high variance tends to shorten paths via hubs\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 0.1\n    heterogeneity_factor = (1.0 + s['std_degree']) / (1.0 + avg_deg)\n\n    # 4. Clustering effect – higher clustering usually shortens distances\n    clustering_factor = 1.0 / (1.0 + s['avg_clustering'])\n\n    # 5. Transitivity – more triangles provide alternate routes\n    trans_factor = 1.0 + s['transitivity']\n\n    # 6. Assortativity – its magnitude influences connectivity\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # 7. Triangle abundance – use a diminishing‑returns sqrt\n    tri_factor = 1.0 + (s['num_triangles'] ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # 8. Degree range – ratio of max to min degree amplifies hub influence\n    deg_range_factor = (s['max_degree'] + 1.0) / (s['min_degree'] + 1e-6)\n\n    # 9. Concentration of high‑degree nodes – top 10% of nodes\n    top_k = max(1, n // 10)\n    high_sum = sum(s['degrees'][-top_k:]) if s['degrees'] else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * heterogeneity_factor\n\n    # Combine all factors multiplicatively\n    estimate = (base * sparse_factor * heterogeneity_factor *\n                clustering_factor * trans_factor * assort_factor *\n                tri_factor * deg_range_factor * top_factor)\n\n    return float(estimate)", "spearman": 0.551598289957249, "pearson": 0.49785731961787527, "rmse": 9.825653177358184, "mae": 4.345392106197964}}
{"timestamp": "2026-02-16T15:24:47.539861+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 8, "model_name": "gpt-oss:20b", "best_val_score": 0.5376982263149925, "no_improve_count": 0}}
{"timestamp": "2026-02-16T15:25:42.289555+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i0_p0_87344662", "generation": 8, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22191621004497614, "novelty_bonus": 0.25138613993252834, "total_score": 0.5273345223747135, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, and triangle counts in a compact, interpretable\n    way.  No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    # Basic scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed graph\n    statistics.  The formula is a compact, interpretable combination of size,\n    degree distribution, density, clustering, transitivity, assortativity,\n    and triangle counts.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.037791\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.110253\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T15:26:27.707168+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i0_p1_451768896", "generation": 8, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5544777911164467, "fitness_mode": "correlation", "simplicity_score": 0.22303413472535122, "novelty_bonus": 0.26542679994882457, "total_score": 0.4531893407915642, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, and triangle counts in a compact, interpretable\n    way.  No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    # Basic scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed graph\n    statistics.  The formula is a compact, interpretable combination of size,\n    degree distribution, density, clustering, transitivity, assortativity,\n    and triangle counts.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.037791\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.110253\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity, triangles\n    and edge count.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    m          = s['m']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (max_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Small adjustment from edge count (captures overall connectivity)\n    base += (m / (n + 1.0)) * 0.01\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity, triangles\n    and edge count.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    m          = s['m']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (max_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Small adjustment from edge count (captures overall connectivity)\n    base += (m / (n + 1.0)) * 0.01\n\n    return base", "spearman": 0.6579089477236932, "pearson": 0.5159676496349022, "rmse": 11.942763124161232, "mae": 8.752655661454934}}
{"timestamp": "2026-02-16T15:33:12.068576+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.108892", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:33:12.069231+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 8, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.108892", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:33:39.824261+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 0, "population_idx": 2, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:33:39.825266+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 8, "island_id": 0, "population_idx": 2, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:34:14.782414+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.123745", "model_name": "gpt-oss:20b", "train_signal": 0.1237454981992797}}
{"timestamp": "2026-02-16T15:34:52.976415+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.136807", "model_name": "gpt-oss:20b", "train_signal": 0.13680672268907562}}
{"timestamp": "2026-02-16T15:35:38.940630+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i1_p0_76271917", "generation": 8, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8482593037214886, "fitness_mode": "correlation", "simplicity_score": 0.12835565138861033, "novelty_bonus": 0.21989649741243522, "total_score": 0.5257291817290084, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust) * (n ** 0.5) / denom_density  # size, clustering, density\n    part3 = 1 + avg_clust                         # clustering\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = avg_deg / (max_deg + 1)               # degree spread\n    part8 = deg_ratio                             # degree ratio\n    part9 = 1 / (1 + deg_variance)                # degree variance\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust) * (n ** 0.5) / denom_density  # size, clustering, density\n    part3 = 1 + avg_clust                         # clustering\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = avg_deg / (max_deg + 1)               # degree spread\n    part8 = deg_ratio                             # degree ratio\n    part9 = 1 / (1 + deg_variance)                # degree variance\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )", "spearman": 0.8681782044551115, "pearson": 0.814767541537408, "rmse": 239.8804041433333, "mae": 153.25581429525914}}
{"timestamp": "2026-02-16T15:36:16.577804+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i1_p1_727415968", "generation": 8, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.12890308834926528, "novelty_bonus": 0.17722193054826363, "total_score": 0.5132395541432648, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clust)         # size & clustering\n    part3 = 1 + trans                              # transitivity\n    part4 = 1 + abs(assort)                        # assortativity\n    part5 = 1 + tri_per_edge                       # triangles per edge\n    part6 = avg_deg / (max_deg + 1)                # degree spread\n    part7 = deg_ratio                              # degree ratio\n    part8 = 1 / (1 + deg_variance)                 # degree variance\n    part9 = 1 / denom_density                      # density\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clust)         # size & clustering\n    part3 = 1 + trans                              # transitivity\n    part4 = 1 + abs(assort)                        # assortativity\n    part5 = 1 + tri_per_edge                       # triangles per edge\n    part6 = avg_deg / (max_deg + 1)                # degree spread\n    part7 = deg_ratio                              # degree ratio\n    part8 = 1 / (1 + deg_variance)                 # degree variance\n    part9 = 1 / denom_density                      # density\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9", "spearman": 0.8685847146178655, "pearson": 0.8329734689997877, "rmse": 21.818633260644265, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T15:36:52.196204+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.141658", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:36:52.196745+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 8, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.141658", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:37:30.854128+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i1_p2_299420928", "generation": 8, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.6096998799519807, "fitness_mode": "correlation", "simplicity_score": 0.11948164090372611, "novelty_bonus": 0.23444225392083484, "total_score": 0.31327873060015177, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\nRecent failures:\nbelow_train_threshold: train_signal=0.137575\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.141658\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    std_deg = s.get('std_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = density if density > 0 else 1e-6\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = n ** 0.5 / (1 + avg_clust)      # size & clustering\n    part3 = 1 + abs(assort)                 # assortativity\n    part4 = 1 + trans                       # transitivity\n    part5 = 1 + tri_per_edge                # triangles per edge\n    part6 = avg_deg / (max_deg + 1)         # degree spread\n    part7 = deg_ratio                       # degree ratio\n    part8 = 1 / (1 + deg_variance)          # degree variance\n    part9 = 1 / (1 + denom_density)         # density penalty\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A composite graph invariant that blends sparsity, size, clustering,\n    assortativity, transitivity, triangle density, degree spread, degree\n    ratio, variance, density penalty, harmonic mean of degrees, and degree\n    skewness.  All components are derived from the pre‑computed feature\n    dictionary `s` and are combined multiplicatively to produce a single\n    scalar invariant.\n    \"\"\"\n    # Basic statistics\n    n          = s['n']\n    m          = s['m']\n    density    = s.get('density', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 0)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    degrees    = s.get('degrees', [])\n\n    # Avoid division by zero\n    denom_m          = max(m, 1)\n    denom_density    = max(density, 1e-6)\n    denom_max_deg    = max(max_deg, 1)\n    denom_min_deg    = max(min_deg, 1e-6)\n    denom_std_deg    = max(std_deg, 1e-6)\n\n    # Derived ratios\n    tri_per_edge     = num_tri / denom_m\n    deg_ratio        = (max_deg + 1) / (min_deg + 1)\n    deg_variance     = std_deg ** 2\n\n    # Harmonic mean of degrees (ignoring zero degrees)\n    if degrees:\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        harmonic_mean_deg = len(degrees) / (inv_sum if inv_sum > 0 else 1e-6)\n    else:\n        harmonic_mean_deg = 0.0\n\n    # Median degree\n    if degrees:\n        sorted_deg = sorted(degrees)\n        mid = len(sorted_deg) // 2\n        median_deg = sorted_deg[mid] if len(sorted_deg) % 2 == 1 else \\\n                     (sorted_deg[mid - 1] + sorted_deg[mid]) / 2.0\n    else:\n        median_deg = 0.0\n\n    # Degree skewness (mean - median) / std\n    skewness = (avg_deg - median_deg) / denom_std_deg\n\n    # Composite parts\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = n ** 0.5 / (1 + avg_clust)            # size & clustering\n    part3 = 1 + abs(assort)                       # assortativity\n    part4 = 1 + trans                             # transitivity\n    part5 = 1 + tri_per_edge                      # triangles per edge\n    part6 = avg_deg / (denom_max_deg + 1)          # degree spread\n    part7 = deg_ratio                              # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / (1 + denom_density)               # density penalty\n    part10 = harmonic_mean_deg / (avg_deg + 1e-6)  # harmonic mean vs mean\n    part11 = median_deg / (denom_max_deg + 1)      # median vs max\n    part12 = 1 + abs(skewness)                    # degree skewness\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9 *\n        part10 * part11 * part12\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A composite graph invariant that blends sparsity, size, clustering,\n    assortativity, transitivity, triangle density, degree spread, degree\n    ratio, variance, density penalty, harmonic mean of degrees, and degree\n    skewness.  All components are derived from the pre‑computed feature\n    dictionary `s` and are combined multiplicatively to produce a single\n    scalar invariant.\n    \"\"\"\n    # Basic statistics\n    n          = s['n']\n    m          = s['m']\n    density    = s.get('density', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 0)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    degrees    = s.get('degrees', [])\n\n    # Avoid division by zero\n    denom_m          = max(m, 1)\n    denom_density    = max(density, 1e-6)\n    denom_max_deg    = max(max_deg, 1)\n    denom_min_deg    = max(min_deg, 1e-6)\n    denom_std_deg    = max(std_deg, 1e-6)\n\n    # Derived ratios\n    tri_per_edge     = num_tri / denom_m\n    deg_ratio        = (max_deg + 1) / (min_deg + 1)\n    deg_variance     = std_deg ** 2\n\n    # Harmonic mean of degrees (ignoring zero degrees)\n    if degrees:\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        harmonic_mean_deg = len(degrees) / (inv_sum if inv_sum > 0 else 1e-6)\n    else:\n        harmonic_mean_deg = 0.0\n\n    # Median degree\n    if degrees:\n        sorted_deg = sorted(degrees)\n        mid = len(sorted_deg) // 2\n        median_deg = sorted_deg[mid] if len(sorted_deg) % 2 == 1 else \\\n                     (sorted_deg[mid - 1] + sorted_deg[mid]) / 2.0\n    else:\n        median_deg = 0.0\n\n    # Degree skewness (mean - median) / std\n    skewness = (avg_deg - median_deg) / denom_std_deg\n\n    # Composite parts\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = n ** 0.5 / (1 + avg_clust)            # size & clustering\n    part3 = 1 + abs(assort)                       # assortativity\n    part4 = 1 + trans                             # transitivity\n    part5 = 1 + tri_per_edge                      # triangles per edge\n    part6 = avg_deg / (denom_max_deg + 1)          # degree spread\n    part7 = deg_ratio                              # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / (1 + denom_density)               # density penalty\n    part10 = harmonic_mean_deg / (avg_deg + 1e-6)  # harmonic mean vs mean\n    part11 = median_deg / (denom_max_deg + 1)      # median vs max\n    part12 = 1 + abs(skewness)                    # degree skewness\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9 *\n        part10 * part11 * part12\n    )", "spearman": 0.4380994524863122, "pearson": 0.4337376325052406, "rmse": 2.2487858698911403, "mae": 2.108351746489771}}
{"timestamp": "2026-02-16T15:37:30.854634+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 8, "island_id": 1, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:38:31.984520+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i1_p3_998168569", "generation": 8, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.6681872749099641, "fitness_mode": "correlation", "simplicity_score": 0.12587468625837553, "novelty_bonus": 0.17919272177365964, "total_score": 0.3401245335782679, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\nRecent failures:\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.141658\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n    degrees = s.get('degrees', [])\n\n    denom_m = max(m, 1)\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = n ** 0.5 / (1 + avg_clust)            # size & clustering\n    part3 = 1 + abs(assort)                       # assortativity\n    part4 = 1 + trans                             # transitivity\n    part5 = 1 + tri_per_edge                      # triangles per edge\n    part6 = avg_deg / (max_deg + 1)               # degree spread\n    part7 = deg_ratio                             # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / (1 + density)                     # density\n\n    mean_deg = sum(degrees) / len(degrees) if degrees else 0\n    part10 = mean_deg / max(max_deg, 1)           # mean degree scaled\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9 *\n        part10\n    )\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n    degrees = s.get('degrees', [])\n\n    denom_m = max(m, 1)\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = n ** 0.5 / (1 + avg_clust)            # size & clustering\n    part3 = 1 + abs(assort)                       # assortativity\n    part4 = 1 + trans                             # transitivity\n    part5 = 1 + tri_per_edge                      # triangles per edge\n    part6 = avg_deg / (max_deg + 1)               # degree spread\n    part7 = deg_ratio                             # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / (1 + density)                     # density\n\n    mean_deg = sum(degrees) / len(degrees) if degrees else 0\n    part10 = mean_deg / max(max_deg, 1)           # mean degree scaled\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9 *\n        part10\n    )", "spearman": 0.5223835595889897, "pearson": 0.49716738678973804, "rmse": 2.140729769413513, "mae": 2.0008168178251178}}
{"timestamp": "2026-02-16T15:39:46.845966+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i1_p4_132565566", "generation": 8, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.6076830732292917, "fitness_mode": "correlation", "simplicity_score": 0.19057200012086947, "novelty_bonus": 0.3636636031649868, "total_score": 0.46321738107117244, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    part1 = n / (denom_m + 1)\n    part2 = n ** 0.5 / denom_density\n    part3 = 1 + avg_clust\n    part4 = 1 + abs(assort)\n    part5 = 1 + trans\n    part6 = 1 + tri_per_edge\n    part7 = avg_deg / (max_deg + 1)\n    part8 = deg_ratio\n    part9 = 1 / (1 + deg_variance)\n\n    return part1 * part2 * part3 * part4 * part5 * part6 * part7 * part8 * part9\nRecent failures:\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.141658\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n    degrees = s.get('degrees', [])\n\n    # Denominators (avoid division by zero)\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg * std_deg\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Median degree from sorted degree list\n    deg_len = len(degrees)\n    if deg_len == 0:\n        median_deg = 0.0\n    else:\n        mid = deg_len // 2\n        if deg_len % 2 == 1:\n            median_deg = degrees[mid]\n        else:\n            median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n\n    # Composite parts\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clust)         # size & clustering\n    part3 = avg_deg / (max_deg + 1)               # degree spread\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = deg_ratio                             # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / (1 + denom_density)               # density penalty\n    part10 = median_deg / (max_deg + 1)           # median degree spread\n    part11 = n / (denom_density + 1e-6)           # size vs density\n    part12 = pow(n, 0.5) / (denom_density + 1e-6) # sqrt size vs density\n    part13 = avg_deg / (min_deg + 1)              # degree vs min degree\n\n    # Final invariant (multiplicative combination)\n    result = (part1 * part2 * part3 * part4 * part5 *\n              part6 * part7 * part8 * part9 * part10 *\n              part11 * part12 * part13)\n    return result\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n    degrees = s.get('degrees', [])\n\n    # Denominators (avoid division by zero)\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg * std_deg\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Median degree from sorted degree list\n    deg_len = len(degrees)\n    if deg_len == 0:\n        median_deg = 0.0\n    else:\n        mid = deg_len // 2\n        if deg_len % 2 == 1:\n            median_deg = degrees[mid]\n        else:\n            median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n\n    # Composite parts\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clust)         # size & clustering\n    part3 = avg_deg / (max_deg + 1)               # degree spread\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = deg_ratio                             # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / (1 + denom_density)               # density penalty\n    part10 = median_deg / (max_deg + 1)           # median degree spread\n    part11 = n / (denom_density + 1e-6)           # size vs density\n    part12 = pow(n, 0.5) / (denom_density + 1e-6) # sqrt size vs density\n    part13 = avg_deg / (min_deg + 1)              # degree vs min degree\n\n    # Final invariant (multiplicative combination)\n    result = (part1 * part2 * part3 * part4 * part5 *\n              part6 * part7 * part8 * part9 * part10 *\n              part11 * part12 * part13)\n    return result", "spearman": 0.632007800195005, "pearson": 0.5488450302436096, "rmse": 130097.74450614219, "mae": 68858.25604618153}}
{"timestamp": "2026-02-16T15:40:19.936109+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i2_p0_551358134", "generation": 8, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.9012725090036015, "fitness_mode": "correlation", "simplicity_score": 0.12492332977922135, "novelty_bonus": 0.16448511212780315, "total_score": 0.5355002288449165, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic blends a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Extract features with sensible defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = max(s.get('std_degree', 0.0), 0.0)\n    max_deg = max(s.get('max_degree', 1), 1)\n    min_deg = max(s.get('min_degree', 1), 1)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density (triangles per possible triangle)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n\n    # Denominator collects factors that tend to shorten paths\n    denom = (1.0 + density +\n             assort +\n             std_deg / avg_deg +\n             max_deg / (avg_deg + 1.0) +\n             min_deg / (avg_deg + 1.0) +\n             tri_ratio)\n\n    # Final estimate\n    return base * (1.0 + clustering) * (1.0 + trans) / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor", "spearman": 0.9223400585014627, "pearson": 0.8773389958654999, "rmse": 1.3051288019690377, "mae": 0.8723547541740444}}
{"timestamp": "2026-02-16T15:41:05.400222+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i2_p1_746945193", "generation": 8, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.6379351740696279, "fitness_mode": "correlation", "simplicity_score": 0.11995797645389346, "novelty_bonus": 0.18641648789422227, "total_score": 0.3916865859101517, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic blends a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Extract features with sensible defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = max(s.get('std_degree', 0.0), 0.0)\n    max_deg = max(s.get('max_degree', 1), 1)\n    min_deg = max(s.get('min_degree', 1), 1)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density (triangles per possible triangle)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n\n    # Denominator collects factors that tend to shorten paths\n    denom = (1.0 + density +\n             assort +\n             std_deg / avg_deg +\n             max_deg / (avg_deg + 1.0) +\n             min_deg / (avg_deg + 1.0) +\n             tri_ratio)\n\n    # Final estimate\n    return base * (1.0 + clustering) * (1.0 + trans) / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic blends a basic random‑graph intuition with multiplicative\n    corrections that capture the influence of clustering, density, degree\n    heterogeneity, hubs, and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections for structural properties\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer\n    trans_factor      = 1.0 + s['transitivity']                # higher transitivity → longer\n    density_factor    = 1.0 / (1.0 + s['density'])              # denser → shorter\n    hetero_factor     = 1.0 / (1.0 + s['std_degree'])           # more heterogeneous → shorter\n    # Very low minimum degree lengthens paths\n    min_factor        = 2.0 - s['min_degree'] / avg_deg\n    # Very high maximum degree (hubs) shortens paths\n    max_factor        = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1.0))\n\n    # Triangle density (triangles per possible triangle)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = s['num_triangles'] / possible_tri if possible_tri > 0 else 0\n    triangle_factor = 1.0 / (1.0 + tri_ratio)                    # more triangles → shorter\n\n    # Optional assortativity adjustment (assortative graphs tend to be slightly\n    # longer, disassortative slightly shorter).  Use absolute value to keep\n    # the factor positive.\n    assort_factor = 1.0 / (1.0 + abs(s['degree_assortativity']))\n\n    # Combine all factors multiplicatively\n    return (base * clustering_factor * trans_factor * density_factor *\n            hetero_factor * min_factor * max_factor * triangle_factor *\n            assort_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic blends a basic random‑graph intuition with multiplicative\n    corrections that capture the influence of clustering, density, degree\n    heterogeneity, hubs, and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections for structural properties\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer\n    trans_factor      = 1.0 + s['transitivity']                # higher transitivity → longer\n    density_factor    = 1.0 / (1.0 + s['density'])              # denser → shorter\n    hetero_factor     = 1.0 / (1.0 + s['std_degree'])           # more heterogeneous → shorter\n    # Very low minimum degree lengthens paths\n    min_factor        = 2.0 - s['min_degree'] / avg_deg\n    # Very high maximum degree (hubs) shortens paths\n    max_factor        = 1.0 / (1.0 + s['max_degree'] / (avg_deg + 1.0))\n\n    # Triangle density (triangles per possible triangle)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = s['num_triangles'] / possible_tri if possible_tri > 0 else 0\n    triangle_factor = 1.0 / (1.0 + tri_ratio)                    # more triangles → shorter\n\n    # Optional assortativity adjustment (assortative graphs tend to be slightly\n    # longer, disassortative slightly shorter).  Use absolute value to keep\n    # the factor positive.\n    assort_factor = 1.0 / (1.0 + abs(s['degree_assortativity']))\n\n    # Combine all factors multiplicatively\n    return (base * clustering_factor * trans_factor * density_factor *\n            hetero_factor * min_factor * max_factor * triangle_factor *\n            assort_factor)", "spearman": 0.6235400885022127, "pearson": 0.4724275605023608, "rmse": 1.4550375306139314, "mae": 1.2266760840982391}}
{"timestamp": "2026-02-16T15:41:38.256646+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i2_p2_479025673", "generation": 8, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.6637695078031213, "fitness_mode": "correlation", "simplicity_score": 0.12226396437886809, "novelty_bonus": 0.1690223083442085, "total_score": 0.44717253570529436, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic blends a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Extract features with sensible defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = max(s.get('std_degree', 0.0), 0.0)\n    max_deg = max(s.get('max_degree', 1), 1)\n    min_deg = max(s.get('min_degree', 1), 1)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density (triangles per possible triangle)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n\n    # Denominator collects factors that tend to shorten paths\n    denom = (1.0 + density +\n             assort +\n             std_deg / avg_deg +\n             max_deg / (avg_deg + 1.0) +\n             min_deg / (avg_deg + 1.0) +\n             tri_ratio)\n\n    # Final estimate\n    return base * (1.0 + clustering) * (1.0 + trans) / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph\n    intuition with multiplicative corrections that capture the\n    influence of clustering, transitivity, density, degree heterogeneity,\n    assortativity and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections that tend to increase the estimate\n    clust_factor   = 1.0 + 0.5 * s.get('avg_clustering', 0.0)\n    trans_factor   = 1.0 + 0.5 * s.get('transitivity', 0.0)\n\n    # Corrections that tend to decrease the estimate\n    density_factor = 1.0 / (1.0 + 0.5 * s.get('density', 0.0))\n    assort_factor  = 1.0 / (1.0 + abs(s.get('degree_assortativity', 0.0)))\n    hetero_factor  = 1.0 / (1.0 + 0.5 * s.get('std_degree', 0.0))\n    min_factor     = 1.0 / (1.0 + 0.5 * s.get('min_degree', 1) / avg_deg)\n\n    # Triangle density (triangles per possible triangle)\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_ratio = s.get('num_triangles', 0) / possible_tri\n    else:\n        tri_ratio = 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (base *\n            clust_factor *\n            trans_factor *\n            density_factor *\n            assort_factor *\n            hetero_factor *\n            min_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph\n    intuition with multiplicative corrections that capture the\n    influence of clustering, transitivity, density, degree heterogeneity,\n    assortativity and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections that tend to increase the estimate\n    clust_factor   = 1.0 + 0.5 * s.get('avg_clustering', 0.0)\n    trans_factor   = 1.0 + 0.5 * s.get('transitivity', 0.0)\n\n    # Corrections that tend to decrease the estimate\n    density_factor = 1.0 / (1.0 + 0.5 * s.get('density', 0.0))\n    assort_factor  = 1.0 / (1.0 + abs(s.get('degree_assortativity', 0.0)))\n    hetero_factor  = 1.0 / (1.0 + 0.5 * s.get('std_degree', 0.0))\n    min_factor     = 1.0 / (1.0 + 0.5 * s.get('min_degree', 1) / avg_deg)\n\n    # Triangle density (triangles per possible triangle)\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_ratio = s.get('num_triangles', 0) / possible_tri\n    else:\n        tri_ratio = 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (base *\n            clust_factor *\n            trans_factor *\n            density_factor *\n            assort_factor *\n            hetero_factor *\n            min_factor *\n            tri_factor)", "spearman": 0.7440261006525164, "pearson": 0.6548509418273832, "rmse": 1.5510581470978018, "mae": 1.1738473667596292}}
{"timestamp": "2026-02-16T15:42:19.916381+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i2_p3_472649426", "generation": 8, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7442496998799519, "fitness_mode": "correlation", "simplicity_score": 0.11879630391836889, "novelty_bonus": 0.24973690209750388, "total_score": 0.45760705458100415, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic blends a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Extract features with sensible defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = max(s.get('std_degree', 0.0), 0.0)\n    max_deg = max(s.get('max_degree', 1), 1)\n    min_deg = max(s.get('min_degree', 1), 1)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density (triangles per possible triangle)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n\n    # Denominator collects factors that tend to shorten paths\n    denom = (1.0 + density +\n             assort +\n             std_deg / avg_deg +\n             max_deg / (avg_deg + 1.0) +\n             min_deg / (avg_deg + 1.0) +\n             tri_ratio)\n\n    # Final estimate\n    return base * (1.0 + clustering) * (1.0 + trans) / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph intuition with multiplicative\n    corrections that capture clustering, density, degree heterogeneity,\n    assortativity, triangle density, and the presence of low/high degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)  # not used directly\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n\n    # Base estimate: larger graphs with lower average degree tend to have\n    # longer paths.\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    min_deg = s.get('min_degree', 1)\n    max_deg = s.get('max_degree', 1)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density (ratio of actual to possible triangles)\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n        tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    else:\n        tri_ratio = 0.0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering\n    trans_factor      = 1.0 + trans\n    density_factor    = 1.0 / (1.0 + density)\n    std_factor        = 1.0 / (1.0 + std_deg)\n    min_factor        = 1.0 / (1.0 + min_deg / avg_deg)\n    max_factor        = 1.0 / (1.0 + max_deg / avg_deg)\n    assort_factor     = 1.0 + abs(assort)\n    tri_factor        = 1.0 / (1.0 + tri_ratio)\n\n    return (base * clustering_factor * trans_factor * density_factor *\n            std_factor * min_factor * max_factor * assort_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph intuition with multiplicative\n    corrections that capture clustering, density, degree heterogeneity,\n    assortativity, triangle density, and the presence of low/high degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features. Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)  # not used directly\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n\n    # Base estimate: larger graphs with lower average degree tend to have\n    # longer paths.\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    min_deg = s.get('min_degree', 1)\n    max_deg = s.get('max_degree', 1)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density (ratio of actual to possible triangles)\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n        tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    else:\n        tri_ratio = 0.0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering\n    trans_factor      = 1.0 + trans\n    density_factor    = 1.0 / (1.0 + density)\n    std_factor        = 1.0 / (1.0 + std_deg)\n    min_factor        = 1.0 / (1.0 + min_deg / avg_deg)\n    max_factor        = 1.0 / (1.0 + max_deg / avg_deg)\n    assort_factor     = 1.0 + abs(assort)\n    tri_factor        = 1.0 / (1.0 + tri_ratio)\n\n    return (base * clustering_factor * trans_factor * density_factor *\n            std_factor * min_factor * max_factor * assort_factor *\n            tri_factor)", "spearman": 0.7178534463361584, "pearson": 0.649725887048141, "rmse": 1.8586176792629936, "mae": 1.7359674815833444}}
{"timestamp": "2026-02-16T15:43:04.773552+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i2_p4_728860098", "generation": 8, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.9048259303721489, "fitness_mode": "correlation", "simplicity_score": 0.12043286804124097, "novelty_bonus": 0.16040801020025486, "total_score": 0.5345137842885151, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a basic random‑graph estimate with corrections for\n    clustering, density, degree heterogeneity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Corrections\n    clustering_factor = 1.0 + s['avg_clustering']              # higher clustering → longer paths\n    density_factor     = 1.0 / (1.0 + s['density'])            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + s['std_degree'])          # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * density_factor * hetero_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic blends a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: more nodes and lower degree → longer paths\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Extract features with sensible defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = max(s.get('std_degree', 0.0), 0.0)\n    max_deg = max(s.get('max_degree', 1), 1)\n    min_deg = max(s.get('min_degree', 1), 1)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density (triangles per possible triangle)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n\n    # Denominator collects factors that tend to shorten paths\n    denom = (1.0 + density +\n             assort +\n             std_deg / avg_deg +\n             max_deg / (avg_deg + 1.0) +\n             min_deg / (avg_deg + 1.0) +\n             tri_ratio)\n\n    # Final estimate\n    return base * (1.0 + clustering) * (1.0 + trans) / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, the presence of low‑degree vertices\n    and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg < 1:\n        avg_deg = 1\n    base = n / (avg_deg + 1)\n\n    # Corrections for various structural properties\n    density = s.get('density', 0.0)\n    density_factor = 1 / (1 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1 / (1 + std_deg)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1 / (1 + min_deg / (avg_deg + 1))\n\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1 + trans\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1 + abs(assort)\n\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1 / (1 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * density_factor\n        * hetero_factor\n        * min_factor\n        * tri_factor\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, the presence of low‑degree vertices\n    and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg < 1:\n        avg_deg = 1\n    base = n / (avg_deg + 1)\n\n    # Corrections for various structural properties\n    density = s.get('density', 0.0)\n    density_factor = 1 / (1 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1 / (1 + std_deg)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1 / (1 + min_deg / (avg_deg + 1))\n\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1 + trans\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1 + abs(assort)\n\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1 / (1 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * density_factor\n        * hetero_factor\n        * min_factor\n        * tri_factor\n    )", "spearman": 0.9246096152403811, "pearson": 0.8829640320073221, "rmse": 1.4651288816431371, "mae": 0.9579665976774416}}
{"timestamp": "2026-02-16T15:43:40.253698+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i3_p0_181949656", "generation": 8, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5813685474189676, "fitness_mode": "correlation", "simplicity_score": 0.15489378242648352, "novelty_bonus": 0.3162634065851646, "total_score": 0.4067668011864143, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length from global graph statistics.\n    The estimator combines a node/edge ratio baseline with multiplicative\n    corrections for density, degree heterogeneity, clustering,\n    transitivity, assortativity, triangle abundance, degree range\n    and the concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        A single scalar intended to correlate with the true average\n        shortest‑path length.\n    \"\"\"\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_degree = s.get('avg_degree', 0.0)\n    max_degree = s.get('max_degree', 0.0)\n    min_degree = s.get('min_degree', 1.0)\n    std_degree = s.get('std_degree', 0.0)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # Base ratio of nodes to edges (regularised)\n    base = n / (m + 1.0)\n\n    # Correction for overall sparsity – sparse graphs tend to have longer paths\n    density_factor = 1.0 / (1.0 + density)\n\n    # Effect of degree heterogeneity – higher variance relative to mean reduces distance\n    het_factor = (std_degree + 1.0) / (avg_degree + 1.0)\n\n    # Clustering tends to create tightly knit communities; higher clustering can reduce path length\n    clustering_factor = 1.0 / (1.0 + avg_clustering)\n\n    # Transitivity (global clustering) adds alternative routes, slightly shortening distances\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity (absolute value) captures mixing of high/low degree nodes\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # Triangle abundance reduces path length; square‑root gives diminishing returns\n    tri_factor = 1.0 + (num_triangles ** 0.5) / ((n ** 0.5) + 1e-6)\n\n    # Degree range emphasises the presence of hubs versus leaves\n    deg_range_factor = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # Concentration of high‑degree vertices – smaller fraction means hubs are more spread out\n    top_k = max(1, n // 10)               # top 10 % of nodes\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Final multiplicative estimate\n    estimate = (\n        base *\n        density_factor *\n        het_factor *\n        clustering_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        deg_range_factor *\n        top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_train_threshold: train_signal=0.161681\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from pre‑computed graph\n    statistics.  The formula blends a baseline node/edge ratio with\n    multiplicative adjustments that capture sparsity, degree heterogeneity,\n    clustering, assortativity, triangle abundance, degree range and the\n    concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Keys that are expected:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # ----- Basic quantities --------------------------------------------\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # 1. Baseline: ratio of nodes to edges (regularised by +1)\n    base = n / (m + 1.0)\n\n    # 2. Sparsity adjustment: sparse graphs tend to have longer paths\n    density = s.get('density', 0.0)\n    sparsity_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity: high variance relative to mean shortens paths\n    avg_degree = s.get('avg_degree', 0.0)\n    std_degree = s.get('std_degree', 0.0)\n    het_factor = (std_degree + 1.0) / (avg_degree + 1.0)\n\n    # 4. Clustering effect: larger average clustering typically reduces distance\n    avg_clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 / (1.0 + avg_clustering)\n\n    # 5. Transitivity influence: more global connections lower distance\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # 6. Assortativity contribution: mixing of high/low degree nodes modifies distance\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # 7. Triangle abundance: many triangles usually shorten paths\n    num_triangles = s.get('num_triangles', 0)\n    tri_factor = 1.0 + (num_triangles ** 0.5) / ((n ** 0.5) + 1e-6)\n\n    # 8. Degree range emphasis: presence of hubs vs leaves\n    max_degree = s.get('max_degree', 0.0)\n    min_degree = s.get('min_degree', 1.0)\n    deg_range_factor = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # 9. High‑degree concentration: how clustered the hubs are\n    degrees = s.get('degrees', [])\n    top_k = max(1, int(n * 0.1))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_deg_sum / total_deg\n    high_conc_factor = 1.0 + (1.0 - top_ratio) * 0.5\n\n    # ----- Final composite estimate -----------------------------------\n    estimate = (\n        base\n        * sparsity_factor\n        * het_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range_factor\n        * high_conc_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from pre‑computed graph\n    statistics.  The formula blends a baseline node/edge ratio with\n    multiplicative adjustments that capture sparsity, degree heterogeneity,\n    clustering, assortativity, triangle abundance, degree range and the\n    concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Keys that are expected:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # ----- Basic quantities --------------------------------------------\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # 1. Baseline: ratio of nodes to edges (regularised by +1)\n    base = n / (m + 1.0)\n\n    # 2. Sparsity adjustment: sparse graphs tend to have longer paths\n    density = s.get('density', 0.0)\n    sparsity_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity: high variance relative to mean shortens paths\n    avg_degree = s.get('avg_degree', 0.0)\n    std_degree = s.get('std_degree', 0.0)\n    het_factor = (std_degree + 1.0) / (avg_degree + 1.0)\n\n    # 4. Clustering effect: larger average clustering typically reduces distance\n    avg_clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 / (1.0 + avg_clustering)\n\n    # 5. Transitivity influence: more global connections lower distance\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # 6. Assortativity contribution: mixing of high/low degree nodes modifies distance\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # 7. Triangle abundance: many triangles usually shorten paths\n    num_triangles = s.get('num_triangles', 0)\n    tri_factor = 1.0 + (num_triangles ** 0.5) / ((n ** 0.5) + 1e-6)\n\n    # 8. Degree range emphasis: presence of hubs vs leaves\n    max_degree = s.get('max_degree', 0.0)\n    min_degree = s.get('min_degree', 1.0)\n    deg_range_factor = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # 9. High‑degree concentration: how clustered the hubs are\n    degrees = s.get('degrees', [])\n    top_k = max(1, int(n * 0.1))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_deg_sum / total_deg\n    high_conc_factor = 1.0 + (1.0 - top_ratio) * 0.5\n\n    # ----- Final composite estimate -----------------------------------\n    estimate = (\n        base\n        * sparsity_factor\n        * het_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range_factor\n        * high_conc_factor\n    )\n\n    return float(estimate)", "spearman": 0.5618180454511364, "pearson": 0.5329067744839837, "rmse": 7.2165090042663, "mae": 3.5325415914030573}}
{"timestamp": "2026-02-16T15:44:24.584697+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i3_p1_768065964", "generation": 8, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5833853541416567, "fitness_mode": "correlation", "simplicity_score": 0.15489378242648352, "novelty_bonus": 0.326601665041626, "total_score": 0.40594118054589823, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length from global graph statistics.\n    The estimator combines a node/edge ratio baseline with multiplicative\n    corrections for density, degree heterogeneity, clustering,\n    transitivity, assortativity, triangle abundance, degree range\n    and the concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        A single scalar intended to correlate with the true average\n        shortest‑path length.\n    \"\"\"\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_degree = s.get('avg_degree', 0.0)\n    max_degree = s.get('max_degree', 0.0)\n    min_degree = s.get('min_degree', 1.0)\n    std_degree = s.get('std_degree', 0.0)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # Base ratio of nodes to edges (regularised)\n    base = n / (m + 1.0)\n\n    # Correction for overall sparsity – sparse graphs tend to have longer paths\n    density_factor = 1.0 / (1.0 + density)\n\n    # Effect of degree heterogeneity – higher variance relative to mean reduces distance\n    het_factor = (std_degree + 1.0) / (avg_degree + 1.0)\n\n    # Clustering tends to create tightly knit communities; higher clustering can reduce path length\n    clustering_factor = 1.0 / (1.0 + avg_clustering)\n\n    # Transitivity (global clustering) adds alternative routes, slightly shortening distances\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity (absolute value) captures mixing of high/low degree nodes\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # Triangle abundance reduces path length; square‑root gives diminishing returns\n    tri_factor = 1.0 + (num_triangles ** 0.5) / ((n ** 0.5) + 1e-6)\n\n    # Degree range emphasises the presence of hubs versus leaves\n    deg_range_factor = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # Concentration of high‑degree vertices – smaller fraction means hubs are more spread out\n    top_k = max(1, n // 10)               # top 10 % of nodes\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Final multiplicative estimate\n    estimate = (\n        base *\n        density_factor *\n        het_factor *\n        clustering_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        deg_range_factor *\n        top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_train_threshold: train_signal=0.161681\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only pre‑computed\n    graph statistics.  The estimator mixes multiplicative corrections for\n    sparsity, degree heterogeneity, clustering, triangle abundance,\n    assortativity, and the presence of hubs.  It does not require any\n    graph traversal or external libraries.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Keys may include:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        A scalar that is expected to correlate with the true\n        average shortest‑path length.\n    \"\"\"\n    # basic properties with fall‑back defaults\n    n      = s.get('n', 1)\n    m      = s.get('m', 0)\n    density   = s.get('density', 0.0)\n    avg_deg   = s.get('avg_degree', 0.0)\n    max_deg   = s.get('max_degree', 0)\n    min_deg   = s.get('min_degree', 1)            # avoid zero division\n    std_deg   = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans     = s.get('transitivity', 0.0)\n    assort    = s.get('degree_assortativity', 0.0)\n    num_tri   = s.get('num_triangles', 0)\n    degrees   = s.get('degrees', [])\n\n    # --- component factors --------------------------------------------------\n    base        = n / (m + 1)                                   # nodes‑to‑edges\n    density_f   = 1 / (1 + density)                              # sparsity\n    het_f       = (std_deg + 1) / (avg_deg + 1)                  # degree heterogeneity\n    clust_f     = 1 / (1 + avg_clust)                            # local clustering\n    trans_f     = 1 + trans                                       # global transitivity\n    assort_f    = 1 + abs(assort)                                 # assortativity\n    tri_f       = 1 + pow(num_tri, 0.5) / (pow(n, 0.5) + 1e-6)   # triangle abundance\n    range_f     = (max_deg + 1) / (min_deg + 1e-6)               # degree range\n\n    # hub concentration (top 10 % of nodes)\n    top_k       = max(1, n // 10)\n    high_sum    = sum(degrees[-top_k:]) if degrees else 0\n    total_deg   = 2 * m if m > 0 else 1e-6\n    top_ratio   = high_sum / total_deg\n    top_f       = 1 + (1 - top_ratio) * het_f\n\n    # --- final multiplicative estimate -------------------------------------\n    estimate = (\n        base * density_f * het_f * clust_f * trans_f *\n        assort_f * tri_f * range_f * top_f\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only pre‑computed\n    graph statistics.  The estimator mixes multiplicative corrections for\n    sparsity, degree heterogeneity, clustering, triangle abundance,\n    assortativity, and the presence of hubs.  It does not require any\n    graph traversal or external libraries.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Keys may include:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        A scalar that is expected to correlate with the true\n        average shortest‑path length.\n    \"\"\"\n    # basic properties with fall‑back defaults\n    n      = s.get('n', 1)\n    m      = s.get('m', 0)\n    density   = s.get('density', 0.0)\n    avg_deg   = s.get('avg_degree', 0.0)\n    max_deg   = s.get('max_degree', 0)\n    min_deg   = s.get('min_degree', 1)            # avoid zero division\n    std_deg   = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans     = s.get('transitivity', 0.0)\n    assort    = s.get('degree_assortativity', 0.0)\n    num_tri   = s.get('num_triangles', 0)\n    degrees   = s.get('degrees', [])\n\n    # --- component factors --------------------------------------------------\n    base        = n / (m + 1)                                   # nodes‑to‑edges\n    density_f   = 1 / (1 + density)                              # sparsity\n    het_f       = (std_deg + 1) / (avg_deg + 1)                  # degree heterogeneity\n    clust_f     = 1 / (1 + avg_clust)                            # local clustering\n    trans_f     = 1 + trans                                       # global transitivity\n    assort_f    = 1 + abs(assort)                                 # assortativity\n    tri_f       = 1 + pow(num_tri, 0.5) / (pow(n, 0.5) + 1e-6)   # triangle abundance\n    range_f     = (max_deg + 1) / (min_deg + 1e-6)               # degree range\n\n    # hub concentration (top 10 % of nodes)\n    top_k       = max(1, n // 10)\n    high_sum    = sum(degrees[-top_k:]) if degrees else 0\n    total_deg   = 2 * m if m > 0 else 1e-6\n    top_ratio   = high_sum / total_deg\n    top_f       = 1 + (1 - top_ratio) * het_f\n\n    # --- final multiplicative estimate -------------------------------------\n    estimate = (\n        base * density_f * het_f * clust_f * trans_f *\n        assort_f * tri_f * range_f * top_f\n    )\n\n    return float(estimate)", "spearman": 0.5539638490962274, "pearson": 0.49810058368566934, "rmse": 9.66865208350098, "mae": 4.26129780250592}}
{"timestamp": "2026-02-16T15:44:58.892086+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i3_p2_403168202", "generation": 8, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5806962785114045, "fitness_mode": "correlation", "simplicity_score": 0.154529956317646, "novelty_bonus": 0.32561614040351006, "total_score": 0.4043899783632067, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length from global graph statistics.\n    The estimator combines a node/edge ratio baseline with multiplicative\n    corrections for density, degree heterogeneity, clustering,\n    transitivity, assortativity, triangle abundance, degree range\n    and the concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        A single scalar intended to correlate with the true average\n        shortest‑path length.\n    \"\"\"\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_degree = s.get('avg_degree', 0.0)\n    max_degree = s.get('max_degree', 0.0)\n    min_degree = s.get('min_degree', 1.0)\n    std_degree = s.get('std_degree', 0.0)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # Base ratio of nodes to edges (regularised)\n    base = n / (m + 1.0)\n\n    # Correction for overall sparsity – sparse graphs tend to have longer paths\n    density_factor = 1.0 / (1.0 + density)\n\n    # Effect of degree heterogeneity – higher variance relative to mean reduces distance\n    het_factor = (std_degree + 1.0) / (avg_degree + 1.0)\n\n    # Clustering tends to create tightly knit communities; higher clustering can reduce path length\n    clustering_factor = 1.0 / (1.0 + avg_clustering)\n\n    # Transitivity (global clustering) adds alternative routes, slightly shortening distances\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity (absolute value) captures mixing of high/low degree nodes\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # Triangle abundance reduces path length; square‑root gives diminishing returns\n    tri_factor = 1.0 + (num_triangles ** 0.5) / ((n ** 0.5) + 1e-6)\n\n    # Degree range emphasises the presence of hubs versus leaves\n    deg_range_factor = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # Concentration of high‑degree vertices – smaller fraction means hubs are more spread out\n    top_k = max(1, n // 10)               # top 10 % of nodes\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Final multiplicative estimate\n    estimate = (\n        base *\n        density_factor *\n        het_factor *\n        clustering_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        deg_range_factor *\n        top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_train_threshold: train_signal=0.161681\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using only global\n    statistics supplied in the dictionary `s`.  \n    The expression mixes a base node/edge ratio with corrections for\n    sparsity, degree heterogeneity, clustering, assortativity,\n    triangle density, degree range and the concentration of hubs.\n    No traversal or explicit graph algorithms are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with pre‑computed graph statistics. Expected keys\n        are:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Scalar estimate that correlates with the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Basic node/edge ratio (regularised)\n    base_ratio = (s.get('n', 1.0) + 1.0) / (s.get('m', 0.0) + 1.0)\n\n    # Sparsity adjustment – sparse graphs tend to have longer paths\n    sparsity = 1.0 / (1.0 + s.get('density', 0.0))\n\n    # Degree heterogeneity factor – larger variance shortens distances\n    std = s.get('std_degree', 0.0)\n    avg_deg = s.get('avg_degree', 1.0)  # avoid divide by zero\n    hetero = (std + 1.0) / (avg_deg + 1.0)\n\n    # Clustering tends to create local tightly‑connected regions\n    clustering = s.get('avg_clustering', 0.0)\n    cluster_factor = 1.0 / (1.0 + clustering)\n\n    # Transitivity (global clustering) provides alternative routes\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + trans\n\n    # Assortativity effect\n    assort = abs(s.get('degree_assortativity', 0.0))\n    assort_factor = 1.0 + assort\n\n    # Triangle density – more triangles usually reduce overall path length\n    num_tri = s.get('num_triangles', 0)\n    tri_factor = 1.0 + (num_tri ** 0.5) / ((s.get('n', 1.0) ** 0.5) + 1e-6)\n\n    # Degree range factor – presence of hubs relative to leaves\n    max_d = s.get('max_degree', 1.0)\n    min_d = s.get('min_degree', 1.0)\n    range_factor = (max_d + 1.0) / (min_d + 1e-6)\n\n    # Concentration of high‑degree vertices (top 10 %)\n    degrees = s.get('degrees', [])\n    if degrees:\n        top_k = max(1, int(0.1 * s.get('n', 1.0)))\n        high_sum = sum(degrees[-top_k:])\n    else:\n        high_sum = 0.0\n    total_deg = 2.0 * s.get('m', 0.0) if s.get('m', 0.0) > 0 else 1e-6\n    top_ratio = high_sum / total_deg if total_deg else 1.0\n    hub_factor = 1.0 + (1.0 - top_ratio) * hetero\n\n    # Compose all factors multiplicatively\n    estimate = (\n        base_ratio *\n        sparsity *\n        hetero *\n        cluster_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        range_factor *\n        hub_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using only global\n    statistics supplied in the dictionary `s`.  \n    The expression mixes a base node/edge ratio with corrections for\n    sparsity, degree heterogeneity, clustering, assortativity,\n    triangle density, degree range and the concentration of hubs.\n    No traversal or explicit graph algorithms are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with pre‑computed graph statistics. Expected keys\n        are:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Scalar estimate that correlates with the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Basic node/edge ratio (regularised)\n    base_ratio = (s.get('n', 1.0) + 1.0) / (s.get('m', 0.0) + 1.0)\n\n    # Sparsity adjustment – sparse graphs tend to have longer paths\n    sparsity = 1.0 / (1.0 + s.get('density', 0.0))\n\n    # Degree heterogeneity factor – larger variance shortens distances\n    std = s.get('std_degree', 0.0)\n    avg_deg = s.get('avg_degree', 1.0)  # avoid divide by zero\n    hetero = (std + 1.0) / (avg_deg + 1.0)\n\n    # Clustering tends to create local tightly‑connected regions\n    clustering = s.get('avg_clustering', 0.0)\n    cluster_factor = 1.0 / (1.0 + clustering)\n\n    # Transitivity (global clustering) provides alternative routes\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + trans\n\n    # Assortativity effect\n    assort = abs(s.get('degree_assortativity', 0.0))\n    assort_factor = 1.0 + assort\n\n    # Triangle density – more triangles usually reduce overall path length\n    num_tri = s.get('num_triangles', 0)\n    tri_factor = 1.0 + (num_tri ** 0.5) / ((s.get('n', 1.0) ** 0.5) + 1e-6)\n\n    # Degree range factor – presence of hubs relative to leaves\n    max_d = s.get('max_degree', 1.0)\n    min_d = s.get('min_degree', 1.0)\n    range_factor = (max_d + 1.0) / (min_d + 1e-6)\n\n    # Concentration of high‑degree vertices (top 10 %)\n    degrees = s.get('degrees', [])\n    if degrees:\n        top_k = max(1, int(0.1 * s.get('n', 1.0)))\n        high_sum = sum(degrees[-top_k:])\n    else:\n        high_sum = 0.0\n    total_deg = 2.0 * s.get('m', 0.0) if s.get('m', 0.0) > 0 else 1e-6\n    top_ratio = high_sum / total_deg if total_deg else 1.0\n    hub_factor = 1.0 + (1.0 - top_ratio) * hetero\n\n    # Compose all factors multiplicatively\n    estimate = (\n        base_ratio *\n        sparsity *\n        hetero *\n        cluster_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        range_factor *\n        hub_factor\n    )\n\n    return float(estimate)", "spearman": 0.551598289957249, "pearson": 0.49785731961787527, "rmse": 9.825653177358184, "mae": 4.345392106197964}}
{"timestamp": "2026-02-16T15:45:35.263150+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i3_p3_40163236", "generation": 8, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5374789915966387, "fitness_mode": "correlation", "simplicity_score": 0.1547777664337583, "novelty_bonus": 0.33249831245781136, "total_score": 0.3988360002979269, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length from global graph statistics.\n    The estimator combines a node/edge ratio baseline with multiplicative\n    corrections for density, degree heterogeneity, clustering,\n    transitivity, assortativity, triangle abundance, degree range\n    and the concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        A single scalar intended to correlate with the true average\n        shortest‑path length.\n    \"\"\"\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_degree = s.get('avg_degree', 0.0)\n    max_degree = s.get('max_degree', 0.0)\n    min_degree = s.get('min_degree', 1.0)\n    std_degree = s.get('std_degree', 0.0)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # Base ratio of nodes to edges (regularised)\n    base = n / (m + 1.0)\n\n    # Correction for overall sparsity – sparse graphs tend to have longer paths\n    density_factor = 1.0 / (1.0 + density)\n\n    # Effect of degree heterogeneity – higher variance relative to mean reduces distance\n    het_factor = (std_degree + 1.0) / (avg_degree + 1.0)\n\n    # Clustering tends to create tightly knit communities; higher clustering can reduce path length\n    clustering_factor = 1.0 / (1.0 + avg_clustering)\n\n    # Transitivity (global clustering) adds alternative routes, slightly shortening distances\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity (absolute value) captures mixing of high/low degree nodes\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # Triangle abundance reduces path length; square‑root gives diminishing returns\n    tri_factor = 1.0 + (num_triangles ** 0.5) / ((n ** 0.5) + 1e-6)\n\n    # Degree range emphasises the presence of hubs versus leaves\n    deg_range_factor = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # Concentration of high‑degree vertices – smaller fraction means hubs are more spread out\n    top_k = max(1, n // 10)               # top 10 % of nodes\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Final multiplicative estimate\n    estimate = (\n        base *\n        density_factor *\n        het_factor *\n        clustering_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        deg_range_factor *\n        top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_train_threshold: train_signal=0.161681\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # unpacking with safe defaults\n    n, m = s.get('n', 1), s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_degree = s.get('avg_degree', 0.0)\n    max_degree = s.get('max_degree', 1.0)\n    min_degree = s.get('min_degree', 1.0)\n    std_degree = s.get('std_degree', 0.0)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # Base ratio of nodes to edges (regularised)\n    base = (n + 1) / (m + 1)\n\n    # Sparsity adjustment – sparse graphs usually have longer paths\n    sparsity_adj = 1 + (1 - density)\n\n    # Heterogeneity factor – more variance reduces path length\n    heterogeneity = 1 + (std_degree / (avg_degree + 1e-6))\n\n    # Clustering dampening – higher clustering can reduce path length\n    clustering_factor = 1 / (1 + avg_clustering)\n\n    # Transitivity bonus – alternative routes shorten paths\n    transitivity_factor = 1 + transitivity\n\n    # Assortativity adjustment\n    assortativity_factor = 1 + abs(degree_assortativity)\n\n    # Triangle influence – diminishing returns with sqrt\n    triangle_factor = 1 + (num_triangles ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range emphasis – hub effect\n    degree_range_factor = (max_degree + 1) / (min_degree + 1e-6)\n\n    # High‑degree concentration – spread of hubs\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_degree = 2 * m if m > 0 else 1\n    high_ratio = high_sum / total_degree\n    high_degree_factor = 1 + (1 - high_ratio) * heterogeneity\n\n    # Final composite estimate\n    estimate = (\n        base\n        * sparsity_adj\n        * heterogeneity\n        * clustering_factor\n        * transitivity_factor\n        * assortativity_factor\n        * triangle_factor\n        * degree_range_factor\n        * high_degree_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    # unpacking with safe defaults\n    n, m = s.get('n', 1), s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_degree = s.get('avg_degree', 0.0)\n    max_degree = s.get('max_degree', 1.0)\n    min_degree = s.get('min_degree', 1.0)\n    std_degree = s.get('std_degree', 0.0)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # Base ratio of nodes to edges (regularised)\n    base = (n + 1) / (m + 1)\n\n    # Sparsity adjustment – sparse graphs usually have longer paths\n    sparsity_adj = 1 + (1 - density)\n\n    # Heterogeneity factor – more variance reduces path length\n    heterogeneity = 1 + (std_degree / (avg_degree + 1e-6))\n\n    # Clustering dampening – higher clustering can reduce path length\n    clustering_factor = 1 / (1 + avg_clustering)\n\n    # Transitivity bonus – alternative routes shorten paths\n    transitivity_factor = 1 + transitivity\n\n    # Assortativity adjustment\n    assortativity_factor = 1 + abs(degree_assortativity)\n\n    # Triangle influence – diminishing returns with sqrt\n    triangle_factor = 1 + (num_triangles ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range emphasis – hub effect\n    degree_range_factor = (max_degree + 1) / (min_degree + 1e-6)\n\n    # High‑degree concentration – spread of hubs\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_degree = 2 * m if m > 0 else 1\n    high_ratio = high_sum / total_degree\n    high_degree_factor = 1 + (1 - high_ratio) * heterogeneity\n\n    # Final composite estimate\n    estimate = (\n        base\n        * sparsity_adj\n        * heterogeneity\n        * clustering_factor\n        * transitivity_factor\n        * assortativity_factor\n        * triangle_factor\n        * degree_range_factor\n        * high_degree_factor\n    )\n\n    return float(estimate)", "spearman": 0.5362619065476637, "pearson": 0.5412598200619025, "rmse": 66.28544877356113, "mae": 40.47921650064807}}
{"timestamp": "2026-02-16T15:46:03.384763+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i3_p4_196879683", "generation": 8, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.582328931572629, "fitness_mode": "correlation", "simplicity_score": 0.1613548616327653, "novelty_bonus": 0.33411445088147906, "total_score": 0.40290956769749947, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length from global graph statistics.\n    The estimator combines a node/edge ratio baseline with multiplicative\n    corrections for density, degree heterogeneity, clustering,\n    transitivity, assortativity, triangle abundance, degree range\n    and the concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        A single scalar intended to correlate with the true average\n        shortest‑path length.\n    \"\"\"\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_degree = s.get('avg_degree', 0.0)\n    max_degree = s.get('max_degree', 0.0)\n    min_degree = s.get('min_degree', 1.0)\n    std_degree = s.get('std_degree', 0.0)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # Base ratio of nodes to edges (regularised)\n    base = n / (m + 1.0)\n\n    # Correction for overall sparsity – sparse graphs tend to have longer paths\n    density_factor = 1.0 / (1.0 + density)\n\n    # Effect of degree heterogeneity – higher variance relative to mean reduces distance\n    het_factor = (std_degree + 1.0) / (avg_degree + 1.0)\n\n    # Clustering tends to create tightly knit communities; higher clustering can reduce path length\n    clustering_factor = 1.0 / (1.0 + avg_clustering)\n\n    # Transitivity (global clustering) adds alternative routes, slightly shortening distances\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity (absolute value) captures mixing of high/low degree nodes\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # Triangle abundance reduces path length; square‑root gives diminishing returns\n    tri_factor = 1.0 + (num_triangles ** 0.5) / ((n ** 0.5) + 1e-6)\n\n    # Degree range emphasises the presence of hubs versus leaves\n    deg_range_factor = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # Concentration of high‑degree vertices – smaller fraction means hubs are more spread out\n    top_k = max(1, n // 10)               # top 10 % of nodes\n    high_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_sum / total_deg\n    top_factor = 1.0 + (1.0 - top_ratio) * het_factor\n\n    # Final multiplicative estimate\n    estimate = (\n        base *\n        density_factor *\n        het_factor *\n        clustering_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        deg_range_factor *\n        top_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_train_threshold: train_signal=0.161681\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest path length derived from global graph\n    statistics only.  The formula is purely multiplicative and uses only\n    features available in the pre‑computed dictionary `s`.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (values are floats or ints):\n        n (int)               – number of nodes\n        m (int)               – number of edges\n        density (float)       – 2*m / (n*(n-1))\n        avg_degree (float)    – average node degree\n        max_degree (int)      – maximum degree in the graph\n        min_degree (int)      – minimum degree in the graph\n        std_degree (float)    – standard deviation of node degrees\n        avg_clustering (float) – average local clustering coefficient\n        transitivity (float)   – global clustering coefficient\n        degree_assortativity (float) – assortativity coefficient\n        num_triangles (int)      – number of triangles in the graph\n        degrees (list[int])      – sorted list of node degrees\n\n    Returns\n    -------\n    float\n        A single scalar intended to correlate with the true average shortest\n        path length.  The expression is intentionally non‑linear yet\n        completely deterministic from the supplied statistics.\n    \"\"\"\n    # Basic node‑to‑edge ratio, regularised by +1 to avoid division by zero\n    base = s['n'] / (s['m'] + 1.0)\n\n    # Sparsity correction – sparse graphs tend to have larger path lengths\n    density_factor = 1.0 / (1.0 + s['density'])\n\n    # Degree heterogeneity factor – higher variance relative to mean reduces\n    # average distance between randomly chosen nodes.\n    hetero_factor = (s['std_degree'] + 1.0) / (s['avg_degree'] + 1.0)\n\n    # Effect of local clustering – high clustering can shorten distances\n    clustering_factor = 1.0 / (1.0 + s['avg_clustering'])\n\n    # Triangle abundance – more triangles usually imply shorter paths\n    tri_factor = 1.0 + (s['num_triangles'] ** 0.5) / (s['n'] ** 0.5 + 1e-12)\n\n    # Degree range emphasis – presence of hubs (large max/min ratio)\n    deg_range_factor = (s['max_degree'] + 1.0) / (s['min_degree'] + 1e-12)\n\n    # Assortativity effect – mixing between high‑ and low‑degree vertices\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Final multiplicative estimate\n    estimate = (base *\n                density_factor *\n                hetero_factor *\n                clustering_factor *\n                tri_factor *\n                deg_range_factor *\n                assort_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest path length derived from global graph\n    statistics only.  The formula is purely multiplicative and uses only\n    features available in the pre‑computed dictionary `s`.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (values are floats or ints):\n        n (int)               – number of nodes\n        m (int)               – number of edges\n        density (float)       – 2*m / (n*(n-1))\n        avg_degree (float)    – average node degree\n        max_degree (int)      – maximum degree in the graph\n        min_degree (int)      – minimum degree in the graph\n        std_degree (float)    – standard deviation of node degrees\n        avg_clustering (float) – average local clustering coefficient\n        transitivity (float)   – global clustering coefficient\n        degree_assortativity (float) – assortativity coefficient\n        num_triangles (int)      – number of triangles in the graph\n        degrees (list[int])      – sorted list of node degrees\n\n    Returns\n    -------\n    float\n        A single scalar intended to correlate with the true average shortest\n        path length.  The expression is intentionally non‑linear yet\n        completely deterministic from the supplied statistics.\n    \"\"\"\n    # Basic node‑to‑edge ratio, regularised by +1 to avoid division by zero\n    base = s['n'] / (s['m'] + 1.0)\n\n    # Sparsity correction – sparse graphs tend to have larger path lengths\n    density_factor = 1.0 / (1.0 + s['density'])\n\n    # Degree heterogeneity factor – higher variance relative to mean reduces\n    # average distance between randomly chosen nodes.\n    hetero_factor = (s['std_degree'] + 1.0) / (s['avg_degree'] + 1.0)\n\n    # Effect of local clustering – high clustering can shorten distances\n    clustering_factor = 1.0 / (1.0 + s['avg_clustering'])\n\n    # Triangle abundance – more triangles usually imply shorter paths\n    tri_factor = 1.0 + (s['num_triangles'] ** 0.5) / (s['n'] ** 0.5 + 1e-12)\n\n    # Degree range emphasis – presence of hubs (large max/min ratio)\n    deg_range_factor = (s['max_degree'] + 1.0) / (s['min_degree'] + 1e-12)\n\n    # Assortativity effect – mixing between high‑ and low‑degree vertices\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Final multiplicative estimate\n    estimate = (base *\n                density_factor *\n                hetero_factor *\n                clustering_factor *\n                tri_factor *\n                deg_range_factor *\n                assort_factor)\n\n    return float(estimate)", "spearman": 0.5408085202130054, "pearson": 0.48277788172695035, "rmse": 5.135606290663276, "mae": 2.5204150662583373}}
{"timestamp": "2026-02-16T15:46:03.386714+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 9, "model_name": "gpt-oss:20b", "best_val_score": 0.5376982263149925, "no_improve_count": 1}}
{"timestamp": "2026-02-16T15:46:49.118863+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i0_p0_457863833", "generation": 9, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22191621004497614, "novelty_bonus": 0.25138613993252834, "total_score": 0.5273345223747135, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, and triangle counts in a compact, interpretable\n    way.  No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    # Basic scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.123745\nbelow_train_threshold: train_signal=0.136807\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T15:47:43.199822+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i0_p1_748076680", "generation": 9, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22185006579734193, "novelty_bonus": 0.25138613993252834, "total_score": 0.5273212935251865, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, and triangle counts in a compact, interpretable\n    way.  No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    # Basic scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.123745\nbelow_train_threshold: train_signal=0.136807\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts and leaf fraction in a\n    compact, interpretable way.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base estimate: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts and leaf fraction in a\n    compact, interpretable way.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base estimate: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T15:48:03.030325+00:00", "event_type": "candidate_rejected", "payload": {"generation": 9, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.059880", "model_name": "gpt-oss:20b", "train_signal": 0.05987995198079231}}
{"timestamp": "2026-02-16T15:48:31.392797+00:00", "event_type": "candidate_rejected", "payload": {"generation": 9, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.061321", "model_name": "gpt-oss:20b", "train_signal": 0.06132052821128451}}
{"timestamp": "2026-02-16T15:49:00.566201+00:00", "event_type": "candidate_rejected", "payload": {"generation": 9, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:49:00.567367+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 9, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:49:49.757912+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i0_p4_709988843", "generation": 9, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.645234093637455, "fitness_mode": "correlation", "simplicity_score": 0.2218830559467793, "novelty_bonus": 0.3105429739337412, "total_score": 0.4494475510706708, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, assortativity and triangle counts.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    density    = s['density']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: size scaled inversely by the square root of average degree\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce the estimate for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase the estimate when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, and triangle counts in a compact, interpretable\n    way.  No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    # Basic scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.136807\nbelow_train_threshold: train_signal=0.059880\nbelow_train_threshold: train_signal=0.061321\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    import math\n\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in s['degrees'] if d == 1) / max(n, 1)\n\n    # 1. Log‑based base: larger graphs → longer paths, higher avg degree → shorter paths\n    base = math.log(n + 1) / (math.log(avg_deg + 1) + 0.5 * clustering + 0.5 * trans)\n\n    # 2. Reduce for dense graphs\n    base /= (1.0 + density)\n\n    # 3. Adjust for degree heterogeneity (hubs & uneven distribution)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n    base /= (1.0 + max_deg / (n + 1.0))\n\n    # 4. Assortativity tends to lengthen paths\n    base *= (1.0 + abs(assort))\n\n    # 5. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 1.5 + 1.0)\n\n    # 6. Leaf nodes increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, transitivity, assortativity, triangle counts,\n    and the fraction of leaf nodes.  No graph traversal or external\n    imports are used.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in s['degrees'] if d == 1) / max(n, 1)\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = pow(n, 0.5) / (pow(avg_deg, 0.5) + 1e-9)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (pow(n, 1.5) + 1.0)\n\n    # 7. Leaf nodes increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a weighted combination of size, degree distribution,\n    density, clustering, transitivity, assortativity, triangle counts,\n    and the fraction of leaf nodes.  No graph traversal or external\n    imports are used.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in s['degrees'] if d == 1) / max(n, 1)\n\n    # 1. Base estimate: sqrt(n) / sqrt(avg_deg)\n    base = pow(n, 0.5) / (pow(avg_deg, 0.5) + 1e-9)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (pow(n, 1.5) + 1.0)\n\n    # 7. Leaf nodes increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.6238160954023851, "pearson": 0.6608871985866023, "rmse": 4.883212084704155, "mae": 4.387660904913705}}
{"timestamp": "2026-02-16T15:49:49.758549+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 9, "island_id": 0, "population_idx": 4, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:50:45.124143+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i1_p0_400727803", "generation": 9, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.12835565138861033, "novelty_bonus": 0.17722193054826363, "total_score": 0.5131300667511338, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust) * (n ** 0.5) / denom_density  # size, clustering, density\n    part3 = 1 + avg_clust                         # clustering\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = avg_deg / (max_deg + 1)               # degree spread\n    part8 = deg_ratio                             # degree ratio\n    part9 = 1 / (1 + deg_variance)                # degree variance\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\nRecent failures:\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.141658\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_max_deg = max(max_deg, 1)\n    denom_min_deg = max(min_deg, 0)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg * std_deg\n    deg_ratio = (denom_max_deg + 1) / (denom_min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clust)         # size & clustering\n    part3 = avg_deg / (denom_max_deg + 1)          # degree spread\n    part4 = 1 + abs(assort)                        # assortativity\n    part5 = 1 + trans                              # transitivity\n    part6 = 1 + tri_per_edge                       # triangles per edge\n    part7 = deg_ratio                              # degree ratio\n    part8 = 1 / (1 + deg_variance)                 # degree variance\n    part9 = 1 / denom_density                      # density\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_max_deg = max(max_deg, 1)\n    denom_min_deg = max(min_deg, 0)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg * std_deg\n    deg_ratio = (denom_max_deg + 1) / (denom_min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clust)         # size & clustering\n    part3 = avg_deg / (denom_max_deg + 1)          # degree spread\n    part4 = 1 + abs(assort)                        # assortativity\n    part5 = 1 + trans                              # transitivity\n    part6 = 1 + tri_per_edge                       # triangles per edge\n    part7 = deg_ratio                              # degree ratio\n    part8 = 1 / (1 + deg_variance)                 # degree variance\n    part9 = 1 / denom_density                      # density\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )", "spearman": 0.8685847146178655, "pearson": 0.8329734689997879, "rmse": 21.81863326064427, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T15:51:25.432736+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i1_p1_539261745", "generation": 9, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8726530612244897, "fitness_mode": "correlation", "simplicity_score": 0.12893321839433186, "novelty_bonus": 0.17722193054826363, "total_score": 0.5132455801522782, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust) * (n ** 0.5) / denom_density  # size, clustering, density\n    part3 = 1 + avg_clust                         # clustering\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = avg_deg / (max_deg + 1)               # degree spread\n    part8 = deg_ratio                             # degree ratio\n    part9 = 1 / (1 + deg_variance)                # degree variance\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\nRecent failures:\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.141658\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust)          # size & clustering\n    part3 = 1 + abs(assort)                       # assortativity\n    part4 = 1 + trans                             # transitivity\n    part5 = 1 + tri_per_edge                      # triangles per edge\n    part6 = avg_deg / (max_deg + 1)               # degree spread\n    part7 = deg_ratio                             # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / denom_density                     # density factor\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust)          # size & clustering\n    part3 = 1 + abs(assort)                       # assortativity\n    part4 = 1 + trans                             # transitivity\n    part5 = 1 + tri_per_edge                      # triangles per edge\n    part6 = avg_deg / (max_deg + 1)               # degree spread\n    part7 = deg_ratio                             # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 / denom_density                     # density factor\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )", "spearman": 0.8685847146178655, "pearson": 0.8329734689997877, "rmse": 21.818633260644265, "mae": 13.365633457095319}}
{"timestamp": "2026-02-16T15:52:22.214901+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i1_p2_852183611", "generation": 9, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8926290516206482, "fitness_mode": "correlation", "simplicity_score": 0.12634761186027726, "novelty_bonus": 0.1557698942473561, "total_score": 0.5164481018365421, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust) * (n ** 0.5) / denom_density  # size, clustering, density\n    part3 = 1 + avg_clust                         # clustering\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = avg_deg / (max_deg + 1)               # degree spread\n    part8 = deg_ratio                             # degree ratio\n    part9 = 1 / (1 + deg_variance)                # degree variance\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\nRecent failures:\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.141658\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_max_deg = max(max_degree, 1)\n    denom_min_deg = min_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = (max_degree + 1) / denom_min_deg\n\n    # Composite invariant components\n    part1 = n / denom_m                     # sparsity\n    part2 = n**0.5 / (1 + avg_clustering)   # size & clustering\n    part3 = 1 + avg_clustering              # clustering boost\n    part4 = 1 + abs(degree_assortativity)   # assortativity\n    part5 = 1 + transitivity                # transitivity\n    part6 = 1 + tri_per_edge                # triangles per edge\n    part7 = avg_degree / denom_max_deg      # degree spread\n    part8 = deg_ratio                       # degree ratio\n    part9 = 1 / (1 + deg_variance)          # degree variance\n    part10 = 1 / denom_density              # density penalty\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 *\n        part9 * part10\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0)\n    std_degree = s.get('std_degree', 0.0)\n    max_degree = s.get('max_degree', 0)\n    min_degree = s.get('min_degree', 0)\n    avg_degree = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_max_deg = max(max_degree, 1)\n    denom_min_deg = min_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = (max_degree + 1) / denom_min_deg\n\n    # Composite invariant components\n    part1 = n / denom_m                     # sparsity\n    part2 = n**0.5 / (1 + avg_clustering)   # size & clustering\n    part3 = 1 + avg_clustering              # clustering boost\n    part4 = 1 + abs(degree_assortativity)   # assortativity\n    part5 = 1 + transitivity                # transitivity\n    part6 = 1 + tri_per_edge                # triangles per edge\n    part7 = avg_degree / denom_max_deg      # degree spread\n    part8 = deg_ratio                       # degree ratio\n    part9 = 1 / (1 + deg_variance)          # degree variance\n    part10 = 1 / denom_density              # density penalty\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 *\n        part9 * part10\n    )", "spearman": 0.8888952223805596, "pearson": 0.8583871003256869, "rmse": 30.134910284849997, "mae": 18.768335259996626}}
{"timestamp": "2026-02-16T15:53:56.345818+00:00", "event_type": "candidate_rejected", "payload": {"generation": 9, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.141043", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:53:56.346550+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 9, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.141043", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:56:50.003097+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i1_p3_920650453", "generation": 9, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.6094117647058823, "fitness_mode": "correlation", "simplicity_score": 0.14047487764814723, "novelty_bonus": 0.33258481741010926, "total_score": 0.44100324907337024, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust) * (n ** 0.5) / denom_density  # size, clustering, density\n    part3 = 1 + avg_clust                         # clustering\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = avg_deg / (max_deg + 1)               # degree spread\n    part8 = deg_ratio                             # degree ratio\n    part9 = 1 / (1 + deg_variance)                # degree variance\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\nRecent failures:\nbelow_train_threshold: train_signal=0.223679\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.141658\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.141043\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n    degrees = s['degrees']          # sorted degree list\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n    denom_min_deg = min_deg + 1\n    denom_max_deg = max_deg + 1\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = denom_max_deg / denom_min_deg\n\n    # Median degree (degrees is sorted)\n    l = len(degrees)\n    if l % 2 == 1:\n        median_deg = degrees[l // 2]\n    else:\n        median_deg = (degrees[l // 2 - 1] + degrees[l // 2]) / 2.0\n\n    mean_deg = avg_deg\n    mean_deg_safe = mean_deg if mean_deg != 0 else 1e-6\n    median_mean_ratio = median_deg / mean_deg_safe\n\n    # Degree skewness\n    deg_skew = (mean_deg - median_deg) / (std_deg + 1e-6)\n\n    # Composite parts\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clust)         # size & clustering\n    part3 = 1 + abs(assort)                       # assortativity\n    part4 = 1 + trans                             # transitivity\n    part5 = 1 + tri_per_edge                      # triangles per edge\n    part6 = avg_deg / denom_max_deg               # degree spread\n    part7 = deg_ratio                             # degree ratio\n    part8 = 1 / (1 + deg_variance)                # degree variance\n    part9 = 1 + median_mean_ratio                 # median/mean ratio\n    part10 = 1 + abs(deg_skew)                    # degree skewness\n    part11 = 1 / (1 + denom_density)              # density effect\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 * part5 *\n        part6 * part7 * part8 * part9 * part10 *\n        part11\n    )\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n    degrees = s['degrees']          # sorted degree list\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = density + 1e-6\n    denom_max = max_deg + 1\n    denom_min = min_deg + 1\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = denom_max / denom_min\n\n    # Median degree (degrees is sorted)\n    l = len(degrees)\n    if l % 2 == 1:\n        median_deg = degrees[l // 2]\n    else:\n        median_deg = (degrees[l // 2 - 1] + degrees[l // 2]) / 2.0\n\n    median_mean_ratio = median_deg / (avg_deg + 1e-6)\n    skew = (avg_deg - median_deg) / (std_deg + 1e-6)\n\n    # Individual components\n    part1 = n / denom_m                           # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust)          # size & clustering\n    part3 = 1 + abs(assort)                        # assortativity\n    part4 = 1 + trans                              # transitivity\n    part5 = 1 + tri_per_edge                       # triangles per edge\n    part6 = avg_deg / denom_max                    # degree spread\n    part7 = deg_ratio                              # degree ratio\n    part8 = 1 / (1 + deg_variance)                 # degree variance\n    part9 = 1 + median_mean_ratio                  # median/mean ratio\n    part10 = 1 + abs(skew)                         # degree skewness\n    part11 = 1 / (1 + denom_density)               # density effect\n\n    # Combine multiplicatively and additively for stability\n    prod = (part1 * part2 * part3 * part4 * part5 *\n            part6 * part7 * part8 * part9 * part10 * part11)\n    sum_parts = (part1 + part2 + part3 + part4 + part5 +\n                 part6 + part7 + part8 + part9 + part10 + part11)\n\n    # Final invariant: weighted average of product and sum\n    return (prod + sum_parts) / 2.0\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n    degrees = s['degrees']          # sorted degree list\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = density + 1e-6\n    denom_max = max_deg + 1\n    denom_min = min_deg + 1\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = denom_max / denom_min\n\n    # Median degree (degrees is sorted)\n    l = len(degrees)\n    if l % 2 == 1:\n        median_deg = degrees[l // 2]\n    else:\n        median_deg = (degrees[l // 2 - 1] + degrees[l // 2]) / 2.0\n\n    median_mean_ratio = median_deg / (avg_deg + 1e-6)\n    skew = (avg_deg - median_deg) / (std_deg + 1e-6)\n\n    # Individual components\n    part1 = n / denom_m                           # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust)          # size & clustering\n    part3 = 1 + abs(assort)                        # assortativity\n    part4 = 1 + trans                              # transitivity\n    part5 = 1 + tri_per_edge                       # triangles per edge\n    part6 = avg_deg / denom_max                    # degree spread\n    part7 = deg_ratio                              # degree ratio\n    part8 = 1 / (1 + deg_variance)                 # degree variance\n    part9 = 1 + median_mean_ratio                  # median/mean ratio\n    part10 = 1 + abs(skew)                         # degree skewness\n    part11 = 1 / (1 + denom_density)               # density effect\n\n    # Combine multiplicatively and additively for stability\n    prod = (part1 * part2 * part3 * part4 * part5 *\n            part6 * part7 * part8 * part9 * part10 * part11)\n    sum_parts = (part1 + part2 + part3 + part4 + part5 +\n                 part6 + part7 + part8 + part9 + part10 + part11)\n\n    # Final invariant: weighted average of product and sum\n    return (prod + sum_parts) / 2.0", "spearman": 0.6262656566414161, "pearson": 0.6743362450210701, "rmse": 8.819747771681442, "mae": 8.751451783961954}}
{"timestamp": "2026-02-16T15:56:50.003760+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 9, "island_id": 1, "population_idx": 3, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T15:57:25.327863+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i1_p4_709698421", "generation": 9, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.9020408163265305, "fitness_mode": "correlation", "simplicity_score": 0.1289938977267644, "novelty_bonus": 0.15637140928523197, "total_score": 0.5205831491545931, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust) * (n ** 0.5) / denom_density  # size, clustering, density\n    part3 = 1 + avg_clust                         # clustering\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = avg_deg / (max_deg + 1)               # degree spread\n    part8 = deg_ratio                             # degree ratio\n    part9 = 1 / (1 + deg_variance)                # degree variance\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    avg_deg = s['avg_degree']\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant combining multiple aspects\n    part1 = n / (denom_m + 1)          # sparsity\n    part2 = n ** 0.5 / denom_density   # size & density\n    part3 = 1 + avg_clust              # clustering\n    part4 = 1 + abs(assort)            # assortativity\n    part5 = 1 + trans                  # transitivity\n    part6 = 1 + tri_per_edge           # triangles per edge\n    part7 = avg_deg / (max_deg + 1)    # degree spread\n    part8 = deg_ratio                  # degree ratio\n    part9 = 1 / (1 + deg_variance)     # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.141658\nbelow_novelty_threshold: novelty_bonus=0.141043\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / denom_density           # size & density\n    part3 = 1 + avg_clust                         # clustering\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = avg_deg / (max_deg + 1)               # degree spread\n    part8 = deg_ratio                             # degree ratio\n    part9 = 1 / (1 + deg_variance)                # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_m\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = pow(n, 0.5) / denom_density           # size & density\n    part3 = 1 + avg_clust                         # clustering\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = avg_deg / (max_deg + 1)               # degree spread\n    part8 = deg_ratio                             # degree ratio\n    part9 = 1 / (1 + deg_variance)                # degree variance\n\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )", "spearman": 0.8957458936473414, "pearson": 0.8461321815324823, "rmse": 35.993662628650526, "mae": 21.959389587623395}}
{"timestamp": "2026-02-16T15:58:22.138197+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i2_p0_583783470", "generation": 9, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.9048259303721489, "fitness_mode": "correlation", "simplicity_score": 0.11961841852509178, "novelty_bonus": 0.16040801020025486, "total_score": 0.5343508943852854, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, the presence of low‑degree vertices\n    and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg < 1:\n        avg_deg = 1\n    base = n / (avg_deg + 1)\n\n    # Corrections for various structural properties\n    density = s.get('density', 0.0)\n    density_factor = 1 / (1 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1 / (1 + std_deg)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1 / (1 + min_deg / (avg_deg + 1))\n\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1 + trans\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1 + abs(assort)\n\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1 / (1 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * density_factor\n        * hetero_factor\n        * min_factor\n        * tri_factor\n    )\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features. Expected keys:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 1))\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature extraction with safe defaults\n    clustering = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    density = float(s.get('density', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    min_deg = float(s.get('min_degree', 1.0))\n    num_tri = float(s.get('num_triangles', 0.0))\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))  # very low min degree lengthens paths\n\n    # Triangle density factor: more triangles tend to reduce path length\n    possible_tri = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (base * clustering_factor * trans_factor * assort_factor *\n            density_factor * hetero_factor * min_factor * tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features. Expected keys:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 1))\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature extraction with safe defaults\n    clustering = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    density = float(s.get('density', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    min_deg = float(s.get('min_degree', 1.0))\n    num_tri = float(s.get('num_triangles', 0.0))\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))  # very low min degree lengthens paths\n\n    # Triangle density factor: more triangles tend to reduce path length\n    possible_tri = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (base * clustering_factor * trans_factor * assort_factor *\n            density_factor * hetero_factor * min_factor * tri_factor)", "spearman": 0.9246096152403811, "pearson": 0.8829640320073221, "rmse": 1.4651288816431371, "mae": 0.9579665976774416}}
{"timestamp": "2026-02-16T15:59:11.804547+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i2_p1_464411858", "generation": 9, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7442496998799519, "fitness_mode": "correlation", "simplicity_score": 0.11841185809938046, "novelty_bonus": 0.24973690209750388, "total_score": 0.4575301654172065, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, the presence of low‑degree vertices\n    and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg < 1:\n        avg_deg = 1\n    base = n / (avg_deg + 1)\n\n    # Corrections for various structural properties\n    density = s.get('density', 0.0)\n    density_factor = 1 / (1 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1 / (1 + std_deg)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1 / (1 + min_deg / (avg_deg + 1))\n\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1 + trans\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1 + abs(assort)\n\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1 / (1 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * density_factor\n        * hetero_factor\n        * min_factor\n        * tri_factor\n    )\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic blends a basic random‑graph intuition with multiplicative\n    corrections for clustering, transitivity, density, degree heterogeneity,\n    assortativity, the presence of low‑degree vertices, the maximum degree,\n    and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)            # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    min_deg = s.get('min_degree', 1)\n    max_deg = s.get('max_degree', 1)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering          # higher clustering → longer paths\n    trans_factor       = 1.0 + trans              # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)    # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)    # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)   # very low min degree can lengthen paths\n    max_factor         = 1.0 / (1.0 + max_deg / avg_deg)   # very high max degree can shorten paths\n    assort_factor      = 1.0 + abs(assort)         # more assortative → longer paths\n\n    # Triangle density factor\n    possible_tri = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)          # more triangles → shorter paths\n\n    # Combine all components\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            min_factor *\n            max_factor *\n            assort_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic blends a basic random‑graph intuition with multiplicative\n    corrections for clustering, transitivity, density, degree heterogeneity,\n    assortativity, the presence of low‑degree vertices, the maximum degree,\n    and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)            # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    min_deg = s.get('min_degree', 1)\n    max_deg = s.get('max_degree', 1)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering          # higher clustering → longer paths\n    trans_factor       = 1.0 + trans              # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)    # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)    # more heterogeneous degrees → shorter paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)   # very low min degree can lengthen paths\n    max_factor         = 1.0 / (1.0 + max_deg / avg_deg)   # very high max degree can shorten paths\n    assort_factor      = 1.0 + abs(assort)         # more assortative → longer paths\n\n    # Triangle density factor\n    possible_tri = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)          # more triangles → shorter paths\n\n    # Combine all components\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            min_factor *\n            max_factor *\n            assort_factor *\n            tri_factor)", "spearman": 0.7178534463361584, "pearson": 0.649725887048141, "rmse": 1.8586176792629936, "mae": 1.7359674815833444}}
{"timestamp": "2026-02-16T16:00:09.028514+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i2_p2_516150524", "generation": 9, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8133013205282112, "fitness_mode": "correlation", "simplicity_score": 0.11813195686511052, "novelty_bonus": 0.22074571098426932, "total_score": 0.4911896381566401, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, the presence of low‑degree vertices\n    and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg < 1:\n        avg_deg = 1\n    base = n / (avg_deg + 1)\n\n    # Corrections for various structural properties\n    density = s.get('density', 0.0)\n    density_factor = 1 / (1 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1 / (1 + std_deg)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1 / (1 + min_deg / (avg_deg + 1))\n\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1 + trans\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1 + abs(assort)\n\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1 / (1 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * density_factor\n        * hetero_factor\n        * min_factor\n        * tri_factor\n    )\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, the presence of low‑ and high‑degree\n    vertices, and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + trans\n\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg)\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    max_deg = s.get('max_degree', 1)\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    num_tri = s.get('num_triangles', 0)\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    else:\n        tri_ratio = 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * density_factor\n        * hetero_factor\n        * assort_factor\n        * min_factor\n        * max_factor\n        * tri_factor\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, the presence of low‑ and high‑degree\n    vertices, and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + trans\n\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg)\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    max_deg = s.get('max_degree', 1)\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    num_tri = s.get('num_triangles', 0)\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    else:\n        tri_ratio = 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * density_factor\n        * hetero_factor\n        * assort_factor\n        * min_factor\n        * max_factor\n        * tri_factor\n    )", "spearman": 0.8026790669766745, "pearson": 0.7154801310520771, "rmse": 1.700038889694477, "mae": 1.5846483991062161}}
{"timestamp": "2026-02-16T16:00:45.409854+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i2_p3_574292945", "generation": 9, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7062184873949579, "fitness_mode": "correlation", "simplicity_score": 0.11778546134688085, "novelty_bonus": 0.39973454091066096, "total_score": 0.48586176415031473, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, the presence of low‑degree vertices\n    and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg < 1:\n        avg_deg = 1\n    base = n / (avg_deg + 1)\n\n    # Corrections for various structural properties\n    density = s.get('density', 0.0)\n    density_factor = 1 / (1 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1 / (1 + std_deg)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1 / (1 + min_deg / (avg_deg + 1))\n\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1 + trans\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1 + abs(assort)\n\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1 / (1 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * density_factor\n        * hetero_factor\n        * min_factor\n        * tri_factor\n    )\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using a weighted product of\n    simple structural descriptors.  The expression is deliberately kept\n    lightweight: it uses only arithmetic operations and a handful of\n    multiplicative corrections that capture common graph properties such\n    as density, clustering, degree heterogeneity and the presence of\n    extreme degrees or triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Density correction – denser graphs tend to have shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Degree heterogeneity – more variation in degrees often shortens paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Extreme degrees – very large or very small degrees reduce path length\n    max_deg = s.get('max_degree', avg_deg)\n    min_deg = s.get('min_degree', 1)\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Clustering and transitivity – higher values generally increase path length\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    clustering_factor = 1.0 + 0.5 * clustering\n    trans_factor = 1.0 + 0.5 * trans\n\n    # Assortativity – assortative mixing tends to lengthen paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + 0.5 * abs(assort)\n\n    # Triangle density – many triangles usually reduce distances\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all multiplicative corrections\n    return (\n        base\n        * density_factor\n        * hetero_factor\n        * max_factor\n        * min_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using a weighted product of\n    simple structural descriptors.  The expression is deliberately kept\n    lightweight: it uses only arithmetic operations and a handful of\n    multiplicative corrections that capture common graph properties such\n    as density, clustering, degree heterogeneity and the presence of\n    extreme degrees or triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Density correction – denser graphs tend to have shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Degree heterogeneity – more variation in degrees often shortens paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Extreme degrees – very large or very small degrees reduce path length\n    max_deg = s.get('max_degree', avg_deg)\n    min_deg = s.get('min_degree', 1)\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Clustering and transitivity – higher values generally increase path length\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    clustering_factor = 1.0 + 0.5 * clustering\n    trans_factor = 1.0 + 0.5 * trans\n\n    # Assortativity – assortative mixing tends to lengthen paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + 0.5 * abs(assort)\n\n    # Triangle density – many triangles usually reduce distances\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all multiplicative corrections\n    return (\n        base\n        * density_factor\n        * hetero_factor\n        * max_factor\n        * min_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )", "spearman": 0.6847686192154805, "pearson": 0.655959051727766, "rmse": 1.0270594189939568, "mae": 0.8150645920993069}}
{"timestamp": "2026-02-16T16:01:24.363488+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i2_p4_924351527", "generation": 9, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8130132052821128, "fitness_mode": "correlation", "simplicity_score": 0.12104621254417641, "novelty_bonus": 0.19141957864120118, "total_score": 0.4842136805653072, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, the presence of low‑degree vertices\n    and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg < 1:\n        avg_deg = 1\n    base = n / (avg_deg + 1)\n\n    # Corrections for various structural properties\n    density = s.get('density', 0.0)\n    density_factor = 1 / (1 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1 / (1 + std_deg)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1 / (1 + min_deg / (avg_deg + 1))\n\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1 + trans\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1 + abs(assort)\n\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1 / (1 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * density_factor\n        * hetero_factor\n        * min_factor\n        * tri_factor\n    )\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity,\n    density, degree heterogeneity, assortativity, the presence of low‑\n    degree vertices, the maximum degree and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1)\n\n    # Correction factors\n    clustering_factor = 1.0 + s.get('avg_clustering', 0.0)\n    density_factor     = 1.0 / (1.0 + s.get('density', 0.0))\n    hetero_factor      = 1.0 / (1.0 + s.get('std_degree', 0.0))\n    assort_factor      = 1.0 + abs(s.get('degree_assortativity', 0.0))\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1))\n\n    max_deg = s.get('max_degree', 1)\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1))\n\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * density_factor\n        * hetero_factor\n        * assort_factor\n        * min_factor\n        * max_factor\n        * tri_factor\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity,\n    density, degree heterogeneity, assortativity, the presence of low‑\n    degree vertices, the maximum degree and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1)\n\n    # Correction factors\n    clustering_factor = 1.0 + s.get('avg_clustering', 0.0)\n    density_factor     = 1.0 / (1.0 + s.get('density', 0.0))\n    hetero_factor      = 1.0 / (1.0 + s.get('std_degree', 0.0))\n    assort_factor      = 1.0 + abs(s.get('degree_assortativity', 0.0))\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1))\n\n    max_deg = s.get('max_degree', 1)\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1))\n\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * density_factor\n        * hetero_factor\n        * assort_factor\n        * min_factor\n        * max_factor\n        * tri_factor\n    )", "spearman": 0.8051571289282232, "pearson": 0.7217874147189891, "rmse": 1.897243318596603, "mae": 1.8014015504643197}}
{"timestamp": "2026-02-16T16:02:04.713978+00:00", "event_type": "candidate_rejected", "payload": {"generation": 9, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.110213", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:02:04.714747+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 9, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.110213", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:02:32.303352+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i3_p0_998793730", "generation": 9, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.4693877551020407, "fitness_mode": "correlation", "simplicity_score": 0.15932021536438679, "novelty_bonus": 0.4839540988524712, "total_score": 0.379721089499038, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from pre‑computed graph\n    statistics.  The formula blends a baseline node/edge ratio with\n    multiplicative adjustments that capture sparsity, degree heterogeneity,\n    clustering, assortativity, triangle abundance, degree range and the\n    concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Keys that are expected:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # ----- Basic quantities --------------------------------------------\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # 1. Baseline: ratio of nodes to edges (regularised by +1)\n    base = n / (m + 1.0)\n\n    # 2. Sparsity adjustment: sparse graphs tend to have longer paths\n    density = s.get('density', 0.0)\n    sparsity_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity: high variance relative to mean shortens paths\n    avg_degree = s.get('avg_degree', 0.0)\n    std_degree = s.get('std_degree', 0.0)\n    het_factor = (std_degree + 1.0) / (avg_degree + 1.0)\n\n    # 4. Clustering effect: larger average clustering typically reduces distance\n    avg_clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 / (1.0 + avg_clustering)\n\n    # 5. Transitivity influence: more global connections lower distance\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # 6. Assortativity contribution: mixing of high/low degree nodes modifies distance\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # 7. Triangle abundance: many triangles usually shorten paths\n    num_triangles = s.get('num_triangles', 0)\n    tri_factor = 1.0 + (num_triangles ** 0.5) / ((n ** 0.5) + 1e-6)\n\n    # 8. Degree range emphasis: presence of hubs vs leaves\n    max_degree = s.get('max_degree', 0.0)\n    min_degree = s.get('min_degree', 1.0)\n    deg_range_factor = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # 9. High‑degree concentration: how clustered the hubs are\n    degrees = s.get('degrees', [])\n    top_k = max(1, int(n * 0.1))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_deg_sum / total_deg\n    high_conc_factor = 1.0 + (1.0 - top_ratio) * 0.5\n\n    # ----- Final composite estimate -----------------------------------\n    estimate = (\n        base\n        * sparsity_factor\n        * het_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range_factor\n        * high_conc_factor\n    )\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_train_threshold: train_signal=0.161681\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.110213\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines a node/edge ratio baseline with multiplicative terms\n    that capture degree heterogeneity, triangle abundance, assortativity,\n    and the presence of low‑degree vertices.  No graph traversal or external\n    libraries are required.\n    \"\"\"\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    avg_degree = s.get('avg_degree', 0.0)\n    std_degree = s.get('std_degree', 0.0)\n    min_degree = s.get('min_degree', 0.0)\n\n    num_triangles = s.get('num_triangles', 0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n\n    # Baseline node‑to‑edge ratio\n    base = n / (m + 1.0)\n\n    # Degree heterogeneity factor (higher variance → shorter paths)\n    het_factor = (std_degree + 1.0) / (avg_degree + 1.0)\n\n    # Triangle abundance factor\n    tri_factor = 1.0 + pow(num_triangles, 0.5) / (n + 1.0)\n\n    # Assortativity factor (mixing of high/low degrees alters distances)\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # Influence of low‑degree vertices\n    min_factor = 1.0 + 1.0 / (min_degree + 1.0)\n\n    estimate = base * het_factor * tri_factor * assort_factor * min_factor\n    return float(estimate)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from pre‑computed graph\n    statistics.  The expression is a multiplicative blend of simple\n    structural ratios and small nonlinear adjustments that avoid\n    any explicit graph traversal or external libraries.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all values are numbers):\n        - n                 : number of nodes\n        - m                 : number of edges\n        - density           : density of the graph\n        - avg_degree        : average degree\n        - max_degree        : maximum degree\n        - min_degree        : minimum degree\n        - std_degree        : standard deviation of the degree sequence\n        - avg_clustering    : average local clustering coefficient\n        - transitivity      : global transitivity (triangle ratio)\n        - degree_assortativity : assortativity coefficient\n        - num_triangles     : total number of triangles\n        - degrees           : sorted list of node degrees (ascending)\n\n    Returns\n    -------\n    float\n        A scalar intended to correlate with the average shortest‑path\n        length.  No traversal, BFS, or DFS is performed.\n    \"\"\"\n    # Basic node‑to‑edge ratio\n    base = s.get('n', 1) / (s.get('m', 0) + 1.0)\n\n    # Density versus clustering adjustment\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    density_factor = (1.0 + density) / (1.0 + clustering)\n\n    # Triangle abundance (sqrt for diminishing returns)\n    num_triangles = s.get('num_triangles', 0)\n    triangle_factor = 1.0 + (num_triangles + 1) ** 0.5\n\n    # Degree range emphasis (hub effect)\n    max_degree = s.get('max_degree', 0.0)\n    min_degree = s.get('min_degree', 1.0)  # avoid division by zero\n    range_factor = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # Assortativity contribution (absolute to keep sign‑independent)\n    assortativity = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assortativity)\n\n    # Degree heterogeneity adjustment (high std → shorter paths)\n    std_degree = s.get('std_degree', 0.0)\n    avg_degree = s.get('avg_degree', 0.0)\n    variance_factor = (1.0 + std_degree) / (1.0 + avg_degree)\n\n    # Composite estimate\n    estimate = (base *\n                density_factor *\n                triangle_factor *\n                range_factor *\n                assort_factor *\n                variance_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from pre‑computed graph\n    statistics.  The expression is a multiplicative blend of simple\n    structural ratios and small nonlinear adjustments that avoid\n    any explicit graph traversal or external libraries.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all values are numbers):\n        - n                 : number of nodes\n        - m                 : number of edges\n        - density           : density of the graph\n        - avg_degree        : average degree\n        - max_degree        : maximum degree\n        - min_degree        : minimum degree\n        - std_degree        : standard deviation of the degree sequence\n        - avg_clustering    : average local clustering coefficient\n        - transitivity      : global transitivity (triangle ratio)\n        - degree_assortativity : assortativity coefficient\n        - num_triangles     : total number of triangles\n        - degrees           : sorted list of node degrees (ascending)\n\n    Returns\n    -------\n    float\n        A scalar intended to correlate with the average shortest‑path\n        length.  No traversal, BFS, or DFS is performed.\n    \"\"\"\n    # Basic node‑to‑edge ratio\n    base = s.get('n', 1) / (s.get('m', 0) + 1.0)\n\n    # Density versus clustering adjustment\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    density_factor = (1.0 + density) / (1.0 + clustering)\n\n    # Triangle abundance (sqrt for diminishing returns)\n    num_triangles = s.get('num_triangles', 0)\n    triangle_factor = 1.0 + (num_triangles + 1) ** 0.5\n\n    # Degree range emphasis (hub effect)\n    max_degree = s.get('max_degree', 0.0)\n    min_degree = s.get('min_degree', 1.0)  # avoid division by zero\n    range_factor = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # Assortativity contribution (absolute to keep sign‑independent)\n    assortativity = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assortativity)\n\n    # Degree heterogeneity adjustment (high std → shorter paths)\n    std_degree = s.get('std_degree', 0.0)\n    avg_degree = s.get('avg_degree', 0.0)\n    variance_factor = (1.0 + std_degree) / (1.0 + avg_degree)\n\n    # Composite estimate\n    estimate = (base *\n                density_factor *\n                triangle_factor *\n                range_factor *\n                assort_factor *\n                variance_factor)\n\n    return float(estimate)", "spearman": 0.4053416335408386, "pearson": 0.44629615749784046, "rmse": 17.478642799971908, "mae": 11.079486083651837}}
{"timestamp": "2026-02-16T16:02:32.304026+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 9, "island_id": 3, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:03:06.695713+00:00", "event_type": "candidate_rejected", "payload": {"generation": 9, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:03:06.696997+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 9, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:03:36.736609+00:00", "event_type": "candidate_rejected", "payload": {"generation": 9, "island_id": 3, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: non-whitelisted call detected: isinstance", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:03:36.737334+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 9, "island_id": 3, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:04:14.205023+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i3_p2_886146451", "generation": 9, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5813685474189676, "fitness_mode": "correlation", "simplicity_score": 0.15482391236046092, "novelty_bonus": 0.3162634065851646, "total_score": 0.40675282717320976, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from pre‑computed graph\n    statistics.  The formula blends a baseline node/edge ratio with\n    multiplicative adjustments that capture sparsity, degree heterogeneity,\n    clustering, assortativity, triangle abundance, degree range and the\n    concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Keys that are expected:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # ----- Basic quantities --------------------------------------------\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # 1. Baseline: ratio of nodes to edges (regularised by +1)\n    base = n / (m + 1.0)\n\n    # 2. Sparsity adjustment: sparse graphs tend to have longer paths\n    density = s.get('density', 0.0)\n    sparsity_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity: high variance relative to mean shortens paths\n    avg_degree = s.get('avg_degree', 0.0)\n    std_degree = s.get('std_degree', 0.0)\n    het_factor = (std_degree + 1.0) / (avg_degree + 1.0)\n\n    # 4. Clustering effect: larger average clustering typically reduces distance\n    avg_clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 / (1.0 + avg_clustering)\n\n    # 5. Transitivity influence: more global connections lower distance\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # 6. Assortativity contribution: mixing of high/low degree nodes modifies distance\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # 7. Triangle abundance: many triangles usually shorten paths\n    num_triangles = s.get('num_triangles', 0)\n    tri_factor = 1.0 + (num_triangles ** 0.5) / ((n ** 0.5) + 1e-6)\n\n    # 8. Degree range emphasis: presence of hubs vs leaves\n    max_degree = s.get('max_degree', 0.0)\n    min_degree = s.get('min_degree', 1.0)\n    deg_range_factor = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # 9. High‑degree concentration: how clustered the hubs are\n    degrees = s.get('degrees', [])\n    top_k = max(1, int(n * 0.1))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_deg_sum / total_deg\n    high_conc_factor = 1.0 + (1.0 - top_ratio) * 0.5\n\n    # ----- Final composite estimate -----------------------------------\n    estimate = (\n        base\n        * sparsity_factor\n        * het_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range_factor\n        * high_conc_factor\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.110213\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based solely on pre‑computed\n    global graph statistics.  The expression mixes multiplicative factors\n    that reflect sparsity, degree heterogeneity, clustering, assortativity,\n    triangle density, degree range, and the concentration of high‑degree\n    nodes.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics of the graph.  Expected keys:\n            - n (int): number of nodes\n            - m (int): number of edges\n            - density (float)\n            - avg_degree (float)\n            - max_degree (int)\n            - min_degree (int)\n            - std_degree (float)\n            - avg_clustering (float)\n            - transitivity (float)\n            - degree_assortativity (float)\n            - num_triangles (int)\n            - degrees (list[int]): sorted degree list (ascending)\n\n    Returns\n    -------\n    float\n        A scalar that correlates with the average shortest‑path length.\n    \"\"\"\n    # Basic quantities\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # 1. Node–edge baseline (regularised by +1)\n    base = n / (m + 1)\n\n    # 2. Sparsity: sparse graphs tend to have larger distances\n    density = s.get('density', 0.0)\n    sparsity = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity: high variance tends to shorten distances\n    avg_deg = s.get('avg_degree', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    hetero = (std_deg + 1.0) / (avg_deg + 1.0)\n\n    # 4. Clustering: higher clustering usually reduces average distance\n    avg_clust = s.get('avg_clustering', 0.0)\n    clust_factor = 1.0 / (1.0 + avg_clust)\n\n    # 5. Transitivity (global clustering)\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + trans\n\n    # 6. Assortativity: mixing of degree classes can stretch paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Triangle abundance: more triangles usually shorten paths\n    num_tri = s.get('num_triangles', 0)\n    tri_factor = 1.0 + (num_tri ** 0.5) / ((n ** 0.5) + 1e-6)\n\n    # 8. Degree range: presence of hubs relative to leaves\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)  # avoid division by zero\n    range_factor = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 9. High‑degree concentration: how clustered the hubs are\n    degrees = s.get('degrees', [])\n    top_k = max(1, int(n * 0.1))\n    if degrees:\n        high_sum = sum(degrees[-top_k:])\n        total_deg = 2.0 * m if m > 0 else 1e-6\n        high_ratio = high_sum / total_deg\n    else:\n        high_ratio = 0.0\n    conc_factor = 1.0 + 0.5 * (1.0 - high_ratio)\n\n    # Composite estimate\n    estimate = (base * sparsity * hetero * clust_factor *\n                trans_factor * assort_factor * tri_factor *\n                range_factor * conc_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based solely on pre‑computed\n    global graph statistics.  The expression mixes multiplicative factors\n    that reflect sparsity, degree heterogeneity, clustering, assortativity,\n    triangle density, degree range, and the concentration of high‑degree\n    nodes.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics of the graph.  Expected keys:\n            - n (int): number of nodes\n            - m (int): number of edges\n            - density (float)\n            - avg_degree (float)\n            - max_degree (int)\n            - min_degree (int)\n            - std_degree (float)\n            - avg_clustering (float)\n            - transitivity (float)\n            - degree_assortativity (float)\n            - num_triangles (int)\n            - degrees (list[int]): sorted degree list (ascending)\n\n    Returns\n    -------\n    float\n        A scalar that correlates with the average shortest‑path length.\n    \"\"\"\n    # Basic quantities\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # 1. Node–edge baseline (regularised by +1)\n    base = n / (m + 1)\n\n    # 2. Sparsity: sparse graphs tend to have larger distances\n    density = s.get('density', 0.0)\n    sparsity = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity: high variance tends to shorten distances\n    avg_deg = s.get('avg_degree', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    hetero = (std_deg + 1.0) / (avg_deg + 1.0)\n\n    # 4. Clustering: higher clustering usually reduces average distance\n    avg_clust = s.get('avg_clustering', 0.0)\n    clust_factor = 1.0 / (1.0 + avg_clust)\n\n    # 5. Transitivity (global clustering)\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + trans\n\n    # 6. Assortativity: mixing of degree classes can stretch paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Triangle abundance: more triangles usually shorten paths\n    num_tri = s.get('num_triangles', 0)\n    tri_factor = 1.0 + (num_tri ** 0.5) / ((n ** 0.5) + 1e-6)\n\n    # 8. Degree range: presence of hubs relative to leaves\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 1)  # avoid division by zero\n    range_factor = (max_deg + 1.0) / (min_deg + 1e-6)\n\n    # 9. High‑degree concentration: how clustered the hubs are\n    degrees = s.get('degrees', [])\n    top_k = max(1, int(n * 0.1))\n    if degrees:\n        high_sum = sum(degrees[-top_k:])\n        total_deg = 2.0 * m if m > 0 else 1e-6\n        high_ratio = high_sum / total_deg\n    else:\n        high_ratio = 0.0\n    conc_factor = 1.0 + 0.5 * (1.0 - high_ratio)\n\n    # Composite estimate\n    estimate = (base * sparsity * hetero * clust_factor *\n                trans_factor * assort_factor * tri_factor *\n                range_factor * conc_factor)\n\n    return float(estimate)", "spearman": 0.5618180454511364, "pearson": 0.5329067744839837, "rmse": 7.2165090042663, "mae": 3.5325415914030573}}
{"timestamp": "2026-02-16T16:04:50.955778+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i3_p3_720055558", "generation": 9, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5947178871548618, "fitness_mode": "correlation", "simplicity_score": 0.1552059604620726, "novelty_bonus": 0.28124203105077616, "total_score": 0.4106879332609437, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from pre‑computed graph\n    statistics.  The formula blends a baseline node/edge ratio with\n    multiplicative adjustments that capture sparsity, degree heterogeneity,\n    clustering, assortativity, triangle abundance, degree range and the\n    concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Keys that are expected:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # ----- Basic quantities --------------------------------------------\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # 1. Baseline: ratio of nodes to edges (regularised by +1)\n    base = n / (m + 1.0)\n\n    # 2. Sparsity adjustment: sparse graphs tend to have longer paths\n    density = s.get('density', 0.0)\n    sparsity_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity: high variance relative to mean shortens paths\n    avg_degree = s.get('avg_degree', 0.0)\n    std_degree = s.get('std_degree', 0.0)\n    het_factor = (std_degree + 1.0) / (avg_degree + 1.0)\n\n    # 4. Clustering effect: larger average clustering typically reduces distance\n    avg_clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 / (1.0 + avg_clustering)\n\n    # 5. Transitivity influence: more global connections lower distance\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # 6. Assortativity contribution: mixing of high/low degree nodes modifies distance\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # 7. Triangle abundance: many triangles usually shorten paths\n    num_triangles = s.get('num_triangles', 0)\n    tri_factor = 1.0 + (num_triangles ** 0.5) / ((n ** 0.5) + 1e-6)\n\n    # 8. Degree range emphasis: presence of hubs vs leaves\n    max_degree = s.get('max_degree', 0.0)\n    min_degree = s.get('min_degree', 1.0)\n    deg_range_factor = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # 9. High‑degree concentration: how clustered the hubs are\n    degrees = s.get('degrees', [])\n    top_k = max(1, int(n * 0.1))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_deg_sum / total_deg\n    high_conc_factor = 1.0 + (1.0 - top_ratio) * 0.5\n\n    # ----- Final composite estimate -----------------------------------\n    estimate = (\n        base\n        * sparsity_factor\n        * het_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range_factor\n        * high_conc_factor\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.110213\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The formula is intentionally a non‑linear combination of\n    multiplicative factors that reflect sparsity, degree heterogeneity,\n    clustering, transitivity, assortativity, triangle density, degree range,\n    and high‑degree concentration.\n\n    Parameters\n    ----------\n    s : dict\n        Graph features with mandatory keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        A scalar proxy for the expected average shortest path length.\n    \"\"\"\n    # Basic graph size terms\n    n = s['n']\n    m = s['m']\n    ratio_nm = n / (m + 1)                      # node‑to‑edge baseline\n\n    # Sparsity adjustment\n    density = s['density']\n    sparsity_factor = 1 / (1 + density)\n\n    # Degree heterogeneity\n    avg_degree = s['avg_degree']\n    std_degree = s['std_degree']\n    heterogeneity_factor = (std_degree + 1) / (avg_degree + 1)\n\n    # Clustering effect\n    avg_clustering = s['avg_clustering']\n    clustering_factor = 1 / (1 + avg_clustering)\n\n    # Global transitivity\n    transitivity = s['transitivity']\n    transitivity_factor = 1 + transitivity\n\n    # Assortativity influence\n    degree_assortativity = s['degree_assortativity']\n    assortativity_factor = 1 + abs(degree_assortativity)\n\n    # Triangle abundance\n    num_triangles = s['num_triangles']\n    triangle_factor = 1 + (num_triangles ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range emphasis\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    degree_range_factor = (max_degree + 1) / (min_degree + 1e-6)\n\n    # High‑degree concentration\n    degrees = s['degrees']          # already sorted ascending\n    top_k = max(1, int(0.1 * n))\n    top_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    top_ratio = top_deg_sum / total_deg\n    high_concentration_factor = 1 + (1 - top_ratio) * 0.5\n\n    # Non‑linear aggregation with tuned exponents\n    estimate = (ratio_nm *\n                sparsity_factor ** 0.8 *\n                heterogeneity_factor ** 0.6 *\n                triangle_factor ** 0.7 *\n                clustering_factor ** 0.9 *\n                transitivity_factor *\n                assortativity_factor *\n                degree_range_factor *\n                high_concentration_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The formula is intentionally a non‑linear combination of\n    multiplicative factors that reflect sparsity, degree heterogeneity,\n    clustering, transitivity, assortativity, triangle density, degree range,\n    and high‑degree concentration.\n\n    Parameters\n    ----------\n    s : dict\n        Graph features with mandatory keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        A scalar proxy for the expected average shortest path length.\n    \"\"\"\n    # Basic graph size terms\n    n = s['n']\n    m = s['m']\n    ratio_nm = n / (m + 1)                      # node‑to‑edge baseline\n\n    # Sparsity adjustment\n    density = s['density']\n    sparsity_factor = 1 / (1 + density)\n\n    # Degree heterogeneity\n    avg_degree = s['avg_degree']\n    std_degree = s['std_degree']\n    heterogeneity_factor = (std_degree + 1) / (avg_degree + 1)\n\n    # Clustering effect\n    avg_clustering = s['avg_clustering']\n    clustering_factor = 1 / (1 + avg_clustering)\n\n    # Global transitivity\n    transitivity = s['transitivity']\n    transitivity_factor = 1 + transitivity\n\n    # Assortativity influence\n    degree_assortativity = s['degree_assortativity']\n    assortativity_factor = 1 + abs(degree_assortativity)\n\n    # Triangle abundance\n    num_triangles = s['num_triangles']\n    triangle_factor = 1 + (num_triangles ** 0.5) / (n ** 0.5 + 1e-6)\n\n    # Degree range emphasis\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    degree_range_factor = (max_degree + 1) / (min_degree + 1e-6)\n\n    # High‑degree concentration\n    degrees = s['degrees']          # already sorted ascending\n    top_k = max(1, int(0.1 * n))\n    top_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    top_ratio = top_deg_sum / total_deg\n    high_concentration_factor = 1 + (1 - top_ratio) * 0.5\n\n    # Non‑linear aggregation with tuned exponents\n    estimate = (ratio_nm *\n                sparsity_factor ** 0.8 *\n                heterogeneity_factor ** 0.6 *\n                triangle_factor ** 0.7 *\n                clustering_factor ** 0.9 *\n                transitivity_factor *\n                assortativity_factor *\n                degree_range_factor *\n                high_concentration_factor)\n\n    return float(estimate)", "spearman": 0.5905482637065927, "pearson": 0.5657668870446936, "rmse": 6.7510607256669175, "mae": 3.4348051657952396}}
{"timestamp": "2026-02-16T16:05:23.421904+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i3_p4_24609312", "generation": 9, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5813685474189676, "fitness_mode": "correlation", "simplicity_score": 0.15663549859390474, "novelty_bonus": 0.31669241731043263, "total_score": 0.4049750409173109, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from pre‑computed graph\n    statistics.  The formula blends a baseline node/edge ratio with\n    multiplicative adjustments that capture sparsity, degree heterogeneity,\n    clustering, assortativity, triangle abundance, degree range and the\n    concentration of high‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Keys that are expected:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # ----- Basic quantities --------------------------------------------\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n\n    # 1. Baseline: ratio of nodes to edges (regularised by +1)\n    base = n / (m + 1.0)\n\n    # 2. Sparsity adjustment: sparse graphs tend to have longer paths\n    density = s.get('density', 0.0)\n    sparsity_factor = 1.0 / (1.0 + density)\n\n    # 3. Degree heterogeneity: high variance relative to mean shortens paths\n    avg_degree = s.get('avg_degree', 0.0)\n    std_degree = s.get('std_degree', 0.0)\n    het_factor = (std_degree + 1.0) / (avg_degree + 1.0)\n\n    # 4. Clustering effect: larger average clustering typically reduces distance\n    avg_clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 / (1.0 + avg_clustering)\n\n    # 5. Transitivity influence: more global connections lower distance\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # 6. Assortativity contribution: mixing of high/low degree nodes modifies distance\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # 7. Triangle abundance: many triangles usually shorten paths\n    num_triangles = s.get('num_triangles', 0)\n    tri_factor = 1.0 + (num_triangles ** 0.5) / ((n ** 0.5) + 1e-6)\n\n    # 8. Degree range emphasis: presence of hubs vs leaves\n    max_degree = s.get('max_degree', 0.0)\n    min_degree = s.get('min_degree', 1.0)\n    deg_range_factor = (max_degree + 1.0) / (min_degree + 1e-6)\n\n    # 9. High‑degree concentration: how clustered the hubs are\n    degrees = s.get('degrees', [])\n    top_k = max(1, int(n * 0.1))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0.0\n    total_deg = 2.0 * m if m > 0 else 1e-6\n    top_ratio = high_deg_sum / total_deg\n    high_conc_factor = 1.0 + (1.0 - top_ratio) * 0.5\n\n    # ----- Final composite estimate -----------------------------------\n    estimate = (\n        base\n        * sparsity_factor\n        * het_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * deg_range_factor\n        * high_conc_factor\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.110213\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest path length from pre‑computed graph\n    statistics.  The expression is intentionally nonlinear and\n    multiplicative, mixing sparsity, heterogeneity, clustering,\n    assortativity, triangles, degree range and hub concentration.\n\n    Parameters\n    ----------\n    s : dict\n        Graph features with mandatory keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic node‑to‑edge ratio\n    base = s['n'] / (s['m'] + 1)\n\n    # Sparsity: sparser graphs tend to have larger distances\n    sparsity = 1.0 / (1.0 + s['density'])\n\n    # Degree heterogeneity: larger variance relative to mean shortens paths\n    het = (s['std_degree'] + 1.0) / (s['avg_degree'] + 1.0)\n\n    # Clustering effect: higher local clustering tends to reduce global distance\n    cluster = 1.0 / (1.0 + s['avg_clustering'])\n\n    # Global transitivity amplifies connectivity\n    trans = 1.0 + s['transitivity']\n\n    # Assortativity factor\n    assort = 1.0 + abs(s['degree_assortativity'])\n\n    # Triangle abundance (sqrt scaling)\n    tri = 1.0 + (pow(s['num_triangles'] if s['num_triangles'] > 0 else 1, 0.5) /\n                 (pow(s['n'], 0.5) + 1e-6))\n\n    # Degree range: presence of hubs relative to leaves\n    deg_range = (s['max_degree'] + 1.0) / (s['min_degree'] + 1e-6)\n\n    # Hub concentration: how much weight the top 10 % of degrees carry\n    top_k = max(1, int(0.1 * s['n']))\n    top_sum = sum(s['degrees'][-top_k:])\n    total_deg = 2 * s['m'] if s['m'] > 0 else 1e-6\n    top_ratio = top_sum / total_deg\n    hub_conc = 1.0 + (1.0 - top_ratio) * 0.5\n\n    # Final composite estimate\n    estimate = (base *\n                sparsity *\n                het *\n                cluster *\n                trans *\n                assort *\n                tri *\n                deg_range *\n                hub_conc)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest path length from pre‑computed graph\n    statistics.  The expression is intentionally nonlinear and\n    multiplicative, mixing sparsity, heterogeneity, clustering,\n    assortativity, triangles, degree range and hub concentration.\n\n    Parameters\n    ----------\n    s : dict\n        Graph features with mandatory keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic node‑to‑edge ratio\n    base = s['n'] / (s['m'] + 1)\n\n    # Sparsity: sparser graphs tend to have larger distances\n    sparsity = 1.0 / (1.0 + s['density'])\n\n    # Degree heterogeneity: larger variance relative to mean shortens paths\n    het = (s['std_degree'] + 1.0) / (s['avg_degree'] + 1.0)\n\n    # Clustering effect: higher local clustering tends to reduce global distance\n    cluster = 1.0 / (1.0 + s['avg_clustering'])\n\n    # Global transitivity amplifies connectivity\n    trans = 1.0 + s['transitivity']\n\n    # Assortativity factor\n    assort = 1.0 + abs(s['degree_assortativity'])\n\n    # Triangle abundance (sqrt scaling)\n    tri = 1.0 + (pow(s['num_triangles'] if s['num_triangles'] > 0 else 1, 0.5) /\n                 (pow(s['n'], 0.5) + 1e-6))\n\n    # Degree range: presence of hubs relative to leaves\n    deg_range = (s['max_degree'] + 1.0) / (s['min_degree'] + 1e-6)\n\n    # Hub concentration: how much weight the top 10 % of degrees carry\n    top_k = max(1, int(0.1 * s['n']))\n    top_sum = sum(s['degrees'][-top_k:])\n    total_deg = 2 * s['m'] if s['m'] > 0 else 1e-6\n    top_ratio = top_sum / total_deg\n    hub_conc = 1.0 + (1.0 - top_ratio) * 0.5\n\n    # Final composite estimate\n    estimate = (base *\n                sparsity *\n                het *\n                cluster *\n                trans *\n                assort *\n                tri *\n                deg_range *\n                hub_conc)\n\n    return float(estimate)", "spearman": 0.5572804320108004, "pearson": 0.5279241999715544, "rmse": 8.005843006117095, "mae": 3.7370376837422508}}
{"timestamp": "2026-02-16T16:05:23.422903+00:00", "event_type": "generation_migration", "payload": {"generation": 9, "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:05:23.424814+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 10, "model_name": "gpt-oss:20b", "best_val_score": 0.5376982263149925, "no_improve_count": 2}}
{"timestamp": "2026-02-16T16:08:40.383787+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i0_p0_425039517", "generation": 10, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.43116446578631445, "fitness_mode": "correlation", "simplicity_score": 0.22007437900550175, "novelty_bonus": 0.5276618676127292, "total_score": 0.41857684267008377, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts and leaf fraction in a\n    compact, interpretable way.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base estimate: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.059880\nbelow_train_threshold: train_signal=0.061321\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and leaf fraction.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering ** 0.5)\n    base *= (1.0 + trans ** 0.5)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contributions from triangles\n    base += triangles / (n ** 2 + 1.0)\n    base += triangles / (n ** 1.5 + 1.0)\n    base += triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac ** 2)\n\n    # 8. Influence of a dominant hub\n    base *= (1.0 + max_deg / (avg_deg + 1.0))\n\n    # 9. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and leaf fraction.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering ** 0.5)\n    base *= (1.0 + trans ** 0.5)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contributions from triangles\n    base += triangles / (n ** 2 + 1.0)\n    base += triangles / (n ** 1.5 + 1.0)\n    base += triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac ** 2)\n\n    # 8. Influence of a dominant hub\n    base *= (1.0 + max_deg / (avg_deg + 1.0))\n\n    # 9. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base", "spearman": 0.4325268131703293, "pearson": 0.4385573237129543, "rmse": 31.183564015791358, "mae": 26.560596425641116}}
{"timestamp": "2026-02-16T16:13:14.231879+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i0_p1_764194403", "generation": 10, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.2217197160851846, "novelty_bonus": 0.25138613993252834, "total_score": 0.5272952235827552, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts and leaf fraction in a\n    compact, interpretable way.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base estimate: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.059880\nbelow_train_threshold: train_signal=0.061321\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T16:14:50.244383+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i0_p2_394961654", "generation": 10, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.4154141656662665, "fitness_mode": "correlation", "simplicity_score": 0.22051463019207068, "novelty_bonus": 0.4871845148281144, "total_score": 0.37077279334967006, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts and leaf fraction in a\n    compact, interpretable way.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base estimate: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.059880\nbelow_train_threshold: train_signal=0.061321\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts and leaf fraction in a\n    compact, interpretable way.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1e-6\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    # Base estimate: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6 + 1e-6)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.8 + max_deg / (n + 1.0))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering ** 0.5)\n    base *= (1.0 + trans ** 0.5)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) ** 0.5)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 1.5 + 1.0)\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac ** 0.5)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    # Slight adjustment based on the total number of edges\n    base *= (1.0 + m / (n ** 1.5 + 1.0))\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts and leaf fraction in a\n    compact, interpretable way.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1e-6\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    # Base estimate: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6 + 1e-6)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.8 + max_deg / (n + 1.0))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering ** 0.5)\n    base *= (1.0 + trans ** 0.5)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) ** 0.5)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 1.5 + 1.0)\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac ** 0.5)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    # Slight adjustment based on the total number of edges\n    base *= (1.0 + m / (n ** 1.5 + 1.0))\n\n    return base", "spearman": 0.3610290257256432, "pearson": 0.18357818135966436, "rmse": 4.982178616365495, "mae": 4.231055825422782}}
{"timestamp": "2026-02-16T16:17:17.186684+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i0_p3_657358911", "generation": 10, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.645234093637455, "fitness_mode": "correlation", "simplicity_score": 0.22178457158834725, "novelty_bonus": 0.3105429739337412, "total_score": 0.4494278541989844, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts and leaf fraction in a\n    compact, interpretable way.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base estimate: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.059880\nbelow_train_threshold: train_signal=0.061321\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    if n <= 0:\n        return 0.0\n\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 1.5 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    if n <= 0:\n        return 0.0\n\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 1.5 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.6238160954023851, "pearson": 0.6608871987537004, "rmse": 4.883212087780121, "mae": 4.387660907599431}}
{"timestamp": "2026-02-16T16:17:54.948023+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.052197", "model_name": "gpt-oss:20b", "train_signal": 0.05219687875150059}}
{"timestamp": "2026-02-16T16:18:36.896691+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i1_p0_851579196", "generation": 10, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.6643457382953182, "fitness_mode": "correlation", "simplicity_score": 0.2209014926046282, "novelty_bonus": 0.28740798641515486, "total_score": 0.5144482955855006, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust) * (n ** 0.5) / denom_density  # size, clustering, density\n    part3 = 1 + avg_clust                         # clustering\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = avg_deg / (max_deg + 1)               # degree spread\n    part8 = deg_ratio                             # degree ratio\n    part9 = 1 / (1 + deg_variance)                # degree variance\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.141658\nbelow_novelty_threshold: novelty_bonus=0.141043\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic features with safe defaults\n    n          = s.get('n', 1)\n    m          = s.get('m', 1)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 0)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / ((avg_deg + 1.0) ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + avg_clust)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic features with safe defaults\n    n          = s.get('n', 1)\n    m          = s.get('m', 1)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 0)\n    min_deg    = s.get('min_degree', 0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / ((avg_deg + 1.0) ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + avg_clust)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.768091202280057, "pearson": 0.7573985010571362, "rmse": 3.629397635748916, "mae": 3.278196877994997}}
{"timestamp": "2026-02-16T16:19:32.861534+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.131786", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:19:32.862285+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.131786", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:21:36.289826+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 1, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: os.", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:21:36.290896+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 1, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:22:25.116816+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:22:25.118028+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:23:20.645987+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 1, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.097438", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:23:20.646365+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 1, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:24:09.249033+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i1_p3_477104041", "generation": 10, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22078856477659164, "novelty_bonus": 0.25138613993252834, "total_score": 0.5271089933210366, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust) * (n ** 0.5) / denom_density  # size, clustering, density\n    part3 = 1 + avg_clust                         # clustering\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = avg_deg / (max_deg + 1)               # degree spread\n    part8 = deg_ratio                             # degree ratio\n    part9 = 1 / (1 + deg_variance)                # degree variance\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: os.\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.097438\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic features with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 0.0), 1.0)          # avoid division by zero\n    max_deg    = max(s.get('max_degree', 0), 1)\n    min_deg    = max(s.get('min_degree', 0), 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic features with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 0.0), 1.0)          # avoid division by zero\n    max_deg    = max(s.get('max_degree', 0), 1)\n    min_deg    = max(s.get('min_degree', 0), 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T16:26:52.594442+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i1_p4_613906011", "generation": 10, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.818295318127251, "fitness_mode": "correlation", "simplicity_score": 0.21966292554789707, "novelty_bonus": 0.15567989199729992, "total_score": 0.5102825438585482, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    avg_deg = s.get('avg_degree', 0.0)\n\n    # Avoid division by zero\n    denom_m = max(m, 1)\n    denom_density = max(density, 1e-6)\n    denom_edges = max(m, 1)\n\n    # Derived ratios\n    tri_per_edge = num_tri / denom_edges\n    deg_variance = std_deg ** 2\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n\n    # Composite invariant components\n    part1 = n / (denom_m + 1)                     # sparsity\n    part2 = (n ** 0.5) / (1 + avg_clust) * (n ** 0.5) / denom_density  # size, clustering, density\n    part3 = 1 + avg_clust                         # clustering\n    part4 = 1 + abs(assort)                       # assortativity\n    part5 = 1 + trans                             # transitivity\n    part6 = 1 + tri_per_edge                      # triangles per edge\n    part7 = avg_deg / (max_deg + 1)               # degree spread\n    part8 = deg_ratio                             # degree ratio\n    part9 = 1 / (1 + deg_variance)                # degree variance\n\n    # Final invariant\n    return (\n        part1 * part2 * part3 * part4 *\n        part5 * part6 * part7 * part8 * part9\n    )\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: os.\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.097438\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_deg = max(s.get('avg_degree', 0.0), 1.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    std_deg = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    triangles = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles per edge\n    tri_per_edge = triangles / max(m, 1)\n    base += tri_per_edge / (n + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = 0.0\n    if degrees:\n        leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    # Degree ratio (max/min) amplifies unevenness\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n    base *= deg_ratio\n\n    # Dampening for high degree variance\n    base /= (1.0 + std_deg * std_deg)\n\n    return base", "extracted_code": "def new_invariant(s):\n    # Extract features with safe defaults\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 1e-6)\n    avg_deg = max(s.get('avg_degree', 0.0), 1.0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    std_deg = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    triangles = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles per edge\n    tri_per_edge = triangles / max(m, 1)\n    base += tri_per_edge / (n + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = 0.0\n    if degrees:\n        leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    # Degree ratio (max/min) amplifies unevenness\n    deg_ratio = (max_deg + 1) / (min_deg + 1)\n    base *= deg_ratio\n\n    # Dampening for high degree variance\n    base /= (1.0 + std_deg * std_deg)\n\n    return base", "spearman": 0.8392919822995576, "pearson": 0.7893858640420824, "rmse": 4.185743314113624, "mae": 2.7032527324847773}}
{"timestamp": "2026-02-16T16:27:30.505297+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i2_p0_694451698", "generation": 10, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.744345738295318, "fitness_mode": "correlation", "simplicity_score": 0.12021180779610383, "novelty_bonus": 0.2368320884505869, "total_score": 0.48742229635210327, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, the presence of low‑degree vertices\n    and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg < 1:\n        avg_deg = 1\n    base = n / (avg_deg + 1)\n\n    # Corrections for various structural properties\n    density = s.get('density', 0.0)\n    density_factor = 1 / (1 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1 / (1 + std_deg)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1 / (1 + min_deg / (avg_deg + 1))\n\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1 + trans\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1 + abs(assort)\n\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1 / (1 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * density_factor\n        * hetero_factor\n        * min_factor\n        * tri_factor\n    )\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic blends a basic random‑graph intuition with multiplicative\n    corrections for clustering, transitivity, density, degree heterogeneity,\n    assortativity, the presence of low‑degree vertices, and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Correction factors\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + 0.5 * clustering          # moderate effect of clustering\n    trans_factor       = 1.0 + 0.5 * trans                # moderate effect of transitivity\n    density_factor     = 1.0 / (1.0 + density)            # denser → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / avg_deg)  # heterogeneous → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)          # assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree → longer paths\n\n    # Triangle density factor (higher triangle ratio → longer paths)\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    tri_factor = 1.0 + tri_ratio\n\n    return (base\n            * clustering_factor\n            * trans_factor\n            * density_factor\n            * hetero_factor\n            * assort_factor\n            * min_factor\n            * tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic blends a basic random‑graph intuition with multiplicative\n    corrections for clustering, transitivity, density, degree heterogeneity,\n    assortativity, the presence of low‑degree vertices, and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Correction factors\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + 0.5 * clustering          # moderate effect of clustering\n    trans_factor       = 1.0 + 0.5 * trans                # moderate effect of transitivity\n    density_factor     = 1.0 / (1.0 + density)            # denser → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / avg_deg)  # heterogeneous → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)          # assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree → longer paths\n\n    # Triangle density factor (higher triangle ratio → longer paths)\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    tri_factor = 1.0 + tri_ratio\n\n    return (base\n            * clustering_factor\n            * trans_factor\n            * density_factor\n            * hetero_factor\n            * assort_factor\n            * min_factor\n            * tri_factor)", "spearman": 0.784660616515413, "pearson": 0.7903281561929243, "rmse": 2.8988607786929146, "mae": 2.470659557762903}}
{"timestamp": "2026-02-16T16:28:10.965525+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i2_p1_273390865", "generation": 10, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8991596638655461, "fitness_mode": "correlation", "simplicity_score": 0.12043286804124097, "novelty_bonus": 0.16664366609165226, "total_score": 0.5343766808609295, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, the presence of low‑degree vertices\n    and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg < 1:\n        avg_deg = 1\n    base = n / (avg_deg + 1)\n\n    # Corrections for various structural properties\n    density = s.get('density', 0.0)\n    density_factor = 1 / (1 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1 / (1 + std_deg)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1 / (1 + min_deg / (avg_deg + 1))\n\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1 + trans\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1 + abs(assort)\n\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1 / (1 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * density_factor\n        * hetero_factor\n        * min_factor\n        * tri_factor\n    )\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The formula combines a basic random‑graph baseline with\n    multiplicative corrections that capture clustering, transitivity,\n    density, degree heterogeneity, assortativity, low‑degree vertices and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float)\n            - 'transitivity' (float)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of ints)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + trans\n\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg)\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1.0 / (1.0 + min_deg / avg_deg)\n\n    # Triangle density factor (optional)\n    num_tri = s.get('num_triangles', 0)\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    else:\n        tri_ratio = 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * density_factor\n        * hetero_factor\n        * min_factor\n        * tri_factor\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The formula combines a basic random‑graph baseline with\n    multiplicative corrections that capture clustering, transitivity,\n    density, degree heterogeneity, assortativity, low‑degree vertices and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float)\n            - 'transitivity' (float)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (sorted list of ints)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + trans\n\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg)\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1.0 / (1.0 + min_deg / avg_deg)\n\n    # Triangle density factor (optional)\n    num_tri = s.get('num_triangles', 0)\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    else:\n        tri_ratio = 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * density_factor\n        * hetero_factor\n        * min_factor\n        * tri_factor\n    )", "spearman": 0.9205940148503713, "pearson": 0.876999103768254, "rmse": 1.3026573020970358, "mae": 0.8749291799255855}}
{"timestamp": "2026-02-16T16:28:57.090805+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i2_p2_160306318", "generation": 10, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.9048259303721489, "fitness_mode": "correlation", "simplicity_score": 0.12180828028045348, "novelty_bonus": 0.16040801020025486, "total_score": 0.5347888667363577, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, the presence of low‑degree vertices\n    and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg < 1:\n        avg_deg = 1\n    base = n / (avg_deg + 1)\n\n    # Corrections for various structural properties\n    density = s.get('density', 0.0)\n    density_factor = 1 / (1 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1 / (1 + std_deg)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1 / (1 + min_deg / (avg_deg + 1))\n\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1 + trans\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1 + abs(assort)\n\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1 / (1 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * density_factor\n        * hetero_factor\n        * min_factor\n        * tri_factor\n    )\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic starts from a random‑graph baseline and applies multiplicative\n    corrections for clustering, transitivity, density, degree heterogeneity,\n    assortativity, the presence of low‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Retrieve features with defaults\n    clustering   = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    density      = s.get('density', 0.0)\n    std_deg      = s.get('std_degree', 0.0)\n    min_deg      = s.get('min_degree', 1)\n    assort       = s.get('degree_assortativity', 0.0)\n    num_tri      = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n\n    # Multiplicative correction factors\n    f_clustering   = 1.0 + clustering                 # more clustering → longer paths\n    f_transitivity = 1.0 + transitivity               # more transitivity → longer paths\n    f_density      = 1.0 / (1.0 + density)             # denser graphs → shorter paths\n    f_std          = 1.0 / (1.0 + std_deg)             # heterogeneous degrees → shorter paths\n    f_min_degree   = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))  # very low min degree → longer paths\n    f_assortativity = 1.0 + abs(assort)                # assortative mixing → longer paths\n    f_triangles    = 1.0 / (1.0 + tri_ratio)           # many triangles → shorter paths\n\n    # Combine all factors\n    return (base * f_clustering * f_transitivity * f_density *\n            f_std * f_min_degree * f_assortativity * f_triangles)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic starts from a random‑graph baseline and applies multiplicative\n    corrections for clustering, transitivity, density, degree heterogeneity,\n    assortativity, the presence of low‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Retrieve features with defaults\n    clustering   = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    density      = s.get('density', 0.0)\n    std_deg      = s.get('std_degree', 0.0)\n    min_deg      = s.get('min_degree', 1)\n    assort       = s.get('degree_assortativity', 0.0)\n    num_tri      = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n\n    # Multiplicative correction factors\n    f_clustering   = 1.0 + clustering                 # more clustering → longer paths\n    f_transitivity = 1.0 + transitivity               # more transitivity → longer paths\n    f_density      = 1.0 / (1.0 + density)             # denser graphs → shorter paths\n    f_std          = 1.0 / (1.0 + std_deg)             # heterogeneous degrees → shorter paths\n    f_min_degree   = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))  # very low min degree → longer paths\n    f_assortativity = 1.0 + abs(assort)                # assortative mixing → longer paths\n    f_triangles    = 1.0 / (1.0 + tri_ratio)           # many triangles → shorter paths\n\n    # Combine all factors\n    return (base * f_clustering * f_transitivity * f_density *\n            f_std * f_min_degree * f_assortativity * f_triangles)", "spearman": 0.9246096152403811, "pearson": 0.8829640320073222, "rmse": 1.4651288816431371, "mae": 0.9579665976774417}}
{"timestamp": "2026-02-16T16:29:45.558014+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.147697", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:29:45.559491+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.147697", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:30:18.480034+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i2_p3_263521955", "generation": 10, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8703481392557022, "fitness_mode": "correlation", "simplicity_score": 0.12059540945458166, "novelty_bonus": 0.22480670279544235, "total_score": 0.5349301769566548, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, the presence of low‑degree vertices\n    and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg < 1:\n        avg_deg = 1\n    base = n / (avg_deg + 1)\n\n    # Corrections for various structural properties\n    density = s.get('density', 0.0)\n    density_factor = 1 / (1 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1 / (1 + std_deg)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1 / (1 + min_deg / (avg_deg + 1))\n\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1 + trans\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1 + abs(assort)\n\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1 / (1 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * density_factor\n        * hetero_factor\n        * min_factor\n        * tri_factor\n    )\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.070685\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.147697\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a simple random‑graph baseline with\n    multiplicative corrections for degree spread, minimum degree, degree\n    heterogeneity, density, clustering, transitivity, assortativity and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'density' (float, 0–1)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n\n    base = n / (avg_deg + 1.0)\n\n    # Degree spread factor: high max relative to avg → longer paths\n    max_deg = s.get('max_degree', avg_deg)\n    spread_factor = 1.0 + (max_deg - avg_deg) / (max_deg + 1.0)\n\n    # Minimum degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg)\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * spread_factor\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the effect of density, clustering, transitivity, degree\n    heterogeneity, assortativity, the presence of very low‑degree vertices\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'density' (float, 0–1)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Minimum‑degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)  # larger when min_deg is small\n\n    # Degree‑heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle‑density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the effect of density, clustering, transitivity, degree\n    heterogeneity, assortativity, the presence of very low‑degree vertices\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'density' (float, 0–1)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Minimum‑degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)  # larger when min_deg is small\n\n    # Degree‑heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle‑density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )", "spearman": 0.8867381684542115, "pearson": 0.8658662523669716, "rmse": 12.25504673775109, "mae": 10.291301689150124}}
{"timestamp": "2026-02-16T16:30:18.480778+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 2, "population_idx": 3, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:31:16.153768+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i2_p4_443633717", "generation": 10, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8133013205282112, "fitness_mode": "correlation", "simplicity_score": 0.11786376492913703, "novelty_bonus": 0.22074571098426932, "total_score": 0.49113599976944544, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic combines a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, the presence of low‑degree vertices\n    and the triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float, 0–1)\n        - 'avg_degree' (float)\n        - 'max_degree' (int)\n        - 'min_degree' (int)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg < 1:\n        avg_deg = 1\n    base = n / (avg_deg + 1)\n\n    # Corrections for various structural properties\n    density = s.get('density', 0.0)\n    density_factor = 1 / (1 + density)\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1 / (1 + std_deg)\n\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1 / (1 + min_deg / (avg_deg + 1))\n\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1 + trans\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1 + abs(assort)\n\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n    tri_factor = 1 / (1 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * density_factor\n        * hetero_factor\n        * min_factor\n        * tri_factor\n    )\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nbelow_novelty_threshold: novelty_bonus=0.147697\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic blends a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, low‑degree vertices, high‑degree\n    hubs, and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float)\n            - 'transitivity' (float)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Extract values with defaults\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    max_deg = s.get('max_degree', 1)\n    min_deg = s.get('min_degree', 1)\n    std_deg = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Basic random‑graph baseline\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering_factor = 1.0 + clustering\n    trans_factor = 1.0 + trans\n    density_factor = 1.0 / (1.0 + density)\n    hetero_factor = 1.0 / (1.0 + std_deg)\n    assort_factor = 1.0 + abs(assort)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # Triangle density factor\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    else:\n        tri_ratio = 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * density_factor\n        * hetero_factor\n        * assort_factor\n        * min_factor\n        * max_factor\n        * tri_factor\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic blends a basic random‑graph intuition\n    with multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, low‑degree vertices, high‑degree\n    hubs, and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float)\n            - 'transitivity' (float)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Extract values with defaults\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    max_deg = s.get('max_degree', 1)\n    min_deg = s.get('min_degree', 1)\n    std_deg = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Basic random‑graph baseline\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering_factor = 1.0 + clustering\n    trans_factor = 1.0 + trans\n    density_factor = 1.0 / (1.0 + density)\n    hetero_factor = 1.0 / (1.0 + std_deg)\n    assort_factor = 1.0 + abs(assort)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # Triangle density factor\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    else:\n        tri_ratio = 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * density_factor\n        * hetero_factor\n        * assort_factor\n        * min_factor\n        * max_factor\n        * tri_factor\n    )", "spearman": 0.8026790669766745, "pearson": 0.7154801310520771, "rmse": 1.700038889694477, "mae": 1.5846483991062161}}
{"timestamp": "2026-02-16T16:32:03.345829+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.016644", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:32:03.346492+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.016644", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:32:30.215333+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 3, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.014314", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:32:30.215887+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 3, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:33:08.554151+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i3_p1_935858752", "generation": 10, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.41262905162064817, "fitness_mode": "correlation", "simplicity_score": 0.126449429145906, "novelty_bonus": 0.4314737868446711, "total_score": 0.37517228288910776, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\nRecent failures:\nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nbelow_novelty_threshold: novelty_bonus=0.016644\nbelow_novelty_threshold: novelty_bonus=0.014314\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate a proxy for the average shortest‑path length using only\n    pre‑computed global graph statistics.  The expression is deliberately\n    nonlinear and mixes multiplicative, divisive and additive terms so that\n    it is sensitive to a wide range of structural properties.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics with keys:\n        n (int)                – number of nodes\n        m (int)                – number of edges\n        density (float)        – edge density (0–1)\n        avg_degree (float)     – average degree\n        max_degree (int)       – maximum degree\n        min_degree (int)       – minimum degree\n        std_degree (float)     – standard deviation of degree\n        avg_clustering (float) – average local clustering (0–1)\n        transitivity (float)   – global transitivity (0–1)\n        degree_assortativity (float) – assortativity coefficient\n        num_triangles (int)    – number of triangles\n        degrees (list[int])    – sorted list of degrees (ascending)\n\n    Returns\n    -------\n    float\n        A scalar value that captures the overall path‑length behaviour\n        of the graph without performing any graph traversal.\n    \"\"\"\n    n = s[\"n\"]\n    m = s[\"m\"]\n    density = s[\"density\"]\n    avg_deg = max(s[\"avg_degree\"], 1e-6)          # avoid division by zero\n    max_deg = s[\"max_degree\"]\n    min_deg = s[\"min_degree\"]\n    std_deg = s[\"std_degree\"]\n    avg_clust = s[\"avg_clustering\"]\n    trans = s[\"transitivity\"]\n    assort = s[\"degree_assortativity\"]\n    triangles = s[\"num_triangles\"]\n    degrees = s[\"degrees\"]\n\n    # Base factor: nodes per edge corrected by density\n    base = (n / (m + 1.0)) * (1.0 + density)\n\n    # Degree heterogeneity multiplier\n    hetero = 1.0 + (std_deg / avg_deg)\n\n    # Clustering penalty (higher clustering → longer paths)\n    cluster_pen = 1.0 / (1.0 + avg_clust)\n\n    # Assortativity effect (absolute value so both signs increase length)\n    assort_mult = 1.0 + abs(assort)\n\n    # Triangle influence (larger triangle counts tend to reduce lengths)\n    tri_mult = (triangles ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Concentration of high degrees in the top 10 %\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m + 1e-6\n    high_ratio = high_sum / total_deg\n    degree_conc = 1.0 + (1.0 - high_ratio)\n\n    # Combine all effects\n    return base * hetero * cluster_pen * assort_mult * (1.0 + tri_mult * degree_conc)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate a proxy for the average shortest‑path length using only\n    pre‑computed global graph statistics.  The expression is deliberately\n    nonlinear and mixes multiplicative, divisive and additive terms so that\n    it is sensitive to a wide range of structural properties.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics with keys:\n        n (int)                – number of nodes\n        m (int)                – number of edges\n        density (float)        – edge density (0–1)\n        avg_degree (float)     – average degree\n        max_degree (int)       – maximum degree\n        min_degree (int)       – minimum degree\n        std_degree (float)     – standard deviation of degree\n        avg_clustering (float) – average local clustering (0–1)\n        transitivity (float)   – global transitivity (0–1)\n        degree_assortativity (float) – assortativity coefficient\n        num_triangles (int)    – number of triangles\n        degrees (list[int])    – sorted list of degrees (ascending)\n\n    Returns\n    -------\n    float\n        A scalar value that captures the overall path‑length behaviour\n        of the graph without performing any graph traversal.\n    \"\"\"\n    n = s[\"n\"]\n    m = s[\"m\"]\n    density = s[\"density\"]\n    avg_deg = max(s[\"avg_degree\"], 1e-6)          # avoid division by zero\n    max_deg = s[\"max_degree\"]\n    min_deg = s[\"min_degree\"]\n    std_deg = s[\"std_degree\"]\n    avg_clust = s[\"avg_clustering\"]\n    trans = s[\"transitivity\"]\n    assort = s[\"degree_assortativity\"]\n    triangles = s[\"num_triangles\"]\n    degrees = s[\"degrees\"]\n\n    # Base factor: nodes per edge corrected by density\n    base = (n / (m + 1.0)) * (1.0 + density)\n\n    # Degree heterogeneity multiplier\n    hetero = 1.0 + (std_deg / avg_deg)\n\n    # Clustering penalty (higher clustering → longer paths)\n    cluster_pen = 1.0 / (1.0 + avg_clust)\n\n    # Assortativity effect (absolute value so both signs increase length)\n    assort_mult = 1.0 + abs(assort)\n\n    # Triangle influence (larger triangle counts tend to reduce lengths)\n    tri_mult = (triangles ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Concentration of high degrees in the top 10 %\n    top_k = max(1, int(0.1 * n))\n    high_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m + 1e-6\n    high_ratio = high_sum / total_deg\n    degree_conc = 1.0 + (1.0 - high_ratio)\n\n    # Combine all effects\n    return base * hetero * cluster_pen * assort_mult * (1.0 + tri_mult * degree_conc)", "spearman": 0.4408805220130504, "pearson": 0.4694499309706207, "rmse": 1.3763081561415755, "mae": 1.176187376107963}}
{"timestamp": "2026-02-16T16:33:45.008343+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:33:45.009359+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:35:00.567465+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i3_p2_16958559", "generation": 10, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6363025210084033, "fitness_mode": "correlation", "simplicity_score": 0.1557993448398995, "novelty_bonus": 0.38835220762343725, "total_score": 0.44037609901920527, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\nRecent failures:\nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nbelow_novelty_threshold: novelty_bonus=0.016644\nbelow_novelty_threshold: novelty_bonus=0.014314\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport math\n\ndef new_invariant(s: dict) -> float:\n    \"\"\"\n    A composite estimator for the average shortest‑path length that blends\n    several global structural indicators without performing any path search.\n\n    The formulation uses:\n\n    * A size‑to‑average‑degree baseline (`base`) inspired by random‑graph theory.\n    * A clustering–transitivity multiplicative boost (`cluster_factor`).\n    * A density normalisation (`density_factor`).\n    * A penalty for extreme degree heterogeneity via the entropy of the\n      degree distribution (`entropy_factor`).\n    * An extra correction that accounts for assortative mixing and degree\n      range (`extra_factor`).\n\n    All ingredients are derived only from the provided feature dictionary.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with at least the following keys:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float, 0–1)\n        - avg_degree (float)\n        - max_degree (int or float)\n        - min_degree (int or float)\n        - std_degree (float)\n        - avg_clustering (float, 0–1)\n        - transitivity (float, 0–1)\n        - degree_assortativity (float, may be negative)\n        - num_triangles (int or float)\n        - degrees (list of int): sorted node degrees (ascending)\n\n    Returns\n    -------\n    float\n        An invariant value that is expected to correlate with the average\n        shortest‑path length of the graph.\n    \"\"\"\n    # ----- 1. Baseline: size vs. connectivity --------------------------------\n    avg_deg = max(s['avg_degree'], 1e-9)          # guard against zero\n    base = math.log(s['n'] + 1.0) / (avg_deg + 1.0)\n\n    # ----- 2. Clustering & transitivity ---------------------------------------\n    cluster_factor = (1.0 + s['avg_clustering']) ** (1.0 + s['transitivity'])\n\n    # ----- 3. Density normalisation ------------------------------------------\n    density_factor = 1.0 / (1.0 + s['density'])\n\n    # ----- 4. Entropy of the degree distribution -----------------------------\n    # Compute normalized degree probabilities\n    sum_deg = 2 * s['m'] if s['m'] > 0 else 1.0\n    entropy = 0.0\n    for deg in s['degrees']:\n        if deg <= 0:\n            continue\n        p = deg / sum_deg\n        entropy -= p * math.log(p)\n    # Use exp(-entropy) to dampen the estimate when degrees are highly\n    # heterogeneous (entropy high) – large entropy → small factor.\n    entropy_factor = math.exp(-entropy)\n\n    # ----- 5. Assortativity & degree range ------------------------------------\n    deg_range = max(s['max_degree'] - s['min_degree'], 1.0)\n    extra_factor = (1.0 + abs(s['degree_assortativity'])) * (1.0 + deg_range / (s['n'] + 1.0))\n\n    # ----- 6. Combine everything ----------------------------------------------\n    estimate = base * cluster_factor * density_factor * entropy_factor * extra_factor\n\n    return float(estimate)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only pre‑computed graph\n    statistics.  The formula is a product of a size–to‑degree baseline and\n    multiplicative factors that capture clustering, density, degree heterogeneity,\n    assortativity, the range of degrees and triangle density.  No graph\n    traversal or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with at least the following keys:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n        - 'degrees' (list of int)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Pull values with defaults for safety\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    density = float(s.get('density', 0.0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    max_deg = float(s.get('max_degree', 0.0))\n    min_deg = float(s.get('min_degree', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    num_tri = float(s.get('num_triangles', 0.0))\n\n    # Avoid division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n\n    # Size‑to‑average‑degree baseline (random‑graph intuition)\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust     = 1.0 + avg_clust\n    f_trans     = 1.0 + trans\n    f_assort    = 1.0 + abs(assort)\n    f_density   = 1.0 / (1.0 + density)\n    f_std       = 1.0 / (1.0 + std_deg)\n    f_min       = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle‑density adjustment (larger triangles → shorter paths)\n    tri_factor  = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri       = 1.0 + tri_factor\n\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_tri\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only pre‑computed graph\n    statistics.  The formula is a product of a size–to‑degree baseline and\n    multiplicative factors that capture clustering, density, degree heterogeneity,\n    assortativity, the range of degrees and triangle density.  No graph\n    traversal or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with at least the following keys:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n        - 'degrees' (list of int)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Pull values with defaults for safety\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    density = float(s.get('density', 0.0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    max_deg = float(s.get('max_degree', 0.0))\n    min_deg = float(s.get('min_degree', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    num_tri = float(s.get('num_triangles', 0.0))\n\n    # Avoid division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n\n    # Size‑to‑average‑degree baseline (random‑graph intuition)\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust     = 1.0 + avg_clust\n    f_trans     = 1.0 + trans\n    f_assort    = 1.0 + abs(assort)\n    f_density   = 1.0 / (1.0 + density)\n    f_std       = 1.0 / (1.0 + std_deg)\n    f_min       = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle‑density adjustment (larger triangles → shorter paths)\n    tri_factor  = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri       = 1.0 + tri_factor\n\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_tri\n    )\n\n    return float(estimate)", "spearman": 0.5854211355283884, "pearson": 0.6113107282748008, "rmse": 6.57342794490395, "mae": 4.672934336818941}}
{"timestamp": "2026-02-16T16:35:00.568063+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 3, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:35:49.736532+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i3_p3_726183109", "generation": 10, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5570708283313325, "fitness_mode": "correlation", "simplicity_score": 0.15545714783547843, "novelty_bonus": 0.45700490734078825, "total_score": 0.4209867216148284, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Combines several pre‑computed graph statistics into a single scalar that\n    is expected to correlate with the average shortest path length.  The\n    expression deliberately mixes multiplicative and divisive terms and\n    uses fractional powers to achieve non‑linearity while remaining\n    independent of any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        - n, m, avg_clustering, degree_assortativity,\n          std_degree, min_degree, transitivity, num_triangles\n\n    Returns\n    -------\n    float\n        An invariant value intended to reflect path length characteristics.\n    \"\"\"\n    # Ratio of nodes to edges (regularised by +1 to avoid division by zero)\n    ratio = s['n'] / (s['m'] + 1.0)\n\n    # Exponential boost controlled by average clustering\n    exponent = 1.0 + s['avg_clustering']\n    base = ratio ** exponent\n\n    # Amplify with the presence of triangles and assortativity\n    triangles_factor = 1.0 + (s['num_triangles'] ** 0.5)\n    assortativity_factor = 1.0 + abs(s['degree_assortativity'])\n    multiplicative = base * triangles_factor * assortativity_factor\n\n    # Normalise by global structural spread (degree variation + transitivity)\n    normaliser = 1.0 + s['std_degree'] + s['min_degree'] + s['transitivity']\n\n    return multiplicative / normaliser\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.016644\nbelow_novelty_threshold: novelty_bonus=0.014314\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest path length from a set of pre‑computed\n    graph statistics.  The expression blends a simple size/degree baseline\n    with multiplicative adjustments that capture clustering, density,\n    degree heterogeneity, assortativity, triangle abundance and the\n    concentration of high‑degree nodes.\n\n    Parameters\n    ----------\n    s : dict\n        Graph features with keys:\n            - n, m, density\n            - avg_degree, max_degree, min_degree, std_degree\n            - avg_clustering, transitivity\n            - degree_assortativity\n            - num_triangles\n            - degrees (sorted list)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n\n    avg_degree   = s['avg_degree']\n    density      = s['density']\n    min_degree   = s['min_degree']\n    std_degree   = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity   = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees       = s['degrees']\n\n    # Base estimate: more nodes and lower average degree → longer paths\n    base = (n + 1) / (avg_degree + 1)\n\n    # Multiplicative corrections\n    cluster_factor   = 1 + avg_clustering\n    trans_factor     = 1 + transitivity\n    assort_factor    = 1 + abs(degree_assortativity)\n    density_factor   = 1 / (1 + density)                # denser → shorter\n    std_factor       = 1 / (1 + std_degree)              # heterogeneous → shorter\n    min_factor       = 1 / (1 + min_degree / (avg_degree if avg_degree > 0 else 1))\n\n    # Triangle influence (square‑root scaling)\n    if n > 0:\n        tri_factor = 1 + (num_triangles ** 0.5) / (n ** 0.5)\n    else:\n        tri_factor = 1\n\n    # High‑degree concentration: if only a few nodes hold most edges,\n    # the graph tends to be “hub‑heavy” and paths can be shorter.\n    if degrees and m > 0:\n        top_k = max(1, int(0.1 * n))          # top 10 % of nodes\n        high_sum = sum(degrees[-top_k:])      # sum of their degrees\n        total_deg = 2 * m                     # twice the edge count\n        high_ratio = high_sum / total_deg\n        high_factor = 1 + (1 - high_ratio)     # low high_ratio → longer\n    else:\n        high_factor = 1\n\n    estimate = (base *\n                cluster_factor *\n                trans_factor *\n                assort_factor *\n                density_factor *\n                std_factor *\n                min_factor *\n                tri_factor *\n                high_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest path length from a set of pre‑computed\n    graph statistics.  The expression blends a simple size/degree baseline\n    with multiplicative adjustments that capture clustering, density,\n    degree heterogeneity, assortativity, triangle abundance and the\n    concentration of high‑degree nodes.\n\n    Parameters\n    ----------\n    s : dict\n        Graph features with keys:\n            - n, m, density\n            - avg_degree, max_degree, min_degree, std_degree\n            - avg_clustering, transitivity\n            - degree_assortativity\n            - num_triangles\n            - degrees (sorted list)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n\n    avg_degree   = s['avg_degree']\n    density      = s['density']\n    min_degree   = s['min_degree']\n    std_degree   = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity   = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees       = s['degrees']\n\n    # Base estimate: more nodes and lower average degree → longer paths\n    base = (n + 1) / (avg_degree + 1)\n\n    # Multiplicative corrections\n    cluster_factor   = 1 + avg_clustering\n    trans_factor     = 1 + transitivity\n    assort_factor    = 1 + abs(degree_assortativity)\n    density_factor   = 1 / (1 + density)                # denser → shorter\n    std_factor       = 1 / (1 + std_degree)              # heterogeneous → shorter\n    min_factor       = 1 / (1 + min_degree / (avg_degree if avg_degree > 0 else 1))\n\n    # Triangle influence (square‑root scaling)\n    if n > 0:\n        tri_factor = 1 + (num_triangles ** 0.5) / (n ** 0.5)\n    else:\n        tri_factor = 1\n\n    # High‑degree concentration: if only a few nodes hold most edges,\n    # the graph tends to be “hub‑heavy” and paths can be shorter.\n    if degrees and m > 0:\n        top_k = max(1, int(0.1 * n))          # top 10 % of nodes\n        high_sum = sum(degrees[-top_k:])      # sum of their degrees\n        total_deg = 2 * m                     # twice the edge count\n        high_ratio = high_sum / total_deg\n        high_factor = 1 + (1 - high_ratio)     # low high_ratio → longer\n    else:\n        high_factor = 1\n\n    estimate = (base *\n                cluster_factor *\n                trans_factor *\n                assort_factor *\n                density_factor *\n                std_factor *\n                min_factor *\n                tri_factor *\n                high_factor)\n\n    return float(estimate)", "spearman": 0.5055876396909924, "pearson": 0.5672430537041692, "rmse": 13.540832195778906, "mae": 10.251003018539496}}
{"timestamp": "2026-02-16T16:36:32.452591+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.110977", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:36:32.454236+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.110977", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:37:07.150727+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 3, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:37:07.152157+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 3, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:37:07.163184+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 11, "model_name": "gpt-oss:20b", "best_val_score": 0.5376982263149925, "no_improve_count": 3}}
{"timestamp": "2026-02-16T16:37:35.006195+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:37:35.007431+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:37:57.851733+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 0, "population_idx": 0, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.052197", "model_name": "gpt-oss:20b", "train_signal": 0.05219687875150059}}
{"timestamp": "2026-02-16T16:37:57.852241+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 0, "population_idx": 0, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:38:30.601928+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.040576", "model_name": "gpt-oss:20b", "train_signal": 0.04057623049219687}}
{"timestamp": "2026-02-16T16:40:03.128969+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i0_p2_536023741", "generation": 11, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.7529891956782714, "fitness_mode": "correlation", "simplicity_score": 0.22146646413886412, "novelty_bonus": 0.22715601309219313, "total_score": 0.5101877904477732, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts and leaf fraction in a\n    compact, interpretable way.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base estimate: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.052197\nbelow_train_threshold: train_signal=0.040576\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and leaf fraction.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.45)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering ** 0.5)\n    base *= (1.0 + trans ** 0.5)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) ** 1.2)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac ** 0.5)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and leaf fraction.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.45)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering ** 0.5)\n    base *= (1.0 + trans ** 0.5)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) ** 1.2)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac ** 0.5)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base", "spearman": 0.7954953873846847, "pearson": 0.7425615514911021, "rmse": 5.806579917366349, "mae": 5.392233163738383}}
{"timestamp": "2026-02-16T16:40:45.778505+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i0_p3_710301044", "generation": 11, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.7138055222088835, "fitness_mode": "correlation", "simplicity_score": 0.2205955879701489, "novelty_bonus": 0.25414417056999206, "total_score": 0.5042684664174688, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts and leaf fraction in a\n    compact, interpretable way.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base estimate: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.052197\nbelow_train_threshold: train_signal=0.040576\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and leaf fraction.  No graph traversal or external\n    libraries are used.\n    \"\"\"\n    # Basic graph statistics\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    # 9. Extra adjustment when the average degree is close to the maximum\n    if avg_deg > max_deg / 2.0:\n        base /= (1.0 + (avg_deg - max_deg / 2.0) / (max_deg / 2.0 + 1.0))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and leaf fraction.  No graph traversal or external\n    libraries are used.\n    \"\"\"\n    # Basic graph statistics\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    # 9. Extra adjustment when the average degree is close to the maximum\n    if avg_deg > max_deg / 2.0:\n        base /= (1.0 + (avg_deg - max_deg / 2.0) / (max_deg / 2.0 + 1.0))\n\n    return base", "spearman": 0.7678121953048828, "pearson": 0.7490456677748466, "rmse": 3.9085595455248416, "mae": 3.2268532145552045}}
{"timestamp": "2026-02-16T16:41:59.638873+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.099785", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:41:59.639705+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.099785", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:42:32.286976+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 0, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.057708", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:42:32.287638+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 0, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:43:30.650048+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i1_p0_20035983", "generation": 11, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22165548823651432, "novelty_bonus": 0.25138613993252834, "total_score": 0.527282378013021, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic features with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 0.0), 1.0)          # avoid division by zero\n    max_deg    = max(s.get('max_degree', 0), 1)\n    min_deg    = max(s.get('min_degree', 0), 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: os.\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.097438\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T16:44:14.783983+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i1_p1_51017190", "generation": 11, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.2217197160851846, "novelty_bonus": 0.25138613993252834, "total_score": 0.5272952235827552, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic features with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 0.0), 1.0)          # avoid division by zero\n    max_deg    = max(s.get('max_degree', 0), 1)\n    min_deg    = max(s.get('min_degree', 0), 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: os.\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.097438\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T16:44:47.671885+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i1_p2_650573864", "generation": 11, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.2207328343862078, "novelty_bonus": 0.25138613993252834, "total_score": 0.5270978472429597, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic features with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 0.0), 1.0)          # avoid division by zero\n    max_deg    = max(s.get('max_degree', 0), 1)\n    min_deg    = max(s.get('min_degree', 0), 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: os.\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.097438\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features.\n    \"\"\"\n    # Basic statistics (ensure no division by zero)\n    n          = s['n']\n    m          = s['m']\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 0.0), 1.0)\n    max_deg    = max(s.get('max_degree', 0), 1)\n    min_deg    = max(s.get('min_degree', 0), 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features.\n    \"\"\"\n    # Basic statistics (ensure no division by zero)\n    n          = s['n']\n    m          = s['m']\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 0.0), 1.0)\n    max_deg    = max(s.get('max_degree', 0), 1)\n    min_deg    = max(s.get('min_degree', 0), 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T16:45:47.470877+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i1_p3_204899863", "generation": 11, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.2209014926046282, "novelty_bonus": 0.25138613993252834, "total_score": 0.5271315788866439, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic features with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 0.0), 1.0)          # avoid division by zero\n    max_deg    = max(s.get('max_degree', 0), 1)\n    min_deg    = max(s.get('min_degree', 0), 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: os.\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.097438\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic statistics with safe defaults\n    n          = s['n']\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 0.0), 1.0)          # avoid division by zero\n    max_deg    = max(s.get('max_degree', 0), 1)\n    min_deg    = max(s.get('min_degree', 0), 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (pow(n, 2) + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + pow(density, 2))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic statistics with safe defaults\n    n          = s['n']\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 0.0), 1.0)          # avoid division by zero\n    max_deg    = max(s.get('max_degree', 0), 1)\n    min_deg    = max(s.get('min_degree', 0), 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (pow(n, 2) + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + pow(density, 2))\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T16:46:31.927762+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i1_p4_145501675", "generation": 11, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22070514926935947, "novelty_bonus": 0.25138613993252834, "total_score": 0.5270923102195901, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic features with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 0.0), 1.0)          # avoid division by zero\n    max_deg    = max(s.get('max_degree', 0), 1)\n    min_deg    = max(s.get('min_degree', 0), 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_clustering = s['avg_clustering']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    num_triangles = s['num_triangles']\n    density = s['density']\n\n    # Optional features (default to 0 if missing)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n\n    # Avoid division by zero\n    denom_m = m + 1\n    denom_density = max(density, 1e-6)\n    denom_min_degree = min_degree + 1\n    denom_max_degree = max_degree + 1\n\n    # Derived ratios\n    tri_per_edge = num_triangles / max(m, 1)\n    deg_variance = std_degree ** 2\n    deg_ratio = denom_max_degree / denom_min_degree\n\n    # Composite invariant\n    part1 = n / denom_m                     # sparsity\n    part2 = pow(n, 0.5) / (1 + avg_clustering)  # size & clustering\n    part3 = avg_degree / denom_max_degree       # degree spread\n    part4 = 1 + abs(degree_assortativity)       # assortativity\n    part5 = 1 + transitivity                    # transitivity\n\n    result = (\n        part1\n        * part2\n        * part3\n        * part4\n        * part5\n        * (1 + tri_per_edge)\n        * deg_ratio\n        / (1 + deg_variance)\n        / denom_density\n    )\n    return result\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: os.\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.097438\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features.\n    \"\"\"\n    # Basic statistics with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 0.0), 1.0)          # avoid division by zero\n    max_deg    = max(s.get('max_degree', 0), 1)\n    min_deg    = max(s.get('min_degree', 0), 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (pow(n, 2) + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features.\n    \"\"\"\n    # Basic statistics with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 0.0), 1.0)          # avoid division by zero\n    max_deg    = max(s.get('max_degree', 0), 1)\n    min_deg    = max(s.get('min_degree', 0), 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (pow(n, 2) + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T16:47:20.346418+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i2_p0_381691431", "generation": 11, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7442496998799519, "fitness_mode": "correlation", "simplicity_score": 0.11887857389644738, "novelty_bonus": 0.24973690209750388, "total_score": 0.4576235085766198, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the effect of density, clustering, transitivity, degree\n    heterogeneity, assortativity, the presence of very low‑degree vertices\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'density' (float, 0–1)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Minimum‑degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)  # larger when min_deg is small\n\n    # Degree‑heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle‑density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nbelow_novelty_threshold: novelty_bonus=0.147697\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic starts from a simple random‑graph baseline and applies\n    multiplicative corrections that capture the effects of density, clustering,\n    transitivity, degree heterogeneity, assortativity, extreme degrees and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n    max_deg = s.get('max_degree', 1)\n    num_tri = s.get('num_triangles', 0)\n\n    clust_factor   = 1.0 + clustering\n    trans_factor   = 1.0 + trans\n    density_factor = 1.0 / (1.0 + density)\n    hetero_factor  = 1.0 / (1.0 + std_deg)\n    assort_factor  = 1.0 + abs(assort)\n    min_factor     = 1.0 / (1.0 + min_deg / avg_deg)\n    max_factor     = 1.0 / (1.0 + max_deg / avg_deg)\n\n    # Triangle density factor: more triangles → shorter paths\n    tri_ratio = 0.0\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            clust_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            max_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic starts from a simple random‑graph baseline and applies\n    multiplicative corrections that capture the effects of density, clustering,\n    transitivity, degree heterogeneity, assortativity, extreme degrees and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n    max_deg = s.get('max_degree', 1)\n    num_tri = s.get('num_triangles', 0)\n\n    clust_factor   = 1.0 + clustering\n    trans_factor   = 1.0 + trans\n    density_factor = 1.0 / (1.0 + density)\n    hetero_factor  = 1.0 / (1.0 + std_deg)\n    assort_factor  = 1.0 + abs(assort)\n    min_factor     = 1.0 / (1.0 + min_deg / avg_deg)\n    max_factor     = 1.0 / (1.0 + max_deg / avg_deg)\n\n    # Triangle density factor: more triangles → shorter paths\n    tri_ratio = 0.0\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            clust_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            max_factor *\n            tri_factor)", "spearman": 0.7178534463361584, "pearson": 0.649725887048141, "rmse": 1.8586176792629936, "mae": 1.7359674815833444}}
{"timestamp": "2026-02-16T16:48:13.141610+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i2_p1_74655219", "generation": 11, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7472268907563024, "fitness_mode": "correlation", "simplicity_score": 0.11783755626803771, "novelty_bonus": 0.18122790278901724, "total_score": 0.44231974168680266, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the effect of density, clustering, transitivity, degree\n    heterogeneity, assortativity, the presence of very low‑degree vertices\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'density' (float, 0–1)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Minimum‑degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)  # larger when min_deg is small\n\n    # Degree‑heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle‑density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nbelow_novelty_threshold: novelty_bonus=0.147697\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic is based on a simple edge‑count baseline and\n    multiplicative corrections that capture the influence of density, clustering,\n    transitivity, degree heterogeneity, assortativity, extreme degrees and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic baseline: larger graphs with more edges tend to have shorter paths\n    n = s['n']\n    m = s.get('m', s['avg_degree'] * n / 2.0)\n    base = n / (m + 1.0)\n\n    # Corrections for various structural properties\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + trans\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    avg_deg = s.get('avg_degree', 1.0)\n    min_deg = s.get('min_degree', 1.0)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Triangle density: more triangles usually shorten paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 0.0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Effect of the largest degree: a very high max degree can provide shortcuts\n    max_deg = s.get('max_degree', avg_deg)\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # Combine all factors\n    return (\n        base\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * min_factor\n        * hetero_factor\n        * tri_factor\n        * max_factor\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic is based on a simple edge‑count baseline and\n    multiplicative corrections that capture the influence of density, clustering,\n    transitivity, degree heterogeneity, assortativity, extreme degrees and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic baseline: larger graphs with more edges tend to have shorter paths\n    n = s['n']\n    m = s.get('m', s['avg_degree'] * n / 2.0)\n    base = n / (m + 1.0)\n\n    # Corrections for various structural properties\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + trans\n\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    avg_deg = s.get('avg_degree', 1.0)\n    min_deg = s.get('min_degree', 1.0)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Triangle density: more triangles usually shorten paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 0.0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Effect of the largest degree: a very high max degree can provide shortcuts\n    max_deg = s.get('max_degree', avg_deg)\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # Combine all factors\n    return (\n        base\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * min_factor\n        * hetero_factor\n        * tri_factor\n        * max_factor\n    )", "spearman": 0.7287677191929799, "pearson": 0.6318376605239711, "rmse": 2.6898118818185623, "mae": 2.563289177325259}}
{"timestamp": "2026-02-16T16:48:51.998810+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i2_p2_633041537", "generation": 11, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.9093397358943576, "fitness_mode": "correlation", "simplicity_score": 0.12076201440485135, "novelty_bonus": 0.1578909472736817, "total_score": 0.5328029691451269, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the effect of density, clustering, transitivity, degree\n    heterogeneity, assortativity, the presence of very low‑degree vertices\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'density' (float, 0–1)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Minimum‑degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)  # larger when min_deg is small\n\n    # Degree‑heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle‑density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nbelow_novelty_threshold: novelty_bonus=0.147697\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest path length.\n\n    The estimate starts from a simple random‑graph baseline\n    ``n / (avg_degree + 1)`` and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, very low‑degree vertices\n    and the abundance of triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float 0–1)\n            - 'transitivity' (float 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Density factor – denser graphs tend to have shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity – higher values usually increase path length\n    clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    clustering_factor = 1.0 + clustering\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity – more assortative mixes tend to stretch the graph\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Degree heterogeneity – more heterogeneous degrees can shorten paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg)\n\n    # Very low minimum degree can create bottlenecks\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)\n\n    # Triangle density – abundant triangles tend to reduce path length\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = 0\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = (num_tri / possible_tri) if possible_tri else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all multiplicative corrections\n    return (base * density_factor * clustering_factor *\n            trans_factor * assort_factor * hetero_factor *\n            min_factor * tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest path length.\n\n    The estimate starts from a simple random‑graph baseline\n    ``n / (avg_degree + 1)`` and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, very low‑degree vertices\n    and the abundance of triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float 0–1)\n            - 'transitivity' (float 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Density factor – denser graphs tend to have shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity – higher values usually increase path length\n    clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    clustering_factor = 1.0 + clustering\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity – more assortative mixes tend to stretch the graph\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Degree heterogeneity – more heterogeneous degrees can shorten paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg)\n\n    # Very low minimum degree can create bottlenecks\n    min_deg = s.get('min_degree', 1)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)\n\n    # Triangle density – abundant triangles tend to reduce path length\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = 0\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = (num_tri / possible_tri) if possible_tri else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all multiplicative corrections\n    return (base * density_factor * clustering_factor *\n            trans_factor * assort_factor * hetero_factor *\n            min_factor * tri_factor)", "spearman": 0.9225665641641043, "pearson": 0.8785234077342516, "rmse": 4.343963836079072, "mae": 2.9492180995506176}}
{"timestamp": "2026-02-16T16:49:44.362480+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i2_p3_164322124", "generation": 11, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.49714285714285716, "fitness_mode": "correlation", "simplicity_score": 0.11799645246587612, "novelty_bonus": 0.4503261453454813, "total_score": 0.4058215622075224, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the effect of density, clustering, transitivity, degree\n    heterogeneity, assortativity, the presence of very low‑degree vertices\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'density' (float, 0–1)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Minimum‑degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)  # larger when min_deg is small\n\n    # Degree‑heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle‑density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nbelow_novelty_threshold: novelty_bonus=0.147697\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the influence of density, clustering, transitivity,\n    degree heterogeneity, assortativity, extreme degree values and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Extract features with defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', avg_deg)\n    min_deg = s.get('min_degree', avg_deg)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density (ratio of actual to possible triangles)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering\n    trans_factor       = 1.0 + trans\n    density_factor     = 1.0 / (1.0 + density)\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    max_factor         = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    min_factor         = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n    assort_factor      = 1.0 / (1.0 + abs(assort))\n    tri_factor         = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * density_factor\n        * hetero_factor\n        * max_factor\n        * min_factor\n        * assort_factor\n        * tri_factor\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the influence of density, clustering, transitivity,\n    degree heterogeneity, assortativity, extreme degree values and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Extract features with defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    max_deg = s.get('max_degree', avg_deg)\n    min_deg = s.get('min_degree', avg_deg)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density (ratio of actual to possible triangles)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering\n    trans_factor       = 1.0 + trans\n    density_factor     = 1.0 / (1.0 + density)\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    max_factor         = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    min_factor         = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n    assort_factor      = 1.0 / (1.0 + abs(assort))\n    tri_factor         = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * clustering_factor\n        * trans_factor\n        * density_factor\n        * hetero_factor\n        * max_factor\n        * min_factor\n        * assort_factor\n        * tri_factor\n    )", "spearman": 0.49424885622140563, "pearson": 0.4413626213892532, "rmse": 1.1964579895733767, "mae": 0.8937328228302747}}
{"timestamp": "2026-02-16T16:50:22.812667+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i2_p4_256255867", "generation": 11, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7867947178871548, "fitness_mode": "correlation", "simplicity_score": 0.12040083189375406, "novelty_bonus": 0.26968216381702825, "total_score": 0.5077118837005639, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the effect of density, clustering, transitivity, degree\n    heterogeneity, assortativity, the presence of very low‑degree vertices\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'density' (float, 0–1)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Minimum‑degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)  # larger when min_deg is small\n\n    # Degree‑heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle‑density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nbelow_novelty_threshold: novelty_bonus=0.147697\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that capture\n    the effect of density, clustering, transitivity, degree heterogeneity,\n    assortativity, the presence of very low‑degree vertices and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Minimum‑degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 / (1.0 + min_deg / avg_deg)\n\n    # Degree‑heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle‑density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that capture\n    the effect of density, clustering, transitivity, degree heterogeneity,\n    assortativity, the presence of very low‑degree vertices and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Minimum‑degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 / (1.0 + min_deg / avg_deg)\n\n    # Degree‑heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle‑density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )", "spearman": 0.805454136353409, "pearson": 0.8042064057740679, "rmse": 5.417246801807605, "mae": 4.399626280294183}}
{"timestamp": "2026-02-16T16:51:20.912715+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.123558", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:51:20.914374+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.123558", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:51:59.295815+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 3, "population_idx": 0, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:51:59.296962+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 3, "population_idx": 0, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:52:49.562199+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: non-whitelisted call detected: isinstance", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:52:49.563367+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: non-whitelisted call detected: isinstance", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:53:20.826167+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i3_p1_417414611", "generation": 11, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.3742136854741897, "fitness_mode": "correlation", "simplicity_score": 0.15320676168494585, "novelty_bonus": 0.3298027450686266, "total_score": 0.24285525768462285, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only pre‑computed graph\n    statistics.  The formula is a product of a size–to‑degree baseline and\n    multiplicative factors that capture clustering, density, degree heterogeneity,\n    assortativity, the range of degrees and triangle density.  No graph\n    traversal or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with at least the following keys:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n        - 'degrees' (list of int)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Pull values with defaults for safety\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    density = float(s.get('density', 0.0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    max_deg = float(s.get('max_degree', 0.0))\n    min_deg = float(s.get('min_degree', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    num_tri = float(s.get('num_triangles', 0.0))\n\n    # Avoid division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n\n    # Size‑to‑average‑degree baseline (random‑graph intuition)\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust     = 1.0 + avg_clust\n    f_trans     = 1.0 + trans\n    f_assort    = 1.0 + abs(assort)\n    f_density   = 1.0 / (1.0 + density)\n    f_std       = 1.0 / (1.0 + std_deg)\n    f_min       = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle‑density adjustment (larger triangles → shorter paths)\n    tri_factor  = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri       = 1.0 + tri_factor\n\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_tri\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.110977\nbelow_novelty_threshold: novelty_bonus=0.123558\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: non-whitelisted call detected: isinstance\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from a small set\n    of pre‑computed statistics.\n\n    The estimate is built on a random‑graph intuition: the basic scale is\n    ``n / (avg_degree + 1)``.  The value is then corrected by a number of\n    multiplicative factors that capture different structural properties:\n      • clustering & transitivity (longer paths when triangles are abundant)\n      • assortativity (more assortative graphs tend to be slightly longer)\n      • density (denser graphs shrink distances)\n      • degree heterogeneity (high variance shortens paths)\n      • presence of low‑degree vertices (very small min degree can increase paths)\n      • presence of high‑degree vertices (high degree hubs shrink paths)\n      • triangle density (larger triangle counts shorten distances)\n      • concentration of degree in the top 10 % nodes (top hubs dominate connectivity)\n\n    All corrections are expressed as simple rational factors that keep the\n    computation lightweight and avoid any graph traversal or external\n    libraries.  The function returns a floating‑point estimate that\n    typically correlates well with the true average shortest‑path length\n    for a wide variety of graphs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing at least the following keys:\n          - 'n' (int): number of nodes\n          - 'm' (int): number of edges\n          - 'density' (float)\n          - 'avg_degree' (float)\n          - 'max_degree' (int or float)\n          - 'min_degree' (int or float)\n          - 'std_degree' (float)\n          - 'avg_clustering' (float, 0–1)\n          - 'transitivity' (float, 0–1)\n          - 'degree_assortativity' (float, can be negative)\n          - 'num_triangles' (int or float)\n          - 'degrees' (sorted list of int)\n\n    Returns\n    -------\n    float\n        A numeric estimate of the graph’s average shortest‑path length.\n    \"\"\"\n    # Basic scaling: size relative to average degree (random‑graph baseline)\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    if avg_deg <= 0.0:\n        avg_deg = 1e-12  # avoid division by zero\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # Clustering and transitivity factors (higher -> longer paths)\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    f_clust = 1.0 + avg_clust\n    f_trans = 1.0 + trans\n\n    # Assortativity factor (absolute value to capture both assortative & disassortative effects)\n    assort = float(s.get('degree_assortativity', 0.0))\n    f_assort = 1.0 + abs(assort)\n\n    # Density factor (denser graphs shorten distances)\n    density = float(s.get('density', 0.0))\n    f_density = 1.0 / (1.0 + density)\n\n    # Degree heterogeneity factor (high std -> shorter paths)\n    std_deg = float(s.get('std_degree', 0.0))\n    f_std = 1.0 / (1.0 + std_deg)\n\n    # Minimum degree factor (very low min degree can increase path lengths)\n    min_deg = float(s.get('min_degree', 0.0))\n    f_min = 1.0 / (1.0 + min_deg / avg_deg)\n\n    # Maximum degree factor (high max degree (hubs) tend to shorten paths)\n    max_deg = float(s.get('max_degree', 0.0))\n    f_max = 1.0 / (1.0 + max_deg / avg_deg)\n\n    # Triangle density factor (more triangles => shorter paths)\n    num_tri = float(s.get('num_triangles', 0.0))\n    tri_factor = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri = 1.0 + tri_factor\n\n    # Concentration of high‑degree nodes in the top 10 % of the spectrum\n    degrees = s.get('degrees', [])\n    if isinstance(degrees, list) and degrees:\n        top_k = max(1, int(0.1 * n))\n        top_k = min(top_k, len(degrees))\n        high_sum = sum(degrees[-top_k:])\n        total_deg = 2.0 * m if m > 0 else 1.0\n        high_ratio = high_sum / total_deg\n        # If high‑degree hubs dominate, paths become shorter\n        f_high = 1.0 + (1.0 - high_ratio) * 0.5\n    else:\n        f_high = 1.0\n\n    # Combine all factors\n    estimate = (base *\n                f_clust *\n                f_trans *\n                f_assort *\n                f_density *\n                f_std *\n                f_min *\n                f_max *\n                f_tri *\n                f_high)\n\n    return float(estimate)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from a set of\n    pre‑computed global statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            n (int), m (int), density (float),\n            avg_degree (float), max_degree (float),\n            min_degree (float), std_degree (float),\n            avg_clustering (float), transitivity (float),\n            degree_assortativity (float),\n            num_triangles (float), degrees (sorted list of ints)\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    if avg_deg <= 0.0:\n        avg_deg = 1e-12\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    f_clust = 1.0 + avg_clust\n    f_trans = 1.0 + trans\n\n    assort = float(s.get('degree_assortativity', 0.0))\n    f_assort = 1.0 + abs(assort)\n\n    density = float(s.get('density', 0.0))\n    f_density = 1.0 / (1.0 + density)\n\n    std_deg = float(s.get('std_degree', 0.0))\n    f_std = 1.0 / (1.0 + std_deg)\n\n    min_deg = float(s.get('min_degree', 0.0))\n    f_min = 1.0 / (1.0 + min_deg / avg_deg)\n\n    max_deg = float(s.get('max_degree', 0.0))\n    f_max = 1.0 / (1.0 + max_deg / avg_deg)\n\n    num_tri = float(s.get('num_triangles', 0.0))\n    tri_factor = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri = 1.0 + tri_factor\n\n    degrees = s.get('degrees', [])\n    f_high = 1.0\n    if degrees:\n        top_k = max(1, int(0.1 * n))\n        top_k = min(top_k, len(degrees))\n        high_sum = sum(degrees[-top_k:])\n        total_deg = 2.0 * m if m > 0 else 1.0\n        high_ratio = high_sum / total_deg\n        f_high = 1.0 + (1.0 - high_ratio) * 0.5\n\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_max *\n        f_tri *\n        f_high\n    )\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from a set of\n    pre‑computed global statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            n (int), m (int), density (float),\n            avg_degree (float), max_degree (float),\n            min_degree (float), std_degree (float),\n            avg_clustering (float), transitivity (float),\n            degree_assortativity (float),\n            num_triangles (float), degrees (sorted list of ints)\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    if avg_deg <= 0.0:\n        avg_deg = 1e-12\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    f_clust = 1.0 + avg_clust\n    f_trans = 1.0 + trans\n\n    assort = float(s.get('degree_assortativity', 0.0))\n    f_assort = 1.0 + abs(assort)\n\n    density = float(s.get('density', 0.0))\n    f_density = 1.0 / (1.0 + density)\n\n    std_deg = float(s.get('std_degree', 0.0))\n    f_std = 1.0 / (1.0 + std_deg)\n\n    min_deg = float(s.get('min_degree', 0.0))\n    f_min = 1.0 / (1.0 + min_deg / avg_deg)\n\n    max_deg = float(s.get('max_degree', 0.0))\n    f_max = 1.0 / (1.0 + max_deg / avg_deg)\n\n    num_tri = float(s.get('num_triangles', 0.0))\n    tri_factor = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri = 1.0 + tri_factor\n\n    degrees = s.get('degrees', [])\n    f_high = 1.0\n    if degrees:\n        top_k = max(1, int(0.1 * n))\n        top_k = min(top_k, len(degrees))\n        high_sum = sum(degrees[-top_k:])\n        total_deg = 2.0 * m if m > 0 else 1.0\n        high_ratio = high_sum / total_deg\n        f_high = 1.0 + (1.0 - high_ratio) * 0.5\n\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_max *\n        f_tri *\n        f_high\n    )\n    return float(estimate)", "spearman": 0.2265461636540914, "pearson": 0.41690087327078573, "rmse": 2.706853317561321, "mae": 1.7623062949772317}}
{"timestamp": "2026-02-16T16:53:20.846019+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 3, "population_idx": 1, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:53:54.651811+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i3_p2_609770524", "generation": 11, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.590876350540216, "fitness_mode": "correlation", "simplicity_score": 0.15630552630922925, "novelty_bonus": 0.38557867419243685, "total_score": 0.41893950763957993, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only pre‑computed graph\n    statistics.  The formula is a product of a size–to‑degree baseline and\n    multiplicative factors that capture clustering, density, degree heterogeneity,\n    assortativity, the range of degrees and triangle density.  No graph\n    traversal or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with at least the following keys:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n        - 'degrees' (list of int)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Pull values with defaults for safety\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    density = float(s.get('density', 0.0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    max_deg = float(s.get('max_degree', 0.0))\n    min_deg = float(s.get('min_degree', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    num_tri = float(s.get('num_triangles', 0.0))\n\n    # Avoid division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n\n    # Size‑to‑average‑degree baseline (random‑graph intuition)\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust     = 1.0 + avg_clust\n    f_trans     = 1.0 + trans\n    f_assort    = 1.0 + abs(assort)\n    f_density   = 1.0 / (1.0 + density)\n    f_std       = 1.0 / (1.0 + std_deg)\n    f_min       = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle‑density adjustment (larger triangles → shorter paths)\n    tri_factor  = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri       = 1.0 + tri_factor\n\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_tri\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.123558\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on global graph statistics.\n    The estimate is a product of several dimensionless factors that capture\n    size, connectivity, clustering, heterogeneity, assortativity and triangle\n    density.  No graph traversal or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all optional, missing keys\n        are treated as zeros or ones as appropriate):\n\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float): graph density in [0, 1]\n        - avg_degree (float): average node degree\n        - max_degree (int): maximum node degree\n        - min_degree (int): minimum node degree\n        - std_degree (float): standard deviation of the degree sequence\n        - avg_clustering (float): average local clustering coefficient\n        - transitivity (float): global transitivity (cluster coefficient)\n        - degree_assortativity (float): assortativity coefficient (negative allowed)\n        - num_triangles (int): number of triangles in the graph\n        - degrees (list[int]): sorted list of node degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.  The value is dimensionless\n        but scales approximately with the true average shortest‑path length\n        for typical graphs.\n    \"\"\"\n    # Pull values with defaults\n    n           = s.get('n', 1)\n    m           = s.get('m', 0)\n    density     = s.get('density', 0.0)\n    avg_deg     = s.get('avg_degree', 0.0)\n    max_deg     = s.get('max_degree', 0)\n    min_deg     = s.get('min_degree', 0)\n    std_deg     = s.get('std_degree', 0.0)\n    avg_clust   = s.get('avg_clustering', 0.0)\n    trans       = s.get('transitivity', 0.0)\n    assort      = s.get('degree_assortativity', 0.0)\n    num_tri     = s.get('num_triangles', 0)\n\n    # Avoid division by zero in subsequent formulas\n    if avg_deg <= 0:\n        avg_deg = 1e-12\n    if n <= 0:\n        n = 1\n\n    # ---------- Baseline factor ----------\n    # Random‑graph intuition: larger graphs with fewer edges have longer paths\n    base = (n + 1.0) / (m + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering tends to increase path length\n    f_clust = 1.0 + avg_clust\n\n    # Transitivity is another global measure of triangles; it behaves similarly\n    f_trans = 1.0 + trans\n\n    # Assortativity (absolute value) captures degree mixing patterns; stronger\n    # assortative or disassortative mixing often elongates average paths\n    f_assort = 1.0 + (assort if assort < 0 else assort)\n\n    # Density reduces path lengths\n    f_density = 1.0 / (1.0 + density)\n\n    # Heterogeneity in degrees (high std) often shortens paths by creating hubs\n    f_std = 1.0 / (1.0 + std_deg)\n\n    # Very low minimum degree can lengthen paths (presence of leaf‑like nodes)\n    f_min = 1.0 / (1.0 + min_deg / (avg_deg + 1e-12))\n\n    # Triangle density: more triangles generally reduce distances\n    tri_factor = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri = 1.0 + tri_factor\n\n    # ---------- Combine all factors ----------\n    estimate = (base *\n                f_clust *\n                f_trans *\n                f_assort *\n                f_density *\n                f_std *\n                f_min *\n                f_tri)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on global graph statistics.\n    The estimate is a product of several dimensionless factors that capture\n    size, connectivity, clustering, heterogeneity, assortativity and triangle\n    density.  No graph traversal or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all optional, missing keys\n        are treated as zeros or ones as appropriate):\n\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float): graph density in [0, 1]\n        - avg_degree (float): average node degree\n        - max_degree (int): maximum node degree\n        - min_degree (int): minimum node degree\n        - std_degree (float): standard deviation of the degree sequence\n        - avg_clustering (float): average local clustering coefficient\n        - transitivity (float): global transitivity (cluster coefficient)\n        - degree_assortativity (float): assortativity coefficient (negative allowed)\n        - num_triangles (int): number of triangles in the graph\n        - degrees (list[int]): sorted list of node degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.  The value is dimensionless\n        but scales approximately with the true average shortest‑path length\n        for typical graphs.\n    \"\"\"\n    # Pull values with defaults\n    n           = s.get('n', 1)\n    m           = s.get('m', 0)\n    density     = s.get('density', 0.0)\n    avg_deg     = s.get('avg_degree', 0.0)\n    max_deg     = s.get('max_degree', 0)\n    min_deg     = s.get('min_degree', 0)\n    std_deg     = s.get('std_degree', 0.0)\n    avg_clust   = s.get('avg_clustering', 0.0)\n    trans       = s.get('transitivity', 0.0)\n    assort      = s.get('degree_assortativity', 0.0)\n    num_tri     = s.get('num_triangles', 0)\n\n    # Avoid division by zero in subsequent formulas\n    if avg_deg <= 0:\n        avg_deg = 1e-12\n    if n <= 0:\n        n = 1\n\n    # ---------- Baseline factor ----------\n    # Random‑graph intuition: larger graphs with fewer edges have longer paths\n    base = (n + 1.0) / (m + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering tends to increase path length\n    f_clust = 1.0 + avg_clust\n\n    # Transitivity is another global measure of triangles; it behaves similarly\n    f_trans = 1.0 + trans\n\n    # Assortativity (absolute value) captures degree mixing patterns; stronger\n    # assortative or disassortative mixing often elongates average paths\n    f_assort = 1.0 + (assort if assort < 0 else assort)\n\n    # Density reduces path lengths\n    f_density = 1.0 / (1.0 + density)\n\n    # Heterogeneity in degrees (high std) often shortens paths by creating hubs\n    f_std = 1.0 / (1.0 + std_deg)\n\n    # Very low minimum degree can lengthen paths (presence of leaf‑like nodes)\n    f_min = 1.0 / (1.0 + min_deg / (avg_deg + 1e-12))\n\n    # Triangle density: more triangles generally reduce distances\n    tri_factor = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri = 1.0 + tri_factor\n\n    # ---------- Combine all factors ----------\n    estimate = (base *\n                f_clust *\n                f_trans *\n                f_assort *\n                f_density *\n                f_std *\n                f_min *\n                f_tri)\n\n    return float(estimate)", "spearman": 0.5440096002400061, "pearson": 0.5609397005549811, "rmse": 2.543577060507717, "mae": 2.4259583040482435}}
{"timestamp": "2026-02-16T16:54:39.807854+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i3_p3_489126332", "generation": 11, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.4928211284513805, "fitness_mode": "correlation", "simplicity_score": 0.154940803466983, "novelty_bonus": 0.47884497112427804, "total_score": 0.4282012410204048, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only pre‑computed graph\n    statistics.  The formula is a product of a size–to‑degree baseline and\n    multiplicative factors that capture clustering, density, degree heterogeneity,\n    assortativity, the range of degrees and triangle density.  No graph\n    traversal or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with at least the following keys:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n        - 'degrees' (list of int)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Pull values with defaults for safety\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    density = float(s.get('density', 0.0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    max_deg = float(s.get('max_degree', 0.0))\n    min_deg = float(s.get('min_degree', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    num_tri = float(s.get('num_triangles', 0.0))\n\n    # Avoid division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n\n    # Size‑to‑average‑degree baseline (random‑graph intuition)\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust     = 1.0 + avg_clust\n    f_trans     = 1.0 + trans\n    f_assort    = 1.0 + abs(assort)\n    f_density   = 1.0 / (1.0 + density)\n    f_std       = 1.0 / (1.0 + std_deg)\n    f_min       = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle‑density adjustment (larger triangles → shorter paths)\n    tri_factor  = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri       = 1.0 + tri_factor\n\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_tri\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.123558\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without traversing the graph.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with the following keys:\n            - 'n'                : int, number of nodes\n            - 'm'                : int, number of edges\n            - 'density'          : float, 0–1\n            - 'avg_degree'       : float\n            - 'max_degree'       : int or float\n            - 'min_degree'       : int or float\n            - 'std_degree'       : float\n            - 'avg_clustering'   : float, 0–1\n            - 'transitivity'     : float, 0–1\n            - 'degree_assortativity' : float, can be negative\n            - 'num_triangles'    : int or float\n            - 'degrees'          : list of sorted degrees\n\n    Returns\n    -------\n    float\n        A numeric estimate that is correlated with the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Basic values – use .get with reasonable defaults to avoid KeyError\n    n               = float(s.get('n', 1))\n    m               = float(s.get('m', 0))\n    density         = float(s.get('density', 0.0))\n    avg_deg         = float(s.get('avg_degree', 0.0))\n    max_deg         = float(s.get('max_degree', 0.0))\n    min_deg         = float(s.get('min_degree', 0.0))\n    std_deg         = float(s.get('std_degree', 0.0))\n    avg_clust       = float(s.get('avg_clustering', 0.0))\n    trans           = float(s.get('transitivity', 0.0))\n    assort          = float(s.get('degree_assortativity', 0.0))\n    num_tri          = float(s.get('num_triangles', 0.0))\n\n    # Guard against division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n    if max_deg <= 0:\n        max_deg = 1.0\n    if n <= 0:\n        n = 1.0\n\n    # ------------------------------------------------------------------\n    # 1. Size / average‑degree baseline (random‑graph intuition)\n    # ------------------------------------------------------------------\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # ------------------------------------------------------------------\n    # 2. Multiplicative corrections\n    # ------------------------------------------------------------------\n    f_density     = 1.0 / (1.0 + density)                # denser → shorter\n    f_clustering  = 1.0 + avg_clust                        # more clustering → longer\n    f_transitivity= 1.0 + trans                            # more transitivity → longer\n    f_assort      = 1.0 / (1.0 + abs(assort))              # stronger assortativity → longer\n    f_std         = 1.0 / (1.0 + std_deg)                  # higher degree variance → shorter\n    f_min_degree  = 1.0 / (1.0 + min_deg / (avg_deg + 1)) # very low min degree → longer\n    f_triangles   = 1.0 + (num_tri ** 0.5) / (n ** 0.5)    # more triangles → shorter\n    f_degree_range= 1.0 + (max_deg - min_deg) / (max_deg + 1)  # wide range → longer\n\n    # ------------------------------------------------------------------\n    # 3. Composite estimate\n    # ------------------------------------------------------------------\n    estimate = (\n        base *\n        f_density *\n        f_clustering *\n        f_transitivity *\n        f_assort *\n        f_std *\n        f_min_degree *\n        f_triangles *\n        f_degree_range\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without traversing the graph.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with the following keys:\n            - 'n'                : int, number of nodes\n            - 'm'                : int, number of edges\n            - 'density'          : float, 0–1\n            - 'avg_degree'       : float\n            - 'max_degree'       : int or float\n            - 'min_degree'       : int or float\n            - 'std_degree'       : float\n            - 'avg_clustering'   : float, 0–1\n            - 'transitivity'     : float, 0–1\n            - 'degree_assortativity' : float, can be negative\n            - 'num_triangles'    : int or float\n            - 'degrees'          : list of sorted degrees\n\n    Returns\n    -------\n    float\n        A numeric estimate that is correlated with the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Basic values – use .get with reasonable defaults to avoid KeyError\n    n               = float(s.get('n', 1))\n    m               = float(s.get('m', 0))\n    density         = float(s.get('density', 0.0))\n    avg_deg         = float(s.get('avg_degree', 0.0))\n    max_deg         = float(s.get('max_degree', 0.0))\n    min_deg         = float(s.get('min_degree', 0.0))\n    std_deg         = float(s.get('std_degree', 0.0))\n    avg_clust       = float(s.get('avg_clustering', 0.0))\n    trans           = float(s.get('transitivity', 0.0))\n    assort          = float(s.get('degree_assortativity', 0.0))\n    num_tri          = float(s.get('num_triangles', 0.0))\n\n    # Guard against division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n    if max_deg <= 0:\n        max_deg = 1.0\n    if n <= 0:\n        n = 1.0\n\n    # ------------------------------------------------------------------\n    # 1. Size / average‑degree baseline (random‑graph intuition)\n    # ------------------------------------------------------------------\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # ------------------------------------------------------------------\n    # 2. Multiplicative corrections\n    # ------------------------------------------------------------------\n    f_density     = 1.0 / (1.0 + density)                # denser → shorter\n    f_clustering  = 1.0 + avg_clust                        # more clustering → longer\n    f_transitivity= 1.0 + trans                            # more transitivity → longer\n    f_assort      = 1.0 / (1.0 + abs(assort))              # stronger assortativity → longer\n    f_std         = 1.0 / (1.0 + std_deg)                  # higher degree variance → shorter\n    f_min_degree  = 1.0 / (1.0 + min_deg / (avg_deg + 1)) # very low min degree → longer\n    f_triangles   = 1.0 + (num_tri ** 0.5) / (n ** 0.5)    # more triangles → shorter\n    f_degree_range= 1.0 + (max_deg - min_deg) / (max_deg + 1)  # wide range → longer\n\n    # ------------------------------------------------------------------\n    # 3. Composite estimate\n    # ------------------------------------------------------------------\n    estimate = (\n        base *\n        f_density *\n        f_clustering *\n        f_transitivity *\n        f_assort *\n        f_std *\n        f_min_degree *\n        f_triangles *\n        f_degree_range\n    )\n\n    return float(estimate)", "spearman": 0.5071191779794495, "pearson": 0.5082771786894297, "rmse": 7.892384590722565, "mae": 6.515723683519924}}
{"timestamp": "2026-02-16T16:55:26.443443+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i3_p4_645306004", "generation": 11, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6965186074429772, "fitness_mode": "correlation", "simplicity_score": 0.18055555555555555, "novelty_bonus": 0.15077326933173318, "total_score": 0.4745906731001608, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only pre‑computed graph\n    statistics.  The formula is a product of a size–to‑degree baseline and\n    multiplicative factors that capture clustering, density, degree heterogeneity,\n    assortativity, the range of degrees and triangle density.  No graph\n    traversal or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with at least the following keys:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n        - 'degrees' (list of int)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Pull values with defaults for safety\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    density = float(s.get('density', 0.0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    max_deg = float(s.get('max_degree', 0.0))\n    min_deg = float(s.get('min_degree', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    num_tri = float(s.get('num_triangles', 0.0))\n\n    # Avoid division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n\n    # Size‑to‑average‑degree baseline (random‑graph intuition)\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust     = 1.0 + avg_clust\n    f_trans     = 1.0 + trans\n    f_assort    = 1.0 + abs(assort)\n    f_density   = 1.0 / (1.0 + density)\n    f_std       = 1.0 / (1.0 + std_deg)\n    f_min       = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle‑density adjustment (larger triangles → shorter paths)\n    tri_factor  = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri       = 1.0 + tri_factor\n\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_tri\n    )\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of average shortest path length from global graph statistics.\n\n    The composite estimate multiplies a base factor derived from the\n    node/edge ratio by terms that capture degree heterogeneity,\n    clustering contrast, assortativity and triangle density.\n    \"\"\"\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending\n\n    # 1. Size‑to‑edges baseline\n    base = (n + 1) / (m + 1)\n\n    # 2. Degree concentration in the top 10 % nodes\n    top_k = max(1, int(0.1 * n))\n    high_deg_sum = sum(degrees[-top_k:]) if degrees else 0\n    total_deg = 2 * m if m > 0 else 1\n    high_deg_ratio = high_deg_sum / total_deg\n\n    # 3. Clustering‑vs‑transitivity factor\n    clus_diff_factor = 1 + 0.5 * (avg_clustering - transitivity)\n\n    # 4. Assortativity multiplier\n    assort_factor = 1 + abs(degree_assortativity)\n\n    # 5. Triangle density adjustment (square‑root ratio)\n    tri_factor = (num_triangles ** 0.5) / (n ** 0.5 if n > 0 else 1)\n\n    # Composite estimate\n    estimate = (\n        base\n        * assort_factor\n        * clus_diff_factor\n        * (1 + tri_factor * (1 - high_deg_ratio))\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.123558\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The estimate is a product of a size‑to‑edge baseline and\n    multiplicative corrections that reflect degree heterogeneity, clustering,\n    transitivity, assortativity, density, and triangle density.  No external\n    libraries or graph traversal algorithms are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of global graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n\n    Returns\n    -------\n    float\n        A numerical estimate that correlates with the graph's average\n        shortest path length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n\n    # Baseline based on size and sparsity\n    base = (n + 1.0) / (m + 1.0)\n\n    # Heterogeneity factor: influence of high‑degree hubs\n    hub_factor = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Clustering and transitivity corrections\n    clust_factor = 1.0 + avg_clust\n    trans_factor = 1.0 + trans\n\n    # Assortativity effect\n    assort_factor = 1.0 + abs(assort)\n\n    # Density and degree variability adjustments\n    density_factor = 1.0 / (1.0 + density)\n    std_factor = 1.0 / (1.0 + std_deg)\n\n    # Influence of minimum degree (captures bottlenecks)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle density effect\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    estimate = (\n        base *\n        hub_factor *\n        clust_factor *\n        trans_factor *\n        assort_factor *\n        density_factor *\n        std_factor *\n        min_factor *\n        tri_factor\n    )\n\n    return estimate", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The estimate is a product of a size‑to‑edge baseline and\n    multiplicative corrections that reflect degree heterogeneity, clustering,\n    transitivity, assortativity, density, and triangle density.  No external\n    libraries or graph traversal algorithms are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of global graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n\n    Returns\n    -------\n    float\n        A numerical estimate that correlates with the graph's average\n        shortest path length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n\n    # Baseline based on size and sparsity\n    base = (n + 1.0) / (m + 1.0)\n\n    # Heterogeneity factor: influence of high‑degree hubs\n    hub_factor = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Clustering and transitivity corrections\n    clust_factor = 1.0 + avg_clust\n    trans_factor = 1.0 + trans\n\n    # Assortativity effect\n    assort_factor = 1.0 + abs(assort)\n\n    # Density and degree variability adjustments\n    density_factor = 1.0 / (1.0 + density)\n    std_factor = 1.0 / (1.0 + std_deg)\n\n    # Influence of minimum degree (captures bottlenecks)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle density effect\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    estimate = (\n        base *\n        hub_factor *\n        clust_factor *\n        trans_factor *\n        assort_factor *\n        density_factor *\n        std_factor *\n        min_factor *\n        tri_factor\n    )\n\n    return estimate", "spearman": 0.7864951623790595, "pearson": 0.7767169110008003, "rmse": 2.39119695759867, "mae": 2.291749305561691}}
{"timestamp": "2026-02-16T16:55:26.449797+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 12, "model_name": "gpt-oss:20b", "best_val_score": 0.5376982263149925, "no_improve_count": 4}}
{"timestamp": "2026-02-16T16:56:02.536021+00:00", "event_type": "candidate_rejected", "payload": {"generation": 12, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:56:02.537371+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 12, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:56:21.309572+00:00", "event_type": "candidate_rejected", "payload": {"generation": 12, "island_id": 0, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.109189", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:56:21.309959+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 12, "island_id": 0, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T16:56:59.261913+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i0_p1_251160253", "generation": 12, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22191621004497614, "novelty_bonus": 0.25138613993252834, "total_score": 0.5273345223747135, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts and leaf fraction in a\n    compact, interpretable way.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base estimate: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.057708\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.109189\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T17:00:36.503952+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i0_p2_615121972", "generation": 12, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5184633853541416, "fitness_mode": "correlation", "simplicity_score": 0.21980506886437962, "novelty_bonus": 0.48482417719379534, "total_score": 0.44212783492021424, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts and leaf fraction in a\n    compact, interpretable way.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base estimate: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.057708\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.109189\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density = s['density']\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 1.0\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    m = s['m']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    base /= (1.0 + abs(assort))\n\n    base += triangles / (n ** 2 + 1.0)\n    base += triangles / (m + 1.0)\n\n    base *= (1.0 + leaf_frac)\n    base *= (1.0 + leaf_frac ** 2)\n\n    base /= (1.0 + density ** 2)\n\n    base *= (1.0 + (max_deg / (avg_deg + 1.0)))\n    base *= (1.0 + (min_deg / (avg_deg + 1.0)))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density = s['density']\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 1.0\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    m = s['m']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    base /= (1.0 + abs(assort))\n\n    base += triangles / (n ** 2 + 1.0)\n    base += triangles / (m + 1.0)\n\n    base *= (1.0 + leaf_frac)\n    base *= (1.0 + leaf_frac ** 2)\n\n    base /= (1.0 + density ** 2)\n\n    base *= (1.0 + (max_deg / (avg_deg + 1.0)))\n    base *= (1.0 + (min_deg / (avg_deg + 1.0)))\n\n    return base", "spearman": 0.5054391359783995, "pearson": 0.4818627723540655, "rmse": 47.796301437059576, "mae": 31.028900537072587}}
{"timestamp": "2026-02-16T17:01:22.330362+00:00", "event_type": "candidate_rejected", "payload": {"generation": 12, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.052197", "model_name": "gpt-oss:20b", "train_signal": 0.05219687875150059}}
{"timestamp": "2026-02-16T17:03:13.457000+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i0_p4_623584068", "generation": 12, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22185006579734193, "novelty_bonus": 0.25138613993252834, "total_score": 0.5273212935251865, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts and leaf fraction in a\n    compact, interpretable way.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base estimate: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.109189\nbelow_train_threshold: train_signal=0.052197\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and leaf fraction.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    # Base estimate: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and leaf fraction.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    # Base estimate: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T17:04:24.448853+00:00", "event_type": "candidate_rejected", "payload": {"generation": 12, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.190108", "model_name": "gpt-oss:20b", "train_signal": 0.1901080432172869}}
{"timestamp": "2026-02-16T17:06:13.227914+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i1_p1_219703128", "generation": 12, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22078856477659164, "novelty_bonus": 0.25138613993252834, "total_score": 0.5271089933210366, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.097438\nbelow_train_threshold: train_signal=0.190108\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 1\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5 + 1e-6)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 1\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5 + 1e-6)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682437838132984, "rmse": 4.314223079243819, "mae": 3.80238605718166}}
{"timestamp": "2026-02-16T17:07:13.376777+00:00", "event_type": "candidate_rejected", "payload": {"generation": 12, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:07:13.377929+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 12, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:07:38.417773+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i1_p2_607094350", "generation": 12, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.6423529411764706, "fitness_mode": "correlation", "simplicity_score": 0.22081661192144697, "novelty_bonus": 0.29945271385978234, "total_score": 0.47518791626171714, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.097438\nbelow_train_threshold: train_signal=0.190108\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport math\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = max(s['max_degree'], 1)\n    min_deg = max(s['min_degree'], 1)\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Base scaling with a logarithmic size factor\n    base = (n ** 0.5) * math.log(n + 1) / (avg_deg ** 0.5)\n\n    # Reduce for high density and presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase for uneven degree distribution\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Additive contribution from triangles\n    base += triangles / (n * n + 1.0)\n\n    # Additional influence from triangle‑to‑edge ratio\n    base += 0.5 * (triangles / (m + 1.0))\n\n    # Leaf‑node fraction (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac ** 2)\n\n    # Dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal or external imports are used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for high density and presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase for uneven degree distribution\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Additional influence from triangle‑to‑edge ratio\n    base += 0.5 * (triangles / (m + 1.0))\n\n    # 8. Leaf‑node fraction (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac ** 2)\n\n    # 9. Dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal or external imports are used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for high density and presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase for uneven degree distribution\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Additional influence from triangle‑to‑edge ratio\n    base += 0.5 * (triangles / (m + 1.0))\n\n    # 8. Leaf‑node fraction (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac ** 2)\n\n    # 9. Dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.6823775594389861, "pearson": 0.7250839442373593, "rmse": 4.405404423718175, "mae": 4.057224166952404}}
{"timestamp": "2026-02-16T17:07:38.418555+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 12, "island_id": 1, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:10:33.731898+00:00", "event_type": "candidate_rejected", "payload": {"generation": 12, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.285570", "model_name": "gpt-oss:20b", "train_signal": 0.2855702280912365}}
{"timestamp": "2026-02-16T17:12:11.480469+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i1_p4_286221246", "generation": 12, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22165548823651432, "novelty_bonus": 0.25138613993252834, "total_score": 0.527282378013021, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.190108\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.285570\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T17:12:48.505354+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i2_p0_214944275", "generation": 12, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8703481392557022, "fitness_mode": "correlation", "simplicity_score": 0.12014998537255803, "novelty_bonus": 0.22480670279544235, "total_score": 0.53484109214025, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the effect of density, clustering, transitivity, degree\n    heterogeneity, assortativity, the presence of very low‑degree vertices\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'density' (float, 0–1)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Minimum‑degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)  # larger when min_deg is small\n\n    # Degree‑heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle‑density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nbelow_novelty_threshold: novelty_bonus=0.147697\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effect of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Minimum‑degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)\n\n    # Degree‑heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle‑density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = 0\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n    tri_ratio = 0.0\n    if possible_tri > 0:\n        tri_ratio = num_tri / possible_tri\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effect of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Minimum‑degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)\n\n    # Degree‑heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle‑density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = 0\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n    tri_ratio = 0.0\n    if possible_tri > 0:\n        tri_ratio = num_tri / possible_tri\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )", "spearman": 0.8867381684542115, "pearson": 0.8658662523669716, "rmse": 12.25504673775109, "mae": 10.291301689150124}}
{"timestamp": "2026-02-16T17:13:29.517356+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i2_p1_603953285", "generation": 12, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8622809123649459, "fitness_mode": "correlation", "simplicity_score": 0.12049740835297465, "novelty_bonus": 0.2439650011795802, "total_score": 0.537219980299426, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the effect of density, clustering, transitivity, degree\n    heterogeneity, assortativity, the presence of very low‑degree vertices\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'density' (float, 0–1)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Minimum‑degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)  # larger when min_deg is small\n\n    # Degree‑heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle‑density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nbelow_novelty_threshold: novelty_bonus=0.147697\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)", "spearman": 0.8798619965499139, "pearson": 0.856530736217558, "rmse": 10.889728766202964, "mae": 9.3389863953469}}
{"timestamp": "2026-02-16T17:14:15.368454+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i2_p2_382433378", "generation": 12, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7699879951980793, "fitness_mode": "correlation", "simplicity_score": 0.11543214670134905, "novelty_bonus": 0.21324229524291283, "total_score": 0.4875301296884381, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the effect of density, clustering, transitivity, degree\n    heterogeneity, assortativity, the presence of very low‑degree vertices\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'density' (float, 0–1)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Minimum‑degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)  # larger when min_deg is small\n\n    # Degree‑heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle‑density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.073628\nbelow_novelty_threshold: novelty_bonus=0.147697\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic is a multiplicative model that starts from a\n    simple random‑graph baseline and applies correction factors for\n    density, clustering, transitivity, degree heterogeneity, assortativity,\n    extreme degree values, leaf nodes and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float)\n            - 'transitivity' (float)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Min‑degree factor (very low min degree can lengthen paths)\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)\n\n    # Max‑degree factor (high max relative to avg indicates hubs that shorten paths)\n    max_deg = s.get('max_degree', avg_deg)\n    max_factor = 1.0 + (max_deg - avg_deg) / avg_deg if avg_deg > 0 else 1.0\n\n    # Degree heterogeneity factor (more heterogeneous → shorter paths)\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / avg_deg if avg_deg > 0 else 1.0)\n\n    # Density factor (denser graphs → shorter paths)\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors (higher values tend to increase path lengths)\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + trans\n\n    # Assortativity factor (more assortative → longer paths)\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle density factor (more triangles → shorter paths)\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 0.0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Leaf (degree‑1) node factor (many leaves tend to increase path lengths)\n    degrees = s.get('degrees', [])\n    leaf_count = sum(1 for d in degrees if d == 1)\n    leaf_ratio = leaf_count / len(degrees) if degrees else 0.0\n    leaf_factor = 1.0 + leaf_ratio\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * max_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * leaf_factor\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic is a multiplicative model that starts from a\n    simple random‑graph baseline and applies correction factors for\n    density, clustering, transitivity, degree heterogeneity, assortativity,\n    extreme degree values, leaf nodes and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int)\n            - 'min_degree' (int)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float)\n            - 'transitivity' (float)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)          # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Min‑degree factor (very low min degree can lengthen paths)\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)\n\n    # Max‑degree factor (high max relative to avg indicates hubs that shorten paths)\n    max_deg = s.get('max_degree', avg_deg)\n    max_factor = 1.0 + (max_deg - avg_deg) / avg_deg if avg_deg > 0 else 1.0\n\n    # Degree heterogeneity factor (more heterogeneous → shorter paths)\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / avg_deg if avg_deg > 0 else 1.0)\n\n    # Density factor (denser graphs → shorter paths)\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors (higher values tend to increase path lengths)\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    trans = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + trans\n\n    # Assortativity factor (more assortative → longer paths)\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle density factor (more triangles → shorter paths)\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 0.0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Leaf (degree‑1) node factor (many leaves tend to increase path lengths)\n    degrees = s.get('degrees', [])\n    leaf_count = sum(1 for d in degrees if d == 1)\n    leaf_ratio = leaf_count / len(degrees) if degrees else 0.0\n    leaf_factor = 1.0 + leaf_ratio\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * max_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * leaf_factor\n    )", "spearman": 0.8009420235505889, "pearson": 0.5787875133134461, "rmse": 69.26880810503226, "mae": 35.25488836447322}}
{"timestamp": "2026-02-16T17:15:12.624366+00:00", "event_type": "candidate_rejected", "payload": {"generation": 12, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.214118", "model_name": "gpt-oss:20b", "train_signal": 0.21411764705882352}}
{"timestamp": "2026-02-16T17:16:02.140421+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i2_p4_553053517", "generation": 12, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7846818727490995, "fitness_mode": "correlation", "simplicity_score": 0.11824246151894066, "novelty_bonus": 0.3115780132253101, "total_score": 0.4908029882986819, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the effect of density, clustering, transitivity, degree\n    heterogeneity, assortativity, the presence of very low‑degree vertices\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'density' (float, 0–1)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Minimum‑degree factor: very low min degree can lengthen paths\n    min_deg = s.get('min_degree', avg_deg)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)  # larger when min_deg is small\n\n    # Degree‑heterogeneity factor: more heterogeneous degrees → shorter paths\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Density factor: denser graphs → shorter paths\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Clustering and transitivity factors: higher values → longer paths\n    clustering = s.get('avg_clustering', 0.0)\n    clustering_factor = 1.0 + clustering\n    transitivity = s.get('transitivity', 0.0)\n    trans_factor = 1.0 + transitivity\n\n    # Assortativity factor: more assortative → longer paths\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Triangle‑density factor: more triangles → shorter paths\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n    )\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.073628\nbelow_novelty_threshold: novelty_bonus=0.147697\nbelow_train_threshold: train_signal=0.214118\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest path length from pre‑computed\n    graph statistics.  The formula starts from a random‑graph baseline and\n    applies a set of multiplicative corrections that capture the influence of\n    degree heterogeneity, low‑degree vertices, graph density, clustering,\n    transitivity, assortativity, triangle density and the presence of hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed features.  Expected keys:\n            - 'n'                 (int)\n            - 'm'                 (int)\n            - 'density'           (float)\n            - 'avg_degree'        (float)\n            - 'max_degree'        (int)\n            - 'min_degree'        (int)\n            - 'std_degree'        (float)\n            - 'avg_clustering'    (float)\n            - 'transitivity'      (float)\n            - 'degree_assortativity' (float)\n            - 'num_triangles'     (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)  # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Factor for very low minimum degree\n    min_deg = max(s.get('min_degree', 1), 1)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)\n\n    # Factor for degree heterogeneity (high std → hubs → shorter paths)\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Factor for graph density (denser → shorter paths)\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Factors for clustering and transitivity (higher → longer paths)\n    clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    clustering_factor = 1.0 + clustering\n    trans_factor = 1.0 + transitivity\n\n    # Factor for assortativity (more assortative → longer paths)\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Factor for triangle density (more triangles → shorter paths)\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Factor for maximum degree (high hubs → shorter paths)\n    max_deg = s.get('max_degree', avg_deg)\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * max_factor\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest path length from pre‑computed\n    graph statistics.  The formula starts from a random‑graph baseline and\n    applies a set of multiplicative corrections that capture the influence of\n    degree heterogeneity, low‑degree vertices, graph density, clustering,\n    transitivity, assortativity, triangle density and the presence of hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed features.  Expected keys:\n            - 'n'                 (int)\n            - 'm'                 (int)\n            - 'density'           (float)\n            - 'avg_degree'        (float)\n            - 'max_degree'        (int)\n            - 'min_degree'        (int)\n            - 'std_degree'        (float)\n            - 'avg_clustering'    (float)\n            - 'transitivity'      (float)\n            - 'degree_assortativity' (float)\n            - 'num_triangles'     (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)  # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Factor for very low minimum degree\n    min_deg = max(s.get('min_degree', 1), 1)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)\n\n    # Factor for degree heterogeneity (high std → hubs → shorter paths)\n    std_deg = s.get('std_degree', 0.0)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Factor for graph density (denser → shorter paths)\n    density = s.get('density', 0.0)\n    density_factor = 1.0 / (1.0 + density)\n\n    # Factors for clustering and transitivity (higher → longer paths)\n    clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    clustering_factor = 1.0 + clustering\n    trans_factor = 1.0 + transitivity\n\n    # Factor for assortativity (more assortative → longer paths)\n    assort = s.get('degree_assortativity', 0.0)\n    assort_factor = 1.0 + abs(assort)\n\n    # Factor for triangle density (more triangles → shorter paths)\n    num_tri = s.get('num_triangles', 0)\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Factor for maximum degree (high hubs → shorter paths)\n    max_deg = s.get('max_degree', avg_deg)\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # Combine all factors\n    return (\n        base\n        * min_factor\n        * hetero_factor\n        * density_factor\n        * clustering_factor\n        * trans_factor\n        * assort_factor\n        * tri_factor\n        * max_factor\n    )", "spearman": 0.7473621840546015, "pearson": 0.7060600514550663, "rmse": 2.9020899910627054, "mae": 1.9793292965000457}}
{"timestamp": "2026-02-16T17:17:00.136638+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i3_p0_931955958", "generation": 12, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6750060024009603, "fitness_mode": "correlation", "simplicity_score": 0.17937881696235647, "novelty_bonus": 0.33783903632883716, "total_score": 0.4743301518580616, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The estimate is a product of a size‑to‑edge baseline and\n    multiplicative corrections that reflect degree heterogeneity, clustering,\n    transitivity, assortativity, density, and triangle density.  No external\n    libraries or graph traversal algorithms are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of global graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n\n    Returns\n    -------\n    float\n        A numerical estimate that correlates with the graph's average\n        shortest path length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n\n    # Baseline based on size and sparsity\n    base = (n + 1.0) / (m + 1.0)\n\n    # Heterogeneity factor: influence of high‑degree hubs\n    hub_factor = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Clustering and transitivity corrections\n    clust_factor = 1.0 + avg_clust\n    trans_factor = 1.0 + trans\n\n    # Assortativity effect\n    assort_factor = 1.0 + abs(assort)\n\n    # Density and degree variability adjustments\n    density_factor = 1.0 / (1.0 + density)\n    std_factor = 1.0 / (1.0 + std_deg)\n\n    # Influence of minimum degree (captures bottlenecks)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle density effect\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    estimate = (\n        base *\n        hub_factor *\n        clust_factor *\n        trans_factor *\n        assort_factor *\n        density_factor *\n        std_factor *\n        min_factor *\n        tri_factor\n    )\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only pre‑computed graph\n    statistics.  The formula is a product of a size–to‑degree baseline and\n    multiplicative factors that capture clustering, density, degree heterogeneity,\n    assortativity, the range of degrees and triangle density.  No graph\n    traversal or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with at least the following keys:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n        - 'degrees' (list of int)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Pull values with defaults for safety\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    density = float(s.get('density', 0.0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    max_deg = float(s.get('max_degree', 0.0))\n    min_deg = float(s.get('min_degree', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    num_tri = float(s.get('num_triangles', 0.0))\n\n    # Avoid division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n\n    # Size‑to‑average‑degree baseline (random‑graph intuition)\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust     = 1.0 + avg_clust\n    f_trans     = 1.0 + trans\n    f_assort    = 1.0 + abs(assort)\n    f_density   = 1.0 / (1.0 + density)\n    f_std       = 1.0 / (1.0 + std_deg)\n    f_min       = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle‑density adjustment (larger triangles → shorter paths)\n    tri_factor  = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri       = 1.0 + tri_factor\n\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_tri\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.123558\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only the pre‑computed\n    graph statistics supplied in *s*.  The estimate is built from a baseline\n    derived from the size and mean degree, multiplied by several factors that\n    encode clustering, density, degree heterogeneity, assortativity,\n    extreme degree values and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing at least the following keys:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int or float)\n        - min_degree (int or float)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int or float)\n\n    Returns\n    -------\n    float\n        Numerical estimate of the graph's average shortest‑path length.\n    \"\"\"\n    # Retrieve values with fallbacks\n    n          = s.get('n', 1)\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 0.0)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure non‑zero average degree for stability\n    if avg_deg == 0:\n        avg_deg = 1e-12\n\n    # ---------- Baseline ----------\n    # Random‑graph intuition: more nodes or fewer edges → longer paths\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # ---------- Multiplicative corrections ----------\n    # Clustering: higher clustering tends to lengthen paths\n    f_clust = 1.0 + avg_clust\n\n    # Transitivity: similar effect as clustering\n    f_trans = 1.0 + trans\n\n    # Assortativity: stronger degree mixing also lengthens typical paths\n    f_assort = 1.0 + abs(assort)\n\n    # Density: denser graphs shrink the diameter\n    f_density = 1.0 / (1.0 + density)\n\n    # Standard deviation of degree: more homogeneous degree distribution\n    # tends to increase the average path length compared to heterogeneous graphs\n    f_std = 1.0 / (1.0 + std_deg)\n\n    # Minimum degree: a very low minimum degree creates bottlenecks\n    f_min = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Maximum degree (hub influence): high hubs reduce path length\n    f_hub = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangle density: more triangles typically shorten paths\n    tri_root = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri = 1.0 + tri_root\n\n    # ---------- Assemble estimate ----------\n    estimate = (base *\n                f_clust *\n                f_trans *\n                f_assort *\n                f_density *\n                f_std *\n                f_min *\n                f_hub *\n                f_tri)\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only the pre‑computed\n    graph statistics supplied in *s*.  The estimate is built from a baseline\n    derived from the size and mean degree, multiplied by several factors that\n    encode clustering, density, degree heterogeneity, assortativity,\n    extreme degree values and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing at least the following keys:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int or float)\n        - min_degree (int or float)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int or float)\n\n    Returns\n    -------\n    float\n        Numerical estimate of the graph's average shortest‑path length.\n    \"\"\"\n    # Retrieve values with fallbacks\n    n          = s.get('n', 1)\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    max_deg    = s.get('max_degree', 0.0)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure non‑zero average degree for stability\n    if avg_deg == 0:\n        avg_deg = 1e-12\n\n    # ---------- Baseline ----------\n    # Random‑graph intuition: more nodes or fewer edges → longer paths\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # ---------- Multiplicative corrections ----------\n    # Clustering: higher clustering tends to lengthen paths\n    f_clust = 1.0 + avg_clust\n\n    # Transitivity: similar effect as clustering\n    f_trans = 1.0 + trans\n\n    # Assortativity: stronger degree mixing also lengthens typical paths\n    f_assort = 1.0 + abs(assort)\n\n    # Density: denser graphs shrink the diameter\n    f_density = 1.0 / (1.0 + density)\n\n    # Standard deviation of degree: more homogeneous degree distribution\n    # tends to increase the average path length compared to heterogeneous graphs\n    f_std = 1.0 / (1.0 + std_deg)\n\n    # Minimum degree: a very low minimum degree creates bottlenecks\n    f_min = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Maximum degree (hub influence): high hubs reduce path length\n    f_hub = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangle density: more triangles typically shorten paths\n    tri_root = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri = 1.0 + tri_root\n\n    # ---------- Assemble estimate ----------\n    estimate = (base *\n                f_clust *\n                f_trans *\n                f_assort *\n                f_density *\n                f_std *\n                f_min *\n                f_hub *\n                f_tri)\n\n    return estimate", "spearman": 0.6742053551338784, "pearson": 0.7252229483917171, "rmse": 9.106997672149722, "mae": 7.018597765592417}}
{"timestamp": "2026-02-16T17:17:44.216705+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i3_p1_921505815", "generation": 12, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.7013205282112844, "fitness_mode": "correlation", "simplicity_score": 0.15593600614794592, "novelty_bonus": 0.16804170104252603, "total_score": 0.4658410675762478, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The estimate is a product of a size‑to‑edge baseline and\n    multiplicative corrections that reflect degree heterogeneity, clustering,\n    transitivity, assortativity, density, and triangle density.  No external\n    libraries or graph traversal algorithms are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of global graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n\n    Returns\n    -------\n    float\n        A numerical estimate that correlates with the graph's average\n        shortest path length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n\n    # Baseline based on size and sparsity\n    base = (n + 1.0) / (m + 1.0)\n\n    # Heterogeneity factor: influence of high‑degree hubs\n    hub_factor = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Clustering and transitivity corrections\n    clust_factor = 1.0 + avg_clust\n    trans_factor = 1.0 + trans\n\n    # Assortativity effect\n    assort_factor = 1.0 + abs(assort)\n\n    # Density and degree variability adjustments\n    density_factor = 1.0 / (1.0 + density)\n    std_factor = 1.0 / (1.0 + std_deg)\n\n    # Influence of minimum degree (captures bottlenecks)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle density effect\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    estimate = (\n        base *\n        hub_factor *\n        clust_factor *\n        trans_factor *\n        assort_factor *\n        density_factor *\n        std_factor *\n        min_factor *\n        tri_factor\n    )\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only pre‑computed graph\n    statistics.  The formula is a product of a size–to‑degree baseline and\n    multiplicative factors that capture clustering, density, degree heterogeneity,\n    assortativity, the range of degrees and triangle density.  No graph\n    traversal or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with at least the following keys:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n        - 'degrees' (list of int)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Pull values with defaults for safety\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    density = float(s.get('density', 0.0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    max_deg = float(s.get('max_degree', 0.0))\n    min_deg = float(s.get('min_degree', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    num_tri = float(s.get('num_triangles', 0.0))\n\n    # Avoid division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n\n    # Size‑to‑average‑degree baseline (random‑graph intuition)\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust     = 1.0 + avg_clust\n    f_trans     = 1.0 + trans\n    f_assort    = 1.0 + abs(assort)\n    f_density   = 1.0 / (1.0 + density)\n    f_std       = 1.0 / (1.0 + std_deg)\n    f_min       = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle‑density adjustment (larger triangles → shorter paths)\n    tri_factor  = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri       = 1.0 + tri_factor\n\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_tri\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.123558\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph\n    statistics only.  The formula is a product of a size‑to‑edge baseline\n    and several multiplicative corrections that capture clustering,\n    density, degree heterogeneity, assortativity, degree range, and\n    triangle density.  No graph traversal or external libraries are\n    required.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - n (int): node count\n            - m (int): edge count\n            - density (float)\n            - avg_degree (float)\n            - max_degree (int or float)\n            - min_degree (int or float)\n            - std_degree (float)\n            - avg_clustering (float)\n            - transitivity (float)\n            - degree_assortativity (float)\n            - num_triangles (int or float)\n\n    Returns\n    -------\n    float\n        An estimate that correlates with the graph's average shortest\n        path length.\n    \"\"\"\n    # Cast to float for safety\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    avg_deg = float(s['avg_degree'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    std_deg = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n\n    # Avoid division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n\n    # Baseline based on graph size and edge count\n    base = (n + 1.0) / (m + 1.0)\n\n    # Corrections for structural properties\n    f_clust   = 1.0 + avg_clust\n    f_trans   = 1.0 + trans\n    f_assort  = 1.0 + abs(assort)\n    f_density = 1.0 / (1.0 + density)\n    f_std     = 1.0 / (1.0 + std_deg)\n    f_min     = 1.0 / (1.0 + min_deg / (avg_deg + 1e-9))\n    f_max     = 1.0 + (max_deg / (avg_deg + 1e-9)) ** 0.5\n    f_tri     = 1.0 + (num_tri ** 0.5) / ((n ** 0.5) if n > 0 else 1.0)\n\n    # Combine everything\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_max *\n        f_tri\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph\n    statistics only.  The formula is a product of a size‑to‑edge baseline\n    and several multiplicative corrections that capture clustering,\n    density, degree heterogeneity, assortativity, degree range, and\n    triangle density.  No graph traversal or external libraries are\n    required.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - n (int): node count\n            - m (int): edge count\n            - density (float)\n            - avg_degree (float)\n            - max_degree (int or float)\n            - min_degree (int or float)\n            - std_degree (float)\n            - avg_clustering (float)\n            - transitivity (float)\n            - degree_assortativity (float)\n            - num_triangles (int or float)\n\n    Returns\n    -------\n    float\n        An estimate that correlates with the graph's average shortest\n        path length.\n    \"\"\"\n    # Cast to float for safety\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    avg_deg = float(s['avg_degree'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    std_deg = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n\n    # Avoid division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n\n    # Baseline based on graph size and edge count\n    base = (n + 1.0) / (m + 1.0)\n\n    # Corrections for structural properties\n    f_clust   = 1.0 + avg_clust\n    f_trans   = 1.0 + trans\n    f_assort  = 1.0 + abs(assort)\n    f_density = 1.0 / (1.0 + density)\n    f_std     = 1.0 / (1.0 + std_deg)\n    f_min     = 1.0 / (1.0 + min_deg / (avg_deg + 1e-9))\n    f_max     = 1.0 + (max_deg / (avg_deg + 1e-9)) ** 0.5\n    f_tri     = 1.0 + (num_tri ** 0.5) / ((n ** 0.5) if n > 0 else 1.0)\n\n    # Combine everything\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_max *\n        f_tri\n    )\n\n    return float(estimate)", "spearman": 0.7684827120678017, "pearson": 0.7338006789334834, "rmse": 2.0919920713184963, "mae": 2.001479723944934}}
{"timestamp": "2026-02-16T17:18:23.878435+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i3_p2_494967645", "generation": 12, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6277551020408163, "fitness_mode": "correlation", "simplicity_score": 0.1562183595911984, "novelty_bonus": 0.2535778511270258, "total_score": 0.4268032644122763, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The estimate is a product of a size‑to‑edge baseline and\n    multiplicative corrections that reflect degree heterogeneity, clustering,\n    transitivity, assortativity, density, and triangle density.  No external\n    libraries or graph traversal algorithms are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of global graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n\n    Returns\n    -------\n    float\n        A numerical estimate that correlates with the graph's average\n        shortest path length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n\n    # Baseline based on size and sparsity\n    base = (n + 1.0) / (m + 1.0)\n\n    # Heterogeneity factor: influence of high‑degree hubs\n    hub_factor = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Clustering and transitivity corrections\n    clust_factor = 1.0 + avg_clust\n    trans_factor = 1.0 + trans\n\n    # Assortativity effect\n    assort_factor = 1.0 + abs(assort)\n\n    # Density and degree variability adjustments\n    density_factor = 1.0 / (1.0 + density)\n    std_factor = 1.0 / (1.0 + std_deg)\n\n    # Influence of minimum degree (captures bottlenecks)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle density effect\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    estimate = (\n        base *\n        hub_factor *\n        clust_factor *\n        trans_factor *\n        assort_factor *\n        density_factor *\n        std_factor *\n        min_factor *\n        tri_factor\n    )\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only pre‑computed graph\n    statistics.  The formula is a product of a size–to‑degree baseline and\n    multiplicative factors that capture clustering, density, degree heterogeneity,\n    assortativity, the range of degrees and triangle density.  No graph\n    traversal or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with at least the following keys:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n        - 'degrees' (list of int)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Pull values with defaults for safety\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    density = float(s.get('density', 0.0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    max_deg = float(s.get('max_degree', 0.0))\n    min_deg = float(s.get('min_degree', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    num_tri = float(s.get('num_triangles', 0.0))\n\n    # Avoid division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n\n    # Size‑to‑average‑degree baseline (random‑graph intuition)\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust     = 1.0 + avg_clust\n    f_trans     = 1.0 + trans\n    f_assort    = 1.0 + abs(assort)\n    f_density   = 1.0 / (1.0 + density)\n    f_std       = 1.0 / (1.0 + std_deg)\n    f_min       = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle‑density adjustment (larger triangles → shorter paths)\n    tri_factor  = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri       = 1.0 + tri_factor\n\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_tri\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.123558\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        A dictionary containing the following keys (values are floats or ints):\n            - 'n'                     : number of nodes\n            - 'm'                     : number of edges\n            - 'density'               : density of the graph\n            - 'avg_degree'            : average node degree\n            - 'max_degree'            : maximum degree\n            - 'min_degree'            : minimum degree\n            - 'std_degree'            : standard deviation of the degree sequence\n            - 'avg_clustering'        : average clustering coefficient\n            - 'transitivity'          : transitivity of the graph\n            - 'degree_assortativity'  : degree assortativity coefficient\n            - 'num_triangles'         : number of triangles\n            - 'degrees'               : sorted list of node degrees\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Grab features with defaults; keep everything as float for safety\n    n          = float(s.get('n', 1))\n    m          = float(s.get('m', 0))\n    density    = float(s.get('density', 0.0))\n    avg_deg    = float(s.get('avg_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    min_deg    = float(s.get('min_degree', 0.0))\n    avg_clust  = float(s.get('avg_clustering', 0.0))\n    trans      = float(s.get('transitivity', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Avoid divisions by zero\n    if avg_deg == 0:\n        avg_deg = 1e-12\n    if min_deg == 0:\n        min_deg = 1e-12\n\n    # Baseline: size over sparsity\n    base = n / (m + 1)\n\n    # Corrections reflecting structural properties\n    clust_factor   = 1.0 + avg_clust\n    trans_factor   = 1.0 + trans\n    assort_factor  = 1.0 + abs(assort)\n    density_factor = 1.0 / (1.0 + density)\n    hetero_factor  = 1.0 + (std_deg / (avg_deg + 1e-9))\n    min_factor     = 1.0 + (1.0 / (min_deg + 1e-9))\n    tri_factor     = 1.0 + ((num_tri ** 0.5) / (n ** 0.5 + 1e-9))\n\n    # Combine everything into a single estimate\n    estimate = (\n        base *\n        clust_factor *\n        trans_factor *\n        assort_factor *\n        density_factor *\n        hetero_factor *\n        min_factor *\n        tri_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        A dictionary containing the following keys (values are floats or ints):\n            - 'n'                     : number of nodes\n            - 'm'                     : number of edges\n            - 'density'               : density of the graph\n            - 'avg_degree'            : average node degree\n            - 'max_degree'            : maximum degree\n            - 'min_degree'            : minimum degree\n            - 'std_degree'            : standard deviation of the degree sequence\n            - 'avg_clustering'        : average clustering coefficient\n            - 'transitivity'          : transitivity of the graph\n            - 'degree_assortativity'  : degree assortativity coefficient\n            - 'num_triangles'         : number of triangles\n            - 'degrees'               : sorted list of node degrees\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Grab features with defaults; keep everything as float for safety\n    n          = float(s.get('n', 1))\n    m          = float(s.get('m', 0))\n    density    = float(s.get('density', 0.0))\n    avg_deg    = float(s.get('avg_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    min_deg    = float(s.get('min_degree', 0.0))\n    avg_clust  = float(s.get('avg_clustering', 0.0))\n    trans      = float(s.get('transitivity', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Avoid divisions by zero\n    if avg_deg == 0:\n        avg_deg = 1e-12\n    if min_deg == 0:\n        min_deg = 1e-12\n\n    # Baseline: size over sparsity\n    base = n / (m + 1)\n\n    # Corrections reflecting structural properties\n    clust_factor   = 1.0 + avg_clust\n    trans_factor   = 1.0 + trans\n    assort_factor  = 1.0 + abs(assort)\n    density_factor = 1.0 / (1.0 + density)\n    hetero_factor  = 1.0 + (std_deg / (avg_deg + 1e-9))\n    min_factor     = 1.0 + (1.0 / (min_deg + 1e-9))\n    tri_factor     = 1.0 + ((num_tri ** 0.5) / (n ** 0.5 + 1e-9))\n\n    # Combine everything into a single estimate\n    estimate = (\n        base *\n        clust_factor *\n        trans_factor *\n        assort_factor *\n        density_factor *\n        hetero_factor *\n        min_factor *\n        tri_factor\n    )\n\n    return float(estimate)", "spearman": 0.6389724743118578, "pearson": 0.6934969249326363, "rmse": 1.5331897161789707, "mae": 1.1367416805408495}}
{"timestamp": "2026-02-16T17:19:10.326812+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i3_p3_211181723", "generation": 12, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.4502761104441776, "fitness_mode": "correlation", "simplicity_score": 0.15378291077244516, "novelty_bonus": 0.47324683117077915, "total_score": 0.3827658823869948, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The estimate is a product of a size‑to‑edge baseline and\n    multiplicative corrections that reflect degree heterogeneity, clustering,\n    transitivity, assortativity, density, and triangle density.  No external\n    libraries or graph traversal algorithms are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of global graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n\n    Returns\n    -------\n    float\n        A numerical estimate that correlates with the graph's average\n        shortest path length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n\n    # Baseline based on size and sparsity\n    base = (n + 1.0) / (m + 1.0)\n\n    # Heterogeneity factor: influence of high‑degree hubs\n    hub_factor = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Clustering and transitivity corrections\n    clust_factor = 1.0 + avg_clust\n    trans_factor = 1.0 + trans\n\n    # Assortativity effect\n    assort_factor = 1.0 + abs(assort)\n\n    # Density and degree variability adjustments\n    density_factor = 1.0 / (1.0 + density)\n    std_factor = 1.0 / (1.0 + std_deg)\n\n    # Influence of minimum degree (captures bottlenecks)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle density effect\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    estimate = (\n        base *\n        hub_factor *\n        clust_factor *\n        trans_factor *\n        assort_factor *\n        density_factor *\n        std_factor *\n        min_factor *\n        tri_factor\n    )\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only pre‑computed graph\n    statistics.  The formula is a product of a size–to‑degree baseline and\n    multiplicative factors that capture clustering, density, degree heterogeneity,\n    assortativity, the range of degrees and triangle density.  No graph\n    traversal or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with at least the following keys:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n        - 'degrees' (list of int)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Pull values with defaults for safety\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    density = float(s.get('density', 0.0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    max_deg = float(s.get('max_degree', 0.0))\n    min_deg = float(s.get('min_degree', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    num_tri = float(s.get('num_triangles', 0.0))\n\n    # Avoid division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n\n    # Size‑to‑average‑degree baseline (random‑graph intuition)\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust     = 1.0 + avg_clust\n    f_trans     = 1.0 + trans\n    f_assort    = 1.0 + abs(assort)\n    f_density   = 1.0 / (1.0 + density)\n    f_std       = 1.0 / (1.0 + std_deg)\n    f_min       = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle‑density adjustment (larger triangles → shorter paths)\n    tri_factor  = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri       = 1.0 + tri_factor\n\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_tri\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.123558\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing at least the following keys:\n        - 'n'                 : int\n        - 'm'                 : int\n        - 'density'           : float\n        - 'avg_degree'        : float\n        - 'max_degree'        : float\n        - 'min_degree'        : float\n        - 'std_degree'        : float\n        - 'avg_clustering'    : float\n        - 'transitivity'      : float\n        - 'degree_assortativity': float\n        - 'num_triangles'     : int\n        - 'degrees'           : list of int (sorted if desired)\n\n    Returns\n    -------\n    float\n        An estimated average shortest‑path length.  The formula uses only\n        elementary arithmetic and simple aggregations of the supplied\n        statistics; no external libraries or graph traversals are required.\n    \"\"\"\n    # ----------  basic constants and safe defaults ----------\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    density = float(s.get('density', 0.0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    max_deg = float(s.get('max_degree', 0.0))\n    min_deg = float(s.get('min_degree', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    num_tri = float(s.get('num_triangles', 0.0))\n    degrees = s.get('degrees', [])\n\n    # avoid division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n    if max_deg <= 1e-12:\n        max_deg = 1e-12\n\n    # ----------  baseline from size and sparsity ----------\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # ----------  multiplicative correction factors ----------\n    # 1. Clustering & transitivity increase path length\n    f_clust   = 1.0 + avg_clust\n    f_trans   = 1.0 + trans\n\n    # 2. Assortativity (absolute value) tends to increase diameter\n    f_assort  = 1.0 + abs(assort)\n\n    # 3. Density reduces path length\n    f_density = 1.0 / (1.0 + density)\n\n    # 4. Degree heterogeneity (std. dev.) reduces path length\n    f_std     = 1.0 / (1.0 + std_deg)\n\n    # 5. Minimum degree can create bottlenecks\n    f_min     = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # 6. Triangle density encourages shortcuts\n    tri_factor = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri     = 1.0 + tri_factor\n\n    # 7. Harmonic‑mean degree factor – reflects the effect of low‑degree\n    # vertices on the effective connectivity.\n    if degrees:\n        # harmonic mean\n        harm_sum = sum(1.0 / d for d in degrees if d > 0)\n        harm_mean = len(degrees) / harm_sum if harm_sum > 0 else 0.0\n    else:\n        harm_mean = 0.0\n    f_harm = (harm_mean + 1e-12) / (avg_deg + 1e-12)\n\n    # ----------  final estimate ----------\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_tri *\n        f_harm\n    )\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing at least the following keys:\n        - 'n'                 : int\n        - 'm'                 : int\n        - 'density'           : float\n        - 'avg_degree'        : float\n        - 'max_degree'        : float\n        - 'min_degree'        : float\n        - 'std_degree'        : float\n        - 'avg_clustering'    : float\n        - 'transitivity'      : float\n        - 'degree_assortativity': float\n        - 'num_triangles'     : int\n        - 'degrees'           : list of int (sorted if desired)\n\n    Returns\n    -------\n    float\n        An estimated average shortest‑path length.  The formula uses only\n        elementary arithmetic and simple aggregations of the supplied\n        statistics; no external libraries or graph traversals are required.\n    \"\"\"\n    # ----------  basic constants and safe defaults ----------\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    density = float(s.get('density', 0.0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    max_deg = float(s.get('max_degree', 0.0))\n    min_deg = float(s.get('min_degree', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    num_tri = float(s.get('num_triangles', 0.0))\n    degrees = s.get('degrees', [])\n\n    # avoid division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n    if max_deg <= 1e-12:\n        max_deg = 1e-12\n\n    # ----------  baseline from size and sparsity ----------\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # ----------  multiplicative correction factors ----------\n    # 1. Clustering & transitivity increase path length\n    f_clust   = 1.0 + avg_clust\n    f_trans   = 1.0 + trans\n\n    # 2. Assortativity (absolute value) tends to increase diameter\n    f_assort  = 1.0 + abs(assort)\n\n    # 3. Density reduces path length\n    f_density = 1.0 / (1.0 + density)\n\n    # 4. Degree heterogeneity (std. dev.) reduces path length\n    f_std     = 1.0 / (1.0 + std_deg)\n\n    # 5. Minimum degree can create bottlenecks\n    f_min     = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # 6. Triangle density encourages shortcuts\n    tri_factor = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri     = 1.0 + tri_factor\n\n    # 7. Harmonic‑mean degree factor – reflects the effect of low‑degree\n    # vertices on the effective connectivity.\n    if degrees:\n        # harmonic mean\n        harm_sum = sum(1.0 / d for d in degrees if d > 0)\n        harm_mean = len(degrees) / harm_sum if harm_sum > 0 else 0.0\n    else:\n        harm_mean = 0.0\n    f_harm = (harm_mean + 1e-12) / (avg_deg + 1e-12)\n\n    # ----------  final estimate ----------\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_tri *\n        f_harm\n    )\n    return float(estimate)", "spearman": 0.4200705017625441, "pearson": 0.5227529240645882, "rmse": 5.407978870420047, "mae": 3.638830954048727}}
{"timestamp": "2026-02-16T17:19:34.811691+00:00", "event_type": "candidate_rejected", "payload": {"generation": 12, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:19:34.812731+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 12, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:20:12.647664+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i3_p4_814695919", "generation": 12, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6693397358943577, "fitness_mode": "correlation", "simplicity_score": 0.15846370438987967, "novelty_bonus": 0.3493414527674029, "total_score": 0.4751518931261072, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The estimate is a product of a size‑to‑edge baseline and\n    multiplicative corrections that reflect degree heterogeneity, clustering,\n    transitivity, assortativity, density, and triangle density.  No external\n    libraries or graph traversal algorithms are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of global graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n\n    Returns\n    -------\n    float\n        A numerical estimate that correlates with the graph's average\n        shortest path length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n\n    # Baseline based on size and sparsity\n    base = (n + 1.0) / (m + 1.0)\n\n    # Heterogeneity factor: influence of high‑degree hubs\n    hub_factor = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Clustering and transitivity corrections\n    clust_factor = 1.0 + avg_clust\n    trans_factor = 1.0 + trans\n\n    # Assortativity effect\n    assort_factor = 1.0 + abs(assort)\n\n    # Density and degree variability adjustments\n    density_factor = 1.0 / (1.0 + density)\n    std_factor = 1.0 / (1.0 + std_deg)\n\n    # Influence of minimum degree (captures bottlenecks)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle density effect\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    estimate = (\n        base *\n        hub_factor *\n        clust_factor *\n        trans_factor *\n        assort_factor *\n        density_factor *\n        std_factor *\n        min_factor *\n        tri_factor\n    )\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only pre‑computed graph\n    statistics.  The formula is a product of a size–to‑degree baseline and\n    multiplicative factors that capture clustering, density, degree heterogeneity,\n    assortativity, the range of degrees and triangle density.  No graph\n    traversal or external libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with at least the following keys:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n        - 'degrees' (list of int)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Pull values with defaults for safety\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 0))\n    density = float(s.get('density', 0.0))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    max_deg = float(s.get('max_degree', 0.0))\n    min_deg = float(s.get('min_degree', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    avg_clust = float(s.get('avg_clustering', 0.0))\n    trans = float(s.get('transitivity', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    num_tri = float(s.get('num_triangles', 0.0))\n\n    # Avoid division by zero\n    if avg_deg <= 1e-12:\n        avg_deg = 1e-12\n\n    # Size‑to‑average‑degree baseline (random‑graph intuition)\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust     = 1.0 + avg_clust\n    f_trans     = 1.0 + trans\n    f_assort    = 1.0 + abs(assort)\n    f_density   = 1.0 / (1.0 + density)\n    f_std       = 1.0 / (1.0 + std_deg)\n    f_min       = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle‑density adjustment (larger triangles → shorter paths)\n    tri_factor  = (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n    f_tri       = 1.0 + tri_factor\n\n    estimate = (\n        base *\n        f_clust *\n        f_trans *\n        f_assort *\n        f_density *\n        f_std *\n        f_min *\n        f_tri\n    )\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.123558\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport math\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a handful of pre‑computed\n    global graph statistics.  The formula is a product of a random‑graph\n    baseline with multiplicative corrections that capture clustering,\n    density, degree heterogeneity, assortativity, bottleneck effects and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Graph features with at least the following keys:\n        - n (int)\n        - avg_degree (float)\n        - avg_clustering (float)\n        - density (float)\n        - std_degree (float)\n        - degree_assortativity (float)\n        - num_triangles (int or float)\n        - min_degree (int or float)\n\n    Returns\n    -------\n    float\n        A scalar that correlates with the average shortest‑path length.\n    \"\"\"\n    # Basic size‑to‑degree baseline (heuristic from random graphs)\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 0.0))\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clust = 1.0 + float(s.get('avg_clustering', 0.0))          # higher clustering → longer paths\n    dens = 1.0 / (1.0 + float(s.get('density', 0.0)))           # denser graphs → shorter paths\n    std = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))         # heterogeneous degrees → shorter paths\n    assort = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))# assortative mixing → longer paths\n\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck = 1.0 / (1.0 + min_deg / max(avg_deg, 1e-12))    # very small min degree lengthens paths\n\n    num_tri = float(s.get('num_triangles', 0.0))\n    tri_factor = 1.0 + (math.sqrt(num_tri) if num_tri > 0 else 0.0) / (math.sqrt(n) if n > 0 else 1.0)\n\n    estimate = base * clust * dens * std * assort * bottleneck * tri_factor\n    return float(estimate)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a handful of pre‑computed\n    global graph statistics.  The formula combines a random‑graph baseline\n    with multiplicative corrections that reflect clustering, density,\n    degree heterogeneity, assortativity, bottleneck effects and triangle\n    density.  It uses only built‑in arithmetic and avoids external\n    libraries or graph traversals.\n\n    Parameters\n    ----------\n    s : dict\n        Graph features with keys:\n        - n (int)\n        - avg_degree (float)\n        - avg_clustering (float)\n        - density (float)\n        - std_degree (float)\n        - degree_assortativity (float)\n        - num_triangles (int or float)\n        - min_degree (int or float)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 0.0))\n\n    # Random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = (n + 1.0) / (max(avg_deg, 1e-12) + 1.0)\n\n    # Multiplicative corrections\n    clust = 1.0 + float(s.get('avg_clustering', 0.0))              # higher clustering → longer paths\n    dens = 1.0 / (1.0 + float(s.get('density', 0.0)))              # denser graphs → shorter paths\n    std = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))            # heterogeneous degrees → shorter paths\n    assort = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))   # assortative mixing → longer paths\n\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck = 1.0 / (1.0 + min_deg / max(avg_deg, 1e-12))       # very small min degree lengthens paths\n\n    num_tri = float(s.get('num_triangles', 0.0))\n    tri_factor = 1.0 + (num_tri**0.5) / (n**0.5 if n > 0 else 1.0)   # larger triangles → shorter paths\n\n    estimate = base * clust * dens * std * assort * bottleneck * tri_factor\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a handful of pre‑computed\n    global graph statistics.  The formula combines a random‑graph baseline\n    with multiplicative corrections that reflect clustering, density,\n    degree heterogeneity, assortativity, bottleneck effects and triangle\n    density.  It uses only built‑in arithmetic and avoids external\n    libraries or graph traversals.\n\n    Parameters\n    ----------\n    s : dict\n        Graph features with keys:\n        - n (int)\n        - avg_degree (float)\n        - avg_clustering (float)\n        - density (float)\n        - std_degree (float)\n        - degree_assortativity (float)\n        - num_triangles (int or float)\n        - min_degree (int or float)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 0.0))\n\n    # Random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = (n + 1.0) / (max(avg_deg, 1e-12) + 1.0)\n\n    # Multiplicative corrections\n    clust = 1.0 + float(s.get('avg_clustering', 0.0))              # higher clustering → longer paths\n    dens = 1.0 / (1.0 + float(s.get('density', 0.0)))              # denser graphs → shorter paths\n    std = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))            # heterogeneous degrees → shorter paths\n    assort = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))   # assortative mixing → longer paths\n\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck = 1.0 / (1.0 + min_deg / max(avg_deg, 1e-12))       # very small min degree lengthens paths\n\n    num_tri = float(s.get('num_triangles', 0.0))\n    tri_factor = 1.0 + (num_tri**0.5) / (n**0.5 if n > 0 else 1.0)   # larger triangles → shorter paths\n\n    estimate = base * clust * dens * std * assort * bottleneck * tri_factor\n    return float(estimate)", "spearman": 0.6773134328358209, "pearson": 0.6649092358398943, "rmse": 3.6888623989548917, "mae": 2.7540966912754192}}
{"timestamp": "2026-02-16T17:20:12.648347+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 12, "island_id": 3, "population_idx": 4, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:20:12.653762+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 13, "model_name": "gpt-oss:20b", "best_val_score": 0.5376982263149925, "no_improve_count": 5}}
{"timestamp": "2026-02-16T17:21:23.971819+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.010324", "model_name": "gpt-oss:20b", "train_signal": 0.010324129651860744}}
{"timestamp": "2026-02-16T17:21:53.910483+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:21:53.911620+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 13, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:23:59.369899+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i0_p1_317419067", "generation": 13, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.8473949579831932, "fitness_mode": "correlation", "simplicity_score": 0.22137394722358028, "novelty_bonus": 0.1695072376809419, "total_score": 0.5366959999749793, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.109189\nbelow_train_threshold: train_signal=0.052197\nbelow_train_threshold: train_signal=0.010324\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    # 9. Small logarithmic bias for very large graphs\n    base += 0.05 * np.log(n + 1)\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base", "spearman": 0.8831380784519614, "pearson": 0.8183468779684626, "rmse": 0.9984024614318124, "mae": 0.6678555369210403}}
{"timestamp": "2026-02-16T17:23:59.373242+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 13, "island_id": 0, "population_idx": 1, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:24:47.511403+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.044994", "model_name": "gpt-oss:20b", "train_signal": 0.04499399759903961}}
{"timestamp": "2026-02-16T17:26:28.494250+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i0_p3_652173818", "generation": 13, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22191621004497614, "novelty_bonus": 0.25138613993252834, "total_score": 0.5273345223747135, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.010324\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.044994\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T17:29:31.911314+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.018776", "model_name": "gpt-oss:20b", "train_signal": 0.018775510204081632}}
{"timestamp": "2026-02-16T17:30:35.431179+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i1_p0_462945405", "generation": 13, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.8499879951980791, "fitness_mode": "correlation", "simplicity_score": 0.2209014926046282, "novelty_bonus": 0.17239314934924, "total_score": 0.4757279890693413, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.190108\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.285570\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula merges the strengths of two high‑performing heuristics:\n    - A size/degree scaling (sqrt(n)/sqrt(avg_degree)) combined with a\n      density/edge‑count adjustment (n/(m+1)).\n    - A rich set of corrections for degree heterogeneity, clustering,\n      transitivity, assortativity, triangles, leaf nodes and very dense\n      regimes.\n\n    No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Incorporate edge count: more edges (relative to n) shorten paths\n    base *= n / (m + 1.0)\n\n    # 3. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + m / (n + 1.0))\n\n    # 4. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 5. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 6. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 7. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 8. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 9. Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula merges the strengths of two high‑performing heuristics:\n    - A size/degree scaling (sqrt(n)/sqrt(avg_degree)) combined with a\n      density/edge‑count adjustment (n/(m+1)).\n    - A rich set of corrections for degree heterogeneity, clustering,\n      transitivity, assortativity, triangles, leaf nodes and very dense\n      regimes.\n\n    No graph traversal is performed; only arithmetic on the supplied\n    features is used.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Incorporate edge count: more edges (relative to n) shorten paths\n    base *= n / (m + 1.0)\n\n    # 3. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + m / (n + 1.0))\n\n    # 4. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 5. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 6. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 7. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 8. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 9. Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    return base", "spearman": 0.7596594914872873, "pearson": 0.5909845877219075, "rmse": 2.1858406985831182, "mae": 1.9920119604380926}}
{"timestamp": "2026-02-16T17:32:00.506057+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i1_p1_883455794", "generation": 13, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7062184873949579, "fitness_mode": "correlation", "simplicity_score": 0.22056848796131304, "novelty_bonus": 0.24369849405660138, "total_score": 0.5021523690373239, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.190108\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.285570\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = max(s['max_degree'], 1)\n    min_deg = max(s['min_degree'], 1)\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    # Edge density adjustment\n    max_edges = n * (n - 1) / 2 + 1\n    base *= (1.0 + m / max_edges)\n\n    return base", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = max(s['max_degree'], 1)\n    min_deg = max(s['min_degree'], 1)\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    # Edge density adjustment\n    max_edges = n * (n - 1) / 2 + 1\n    base *= (1.0 + m / max_edges)\n\n    return base", "spearman": 0.7698582464561615, "pearson": 0.7608551841300071, "rmse": 4.967341453643882, "mae": 4.539466444579246}}
{"timestamp": "2026-02-16T17:32:42.146683+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i1_p2_175916880", "generation": 13, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22140464171531832, "novelty_bonus": 0.25138613993252834, "total_score": 0.5272322087087818, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.190108\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.285570\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    # Extract features with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    # Extract features with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T17:34:40.639440+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: missing `new_invariant` function", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:34:40.640263+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 13, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: missing `new_invariant` function", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:35:20.930012+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i1_p3_43115653", "generation": 13, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22098750271261194, "novelty_bonus": 0.25138613993252834, "total_score": 0.5271487809082406, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.190108\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.285570\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: missing `new_invariant` function\nPrevious candidate code:\n```python\n\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 1\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density    = s['density']\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 1\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T17:35:20.931845+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 13, "island_id": 1, "population_idx": 3, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:36:22.245613+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i1_p4_551192281", "generation": 13, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22175206469573494, "novelty_bonus": 0.25138613993252834, "total_score": 0.5273016933048652, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density * density)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.285570\nno_valid_train_predictions: static_invalid: missing `new_invariant` function\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T17:37:10.398832+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:37:10.399473+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 13, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:37:36.642196+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i2_p0_384122721", "generation": 13, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7900600240096038, "fitness_mode": "correlation", "simplicity_score": 0.12443636912991796, "novelty_bonus": 0.1921365855626399, "total_score": 0.4969113590725151, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.073628\nbelow_novelty_threshold: novelty_bonus=0.147697\nbelow_train_threshold: train_signal=0.214118\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport math\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that capture\n    clustering, transitivity, density, degree heterogeneity, assortativity,\n    the presence of very low‑degree vertices, triangle density and degree\n    skewness.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n\n    # Basic random‑graph baseline\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Degree skewness\n    skew = (max_deg - min_deg) / (avg_deg + 1e-6)\n\n    # Multiplicative correction factors\n    f_cluster = (1 + clustering) ** 0.8\n    f_trans   = (1 + trans)       ** 0.8\n    f_density = (1 + density)     ** -1.0\n    f_std     = (1 + std_deg / (avg_deg + 1)) ** -0.6\n    f_assort  = (1 + abs(assort) ** 0.5)\n    f_min     = (1 + 1 / (min_deg + 1)) ** 0.5\n    f_tri     = (1 + tri_ratio)    ** -0.7\n    f_skew    = (1 + skew)          ** 0.4\n\n    return (base * f_cluster * f_trans * f_density *\n            f_std * f_assort * f_min * f_tri * f_skew)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that capture\n    clustering, transitivity, density, degree heterogeneity, assortativity,\n    the presence of very low‑degree vertices, triangle density and degree\n    skewness.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n\n    # Basic random‑graph baseline\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Degree skewness\n    skew = (max_deg - min_deg) / (avg_deg + 1e-6)\n\n    # Multiplicative correction factors\n    f_cluster = (1 + clustering) ** 0.8\n    f_trans   = (1 + trans)       ** 0.8\n    f_density = (1 + density)     ** -1.0\n    f_std     = (1 + std_deg / (avg_deg + 1)) ** -0.6\n    f_assort  = (1 + abs(assort) ** 0.5)\n    f_min     = (1 + 1 / (min_deg + 1)) ** 0.5\n    f_tri     = (1 + tri_ratio)    ** -0.7\n    f_skew    = (1 + skew)          ** 0.4\n\n    return (base * f_cluster * f_trans * f_density *\n            f_std * f_assort * f_min * f_tri * f_skew)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that capture\n    clustering, transitivity, density, degree heterogeneity, assortativity,\n    the presence of very low‑degree vertices, triangle density and degree\n    skewness.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n\n    # Basic random‑graph baseline\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Degree skewness\n    skew = (max_deg - min_deg) / (avg_deg + 1e-6)\n\n    # Multiplicative correction factors\n    f_cluster = (1 + clustering) ** 0.8\n    f_trans   = (1 + trans)       ** 0.8\n    f_density = (1 + density)     ** -1.0\n    f_std     = (1 + std_deg / (avg_deg + 1)) ** -0.6\n    f_assort  = (1 + abs(assort) ** 0.5)\n    f_min     = (1 + 1 / (min_deg + 1)) ** 0.5\n    f_tri     = (1 + tri_ratio)    ** -0.7\n    f_skew    = (1 + skew)          ** 0.4\n\n    return (base * f_cluster * f_trans * f_density *\n            f_std * f_assort * f_min * f_tri * f_skew)", "spearman": 0.8287662191554791, "pearson": 0.7540513177232515, "rmse": 24.41036807622199, "mae": 18.901873474713902}}
{"timestamp": "2026-02-16T17:37:36.642802+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 13, "island_id": 2, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:38:25.261284+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:38:25.262637+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 13, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:38:54.836270+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.078185", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:38:54.837490+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 13, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:39:27.278451+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i2_p2_895366422", "generation": 13, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8622809123649459, "fitness_mode": "correlation", "simplicity_score": 0.12024293817095602, "novelty_bonus": 0.2439650011795802, "total_score": 0.5371690862630223, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\nRecent failures:\nbelow_train_threshold: train_signal=0.214118\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.078185\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed graph features.  Expected keys:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)           # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6\n    else:\n        possible_tri = 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed graph features.  Expected keys:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)           # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6\n    else:\n        possible_tri = 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)", "spearman": 0.8798619965499139, "pearson": 0.856530736217558, "rmse": 10.889728766202964, "mae": 9.3389863953469}}
{"timestamp": "2026-02-16T17:40:05.837426+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i2_p3_789525634", "generation": 13, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8622809123649459, "fitness_mode": "correlation", "simplicity_score": 0.12049740835297465, "novelty_bonus": 0.2439650011795802, "total_score": 0.537219980299426, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\nRecent failures:\nbelow_train_threshold: train_signal=0.214118\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.078185\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic is based on a random‑graph baseline and\n    multiplicative corrections that capture the influence of clustering,\n    transitivity, density, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic is based on a random‑graph baseline and\n    multiplicative corrections that capture the influence of clustering,\n    transitivity, density, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)", "spearman": 0.8798619965499139, "pearson": 0.856530736217558, "rmse": 10.889728766202964, "mae": 9.3389863953469}}
{"timestamp": "2026-02-16T17:40:43.821748+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i2_p4_550301568", "generation": 13, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8622809123649459, "fitness_mode": "correlation", "simplicity_score": 0.12049740835297465, "novelty_bonus": 0.2439650011795802, "total_score": 0.537219980299426, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity and the presence of low‑degree\n    vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    n = s['n']\n    avg_deg = s.get('avg_degree', 1.0)\n    avg_deg = max(avg_deg, 1.0)          # avoid division by zero\n\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', 1)\n\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg)        # more heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 / (1.0 + min_deg / avg_deg)  # very low min degree can lengthen paths\n\n    return base * clustering_factor * trans_factor * density_factor * hetero_factor * assort_factor * min_factor\nRecent failures:\nbelow_train_threshold: train_signal=0.214118\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.078185\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, low‑degree vertices and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n\n    # Basic random‑graph baseline\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering\n    trans_factor       = 1.0 + trans\n    density_factor     = 1.0 / (1.0 + density)\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    assort_factor      = 1.0 + 0.5 * abs(assort)\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)\n    tri_factor         = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic blends a basic random‑graph intuition with\n    multiplicative corrections for clustering, transitivity, density,\n    degree heterogeneity, assortativity, low‑degree vertices and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n\n    # Basic random‑graph baseline\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering\n    trans_factor       = 1.0 + trans\n    density_factor     = 1.0 / (1.0 + density)\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    assort_factor      = 1.0 + 0.5 * abs(assort)\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)\n    tri_factor         = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)", "spearman": 0.8798619965499139, "pearson": 0.856530736217558, "rmse": 10.889728766202964, "mae": 9.3389863953469}}
{"timestamp": "2026-02-16T17:41:31.743445+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.085601", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:41:31.744080+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 13, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.085601", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:42:27.497459+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i3_p0_371641103", "generation": 13, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.3995678271308523, "fitness_mode": "correlation", "simplicity_score": 0.1764345127329675, "novelty_bonus": 0.4777785593736724, "total_score": 0.36397110412453937, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a handful of pre‑computed\n    global graph statistics.  The formula combines a random‑graph baseline\n    with multiplicative corrections that reflect clustering, density,\n    degree heterogeneity, assortativity, bottleneck effects and triangle\n    density.  It uses only built‑in arithmetic and avoids external\n    libraries or graph traversals.\n\n    Parameters\n    ----------\n    s : dict\n        Graph features with keys:\n        - n (int)\n        - avg_degree (float)\n        - avg_clustering (float)\n        - density (float)\n        - std_degree (float)\n        - degree_assortativity (float)\n        - num_triangles (int or float)\n        - min_degree (int or float)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 0.0))\n\n    # Random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = (n + 1.0) / (max(avg_deg, 1e-12) + 1.0)\n\n    # Multiplicative corrections\n    clust = 1.0 + float(s.get('avg_clustering', 0.0))              # higher clustering → longer paths\n    dens = 1.0 / (1.0 + float(s.get('density', 0.0)))              # denser graphs → shorter paths\n    std = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))            # heterogeneous degrees → shorter paths\n    assort = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))   # assortative mixing → longer paths\n\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck = 1.0 / (1.0 + min_deg / max(avg_deg, 1e-12))       # very small min degree lengthens paths\n\n    num_tri = float(s.get('num_triangles', 0.0))\n    tri_factor = 1.0 + (num_tri**0.5) / (n**0.5 if n > 0 else 1.0)   # larger triangles → shorter paths\n\n    estimate = base * clust * dens * std * assort * bottleneck * tri_factor\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The estimate is a product of a size‑to‑edge baseline and\n    multiplicative corrections that reflect degree heterogeneity, clustering,\n    transitivity, assortativity, density, and triangle density.  No external\n    libraries or graph traversal algorithms are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of global graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n\n    Returns\n    -------\n    float\n        A numerical estimate that correlates with the graph's average\n        shortest path length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n\n    # Baseline based on size and sparsity\n    base = (n + 1.0) / (m + 1.0)\n\n    # Heterogeneity factor: influence of high‑degree hubs\n    hub_factor = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Clustering and transitivity corrections\n    clust_factor = 1.0 + avg_clust\n    trans_factor = 1.0 + trans\n\n    # Assortativity effect\n    assort_factor = 1.0 + abs(assort)\n\n    # Density and degree variability adjustments\n    density_factor = 1.0 / (1.0 + density)\n    std_factor = 1.0 / (1.0 + std_deg)\n\n    # Influence of minimum degree (captures bottlenecks)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle density effect\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    estimate = (\n        base *\n        hub_factor *\n        clust_factor *\n        trans_factor *\n        assort_factor *\n        density_factor *\n        std_factor *\n        min_factor *\n        tri_factor\n    )\n\n    return estimate\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.123558\nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.085601\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only pre‑computed graph\n    features.  The formula is a multiplicative combination of a simple\n    size‑to‑edge baseline and corrections that encode clustering, density,\n    degree heterogeneity, assortativity, high‑degree hubs, bottleneck effects,\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph statistics. Expected keys are:\n        - n, m\n        - density\n        - avg_degree, max_degree, min_degree, std_degree\n        - avg_clustering, transitivity, degree_assortativity\n        - num_triangles\n        - degrees (sorted ascending list)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the average shortest‑path\n        length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']  # sorted ascending list\n\n    # Base term: graph size vs. edge count\n    base = (n + 1.0) / (m + 1.0)\n\n    # Corrections based on global properties\n    clust_factor   = 1.0 + avg_clust\n    dens_factor    = 1.0 / (1.0 + density)\n    assort_factor  = 1.0 + abs(assort)\n    heter_factor   = 1.0 / (1.0 + std_deg)\n    min_factor     = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Hub influence: average of the top 5% degrees\n    top_k   = max(1, int(0.05 * len(degrees)))\n    high_avg = sum(degrees[-top_k:]) / top_k\n    hub_factor = (high_avg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangle density adjustment\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    estimate = (base * clust_factor * dens_factor * assort_factor *\n                heter_factor * min_factor * hub_factor * tri_factor)\n\n    return estimate\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a handful of pre‑computed\n    global graph statistics.  The formula is intentionally novel: it starts\n    from a simple size/edge baseline and applies multiplicative corrections\n    that capture (1) clustering, (2) density, (3) assortativity, (4) degree\n    heterogeneity, (5) bottleneck effects (minimum degree), (6) influence\n    of high‑degree hubs, (7) degree‑distribution skew (tail factor),\n    (8) ratio of extremes (max/min degree), and (9) harmonic‑mean degree.\n    All operations use only Python's built‑in arithmetic – no external\n    libraries are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features with the following keys:\n        - 'n', 'm', 'density'\n        - 'avg_degree', 'max_degree', 'min_degree', 'std_degree'\n        - 'avg_clustering', 'transitivity', 'degree_assortativity'\n        - 'num_triangles'\n        - 'degrees'   (sorted ascending list of vertex degrees)\n\n    Returns\n    -------\n    float\n        Numeric estimate correlated with the graph's average shortest‑path\n        length.  A higher value suggests longer typical distances.\n    \"\"\"\n    # Basic values\n    n      = s['n']\n    m      = s['m']\n    density= s['density']\n\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n\n    avg_clust = s['avg_clustering']\n    trans     = s['transitivity']\n    assort    = s['degree_assortativity']\n    num_tri   = s['num_triangles']\n\n    degrees = s['degrees']                      # sorted ascending list\n\n    # ------------------------------------------------------------------\n    # 1. Size/edge baseline\n    # ------------------------------------------------------------------\n    base = (n + 1.0) / (m + 1.0)\n\n    # ------------------------------------------------------------------\n    # 2. Corrections for global properties\n    # ------------------------------------------------------------------\n    clust_factor   = 1.0 + avg_clust                 # higher clustering → longer paths\n    dens_factor    = 1.0 / (1.0 + density)           # denser graphs → shorter paths\n    assort_factor  = 1.0 + abs(assort)                # assortative mixing → longer paths\n    heter_factor   = 1.0 / (1.0 + std_deg)           # heterogeneous degrees → shorter paths\n    min_factor     = 1.0 / (1.0 + min_deg/(avg_deg + 1.0))\n\n    # ------------------------------------------------------------------\n    # 3. High‑degree hub influence (top 5% of degrees)\n    # ------------------------------------------------------------------\n    top_k = max(1, int(0.05 * len(degrees)))\n    high_avg = sum(degrees[-top_k:]) / top_k\n    hub_factor = (high_avg / (avg_deg + 1.0)) ** 0.5\n\n    # ------------------------------------------------------------------\n    # 4. Tail (skew) factor: how far the maximum degree overshoots the mean\n    # ------------------------------------------------------------------\n    if max_deg > 0:\n        tail_ratio = (max_deg - avg_deg) / (max_deg + 1.0)\n    else:\n        tail_ratio = 0.0\n    tail_factor = 1.0 + tail_ratio\n\n    # ------------------------------------------------------------------\n    # 5. Extreme‑degree ratio factor\n    # ------------------------------------------------------------------\n    if max_deg > 0:\n        ratio_factor = min_deg / (max_deg + 1.0)\n    else:\n        ratio_factor = 0.0\n\n    # ------------------------------------------------------------------\n    # 6. Triangle (local closure) factor\n    # ------------------------------------------------------------------\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # ------------------------------------------------------------------\n    # 7. Harmonic‑mean degree factor (captures influence of many low‑degree nodes)\n    # ------------------------------------------------------------------\n    nonzero_degrees = [d for d in degrees if d > 0]\n    if nonzero_degrees:\n        hm = len(nonzero_degrees) / sum(1.0 / d for d in nonzero_degrees)\n        hm_factor = 1.0 + (hm / (avg_deg + 1.0)) ** 0.5\n    else:\n        hm_factor = 1.0\n\n    # ------------------------------------------------------------------\n    # 8. Assemble the estimate\n    # ------------------------------------------------------------------\n    estimate = (\n        base\n        * clust_factor\n        * dens_factor\n        * assort_factor\n        * heter_factor\n        * min_factor\n        * hub_factor\n        * tri_factor\n        * tail_factor\n        * ratio_factor\n        * hm_factor\n    )\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a handful of pre‑computed\n    global graph statistics.  The formula is intentionally novel: it starts\n    from a simple size/edge baseline and applies multiplicative corrections\n    that capture (1) clustering, (2) density, (3) assortativity, (4) degree\n    heterogeneity, (5) bottleneck effects (minimum degree), (6) influence\n    of high‑degree hubs, (7) degree‑distribution skew (tail factor),\n    (8) ratio of extremes (max/min degree), and (9) harmonic‑mean degree.\n    All operations use only Python's built‑in arithmetic – no external\n    libraries are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features with the following keys:\n        - 'n', 'm', 'density'\n        - 'avg_degree', 'max_degree', 'min_degree', 'std_degree'\n        - 'avg_clustering', 'transitivity', 'degree_assortativity'\n        - 'num_triangles'\n        - 'degrees'   (sorted ascending list of vertex degrees)\n\n    Returns\n    -------\n    float\n        Numeric estimate correlated with the graph's average shortest‑path\n        length.  A higher value suggests longer typical distances.\n    \"\"\"\n    # Basic values\n    n      = s['n']\n    m      = s['m']\n    density= s['density']\n\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n\n    avg_clust = s['avg_clustering']\n    trans     = s['transitivity']\n    assort    = s['degree_assortativity']\n    num_tri   = s['num_triangles']\n\n    degrees = s['degrees']                      # sorted ascending list\n\n    # ------------------------------------------------------------------\n    # 1. Size/edge baseline\n    # ------------------------------------------------------------------\n    base = (n + 1.0) / (m + 1.0)\n\n    # ------------------------------------------------------------------\n    # 2. Corrections for global properties\n    # ------------------------------------------------------------------\n    clust_factor   = 1.0 + avg_clust                 # higher clustering → longer paths\n    dens_factor    = 1.0 / (1.0 + density)           # denser graphs → shorter paths\n    assort_factor  = 1.0 + abs(assort)                # assortative mixing → longer paths\n    heter_factor   = 1.0 / (1.0 + std_deg)           # heterogeneous degrees → shorter paths\n    min_factor     = 1.0 / (1.0 + min_deg/(avg_deg + 1.0))\n\n    # ------------------------------------------------------------------\n    # 3. High‑degree hub influence (top 5% of degrees)\n    # ------------------------------------------------------------------\n    top_k = max(1, int(0.05 * len(degrees)))\n    high_avg = sum(degrees[-top_k:]) / top_k\n    hub_factor = (high_avg / (avg_deg + 1.0)) ** 0.5\n\n    # ------------------------------------------------------------------\n    # 4. Tail (skew) factor: how far the maximum degree overshoots the mean\n    # ------------------------------------------------------------------\n    if max_deg > 0:\n        tail_ratio = (max_deg - avg_deg) / (max_deg + 1.0)\n    else:\n        tail_ratio = 0.0\n    tail_factor = 1.0 + tail_ratio\n\n    # ------------------------------------------------------------------\n    # 5. Extreme‑degree ratio factor\n    # ------------------------------------------------------------------\n    if max_deg > 0:\n        ratio_factor = min_deg / (max_deg + 1.0)\n    else:\n        ratio_factor = 0.0\n\n    # ------------------------------------------------------------------\n    # 6. Triangle (local closure) factor\n    # ------------------------------------------------------------------\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # ------------------------------------------------------------------\n    # 7. Harmonic‑mean degree factor (captures influence of many low‑degree nodes)\n    # ------------------------------------------------------------------\n    nonzero_degrees = [d for d in degrees if d > 0]\n    if nonzero_degrees:\n        hm = len(nonzero_degrees) / sum(1.0 / d for d in nonzero_degrees)\n        hm_factor = 1.0 + (hm / (avg_deg + 1.0)) ** 0.5\n    else:\n        hm_factor = 1.0\n\n    # ------------------------------------------------------------------\n    # 8. Assemble the estimate\n    # ------------------------------------------------------------------\n    estimate = (\n        base\n        * clust_factor\n        * dens_factor\n        * assort_factor\n        * heter_factor\n        * min_factor\n        * hub_factor\n        * tri_factor\n        * tail_factor\n        * ratio_factor\n        * hm_factor\n    )\n\n    return estimate", "spearman": 0.37070126753168836, "pearson": 0.3031574418789062, "rmse": 2.667609151337329, "mae": 2.5339797884241664}}
{"timestamp": "2026-02-16T17:42:27.500745+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 13, "island_id": 3, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:43:25.434076+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i3_p1_16044463", "generation": 13, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6972869147659063, "fitness_mode": "correlation", "simplicity_score": 0.1548007963727991, "novelty_bonus": 0.31805156945865676, "total_score": 0.4979709199944039, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a handful of pre‑computed\n    global graph statistics.  The formula combines a random‑graph baseline\n    with multiplicative corrections that reflect clustering, density,\n    degree heterogeneity, assortativity, bottleneck effects and triangle\n    density.  It uses only built‑in arithmetic and avoids external\n    libraries or graph traversals.\n\n    Parameters\n    ----------\n    s : dict\n        Graph features with keys:\n        - n (int)\n        - avg_degree (float)\n        - avg_clustering (float)\n        - density (float)\n        - std_degree (float)\n        - degree_assortativity (float)\n        - num_triangles (int or float)\n        - min_degree (int or float)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 0.0))\n\n    # Random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = (n + 1.0) / (max(avg_deg, 1e-12) + 1.0)\n\n    # Multiplicative corrections\n    clust = 1.0 + float(s.get('avg_clustering', 0.0))              # higher clustering → longer paths\n    dens = 1.0 / (1.0 + float(s.get('density', 0.0)))              # denser graphs → shorter paths\n    std = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))            # heterogeneous degrees → shorter paths\n    assort = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))   # assortative mixing → longer paths\n\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck = 1.0 / (1.0 + min_deg / max(avg_deg, 1e-12))       # very small min degree lengthens paths\n\n    num_tri = float(s.get('num_triangles', 0.0))\n    tri_factor = 1.0 + (num_tri**0.5) / (n**0.5 if n > 0 else 1.0)   # larger triangles → shorter paths\n\n    estimate = base * clust * dens * std * assort * bottleneck * tri_factor\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The estimate is a product of a size‑to‑edge baseline and\n    multiplicative corrections that reflect degree heterogeneity, clustering,\n    transitivity, assortativity, density, and triangle density.  No external\n    libraries or graph traversal algorithms are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of global graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n\n    Returns\n    -------\n    float\n        A numerical estimate that correlates with the graph's average\n        shortest path length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n\n    # Baseline based on size and sparsity\n    base = (n + 1.0) / (m + 1.0)\n\n    # Heterogeneity factor: influence of high‑degree hubs\n    hub_factor = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Clustering and transitivity corrections\n    clust_factor = 1.0 + avg_clust\n    trans_factor = 1.0 + trans\n\n    # Assortativity effect\n    assort_factor = 1.0 + abs(assort)\n\n    # Density and degree variability adjustments\n    density_factor = 1.0 / (1.0 + density)\n    std_factor = 1.0 / (1.0 + std_deg)\n\n    # Influence of minimum degree (captures bottlenecks)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle density effect\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    estimate = (\n        base *\n        hub_factor *\n        clust_factor *\n        trans_factor *\n        assort_factor *\n        density_factor *\n        std_factor *\n        min_factor *\n        tri_factor\n    )\n\n    return estimate\nRecent failures:\nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.085601\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from a set of\n    pre‑computed global statistics, without inspecting the graph itself.\n    The formula combines a size‑to‑edge baseline with multiplicative\n    corrections that account for clustering, density, degree heterogeneity,\n    assortativity, minimum‑degree bottlenecks and the presence of high‑degree\n    hubs and triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average\n        shortest‑path length.\n    \"\"\"\n    # Base features\n    n = s.get('n', 1)\n    m = s.get('m', 1)\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0.0)\n    min_deg = s.get('min_degree', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0.0)\n    degs = s.get('degrees', [])\n\n    # Handle potential division by zero\n    eps = 1e-12\n\n    # Random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = n / (max(avg_deg, eps) + 1.0)\n\n    # Corrections for structural properties\n    clust_factor      = 1.0 + avg_clust                  # more clustering → longer paths\n    density_factor    = 1.0 / (1.0 + density)           # denser → shorter paths\n    assort_factor     = 1.0 + abs(assort)                # assortative mixing → longer paths\n    std_factor        = 1.0 / (1.0 + std_deg)            # heterogeneous degrees → shorter paths\n    min_factor        = 1.0 / (1.0 + min_deg / (max(avg_deg, eps) + 1.0))  # low min degree → longer paths\n\n    # Influence of high‑degree hubs (top 5 % of the degree spectrum)\n    k = max(1, int(round(0.05 * n)))\n    if len(degs) >= k:\n        top_hubs = degs[-k:]\n        avg_high_deg = sum(top_hubs) / k\n    else:\n        avg_high_deg = avg_deg\n    hub_factor = avg_high_deg / (max(avg_deg, eps) + 1.0)\n\n    # Triangle density effect (captures local transitivity)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Combine all factors multiplicatively\n    estimate = (base * clust_factor * density_factor * assort_factor *\n                std_factor * min_factor * hub_factor * tri_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from a set of\n    pre‑computed global statistics, without inspecting the graph itself.\n    The formula combines a size‑to‑edge baseline with multiplicative\n    corrections that account for clustering, density, degree heterogeneity,\n    assortativity, minimum‑degree bottlenecks and the presence of high‑degree\n    hubs and triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average\n        shortest‑path length.\n    \"\"\"\n    # Base features\n    n = s.get('n', 1)\n    m = s.get('m', 1)\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0.0)\n    min_deg = s.get('min_degree', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0.0)\n    degs = s.get('degrees', [])\n\n    # Handle potential division by zero\n    eps = 1e-12\n\n    # Random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = n / (max(avg_deg, eps) + 1.0)\n\n    # Corrections for structural properties\n    clust_factor      = 1.0 + avg_clust                  # more clustering → longer paths\n    density_factor    = 1.0 / (1.0 + density)           # denser → shorter paths\n    assort_factor     = 1.0 + abs(assort)                # assortative mixing → longer paths\n    std_factor        = 1.0 / (1.0 + std_deg)            # heterogeneous degrees → shorter paths\n    min_factor        = 1.0 / (1.0 + min_deg / (max(avg_deg, eps) + 1.0))  # low min degree → longer paths\n\n    # Influence of high‑degree hubs (top 5 % of the degree spectrum)\n    k = max(1, int(round(0.05 * n)))\n    if len(degs) >= k:\n        top_hubs = degs[-k:]\n        avg_high_deg = sum(top_hubs) / k\n    else:\n        avg_high_deg = avg_deg\n    hub_factor = avg_high_deg / (max(avg_deg, eps) + 1.0)\n\n    # Triangle density effect (captures local transitivity)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Combine all factors multiplicatively\n    estimate = (base * clust_factor * density_factor * assort_factor *\n                std_factor * min_factor * hub_factor * tri_factor)\n\n    return float(estimate)", "spearman": 0.7431905797644942, "pearson": 0.765455946622627, "rmse": 8.419986256261103, "mae": 6.616177754630144}}
{"timestamp": "2026-02-16T17:43:53.103005+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i3_p2_122557201", "generation": 13, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6720288115246097, "fitness_mode": "correlation", "simplicity_score": 0.15645345128137478, "novelty_bonus": 0.34835677092639694, "total_score": 0.4888502978486019, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a handful of pre‑computed\n    global graph statistics.  The formula combines a random‑graph baseline\n    with multiplicative corrections that reflect clustering, density,\n    degree heterogeneity, assortativity, bottleneck effects and triangle\n    density.  It uses only built‑in arithmetic and avoids external\n    libraries or graph traversals.\n\n    Parameters\n    ----------\n    s : dict\n        Graph features with keys:\n        - n (int)\n        - avg_degree (float)\n        - avg_clustering (float)\n        - density (float)\n        - std_degree (float)\n        - degree_assortativity (float)\n        - num_triangles (int or float)\n        - min_degree (int or float)\n\n    Returns\n    -------\n    float\n        A numeric estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 0.0))\n\n    # Random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = (n + 1.0) / (max(avg_deg, 1e-12) + 1.0)\n\n    # Multiplicative corrections\n    clust = 1.0 + float(s.get('avg_clustering', 0.0))              # higher clustering → longer paths\n    dens = 1.0 / (1.0 + float(s.get('density', 0.0)))              # denser graphs → shorter paths\n    std = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))            # heterogeneous degrees → shorter paths\n    assort = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))   # assortative mixing → longer paths\n\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck = 1.0 / (1.0 + min_deg / max(avg_deg, 1e-12))       # very small min degree lengthens paths\n\n    num_tri = float(s.get('num_triangles', 0.0))\n    tri_factor = 1.0 + (num_tri**0.5) / (n**0.5 if n > 0 else 1.0)   # larger triangles → shorter paths\n\n    estimate = base * clust * dens * std * assort * bottleneck * tri_factor\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The estimate is a product of a size‑to‑edge baseline and\n    multiplicative corrections that reflect degree heterogeneity, clustering,\n    transitivity, assortativity, density, and triangle density.  No external\n    libraries or graph traversal algorithms are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of global graph features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int or float)\n\n    Returns\n    -------\n    float\n        A numerical estimate that correlates with the graph's average\n        shortest path length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n\n    # Baseline based on size and sparsity\n    base = (n + 1.0) / (m + 1.0)\n\n    # Heterogeneity factor: influence of high‑degree hubs\n    hub_factor = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Clustering and transitivity corrections\n    clust_factor = 1.0 + avg_clust\n    trans_factor = 1.0 + trans\n\n    # Assortativity effect\n    assort_factor = 1.0 + abs(assort)\n\n    # Density and degree variability adjustments\n    density_factor = 1.0 / (1.0 + density)\n    std_factor = 1.0 / (1.0 + std_deg)\n\n    # Influence of minimum degree (captures bottlenecks)\n    min_factor = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    # Triangle density effect\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    estimate = (\n        base *\n        hub_factor *\n        clust_factor *\n        trans_factor *\n        assort_factor *\n        density_factor *\n        std_factor *\n        min_factor *\n        tri_factor\n    )\n\n    return estimate\nRecent failures:\nno_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.085601\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a concise set of pre‑computed\n    graph statistics.  The formula combines a size‑to‑degree baseline with\n    multiplicative corrections that capture clustering, density, degree\n    heterogeneity, assortativity, bottlenecks and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features containing the keys:\n            - 'n'                : number of nodes\n            - 'm'                : number of edges\n            - 'density'          : graph density (0–1)\n            - 'avg_degree'       : average degree\n            - 'max_degree'       : maximum degree\n            - 'min_degree'       : minimum degree\n            - 'std_degree'       : standard deviation of degrees\n            - 'avg_clustering'   : average clustering coefficient\n            - 'transitivity'     : transitivity (global clustering)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'    : total number of triangles\n            - 'degrees'          : sorted list of vertex degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic size‑to‑degree baseline\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = (n ** 0.5) / (avg_deg + 0.5)            # larger graphs and lower degree → longer paths\n\n    # Correction factors\n    clust_factor      = 1.0 + float(s.get('avg_clustering', 0.0))\n    trans_factor      = 1.0 + float(s.get('transitivity', 0.0))\n    dens_factor       = 1.0 / (1.0 + float(s.get('density', 0.0)))            # denser graphs shrink distances\n    std_factor        = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))          # high degree heterogeneity tends to shorten paths\n    assort_factor     = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))  # assortative mixing stretches distances\n\n    # Bottleneck penalty (very low min degree can lengthen paths)\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 0.5))\n\n    # Triangle effect: abundant triangles tend to shorten distances\n    tri = float(s.get('num_triangles', 0.0))\n    tri_factor = 1.0 + (tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Hub impact: the ratio of maximum to average degree influences path length\n    max_deg = float(s.get('max_degree', avg_deg))\n    hub_factor = (max_deg / (avg_deg + 0.5)) ** 0.5\n\n    # Combine all components\n    estimate = (base *\n                clust_factor *\n                trans_factor *\n                dens_factor *\n                std_factor *\n                assort_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a concise set of pre‑computed\n    graph statistics.  The formula combines a size‑to‑degree baseline with\n    multiplicative corrections that capture clustering, density, degree\n    heterogeneity, assortativity, bottlenecks and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features containing the keys:\n            - 'n'                : number of nodes\n            - 'm'                : number of edges\n            - 'density'          : graph density (0–1)\n            - 'avg_degree'       : average degree\n            - 'max_degree'       : maximum degree\n            - 'min_degree'       : minimum degree\n            - 'std_degree'       : standard deviation of degrees\n            - 'avg_clustering'   : average clustering coefficient\n            - 'transitivity'     : transitivity (global clustering)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'    : total number of triangles\n            - 'degrees'          : sorted list of vertex degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic size‑to‑degree baseline\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = (n ** 0.5) / (avg_deg + 0.5)            # larger graphs and lower degree → longer paths\n\n    # Correction factors\n    clust_factor      = 1.0 + float(s.get('avg_clustering', 0.0))\n    trans_factor      = 1.0 + float(s.get('transitivity', 0.0))\n    dens_factor       = 1.0 / (1.0 + float(s.get('density', 0.0)))            # denser graphs shrink distances\n    std_factor        = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))          # high degree heterogeneity tends to shorten paths\n    assort_factor     = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))  # assortative mixing stretches distances\n\n    # Bottleneck penalty (very low min degree can lengthen paths)\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 0.5))\n\n    # Triangle effect: abundant triangles tend to shorten distances\n    tri = float(s.get('num_triangles', 0.0))\n    tri_factor = 1.0 + (tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Hub impact: the ratio of maximum to average degree influences path length\n    max_deg = float(s.get('max_degree', avg_deg))\n    hub_factor = (max_deg / (avg_deg + 0.5)) ** 0.5\n\n    # Combine all components\n    estimate = (base *\n                clust_factor *\n                trans_factor *\n                dens_factor *\n                std_factor *\n                assort_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return float(estimate)", "spearman": 0.7061051526288158, "pearson": 0.7446691164085778, "rmse": 1.0230535958542617, "mae": 0.8067532461772938}}
{"timestamp": "2026-02-16T17:44:59.901795+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.122583", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:44:59.903172+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 13, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.122583", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:45:49.650751+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 3, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:45:49.651796+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 13, "island_id": 3, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:46:39.735880+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.276255", "model_name": "gpt-oss:20b", "train_signal": 0.27625450180072025}}
{"timestamp": "2026-02-16T17:46:39.739464+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 14, "model_name": "gpt-oss:20b", "best_val_score": 0.5376982263149925, "no_improve_count": 6}}
{"timestamp": "2026-02-16T17:47:30.374832+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i0_p0_939440461", "generation": 14, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.6835534213685474, "fitness_mode": "correlation", "simplicity_score": 0.22116302089367137, "novelty_bonus": 0.29971844625275246, "total_score": 0.4414540707028763, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.044994\nbelow_train_threshold: train_signal=0.018776\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 1.2 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + ((avg_deg - min_deg) / (avg_deg + 1.0)) ** 0.8)\n    base *= (1.0 + (std_deg / (avg_deg + 1.0)) ** 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering) ** 0.7\n    base *= (1.0 + trans) ** 0.7\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.8)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 1.5 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.6)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 1.2 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + ((avg_deg - min_deg) / (avg_deg + 1.0)) ** 0.8)\n    base *= (1.0 + (std_deg / (avg_deg + 1.0)) ** 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering) ** 0.7\n    base *= (1.0 + trans) ** 0.7\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.8)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 1.5 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.6)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.6146118652966326, "pearson": 0.5669360654910414, "rmse": 2.650473182528553, "mae": 2.2932255897648988}}
{"timestamp": "2026-02-16T17:48:18.462270+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i0_p1_722218910", "generation": 14, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.6543577430972389, "fitness_mode": "correlation", "simplicity_score": 0.22178457158834725, "novelty_bonus": 0.2996518194720077, "total_score": 0.45646951558565746, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.044994\nbelow_train_threshold: train_signal=0.018776\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic graph statistics\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += triangles / (max(s['m'], 1) + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic graph statistics\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += triangles / (max(s['m'], 1) + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.6444341108527714, "pearson": 0.704756970509894, "rmse": 5.00753503677783, "mae": 4.550377815603794}}
{"timestamp": "2026-02-16T17:50:04.948414+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i0_p2_740143593", "generation": 14, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.8325090036014406, "fitness_mode": "correlation", "simplicity_score": 0.22107466943064283, "novelty_bonus": 0.20792146225671126, "total_score": 0.5437150506550943, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.044994\nbelow_train_threshold: train_signal=0.018776\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.7 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.9)\n    base *= (1.0 + trans * 0.9)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.7)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.5\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.8)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.7 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.9)\n    base *= (1.0 + trans * 0.9)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.7)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.5\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.8)\n\n    return base", "spearman": 0.8742473561839047, "pearson": 0.817885160114956, "rmse": 0.7832090691156494, "mae": 0.5728149156056922}}
{"timestamp": "2026-02-16T17:51:57.682540+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i0_p3_647058354", "generation": 14, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.6388955582232894, "fitness_mode": "correlation", "simplicity_score": 0.22113343699055302, "novelty_bonus": 0.3147892691112032, "total_score": 0.42990399914474686, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.044994\nbelow_train_threshold: train_signal=0.018776\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is intentionally compact and interpretable, combining size,\n    degree distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal is\n    performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    hub_factor = (max_deg / (n * avg_deg)) ** 0.5 if n > 0 else 0.0\n    base /= (1.0 + density ** 0.8 + hub_factor)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated)\n    base /= (1.0 + abs(assort) ** 0.5)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 1.5 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + leaf_frac ** 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is intentionally compact and interpretable, combining size,\n    degree distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal is\n    performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    hub_factor = (max_deg / (n * avg_deg)) ** 0.5 if n > 0 else 0.0\n    base /= (1.0 + density ** 0.8 + hub_factor)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated)\n    base /= (1.0 + abs(assort) ** 0.5)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 1.5 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + leaf_frac ** 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.2)\n\n    return base", "spearman": 0.5824810620265507, "pearson": 0.6021256360558895, "rmse": 2.3726901094567414, "mae": 1.9126235177237367}}
{"timestamp": "2026-02-16T17:52:54.852047+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i0_p4_379473059", "generation": 14, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22191621004497614, "novelty_bonus": 0.25138613993252834, "total_score": 0.5273345223747135, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.044994\nbelow_train_threshold: train_signal=0.018776\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T17:53:31.594694+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i1_p0_787418219", "generation": 14, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22168752438400124, "novelty_bonus": 0.25138613993252834, "total_score": 0.5272887852425184, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.285570\nno_valid_train_predictions: static_invalid: missing `new_invariant` function\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T17:54:03.847238+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i1_p1_181187479", "generation": 14, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22162360630380393, "novelty_bonus": 0.25138613993252834, "total_score": 0.5272760016264789, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.285570\nno_valid_train_predictions: static_invalid: missing `new_invariant` function\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula uses only arithmetic on the supplied features; no graph traversal\n    or external libraries are required.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1e-6)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula uses only arithmetic on the supplied features; no graph traversal\n    or external libraries are required.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1e-6)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T17:54:38.675033+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i1_p2_21682535", "generation": 14, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.2206775829744107, "novelty_bonus": 0.25138613993252834, "total_score": 0.5270867969606003, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.285570\nno_valid_train_predictions: static_invalid: missing `new_invariant` function\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    # Extract features with safe defaults\n    n          = s.get('n', 1)\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 1.0), 1e-6)          # avoid division by zero\n    max_deg    = max(s.get('max_degree', 1), 1)\n    min_deg    = max(s.get('min_degree', 1), 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    # Extract features with safe defaults\n    n          = s.get('n', 1)\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = max(s.get('avg_degree', 1.0), 1e-6)          # avoid division by zero\n    max_deg    = max(s.get('max_degree', 1), 1)\n    min_deg    = max(s.get('min_degree', 1), 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T17:55:09.302148+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i1_p3_122704106", "generation": 14, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22162360630380393, "novelty_bonus": 0.25138613993252834, "total_score": 0.5272760016264789, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.285570\nno_valid_train_predictions: static_invalid: missing `new_invariant` function\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T17:56:03.450829+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i1_p4_930690498", "generation": 14, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.2217197160851846, "novelty_bonus": 0.25138613993252834, "total_score": 0.5272952235827552, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.285570\nno_valid_train_predictions: static_invalid: missing `new_invariant` function\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T17:56:42.988663+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.124694", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:56:42.990193+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 14, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.124694", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:57:14.662231+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 2, "population_idx": 0, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:57:14.663123+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 14, "island_id": 2, "population_idx": 0, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T17:58:02.504993+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i2_p1_737648241", "generation": 14, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7669147659063624, "fitness_mode": "correlation", "simplicity_score": 0.11824246151894066, "novelty_bonus": 0.3499434179841313, "total_score": 0.4887965218241307, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic is based on a random‑graph baseline and\n    multiplicative corrections that capture the influence of clustering,\n    transitivity, density, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.078185\nbelow_novelty_threshold: novelty_bonus=0.124694\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the influence of clustering, transitivity, density,\n    degree heterogeneity, assortativity, low‑degree vertices, triangle\n    density and the presence of very high‑degree hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n    max_deg = s.get('max_degree', avg_deg)\n\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    clustering_factor = 1.0 + clustering\n    trans_factor = 1.0 + trans\n    density_factor = 1.0 / (1.0 + density)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    assort_factor = 1.0 + 0.5 * abs(assort)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor *\n            max_factor)", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the influence of clustering, transitivity, density,\n    degree heterogeneity, assortativity, low‑degree vertices, triangle\n    density and the presence of very high‑degree hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n    max_deg = s.get('max_degree', avg_deg)\n\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    clustering_factor = 1.0 + clustering\n    trans_factor = 1.0 + trans\n    density_factor = 1.0 / (1.0 + density)\n    hetero_factor = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    assort_factor = 1.0 + 0.5 * abs(assort)\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n    max_factor = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor *\n            max_factor)", "spearman": 0.7203300082502063, "pearson": 0.6740477985005873, "rmse": 2.4878172197661046, "mae": 1.7304965774658472}}
{"timestamp": "2026-02-16T17:58:59.079221+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i2_p2_834734746", "generation": 14, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7669147659063624, "fitness_mode": "correlation", "simplicity_score": 0.11791650864831736, "novelty_bonus": 0.3499434179841313, "total_score": 0.48873133125000606, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic is based on a random‑graph baseline and\n    multiplicative corrections that capture the influence of clustering,\n    transitivity, density, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.078185\nbelow_novelty_threshold: novelty_bonus=0.124694\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a random‑graph baseline and applies\n    multiplicative corrections that capture the effects of clustering,\n    transitivity, density, degree heterogeneity, assortativity, low‑degree\n    vertices, high‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n            - 'max_degree' (int or float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg <= 0:\n        avg_deg = 1.0\n\n    # Basic random‑graph baseline\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6\n        tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    else:\n        tri_ratio = 0.0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering\n    trans_factor       = 1.0 + trans\n    density_factor     = 1.0 / (1.0 + density)\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    assort_factor      = 1.0 + 0.5 * abs(assort)\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)\n    max_factor         = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    tri_factor         = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            max_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a random‑graph baseline and applies\n    multiplicative corrections that capture the effects of clustering,\n    transitivity, density, degree heterogeneity, assortativity, low‑degree\n    vertices, high‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'density' (float, 0–1)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n            - 'max_degree' (int or float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg <= 0:\n        avg_deg = 1.0\n\n    # Basic random‑graph baseline\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6\n        tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n    else:\n        tri_ratio = 0.0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering\n    trans_factor       = 1.0 + trans\n    density_factor     = 1.0 / (1.0 + density)\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    assort_factor      = 1.0 + 0.5 * abs(assort)\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)\n    max_factor         = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    tri_factor         = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            max_factor *\n            tri_factor)", "spearman": 0.7203300082502063, "pearson": 0.674047798500587, "rmse": 2.4878172197661046, "mae": 1.7304965774658472}}
{"timestamp": "2026-02-16T17:59:34.084537+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i2_p3_649110713", "generation": 14, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8622809123649459, "fitness_mode": "correlation", "simplicity_score": 0.12002805993232075, "novelty_bonus": 0.2439650011795802, "total_score": 0.5371261106152951, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic is based on a random‑graph baseline and\n    multiplicative corrections that capture the influence of clustering,\n    transitivity, density, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.078185\nbelow_novelty_threshold: novelty_bonus=0.124694\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the influence of clustering, transitivity, density,\n    degree heterogeneity, assortativity, low‑degree vertices and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = 0\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6\n    tri_ratio = 0.0\n    if possible_tri > 0:\n        tri_ratio = num_tri / possible_tri\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering                 # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                       # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)             # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)           # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)       # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)           # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the influence of clustering, transitivity, density,\n    degree heterogeneity, assortativity, low‑degree vertices and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = 0\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6\n    tri_ratio = 0.0\n    if possible_tri > 0:\n        tri_ratio = num_tri / possible_tri\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering                 # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                       # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)             # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)           # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)       # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)           # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)", "spearman": 0.8798619965499139, "pearson": 0.856530736217558, "rmse": 10.889728766202964, "mae": 9.3389863953469}}
{"timestamp": "2026-02-16T18:00:16.157753+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.078715", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:00:16.158954+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 14, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.078715", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:00:49.725297+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 2, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.063245", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:00:49.726079+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 14, "island_id": 2, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:01:33.544882+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i3_p0_126936836", "generation": 14, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6349579831932772, "fitness_mode": "correlation", "simplicity_score": 0.15814844518841947, "novelty_bonus": 0.22415515485815973, "total_score": 0.4527185815537833, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from a set of\n    pre‑computed global statistics, without inspecting the graph itself.\n    The formula combines a size‑to‑edge baseline with multiplicative\n    corrections that account for clustering, density, degree heterogeneity,\n    assortativity, minimum‑degree bottlenecks and the presence of high‑degree\n    hubs and triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average\n        shortest‑path length.\n    \"\"\"\n    # Base features\n    n = s.get('n', 1)\n    m = s.get('m', 1)\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0.0)\n    min_deg = s.get('min_degree', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0.0)\n    degs = s.get('degrees', [])\n\n    # Handle potential division by zero\n    eps = 1e-12\n\n    # Random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = n / (max(avg_deg, eps) + 1.0)\n\n    # Corrections for structural properties\n    clust_factor      = 1.0 + avg_clust                  # more clustering → longer paths\n    density_factor    = 1.0 / (1.0 + density)           # denser → shorter paths\n    assort_factor     = 1.0 + abs(assort)                # assortative mixing → longer paths\n    std_factor        = 1.0 / (1.0 + std_deg)            # heterogeneous degrees → shorter paths\n    min_factor        = 1.0 / (1.0 + min_deg / (max(avg_deg, eps) + 1.0))  # low min degree → longer paths\n\n    # Influence of high‑degree hubs (top 5 % of the degree spectrum)\n    k = max(1, int(round(0.05 * n)))\n    if len(degs) >= k:\n        top_hubs = degs[-k:]\n        avg_high_deg = sum(top_hubs) / k\n    else:\n        avg_high_deg = avg_deg\n    hub_factor = avg_high_deg / (max(avg_deg, eps) + 1.0)\n\n    # Triangle density effect (captures local transitivity)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Combine all factors multiplicatively\n    estimate = (base * clust_factor * density_factor * assort_factor *\n                std_factor * min_factor * hub_factor * tri_factor)\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a concise set of pre‑computed\n    graph statistics.  The formula combines a size‑to‑degree baseline with\n    multiplicative corrections that capture clustering, density, degree\n    heterogeneity, assortativity, bottlenecks and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features containing the keys:\n            - 'n'                : number of nodes\n            - 'm'                : number of edges\n            - 'density'          : graph density (0–1)\n            - 'avg_degree'       : average degree\n            - 'max_degree'       : maximum degree\n            - 'min_degree'       : minimum degree\n            - 'std_degree'       : standard deviation of degrees\n            - 'avg_clustering'   : average clustering coefficient\n            - 'transitivity'     : transitivity (global clustering)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'    : total number of triangles\n            - 'degrees'          : sorted list of vertex degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic size‑to‑degree baseline\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = (n ** 0.5) / (avg_deg + 0.5)            # larger graphs and lower degree → longer paths\n\n    # Correction factors\n    clust_factor      = 1.0 + float(s.get('avg_clustering', 0.0))\n    trans_factor      = 1.0 + float(s.get('transitivity', 0.0))\n    dens_factor       = 1.0 / (1.0 + float(s.get('density', 0.0)))            # denser graphs shrink distances\n    std_factor        = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))          # high degree heterogeneity tends to shorten paths\n    assort_factor     = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))  # assortative mixing stretches distances\n\n    # Bottleneck penalty (very low min degree can lengthen paths)\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 0.5))\n\n    # Triangle effect: abundant triangles tend to shorten distances\n    tri = float(s.get('num_triangles', 0.0))\n    tri_factor = 1.0 + (tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Hub impact: the ratio of maximum to average degree influences path length\n    max_deg = float(s.get('max_degree', avg_deg))\n    hub_factor = (max_deg / (avg_deg + 0.5)) ** 0.5\n\n    # Combine all components\n    estimate = (base *\n                clust_factor *\n                trans_factor *\n                dens_factor *\n                std_factor *\n                assort_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.122583\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a compact set of pre‑computed\n    graph statistics.  The formula combines a size‑to‑degree baseline with\n    multiplicative corrections that capture clustering, density, degree\n    heterogeneity, assortativity, bottlenecks (min degree), hub presence (max\n    degree), and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Graph feature dictionary with keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic size‑to‑degree baseline\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = (n ** 0.5) / (avg_deg + 0.5)          # larger n & lower degree → longer paths\n\n    # Corrections for structural properties\n    clust_factor = 1.0 + float(s.get('avg_clustering', 0.0))      # more clustering → longer paths\n    trans_factor = 1.0 + float(s.get('transitivity', 0.0))       # higher transitivity → longer paths\n    dens_factor  = 1.0 / (1.0 + float(s.get('density', 0.0)))     # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))# high degree heterogeneity → shorter paths\n    assort_factor = 1.0 + abs(float(s.get('degree_assortativity', 0.0))) # assortative mixing → longer paths\n\n    # Bottleneck penalty via min‑degree ratio (safe with +1)\n    bottleneck_factor = (float(s.get('max_degree', avg_deg)) + 1.0) / \\\n                        (float(s.get('min_degree', 0.0)) + 1.0)\n\n    # Triangle effect: abundance of triangles tends to shorten distances\n    tri_factor = 1.0 + (float(s.get('num_triangles', 0.0)) ** 0.5) / (n ** 0.5 if n else 1.0)\n\n    # Final estimate\n    estimate = (base * clust_factor * trans_factor * dens_factor *\n                hetero_factor * assort_factor * bottleneck_factor *\n                tri_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a compact set of pre‑computed\n    graph statistics.  The formula combines a size‑to‑degree baseline with\n    multiplicative corrections that capture clustering, density, degree\n    heterogeneity, assortativity, bottlenecks (min degree), hub presence (max\n    degree), and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Graph feature dictionary with keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic size‑to‑degree baseline\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = (n ** 0.5) / (avg_deg + 0.5)          # larger n & lower degree → longer paths\n\n    # Corrections for structural properties\n    clust_factor = 1.0 + float(s.get('avg_clustering', 0.0))      # more clustering → longer paths\n    trans_factor = 1.0 + float(s.get('transitivity', 0.0))       # higher transitivity → longer paths\n    dens_factor  = 1.0 / (1.0 + float(s.get('density', 0.0)))     # denser graphs → shorter paths\n    hetero_factor = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))# high degree heterogeneity → shorter paths\n    assort_factor = 1.0 + abs(float(s.get('degree_assortativity', 0.0))) # assortative mixing → longer paths\n\n    # Bottleneck penalty via min‑degree ratio (safe with +1)\n    bottleneck_factor = (float(s.get('max_degree', avg_deg)) + 1.0) / \\\n                        (float(s.get('min_degree', 0.0)) + 1.0)\n\n    # Triangle effect: abundance of triangles tends to shorten distances\n    tri_factor = 1.0 + (float(s.get('num_triangles', 0.0)) ** 0.5) / (n ** 0.5 if n else 1.0)\n\n    # Final estimate\n    estimate = (base * clust_factor * trans_factor * dens_factor *\n                hetero_factor * assort_factor * bottleneck_factor *\n                tri_factor)\n\n    return float(estimate)", "spearman": 0.707684692117303, "pearson": 0.6927801429478335, "rmse": 4.943497753192322, "mae": 3.074171543494152}}
{"timestamp": "2026-02-16T18:02:21.218642+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i3_p1_216775392", "generation": 14, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6901800720288115, "fitness_mode": "correlation", "simplicity_score": 0.15558659087281873, "novelty_bonus": 0.371845035328932, "total_score": 0.5133405955174121, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from a set of\n    pre‑computed global statistics, without inspecting the graph itself.\n    The formula combines a size‑to‑edge baseline with multiplicative\n    corrections that account for clustering, density, degree heterogeneity,\n    assortativity, minimum‑degree bottlenecks and the presence of high‑degree\n    hubs and triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average\n        shortest‑path length.\n    \"\"\"\n    # Base features\n    n = s.get('n', 1)\n    m = s.get('m', 1)\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0.0)\n    min_deg = s.get('min_degree', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0.0)\n    degs = s.get('degrees', [])\n\n    # Handle potential division by zero\n    eps = 1e-12\n\n    # Random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = n / (max(avg_deg, eps) + 1.0)\n\n    # Corrections for structural properties\n    clust_factor      = 1.0 + avg_clust                  # more clustering → longer paths\n    density_factor    = 1.0 / (1.0 + density)           # denser → shorter paths\n    assort_factor     = 1.0 + abs(assort)                # assortative mixing → longer paths\n    std_factor        = 1.0 / (1.0 + std_deg)            # heterogeneous degrees → shorter paths\n    min_factor        = 1.0 / (1.0 + min_deg / (max(avg_deg, eps) + 1.0))  # low min degree → longer paths\n\n    # Influence of high‑degree hubs (top 5 % of the degree spectrum)\n    k = max(1, int(round(0.05 * n)))\n    if len(degs) >= k:\n        top_hubs = degs[-k:]\n        avg_high_deg = sum(top_hubs) / k\n    else:\n        avg_high_deg = avg_deg\n    hub_factor = avg_high_deg / (max(avg_deg, eps) + 1.0)\n\n    # Triangle density effect (captures local transitivity)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Combine all factors multiplicatively\n    estimate = (base * clust_factor * density_factor * assort_factor *\n                std_factor * min_factor * hub_factor * tri_factor)\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a concise set of pre‑computed\n    graph statistics.  The formula combines a size‑to‑degree baseline with\n    multiplicative corrections that capture clustering, density, degree\n    heterogeneity, assortativity, bottlenecks and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features containing the keys:\n            - 'n'                : number of nodes\n            - 'm'                : number of edges\n            - 'density'          : graph density (0–1)\n            - 'avg_degree'       : average degree\n            - 'max_degree'       : maximum degree\n            - 'min_degree'       : minimum degree\n            - 'std_degree'       : standard deviation of degrees\n            - 'avg_clustering'   : average clustering coefficient\n            - 'transitivity'     : transitivity (global clustering)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'    : total number of triangles\n            - 'degrees'          : sorted list of vertex degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic size‑to‑degree baseline\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = (n ** 0.5) / (avg_deg + 0.5)            # larger graphs and lower degree → longer paths\n\n    # Correction factors\n    clust_factor      = 1.0 + float(s.get('avg_clustering', 0.0))\n    trans_factor      = 1.0 + float(s.get('transitivity', 0.0))\n    dens_factor       = 1.0 / (1.0 + float(s.get('density', 0.0)))            # denser graphs shrink distances\n    std_factor        = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))          # high degree heterogeneity tends to shorten paths\n    assort_factor     = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))  # assortative mixing stretches distances\n\n    # Bottleneck penalty (very low min degree can lengthen paths)\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 0.5))\n\n    # Triangle effect: abundant triangles tend to shorten distances\n    tri = float(s.get('num_triangles', 0.0))\n    tri_factor = 1.0 + (tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Hub impact: the ratio of maximum to average degree influences path length\n    max_deg = float(s.get('max_degree', avg_deg))\n    hub_factor = (max_deg / (avg_deg + 0.5)) ** 0.5\n\n    # Combine all components\n    estimate = (base *\n                clust_factor *\n                trans_factor *\n                dens_factor *\n                std_factor *\n                assort_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.122583\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)", "spearman": 0.7413395334883374, "pearson": 0.740784516881863, "rmse": 1.1368805512560614, "mae": 1.0163434818161656}}
{"timestamp": "2026-02-16T18:02:56.105158+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i3_p2_161256393", "generation": 14, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6733733493397358, "fitness_mode": "correlation", "simplicity_score": 0.15601942165517807, "novelty_bonus": 0.3428902759852963, "total_score": 0.46875033411079914, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from a set of\n    pre‑computed global statistics, without inspecting the graph itself.\n    The formula combines a size‑to‑edge baseline with multiplicative\n    corrections that account for clustering, density, degree heterogeneity,\n    assortativity, minimum‑degree bottlenecks and the presence of high‑degree\n    hubs and triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average\n        shortest‑path length.\n    \"\"\"\n    # Base features\n    n = s.get('n', 1)\n    m = s.get('m', 1)\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0.0)\n    min_deg = s.get('min_degree', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0.0)\n    degs = s.get('degrees', [])\n\n    # Handle potential division by zero\n    eps = 1e-12\n\n    # Random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = n / (max(avg_deg, eps) + 1.0)\n\n    # Corrections for structural properties\n    clust_factor      = 1.0 + avg_clust                  # more clustering → longer paths\n    density_factor    = 1.0 / (1.0 + density)           # denser → shorter paths\n    assort_factor     = 1.0 + abs(assort)                # assortative mixing → longer paths\n    std_factor        = 1.0 / (1.0 + std_deg)            # heterogeneous degrees → shorter paths\n    min_factor        = 1.0 / (1.0 + min_deg / (max(avg_deg, eps) + 1.0))  # low min degree → longer paths\n\n    # Influence of high‑degree hubs (top 5 % of the degree spectrum)\n    k = max(1, int(round(0.05 * n)))\n    if len(degs) >= k:\n        top_hubs = degs[-k:]\n        avg_high_deg = sum(top_hubs) / k\n    else:\n        avg_high_deg = avg_deg\n    hub_factor = avg_high_deg / (max(avg_deg, eps) + 1.0)\n\n    # Triangle density effect (captures local transitivity)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Combine all factors multiplicatively\n    estimate = (base * clust_factor * density_factor * assort_factor *\n                std_factor * min_factor * hub_factor * tri_factor)\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a concise set of pre‑computed\n    graph statistics.  The formula combines a size‑to‑degree baseline with\n    multiplicative corrections that capture clustering, density, degree\n    heterogeneity, assortativity, bottlenecks and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features containing the keys:\n            - 'n'                : number of nodes\n            - 'm'                : number of edges\n            - 'density'          : graph density (0–1)\n            - 'avg_degree'       : average degree\n            - 'max_degree'       : maximum degree\n            - 'min_degree'       : minimum degree\n            - 'std_degree'       : standard deviation of degrees\n            - 'avg_clustering'   : average clustering coefficient\n            - 'transitivity'     : transitivity (global clustering)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'    : total number of triangles\n            - 'degrees'          : sorted list of vertex degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic size‑to‑degree baseline\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = (n ** 0.5) / (avg_deg + 0.5)            # larger graphs and lower degree → longer paths\n\n    # Correction factors\n    clust_factor      = 1.0 + float(s.get('avg_clustering', 0.0))\n    trans_factor      = 1.0 + float(s.get('transitivity', 0.0))\n    dens_factor       = 1.0 / (1.0 + float(s.get('density', 0.0)))            # denser graphs shrink distances\n    std_factor        = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))          # high degree heterogeneity tends to shorten paths\n    assort_factor     = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))  # assortative mixing stretches distances\n\n    # Bottleneck penalty (very low min degree can lengthen paths)\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 0.5))\n\n    # Triangle effect: abundant triangles tend to shorten distances\n    tri = float(s.get('num_triangles', 0.0))\n    tri_factor = 1.0 + (tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Hub impact: the ratio of maximum to average degree influences path length\n    max_deg = float(s.get('max_degree', avg_deg))\n    hub_factor = (max_deg / (avg_deg + 0.5)) ** 0.5\n\n    # Combine all components\n    estimate = (base *\n                clust_factor *\n                trans_factor *\n                dens_factor *\n                std_factor *\n                assort_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.122583\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a small set of global graph\n    statistics.  The formula starts from a random‑graph baseline (size divided\n    by average degree) and multiplies a collection of multiplicative correction\n    factors that reflect clustering, density, degree heterogeneity, assortativity,\n    bottlenecks, hubs and triangle abundance.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            n                    : int   – number of nodes\n            m                    : int   – number of edges\n            density              : float – graph density\n            avg_degree           : float – average degree\n            max_degree           : int   – maximum degree\n            min_degree           : int   – minimum degree\n            std_degree           : float – standard deviation of degrees\n            avg_clustering       : float – average clustering coefficient\n            transitivity         : float – global clustering coefficient\n            degree_assortativity : float – assortativity coefficient\n            num_triangles        : int   – total number of triangles\n            degrees              : list  – sorted list of vertex degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # --------------------------------------------------------------------\n    # Helper values\n    # --------------------------------------------------------------------\n    n        = float(s.get('n', 1))\n    m        = float(s.get('m', 1))\n    avg_deg  = float(s.get('avg_degree', 1.0))\n    # Avoid division by zero – if avg_deg is tiny use 1.0 as safe denominator\n    safe_avg = avg_deg if avg_deg > 1e-8 else 1.0\n\n    # --------------------------------------------------------------------\n    # Baseline: larger graphs with sparser connectivity yield larger distances\n    # --------------------------------------------------------------------\n    base = n / (safe_avg + 1.0)\n\n    # --------------------------------------------------------------------\n    # Correction factors\n    # --------------------------------------------------------------------\n    # Higher clustering / transitivity generally increase typical distances\n    clust_factor   = 1.0 + float(s.get('avg_clustering', 0.0))\n    trans_factor   = 1.0 + float(s.get('transitivity', 0.0))\n\n    # Denser graphs have shorter distances\n    density_factor = 1.0 / (1.0 + float(s.get('density', 0.0)))\n\n    # Degree heterogeneity: a spread of degrees (high std) tends to shorten paths\n    std_factor     = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))\n\n    # Assortativity: assortative mixing stretches paths\n    assort_factor  = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))\n\n    # Bottleneck penalty – very low min degree inflates distances\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_factor = 1.0 / (1.0 + min_deg / (safe_avg + 1.0))\n\n    # Hub impact – very large maximum degree reduces typical distances\n    max_deg = float(s.get('max_degree', safe_avg))\n    hub_factor = pow(max_deg / (safe_avg + 1.0), 0.5)\n\n    # Triangle abundance shortens distances\n    num_tri = float(s.get('num_triangles', 0.0))\n    tri_factor = 1.0 + pow(num_tri, 0.5) / (pow(n, 0.5) if n > 0 else 1.0)\n\n    # --------------------------------------------------------------------\n    # Combine all pieces\n    # --------------------------------------------------------------------\n    estimate = (\n        base *\n        clust_factor *\n        trans_factor *\n        density_factor *\n        std_factor *\n        assort_factor *\n        bottleneck_factor *\n        hub_factor *\n        tri_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a small set of global graph\n    statistics.  The formula starts from a random‑graph baseline (size divided\n    by average degree) and multiplies a collection of multiplicative correction\n    factors that reflect clustering, density, degree heterogeneity, assortativity,\n    bottlenecks, hubs and triangle abundance.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n            n                    : int   – number of nodes\n            m                    : int   – number of edges\n            density              : float – graph density\n            avg_degree           : float – average degree\n            max_degree           : int   – maximum degree\n            min_degree           : int   – minimum degree\n            std_degree           : float – standard deviation of degrees\n            avg_clustering       : float – average clustering coefficient\n            transitivity         : float – global clustering coefficient\n            degree_assortativity : float – assortativity coefficient\n            num_triangles        : int   – total number of triangles\n            degrees              : list  – sorted list of vertex degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # --------------------------------------------------------------------\n    # Helper values\n    # --------------------------------------------------------------------\n    n        = float(s.get('n', 1))\n    m        = float(s.get('m', 1))\n    avg_deg  = float(s.get('avg_degree', 1.0))\n    # Avoid division by zero – if avg_deg is tiny use 1.0 as safe denominator\n    safe_avg = avg_deg if avg_deg > 1e-8 else 1.0\n\n    # --------------------------------------------------------------------\n    # Baseline: larger graphs with sparser connectivity yield larger distances\n    # --------------------------------------------------------------------\n    base = n / (safe_avg + 1.0)\n\n    # --------------------------------------------------------------------\n    # Correction factors\n    # --------------------------------------------------------------------\n    # Higher clustering / transitivity generally increase typical distances\n    clust_factor   = 1.0 + float(s.get('avg_clustering', 0.0))\n    trans_factor   = 1.0 + float(s.get('transitivity', 0.0))\n\n    # Denser graphs have shorter distances\n    density_factor = 1.0 / (1.0 + float(s.get('density', 0.0)))\n\n    # Degree heterogeneity: a spread of degrees (high std) tends to shorten paths\n    std_factor     = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))\n\n    # Assortativity: assortative mixing stretches paths\n    assort_factor  = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))\n\n    # Bottleneck penalty – very low min degree inflates distances\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_factor = 1.0 / (1.0 + min_deg / (safe_avg + 1.0))\n\n    # Hub impact – very large maximum degree reduces typical distances\n    max_deg = float(s.get('max_degree', safe_avg))\n    hub_factor = pow(max_deg / (safe_avg + 1.0), 0.5)\n\n    # Triangle abundance shortens distances\n    num_tri = float(s.get('num_triangles', 0.0))\n    tri_factor = 1.0 + pow(num_tri, 0.5) / (pow(n, 0.5) if n > 0 else 1.0)\n\n    # --------------------------------------------------------------------\n    # Combine all pieces\n    # --------------------------------------------------------------------\n    estimate = (\n        base *\n        clust_factor *\n        trans_factor *\n        density_factor *\n        std_factor *\n        assort_factor *\n        bottleneck_factor *\n        hub_factor *\n        tri_factor\n    )\n\n    return float(estimate)", "spearman": 0.6693587339683493, "pearson": 0.7229132308872719, "rmse": 8.938763578437579, "mae": 6.866870031365437}}
{"timestamp": "2026-02-16T18:03:30.268320+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden call detected: locals", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:03:30.269661+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 14, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden call detected: locals", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:04:04.215652+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i3_p3_343906187", "generation": 14, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6907563025210084, "fitness_mode": "correlation", "simplicity_score": 0.15484711497506606, "novelty_bonus": 0.33499763927088455, "total_score": 0.5058848251790387, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from a set of\n    pre‑computed global statistics, without inspecting the graph itself.\n    The formula combines a size‑to‑edge baseline with multiplicative\n    corrections that account for clustering, density, degree heterogeneity,\n    assortativity, minimum‑degree bottlenecks and the presence of high‑degree\n    hubs and triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average\n        shortest‑path length.\n    \"\"\"\n    # Base features\n    n = s.get('n', 1)\n    m = s.get('m', 1)\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0.0)\n    min_deg = s.get('min_degree', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0.0)\n    degs = s.get('degrees', [])\n\n    # Handle potential division by zero\n    eps = 1e-12\n\n    # Random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = n / (max(avg_deg, eps) + 1.0)\n\n    # Corrections for structural properties\n    clust_factor      = 1.0 + avg_clust                  # more clustering → longer paths\n    density_factor    = 1.0 / (1.0 + density)           # denser → shorter paths\n    assort_factor     = 1.0 + abs(assort)                # assortative mixing → longer paths\n    std_factor        = 1.0 / (1.0 + std_deg)            # heterogeneous degrees → shorter paths\n    min_factor        = 1.0 / (1.0 + min_deg / (max(avg_deg, eps) + 1.0))  # low min degree → longer paths\n\n    # Influence of high‑degree hubs (top 5 % of the degree spectrum)\n    k = max(1, int(round(0.05 * n)))\n    if len(degs) >= k:\n        top_hubs = degs[-k:]\n        avg_high_deg = sum(top_hubs) / k\n    else:\n        avg_high_deg = avg_deg\n    hub_factor = avg_high_deg / (max(avg_deg, eps) + 1.0)\n\n    # Triangle density effect (captures local transitivity)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Combine all factors multiplicatively\n    estimate = (base * clust_factor * density_factor * assort_factor *\n                std_factor * min_factor * hub_factor * tri_factor)\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a concise set of pre‑computed\n    graph statistics.  The formula combines a size‑to‑degree baseline with\n    multiplicative corrections that capture clustering, density, degree\n    heterogeneity, assortativity, bottlenecks and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features containing the keys:\n            - 'n'                : number of nodes\n            - 'm'                : number of edges\n            - 'density'          : graph density (0–1)\n            - 'avg_degree'       : average degree\n            - 'max_degree'       : maximum degree\n            - 'min_degree'       : minimum degree\n            - 'std_degree'       : standard deviation of degrees\n            - 'avg_clustering'   : average clustering coefficient\n            - 'transitivity'     : transitivity (global clustering)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'    : total number of triangles\n            - 'degrees'          : sorted list of vertex degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic size‑to‑degree baseline\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = (n ** 0.5) / (avg_deg + 0.5)            # larger graphs and lower degree → longer paths\n\n    # Correction factors\n    clust_factor      = 1.0 + float(s.get('avg_clustering', 0.0))\n    trans_factor      = 1.0 + float(s.get('transitivity', 0.0))\n    dens_factor       = 1.0 / (1.0 + float(s.get('density', 0.0)))            # denser graphs shrink distances\n    std_factor        = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))          # high degree heterogeneity tends to shorten paths\n    assort_factor     = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))  # assortative mixing stretches distances\n\n    # Bottleneck penalty (very low min degree can lengthen paths)\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 0.5))\n\n    # Triangle effect: abundant triangles tend to shorten distances\n    tri = float(s.get('num_triangles', 0.0))\n    tri_factor = 1.0 + (tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Hub impact: the ratio of maximum to average degree influences path length\n    max_deg = float(s.get('max_degree', avg_deg))\n    hub_factor = (max_deg / (avg_deg + 0.5)) ** 0.5\n\n    # Combine all components\n    estimate = (base *\n                clust_factor *\n                trans_factor *\n                dens_factor *\n                std_factor *\n                assort_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return float(estimate)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.122583\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden call detected: locals\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines a size‑to‑degree baseline with multiplicative\n    corrections that capture clustering, density, degree heterogeneity,\n    assortativity, bottlenecks, hubs, triangles, and the median degree.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic size‑to‑degree baseline: larger graphs and smaller degree → longer paths\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = n / (max(avg_deg, 1.0))\n\n    # Multiplicative corrections\n    clustering_adj  = 1.0 + float(s.get('avg_clustering', 0.0))          # more clustering → longer paths\n    density_adj     = 1.0 / (1.0 + float(s.get('density', 0.0)))         # denser → shorter paths\n    assort_adj      = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))# assortative → longer paths\n    std_adj         = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))       # heterogeneous degrees → shorter paths\n\n    # Bottleneck penalty: very low min degree can lengthen paths\n    min_deg          = float(s.get('min_degree', 0.0))\n    bottleneck_adj   = 1.0 + (min_deg / (max(avg_deg, 1.0)))\n\n    # Hub impact: ratio of maximum to average degree\n    max_deg          = float(s.get('max_degree', max_deg if 'max_deg' in locals() else avg_deg))\n    hub_adj          = (max_deg / (max(avg_deg, 1.0))) ** 0.5\n\n    # Triangle density effect\n    num_tri          = float(s.get('num_triangles', 0.0))\n    triangle_adj     = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Median degree influence\n    degs = s.get('degrees', [])\n    if degs:\n        k = len(degs)\n        mid = k // 2\n        if k % 2 == 0:\n            median_deg = (degs[mid - 1] + degs[mid]) / 2.0\n        else:\n            median_deg = degs[mid]\n    else:\n        median_deg = avg_deg\n    median_adj = (median_deg / (max(avg_deg, 1.0))) ** 0.25\n\n    # Combine all factors\n    estimate = (\n        base\n        * clustering_adj\n        * density_adj\n        * assort_adj\n        * std_adj\n        * bottleneck_adj\n        * hub_adj\n        * triangle_adj\n        * median_adj\n    )\n\n    return float(estimate)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = n / max(avg_deg, 1.0)\n\n    clustering_adj = 1.0 + float(s.get('avg_clustering', 0.0))\n    density_adj = 1.0 / (1.0 + float(s.get('density', 0.0)))\n    assort_adj = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))\n    std_adj = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))\n\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_adj = 1.0 + (min_deg / max(avg_deg, 1.0))\n\n    max_deg = float(s.get('max_degree', avg_deg))\n    hub_adj = (max_deg / max(avg_deg, 1.0)) ** 0.5\n\n    num_tri = float(s.get('num_triangles', 0.0))\n    triangle_adj = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    degs = s.get('degrees', [])\n    if degs:\n        k = len(degs)\n        mid = k // 2\n        if k % 2 == 0:\n            median_deg = (degs[mid - 1] + degs[mid]) / 2.0\n        else:\n            median_deg = degs[mid]\n    else:\n        median_deg = avg_deg\n    median_adj = (median_deg / max(avg_deg, 1.0)) ** 0.25\n\n    estimate = (base * clustering_adj * density_adj * assort_adj * std_adj *\n                bottleneck_adj * hub_adj * triangle_adj * median_adj)\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = n / max(avg_deg, 1.0)\n\n    clustering_adj = 1.0 + float(s.get('avg_clustering', 0.0))\n    density_adj = 1.0 / (1.0 + float(s.get('density', 0.0)))\n    assort_adj = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))\n    std_adj = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))\n\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_adj = 1.0 + (min_deg / max(avg_deg, 1.0))\n\n    max_deg = float(s.get('max_degree', avg_deg))\n    hub_adj = (max_deg / max(avg_deg, 1.0)) ** 0.5\n\n    num_tri = float(s.get('num_triangles', 0.0))\n    triangle_adj = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    degs = s.get('degrees', [])\n    if degs:\n        k = len(degs)\n        mid = k // 2\n        if k % 2 == 0:\n            median_deg = (degs[mid - 1] + degs[mid]) / 2.0\n        else:\n            median_deg = degs[mid]\n    else:\n        median_deg = avg_deg\n    median_adj = (median_deg / max(avg_deg, 1.0)) ** 0.25\n\n    estimate = (base * clustering_adj * density_adj * assort_adj * std_adj *\n                bottleneck_adj * hub_adj * triangle_adj * median_adj)\n    return float(estimate)", "spearman": 0.7488322208055201, "pearson": 0.7340499357554349, "rmse": 19.119630938222663, "mae": 15.359267847502181}}
{"timestamp": "2026-02-16T18:04:04.216303+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 14, "island_id": 3, "population_idx": 3, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:04:38.813081+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i3_p4_709353430", "generation": 14, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6733733493397358, "fitness_mode": "correlation", "simplicity_score": 0.15685446318239038, "novelty_bonus": 0.3428902759852963, "total_score": 0.4689173424162416, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from a set of\n    pre‑computed global statistics, without inspecting the graph itself.\n    The formula combines a size‑to‑edge baseline with multiplicative\n    corrections that account for clustering, density, degree heterogeneity,\n    assortativity, minimum‑degree bottlenecks and the presence of high‑degree\n    hubs and triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average\n        shortest‑path length.\n    \"\"\"\n    # Base features\n    n = s.get('n', 1)\n    m = s.get('m', 1)\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 0.0)\n    max_deg = s.get('max_degree', 0.0)\n    min_deg = s.get('min_degree', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    avg_clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0.0)\n    degs = s.get('degrees', [])\n\n    # Handle potential division by zero\n    eps = 1e-12\n\n    # Random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = n / (max(avg_deg, eps) + 1.0)\n\n    # Corrections for structural properties\n    clust_factor      = 1.0 + avg_clust                  # more clustering → longer paths\n    density_factor    = 1.0 / (1.0 + density)           # denser → shorter paths\n    assort_factor     = 1.0 + abs(assort)                # assortative mixing → longer paths\n    std_factor        = 1.0 / (1.0 + std_deg)            # heterogeneous degrees → shorter paths\n    min_factor        = 1.0 / (1.0 + min_deg / (max(avg_deg, eps) + 1.0))  # low min degree → longer paths\n\n    # Influence of high‑degree hubs (top 5 % of the degree spectrum)\n    k = max(1, int(round(0.05 * n)))\n    if len(degs) >= k:\n        top_hubs = degs[-k:]\n        avg_high_deg = sum(top_hubs) / k\n    else:\n        avg_high_deg = avg_deg\n    hub_factor = avg_high_deg / (max(avg_deg, eps) + 1.0)\n\n    # Triangle density effect (captures local transitivity)\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Combine all factors multiplicatively\n    estimate = (base * clust_factor * density_factor * assort_factor *\n                std_factor * min_factor * hub_factor * tri_factor)\n\n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a concise set of pre‑computed\n    graph statistics.  The formula combines a size‑to‑degree baseline with\n    multiplicative corrections that capture clustering, density, degree\n    heterogeneity, assortativity, bottlenecks and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features containing the keys:\n            - 'n'                : number of nodes\n            - 'm'                : number of edges\n            - 'density'          : graph density (0–1)\n            - 'avg_degree'       : average degree\n            - 'max_degree'       : maximum degree\n            - 'min_degree'       : minimum degree\n            - 'std_degree'       : standard deviation of degrees\n            - 'avg_clustering'   : average clustering coefficient\n            - 'transitivity'     : transitivity (global clustering)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'    : total number of triangles\n            - 'degrees'          : sorted list of vertex degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic size‑to‑degree baseline\n    n = float(s.get('n', 1))\n    m = float(s.get('m', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = (n ** 0.5) / (avg_deg + 0.5)            # larger graphs and lower degree → longer paths\n\n    # Correction factors\n    clust_factor      = 1.0 + float(s.get('avg_clustering', 0.0))\n    trans_factor      = 1.0 + float(s.get('transitivity', 0.0))\n    dens_factor       = 1.0 / (1.0 + float(s.get('density', 0.0)))            # denser graphs shrink distances\n    std_factor        = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))          # high degree heterogeneity tends to shorten paths\n    assort_factor     = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))  # assortative mixing stretches distances\n\n    # Bottleneck penalty (very low min degree can lengthen paths)\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 0.5))\n\n    # Triangle effect: abundant triangles tend to shorten distances\n    tri = float(s.get('num_triangles', 0.0))\n    tri_factor = 1.0 + (tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Hub impact: the ratio of maximum to average degree influences path length\n    max_deg = float(s.get('max_degree', avg_deg))\n    hub_factor = (max_deg / (avg_deg + 0.5)) ** 0.5\n\n    # Combine all components\n    estimate = (base *\n                clust_factor *\n                trans_factor *\n                dens_factor *\n                std_factor *\n                assort_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed global statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all optional, defaults applied):\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (float)\n            - 'min_degree' (float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of int, sorted ascending)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic sizes and averages\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n\n    # Avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Correction factors derived from structural descriptors\n    clust_f   = 1.0 + float(s.get('avg_clustering', 0.0))\n    trans_f   = 1.0 + float(s.get('transitivity', 0.0))\n    dens_f    = 1.0 / (1.0 + float(s.get('density', 0.0)))\n    std_f     = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))\n    assort_f  = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))\n\n    # Bottleneck (very low minimum degree) and hub (high maximum degree) effects\n    min_deg   = float(s.get('min_degree', 0.0))\n    bott_f    = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    max_deg   = float(s.get('max_degree', avg_deg))\n    hub_f     = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangle density effect\n    num_tri   = float(s.get('num_triangles', 0.0))\n    tri_f     = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Combine all factors multiplicatively\n    estimate = (base * clust_f * trans_f * dens_f * std_f *\n                assort_f * bott_f * hub_f * tri_f)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed global statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all optional, defaults applied):\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (float)\n            - 'min_degree' (float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of int, sorted ascending)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic sizes and averages\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n\n    # Avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # Correction factors derived from structural descriptors\n    clust_f   = 1.0 + float(s.get('avg_clustering', 0.0))\n    trans_f   = 1.0 + float(s.get('transitivity', 0.0))\n    dens_f    = 1.0 / (1.0 + float(s.get('density', 0.0)))\n    std_f     = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))\n    assort_f  = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))\n\n    # Bottleneck (very low minimum degree) and hub (high maximum degree) effects\n    min_deg   = float(s.get('min_degree', 0.0))\n    bott_f    = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))\n\n    max_deg   = float(s.get('max_degree', avg_deg))\n    hub_f     = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangle density effect\n    num_tri   = float(s.get('num_triangles', 0.0))\n    tri_f     = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Combine all factors multiplicatively\n    estimate = (base * clust_f * trans_f * dens_f * std_f *\n                assort_f * bott_f * hub_f * tri_f)\n\n    return float(estimate)", "spearman": 0.6693587339683493, "pearson": 0.7229132308872719, "rmse": 8.938763578437579, "mae": 6.866870031365437}}
{"timestamp": "2026-02-16T18:04:38.822651+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 15, "model_name": "gpt-oss:20b", "best_val_score": 0.5437150506550943, "no_improve_count": 0}}
{"timestamp": "2026-02-16T18:06:24.507741+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i0_p0_431368901", "generation": 15, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.8473949579831932, "fitness_mode": "correlation", "simplicity_score": 0.22137394722358028, "novelty_bonus": 0.1695072376809419, "total_score": 0.5366959999749793, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.7 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.9)\n    base *= (1.0 + trans * 0.9)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.7)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.5\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.8)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.044994\nbelow_train_threshold: train_signal=0.018776\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base", "spearman": 0.8831380784519614, "pearson": 0.8183468779684626, "rmse": 0.9984024614318124, "mae": 0.6678555369210403}}
{"timestamp": "2026-02-16T18:07:14.275682+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:07:14.277058+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 15, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:07:29.209819+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i0_p1_139821265", "generation": 15, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.828859543817527, "fitness_mode": "correlation", "simplicity_score": 0.22113343699055302, "novelty_bonus": 0.2043064947762897, "total_score": 0.5466511641442053, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.7 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.9)\n    base *= (1.0 + trans * 0.9)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.7)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.5\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.8)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.044994\nbelow_train_threshold: train_signal=0.018776\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 08)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base", "spearman": 0.8822650566264157, "pearson": 0.817347552090235, "rmse": 0.5746952936508153, "mae": 0.35687948558486027}}
{"timestamp": "2026-02-16T18:07:29.212940+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 15, "island_id": 0, "population_idx": 1, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:08:02.285384+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:08:02.286032+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 15, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:09:23.999797+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i0_p2_456945452", "generation": 15, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.7788235294117648, "fitness_mode": "correlation", "simplicity_score": 0.22168752438400124, "novelty_bonus": 0.2339694346078568, "total_score": 0.4635345604147862, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.7 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.9)\n    base *= (1.0 + trans * 0.9)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.7)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.5\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.8)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.044994\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\ndef new_invariant(s):\n    import math\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base term: log size times sqrt average degree, dampened by density\n    base = (math.log(n + 1) * math.sqrt(avg_deg)) / (density + 0.1)\n\n    # Adjust for degree heterogeneity\n    base *= (1 + (avg_deg - min_deg) / (avg_deg + 1))\n    base *= (1 + std_deg / (avg_deg + 1))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base /= (1 + clustering)\n    base /= (1 + trans)\n\n    # Assortativity tends to lengthen paths\n    base *= (1 + abs(assort))\n\n    # Triangle contribution\n    base += triangles / (m + 1)\n\n    # Leaf nodes increase path lengths\n    base *= (1 + leaf_frac)\n\n    # Hub effect: large max degree reduces path length\n    base /= (1 + max_deg / (n + 1))\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (m + 1.0)\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # Hub effect: large max degree reduces path length\n    base /= (1.0 + max_deg / (n + 1.0))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (m + 1.0)\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # Hub effect: large max degree reduces path length\n    base /= (1.0 + max_deg / (n + 1.0))\n\n    return base", "spearman": 0.6980124503112578, "pearson": 0.7188282789020012, "rmse": 1.347835470003998, "mae": 0.9883743896754866}}
{"timestamp": "2026-02-16T18:09:24.000890+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 15, "island_id": 0, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:10:39.790013+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i0_p3_570939379", "generation": 15, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22205049545154468, "novelty_bonus": 0.25138613993252834, "total_score": 0.5273613794560271, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.7 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.9)\n    base *= (1.0 + trans * 0.9)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.7)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.5\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.8)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed.\n    \"\"\"\n    n          = s['n']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed.\n    \"\"\"\n    n          = s['n']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T18:13:56.111836+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i0_p4_101729401", "generation": 15, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22165548823651432, "novelty_bonus": 0.25138613993252834, "total_score": 0.527282378013021, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.7 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.9)\n    base *= (1.0 + trans * 0.9)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.7)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.5\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.8)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact, interpretable, and uses only arithmetic on the\n    supplied features.  No graph traversal or external libraries are required.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact, interpretable, and uses only arithmetic on the\n    supplied features.  No graph traversal or external libraries are required.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T18:14:35.297308+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i1_p0_362756267", "generation": 15, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22162360630380393, "novelty_bonus": 0.25138613993252834, "total_score": 0.5272760016264789, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.285570\nno_valid_train_predictions: static_invalid: missing `new_invariant` function\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T18:15:32.479376+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.296134", "model_name": "gpt-oss:20b", "train_signal": 0.2961344537815126}}
{"timestamp": "2026-02-16T18:16:40.254652+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:16:40.255849+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 15, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:17:20.842685+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i1_p2_842934436", "generation": 15, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7145738295318126, "fitness_mode": "correlation", "simplicity_score": 0.22146646413886412, "novelty_bonus": 0.2543734988459191, "total_score": 0.5255209653721209, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.285570\nno_valid_train_predictions: static_invalid: missing `new_invariant` function\nbelow_train_threshold: train_signal=0.296134\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, leaf‑node fraction, and\n    edge count.  No graph traversal is performed; only arithmetic on the\n    supplied features is used.\n    \"\"\"\n    # Extract features with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = np.sqrt(n) / np.sqrt(avg_deg)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += np.sqrt(triangles) / (n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    # 9. Small adjustment from the edge count (log‑scale)\n    base += np.log(m + 1.0) / (n + 1.0)\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += (triangles ** 0.5) / (n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += (triangles ** 0.5) / (n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8098312457811447, "pearson": 0.767823078476736, "rmse": 4.414960569687729, "mae": 3.930706812519572}}
{"timestamp": "2026-02-16T18:17:20.844665+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 15, "island_id": 1, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:18:18.786158+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i1_p3_576982426", "generation": 15, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22165548823651432, "novelty_bonus": 0.25138613993252834, "total_score": 0.527282378013021, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: missing `new_invariant` function\nbelow_train_threshold: train_signal=0.296134\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T18:19:30.657822+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.194430", "model_name": "gpt-oss:20b", "train_signal": 0.1944297719087635}}
{"timestamp": "2026-02-16T18:20:06.663331+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i2_p0_643929713", "generation": 15, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8622809123649459, "fitness_mode": "correlation", "simplicity_score": 0.12011929088081999, "novelty_bonus": 0.2439650011795802, "total_score": 0.537144356804995, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic is based on a random‑graph baseline and\n    multiplicative corrections that capture the influence of clustering,\n    transitivity, density, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.078715\nbelow_novelty_threshold: novelty_bonus=0.063245\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of\n    clustering, transitivity, density, degree heterogeneity, assortativity,\n    low‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n    else:\n        possible_tri = 0.0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering              # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                    # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)          # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)        # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)    # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)        # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of\n    clustering, transitivity, density, degree heterogeneity, assortativity,\n    low‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n    else:\n        possible_tri = 0.0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering              # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                    # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)          # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)        # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)    # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)        # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)", "spearman": 0.8798619965499139, "pearson": 0.856530736217558, "rmse": 10.889728766202964, "mae": 9.3389863953469}}
{"timestamp": "2026-02-16T18:20:48.786560+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i2_p1_609075865", "generation": 15, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7465546218487394, "fitness_mode": "correlation", "simplicity_score": 0.11758126705949756, "novelty_bonus": 0.33808854081107476, "total_score": 0.4979511408633522, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic is based on a random‑graph baseline and\n    multiplicative corrections that capture the influence of clustering,\n    transitivity, density, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.078715\nbelow_novelty_threshold: novelty_bonus=0.063245\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic uses a random‑graph baseline and\n    multiplicative corrections that capture the influence of clustering,\n    transitivity, density, degree heterogeneity, assortativity, low‑degree\n    vertices, triangle density and degree spread.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # --- Basic random‑graph baseline ---------------------------------------\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # --- Feature values with safe defaults --------------------------------\n    clustering   = s.get('avg_clustering', 0.0)\n    trans        = s.get('transitivity', 0.0)\n    density      = s.get('density', 0.0)\n    std_deg      = s.get('std_degree', 0.0)\n    assort       = s.get('degree_assortativity', 0.0)\n    min_deg      = s.get('min_degree', avg_deg)\n    if min_deg < 0.0:\n        min_deg = 0.0\n    max_deg      = s.get('max_degree', avg_deg)\n    num_tri      = s.get('num_triangles', 0)\n\n    # --- Triangle density ratio --------------------------------------------\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6\n    else:\n        possible_tri = 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # --- Multiplicative correction factors --------------------------------\n    clustering_factor = 1.0 + 0.5 * clustering\n    trans_factor      = 1.0 + 0.5 * trans\n    density_factor    = 1.0 / (1.0 + density)\n    hetero_factor     = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    assort_factor     = 1.0 + 0.3 * abs(assort)\n    min_factor        = 1.0 + 1.0 / (min_deg + 1.0)\n    tri_factor        = 1.0 / (1.0 + tri_ratio)\n    max_factor        = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # --- Final estimate ----------------------------------------------------\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor *\n            max_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic uses a random‑graph baseline and\n    multiplicative corrections that capture the influence of clustering,\n    transitivity, density, degree heterogeneity, assortativity, low‑degree\n    vertices, triangle density and degree spread.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # --- Basic random‑graph baseline ---------------------------------------\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # --- Feature values with safe defaults --------------------------------\n    clustering   = s.get('avg_clustering', 0.0)\n    trans        = s.get('transitivity', 0.0)\n    density      = s.get('density', 0.0)\n    std_deg      = s.get('std_degree', 0.0)\n    assort       = s.get('degree_assortativity', 0.0)\n    min_deg      = s.get('min_degree', avg_deg)\n    if min_deg < 0.0:\n        min_deg = 0.0\n    max_deg      = s.get('max_degree', avg_deg)\n    num_tri      = s.get('num_triangles', 0)\n\n    # --- Triangle density ratio --------------------------------------------\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6\n    else:\n        possible_tri = 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # --- Multiplicative correction factors --------------------------------\n    clustering_factor = 1.0 + 0.5 * clustering\n    trans_factor      = 1.0 + 0.5 * trans\n    density_factor    = 1.0 / (1.0 + density)\n    hetero_factor     = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    assort_factor     = 1.0 + 0.3 * abs(assort)\n    min_factor        = 1.0 + 1.0 / (min_deg + 1.0)\n    tri_factor        = 1.0 / (1.0 + tri_ratio)\n    max_factor        = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # --- Final estimate ----------------------------------------------------\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor *\n            max_factor)", "spearman": 0.7460166504162605, "pearson": 0.6711976906659709, "rmse": 1.3905560599797187, "mae": 1.0117099223964623}}
{"timestamp": "2026-02-16T18:21:25.266052+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:21:25.267296+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 15, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:21:52.248147+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 2, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.105557", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:21:52.248892+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 15, "island_id": 2, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:22:31.029177+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i2_p3_300294398", "generation": 15, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8622809123649459, "fitness_mode": "correlation", "simplicity_score": 0.12679266757920307, "novelty_bonus": 0.2439650011795802, "total_score": 0.5384790321446716, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic is based on a random‑graph baseline and\n    multiplicative corrections that capture the influence of clustering,\n    transitivity, density, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.063245\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.105557\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)", "spearman": 0.8798619965499139, "pearson": 0.856530736217558, "rmse": 10.889728766202962, "mae": 9.3389863953469}}
{"timestamp": "2026-02-16T18:23:08.902152+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.109158", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:23:08.903878+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 15, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.109158", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:23:40.558901+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i2_p4_423506692", "generation": 15, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8703481392557022, "fitness_mode": "correlation", "simplicity_score": 0.12049740835297465, "novelty_bonus": 0.22480670279544235, "total_score": 0.5349105767363334, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic is based on a random‑graph baseline and\n    multiplicative corrections that capture the influence of clustering,\n    transitivity, density, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.063245\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.105557\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.109158\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the influence of clustering, transitivity, density,\n    degree heterogeneity, assortativity, low‑degree vertices and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + 0.5 * clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + 0.5 * trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + 2.0 * density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.3 * abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)        # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)            # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the influence of clustering, transitivity, density,\n    degree heterogeneity, assortativity, low‑degree vertices and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n    else:\n        possible_tri = 0.0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the influence of clustering, transitivity, density,\n    degree heterogeneity, assortativity, low‑degree vertices and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n    else:\n        possible_tri = 0.0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + abs(assort)            # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)", "spearman": 0.8867381684542115, "pearson": 0.8658662523669716, "rmse": 12.25504673775109, "mae": 10.291301689150124}}
{"timestamp": "2026-02-16T18:23:40.560395+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 15, "island_id": 2, "population_idx": 4, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T18:24:35.336111+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i3_p0_300527601", "generation": 15, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5180792316926771, "fitness_mode": "correlation", "simplicity_score": 0.1548007963727991, "novelty_bonus": 0.5064760667737416, "total_score": 0.45826486335378347, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\n\ndef new_invariant(s):\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = n / max(avg_deg, 1.0)\n\n    clustering_adj = 1.0 + float(s.get('avg_clustering', 0.0))\n    density_adj = 1.0 / (1.0 + float(s.get('density', 0.0)))\n    assort_adj = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))\n    std_adj = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))\n\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_adj = 1.0 + (min_deg / max(avg_deg, 1.0))\n\n    max_deg = float(s.get('max_degree', avg_deg))\n    hub_adj = (max_deg / max(avg_deg, 1.0)) ** 0.5\n\n    num_tri = float(s.get('num_triangles', 0.0))\n    triangle_adj = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    degs = s.get('degrees', [])\n    if degs:\n        k = len(degs)\n        mid = k // 2\n        if k % 2 == 0:\n            median_deg = (degs[mid - 1] + degs[mid]) / 2.0\n        else:\n            median_deg = degs[mid]\n    else:\n        median_deg = avg_deg\n    median_adj = (median_deg / max(avg_deg, 1.0)) ** 0.25\n\n    estimate = (base * clustering_adj * density_adj * assort_adj * std_adj *\n                bottleneck_adj * hub_adj * triangle_adj * median_adj)\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features.\n    The estimate uses a simple baseline that scales with the number of nodes and\n    inversely with the mean degree, and it multiplies several correction\n    factors that capture clustering, density, degree heterogeneity,\n    assortativity, triangles, and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics. Expected keys:\n            - 'n'                 : number of nodes\n            - 'm'                 : number of edges\n            - 'density'           : graph density (0–1)\n            - 'avg_degree'        : average degree\n            - 'max_degree'        : maximum degree\n            - 'min_degree'        : minimum degree\n            - 'std_degree'        : standard deviation of degrees\n            - 'avg_clustering'    : average clustering coefficient\n            - 'transitivity'      : global transitivity\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'     : total number of triangles\n            - 'degrees'           : sorted list of degrees\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Extract features with safe defaults\n    n          = float(s.get('n', 1))\n    m          = float(s.get('m', 0))\n    density    = float(s.get('density', 0))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    avg_clust  = float(s.get('avg_clustering', 0.0))\n    trans      = float(s.get('transitivity', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Avoid divisions by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # Simple baseline inversely proportional to the mean degree\n    base = n / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + avg_clust                 # higher clustering → longer paths\n    trans_factor   = 1.0 + trans                     # higher transitivity → longer paths\n    assort_factor  = 1.0 + abs(assort)                # more assortative mixing → longer paths\n    dens_factor    = 1.0 / (1.0 + density)           # denser graphs → shorter paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)           # heterogeneous degrees → shorter paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low minimum degree can bottleneck\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps) # many triangles → shorter paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5   # presence of hubs shortens paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                trans_factor *\n                assort_factor *\n                dens_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features.\n    The estimate uses a simple baseline that scales with the number of nodes and\n    inversely with the mean degree, and it multiplies several correction\n    factors that capture clustering, density, degree heterogeneity,\n    assortativity, triangles, and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics. Expected keys:\n            - 'n'                 : number of nodes\n            - 'm'                 : number of edges\n            - 'density'           : graph density (0–1)\n            - 'avg_degree'        : average degree\n            - 'max_degree'        : maximum degree\n            - 'min_degree'        : minimum degree\n            - 'std_degree'        : standard deviation of degrees\n            - 'avg_clustering'    : average clustering coefficient\n            - 'transitivity'      : global transitivity\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'     : total number of triangles\n            - 'degrees'           : sorted list of degrees\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Extract features with safe defaults\n    n          = float(s.get('n', 1))\n    m          = float(s.get('m', 0))\n    density    = float(s.get('density', 0))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    avg_clust  = float(s.get('avg_clustering', 0.0))\n    trans      = float(s.get('transitivity', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Avoid divisions by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # Simple baseline inversely proportional to the mean degree\n    base = n / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + avg_clust                 # higher clustering → longer paths\n    trans_factor   = 1.0 + trans                     # higher transitivity → longer paths\n    assort_factor  = 1.0 + abs(assort)                # more assortative mixing → longer paths\n    dens_factor    = 1.0 / (1.0 + density)           # denser graphs → shorter paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)           # heterogeneous degrees → shorter paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low minimum degree can bottleneck\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps) # many triangles → shorter paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5   # presence of hubs shortens paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                trans_factor *\n                assort_factor *\n                dens_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return float(estimate)", "spearman": 0.5507237680942024, "pearson": 0.621683990961215, "rmse": 17.92938705674018, "mae": 14.608968565438632}}
{"timestamp": "2026-02-16T18:25:14.997979+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i3_p1_656035337", "generation": 15, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6907563025210084, "fitness_mode": "correlation", "simplicity_score": 0.15418651370236358, "novelty_bonus": 0.33499763927088455, "total_score": 0.5057527049244981, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\n\ndef new_invariant(s):\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = n / max(avg_deg, 1.0)\n\n    clustering_adj = 1.0 + float(s.get('avg_clustering', 0.0))\n    density_adj = 1.0 / (1.0 + float(s.get('density', 0.0)))\n    assort_adj = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))\n    std_adj = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))\n\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_adj = 1.0 + (min_deg / max(avg_deg, 1.0))\n\n    max_deg = float(s.get('max_degree', avg_deg))\n    hub_adj = (max_deg / max(avg_deg, 1.0)) ** 0.5\n\n    num_tri = float(s.get('num_triangles', 0.0))\n    triangle_adj = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    degs = s.get('degrees', [])\n    if degs:\n        k = len(degs)\n        mid = k // 2\n        if k % 2 == 0:\n            median_deg = (degs[mid - 1] + degs[mid]) / 2.0\n        else:\n            median_deg = degs[mid]\n    else:\n        median_deg = avg_deg\n    median_adj = (median_deg / max(avg_deg, 1.0)) ** 0.25\n\n    estimate = (base * clustering_adj * density_adj * assort_adj * std_adj *\n                bottleneck_adj * hub_adj * triangle_adj * median_adj)\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing global graph features. Missing keys are replaced by\n        sensible defaults:\n            - 'n' : 1\n            - 'avg_degree' : 1.0\n            - 'avg_clustering' : 0.0\n            - 'density' : 0.0\n            - 'degree_assortativity' : 0.0\n            - 'std_degree' : 0.0\n            - 'min_degree' : 0.0\n            - 'max_degree' : avg_degree\n            - 'num_triangles' : 0.0\n            - 'degrees' : None\n\n    Returns\n    -------\n    float\n        A numeric estimate correlated with the graph's average shortest‑path length.\n    \"\"\"\n    # Base estimate: larger n and smaller average degree → longer paths\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = n / max(avg_deg, 1.0)\n\n    # Retrieve auxiliary statistics\n    clust = float(s.get('avg_clustering', 0.0))\n    density = float(s.get('density', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    min_deg = float(s.get('min_degree', 0.0))\n    max_deg = float(s.get('max_degree', avg_deg))\n    num_tri = float(s.get('num_triangles', 0.0))\n    degrees = s.get('degrees', None)\n\n    # Adjustment factors\n    clust_adj = 1.0 + clust                         # higher clustering → longer paths\n    density_adj = 1.0 / (1.0 + density)             # denser graphs shorten paths\n    assort_adj = 1.0 + abs(assort)                  # assortative mixing elongates paths\n    std_adj = 1.0 / (1.0 + std_deg)                 # heterogeneous degrees shorten paths\n    min_adj = 1.0 + (min_deg / max(avg_deg, 1.0))   # very low min degree can lengthen paths\n    hub_adj = (max_deg / max(avg_deg, 1.0)) ** 0.5  # presence of hubs reduces distances\n    tri_adj = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Median degree adjustment if degree list is available\n    if degrees and len(degrees) > 0:\n        k = len(degrees)\n        mid = k // 2\n        if k % 2 == 0:\n            median = (degrees[mid - 1] + degrees[mid]) / 2.0\n        else:\n            median = degrees[mid]\n        median_adj = (median / max(avg_deg, 1.0)) ** 0.25\n    else:\n        median_adj = 1.0\n\n    # Combine all factors\n    estimate = (base * clust_adj * density_adj * assort_adj *\n                std_adj * min_adj * hub_adj * tri_adj * median_adj)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing global graph features. Missing keys are replaced by\n        sensible defaults:\n            - 'n' : 1\n            - 'avg_degree' : 1.0\n            - 'avg_clustering' : 0.0\n            - 'density' : 0.0\n            - 'degree_assortativity' : 0.0\n            - 'std_degree' : 0.0\n            - 'min_degree' : 0.0\n            - 'max_degree' : avg_degree\n            - 'num_triangles' : 0.0\n            - 'degrees' : None\n\n    Returns\n    -------\n    float\n        A numeric estimate correlated with the graph's average shortest‑path length.\n    \"\"\"\n    # Base estimate: larger n and smaller average degree → longer paths\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = n / max(avg_deg, 1.0)\n\n    # Retrieve auxiliary statistics\n    clust = float(s.get('avg_clustering', 0.0))\n    density = float(s.get('density', 0.0))\n    assort = float(s.get('degree_assortativity', 0.0))\n    std_deg = float(s.get('std_degree', 0.0))\n    min_deg = float(s.get('min_degree', 0.0))\n    max_deg = float(s.get('max_degree', avg_deg))\n    num_tri = float(s.get('num_triangles', 0.0))\n    degrees = s.get('degrees', None)\n\n    # Adjustment factors\n    clust_adj = 1.0 + clust                         # higher clustering → longer paths\n    density_adj = 1.0 / (1.0 + density)             # denser graphs shorten paths\n    assort_adj = 1.0 + abs(assort)                  # assortative mixing elongates paths\n    std_adj = 1.0 / (1.0 + std_deg)                 # heterogeneous degrees shorten paths\n    min_adj = 1.0 + (min_deg / max(avg_deg, 1.0))   # very low min degree can lengthen paths\n    hub_adj = (max_deg / max(avg_deg, 1.0)) ** 0.5  # presence of hubs reduces distances\n    tri_adj = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    # Median degree adjustment if degree list is available\n    if degrees and len(degrees) > 0:\n        k = len(degrees)\n        mid = k // 2\n        if k % 2 == 0:\n            median = (degrees[mid - 1] + degrees[mid]) / 2.0\n        else:\n            median = degrees[mid]\n        median_adj = (median / max(avg_deg, 1.0)) ** 0.25\n    else:\n        median_adj = 1.0\n\n    # Combine all factors\n    estimate = (base * clust_adj * density_adj * assort_adj *\n                std_adj * min_adj * hub_adj * tri_adj * median_adj)\n\n    return float(estimate)", "spearman": 0.7488322208055201, "pearson": 0.7340499357554349, "rmse": 19.119630938222663, "mae": 15.359267847502181}}
{"timestamp": "2026-02-16T18:26:00.306909+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i3_p2_187974369", "generation": 15, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6901800720288115, "fitness_mode": "correlation", "simplicity_score": 0.15558659087281873, "novelty_bonus": 0.371845035328932, "total_score": 0.5133405955174121, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\n\ndef new_invariant(s):\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = n / max(avg_deg, 1.0)\n\n    clustering_adj = 1.0 + float(s.get('avg_clustering', 0.0))\n    density_adj = 1.0 / (1.0 + float(s.get('density', 0.0)))\n    assort_adj = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))\n    std_adj = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))\n\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_adj = 1.0 + (min_deg / max(avg_deg, 1.0))\n\n    max_deg = float(s.get('max_degree', avg_deg))\n    hub_adj = (max_deg / max(avg_deg, 1.0)) ** 0.5\n\n    num_tri = float(s.get('num_triangles', 0.0))\n    triangle_adj = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    degs = s.get('degrees', [])\n    if degs:\n        k = len(degs)\n        mid = k // 2\n        if k % 2 == 0:\n            median_deg = (degs[mid - 1] + degs[mid]) / 2.0\n        else:\n            median_deg = degs[mid]\n    else:\n        median_deg = avg_deg\n    median_adj = (median_deg / max(avg_deg, 1.0)) ** 0.25\n\n    estimate = (base * clustering_adj * density_adj * assort_adj * std_adj *\n                bottleneck_adj * hub_adj * triangle_adj * median_adj)\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length of a graph from pre‑computed\n    global features.  The estimate uses a baseline that grows with the\n    square‑root of the number of nodes and is inversely related to the\n    average degree.  Several multiplicative corrections capture how\n    clustering, density, degree heterogeneity, assortativity, bottlenecks\n    (low minimum degree), hubs (high maximum degree) and triangles influence\n    typical distances.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph statistics with possible keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (float)\n        - 'min_degree' (float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Numeric estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Pull values with defaults, converting to float for consistency\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    clust      = float(s.get('avg_clustering', 0.0))\n    density    = float(s.get('density', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Guard against division by zero\n    eps       = 1e-12\n    avg_deg   = max(avg_deg, eps)\n    max_deg   = max(max_deg, eps)\n    std_deg   = max(std_deg, eps)\n    min_deg   = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # Square‑root dependence on n, scaled by average degree\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering tends to increase distances\n    clust_factor   = 1.0 + clust\n\n    # Density shortens paths\n    dens_factor    = 1.0 / (1.0 + density)\n\n    # Assortative mixing can elongate paths\n    assort_factor  = 1.0 + abs(assort)\n\n    # Degree heterogeneity (large std) usually shortens distances\n    hetero_factor  = 1.0 / (1.0 + std_deg)\n\n    # Very low minimum degree can create bottlenecks\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Hubs (high maximum degree) tend to reduce typical distances\n    hub_factor     = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangles create shortcuts\n    tri_factor = 1.0 + ((num_tri ** 0.5) / (n ** 0.5 + eps))\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length of a graph from pre‑computed\n    global features.  The estimate uses a baseline that grows with the\n    square‑root of the number of nodes and is inversely related to the\n    average degree.  Several multiplicative corrections capture how\n    clustering, density, degree heterogeneity, assortativity, bottlenecks\n    (low minimum degree), hubs (high maximum degree) and triangles influence\n    typical distances.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph statistics with possible keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (float)\n        - 'min_degree' (float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Numeric estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Pull values with defaults, converting to float for consistency\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    clust      = float(s.get('avg_clustering', 0.0))\n    density    = float(s.get('density', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Guard against division by zero\n    eps       = 1e-12\n    avg_deg   = max(avg_deg, eps)\n    max_deg   = max(max_deg, eps)\n    std_deg   = max(std_deg, eps)\n    min_deg   = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # Square‑root dependence on n, scaled by average degree\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering tends to increase distances\n    clust_factor   = 1.0 + clust\n\n    # Density shortens paths\n    dens_factor    = 1.0 / (1.0 + density)\n\n    # Assortative mixing can elongate paths\n    assort_factor  = 1.0 + abs(assort)\n\n    # Degree heterogeneity (large std) usually shortens distances\n    hetero_factor  = 1.0 / (1.0 + std_deg)\n\n    # Very low minimum degree can create bottlenecks\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Hubs (high maximum degree) tend to reduce typical distances\n    hub_factor     = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangles create shortcuts\n    tri_factor = 1.0 + ((num_tri ** 0.5) / (n ** 0.5 + eps))\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return float(estimate)", "spearman": 0.7413395334883374, "pearson": 0.740784516881863, "rmse": 1.1368805512560611, "mae": 1.0163434818161656}}
{"timestamp": "2026-02-16T18:26:32.818113+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i3_p3_808501667", "generation": 15, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.7628811524609843, "fitness_mode": "correlation", "simplicity_score": 0.15892187219941084, "novelty_bonus": 0.17198565798695054, "total_score": 0.48144502345975804, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\n\ndef new_invariant(s):\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = n / max(avg_deg, 1.0)\n\n    clustering_adj = 1.0 + float(s.get('avg_clustering', 0.0))\n    density_adj = 1.0 / (1.0 + float(s.get('density', 0.0)))\n    assort_adj = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))\n    std_adj = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))\n\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_adj = 1.0 + (min_deg / max(avg_deg, 1.0))\n\n    max_deg = float(s.get('max_degree', avg_deg))\n    hub_adj = (max_deg / max(avg_deg, 1.0)) ** 0.5\n\n    num_tri = float(s.get('num_triangles', 0.0))\n    triangle_adj = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    degs = s.get('degrees', [])\n    if degs:\n        k = len(degs)\n        mid = k // 2\n        if k % 2 == 0:\n            median_deg = (degs[mid - 1] + degs[mid]) / 2.0\n        else:\n            median_deg = degs[mid]\n    else:\n        median_deg = avg_deg\n    median_adj = (median_deg / max(avg_deg, 1.0)) ** 0.25\n\n    estimate = (base * clustering_adj * density_adj * assort_adj * std_adj *\n                bottleneck_adj * hub_adj * triangle_adj * median_adj)\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed graph\n    statistics.  The estimate is built from a baseline that scales with the\n    number of nodes and inversely with the average degree, and a series of\n    multiplicative correction factors that capture the influence of clustering,\n    density, degree heterogeneity, assortativity, bottleneck nodes, hub\n    concentration, and triangle abundance.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Keys must include:\n            - 'n'                : number of nodes\n            - 'm'                : number of edges\n            - 'density'          : graph density (0–1)\n            - 'avg_degree'       : average degree\n            - 'max_degree'       : maximum degree\n            - 'min_degree'       : minimum degree\n            - 'std_degree'       : standard deviation of degrees\n            - 'avg_clustering'   : average clustering coefficient\n            - 'transitivity'     : global transitivity (0–1)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'    : total number of triangles\n            - 'degrees'          : sorted list of degrees (optional)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path\n        length.\n    \"\"\"\n    # Core quantities\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clust      = s['avg_clustering']\n    density    = s['density']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n\n    # Basic baseline: grows with |V| and shrinks with mean degree\n    base = n / (avg_deg + 1)\n\n    # Multiplicative corrections\n    clust_factor   = 1.0 + clust                     # higher clustering → longer paths\n    dens_factor    = 1.0 / (1.0 + density)           # denser graphs → shorter paths\n    assort_factor  = 1.0 + abs(assort)               # more assortative → longer paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)           # heterogeneous degrees → shorter paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1))  # low minimum degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # hubs tend to reduce distances\n    tri_factor     = 1.0 + (num_tri ** 0.5) / (n + 1)  # many triangles → shorter paths\n\n    # Combine everything\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed graph\n    statistics.  The estimate is built from a baseline that scales with the\n    number of nodes and inversely with the average degree, and a series of\n    multiplicative correction factors that capture the influence of clustering,\n    density, degree heterogeneity, assortativity, bottleneck nodes, hub\n    concentration, and triangle abundance.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Keys must include:\n            - 'n'                : number of nodes\n            - 'm'                : number of edges\n            - 'density'          : graph density (0–1)\n            - 'avg_degree'       : average degree\n            - 'max_degree'       : maximum degree\n            - 'min_degree'       : minimum degree\n            - 'std_degree'       : standard deviation of degrees\n            - 'avg_clustering'   : average clustering coefficient\n            - 'transitivity'     : global transitivity (0–1)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'    : total number of triangles\n            - 'degrees'          : sorted list of degrees (optional)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path\n        length.\n    \"\"\"\n    # Core quantities\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clust      = s['avg_clustering']\n    density    = s['density']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n\n    # Basic baseline: grows with |V| and shrinks with mean degree\n    base = n / (avg_deg + 1)\n\n    # Multiplicative corrections\n    clust_factor   = 1.0 + clust                     # higher clustering → longer paths\n    dens_factor    = 1.0 / (1.0 + density)           # denser graphs → shorter paths\n    assort_factor  = 1.0 + abs(assort)               # more assortative → longer paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)           # heterogeneous degrees → shorter paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1))  # low minimum degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # hubs tend to reduce distances\n    tri_factor     = 1.0 + (num_tri ** 0.5) / (n + 1)  # many triangles → shorter paths\n\n    # Combine everything\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return float(estimate)", "spearman": 0.7961299032475814, "pearson": 0.7030416163628692, "rmse": 7.32495323725477, "mae": 4.765149659473361}}
{"timestamp": "2026-02-16T18:27:16.200172+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i3_p4_958965204", "generation": 15, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6768307322929171, "fitness_mode": "correlation", "simplicity_score": 0.15324228252574418, "novelty_bonus": 0.38263160123949647, "total_score": 0.5053801854332117, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\n\ndef new_invariant(s):\n    n = float(s.get('n', 1))\n    avg_deg = float(s.get('avg_degree', 1.0))\n    base = n / max(avg_deg, 1.0)\n\n    clustering_adj = 1.0 + float(s.get('avg_clustering', 0.0))\n    density_adj = 1.0 / (1.0 + float(s.get('density', 0.0)))\n    assort_adj = 1.0 + abs(float(s.get('degree_assortativity', 0.0)))\n    std_adj = 1.0 / (1.0 + float(s.get('std_degree', 0.0)))\n\n    min_deg = float(s.get('min_degree', 0.0))\n    bottleneck_adj = 1.0 + (min_deg / max(avg_deg, 1.0))\n\n    max_deg = float(s.get('max_degree', avg_deg))\n    hub_adj = (max_deg / max(avg_deg, 1.0)) ** 0.5\n\n    num_tri = float(s.get('num_triangles', 0.0))\n    triangle_adj = 1.0 + (num_tri ** 0.5) / (n ** 0.5 if n > 0 else 1.0)\n\n    degs = s.get('degrees', [])\n    if degs:\n        k = len(degs)\n        mid = k // 2\n        if k % 2 == 0:\n            median_deg = (degs[mid - 1] + degs[mid]) / 2.0\n        else:\n            median_deg = degs[mid]\n    else:\n        median_deg = avg_deg\n    median_adj = (median_deg / max(avg_deg, 1.0)) ** 0.25\n\n    estimate = (base * clustering_adj * density_adj * assort_adj * std_adj *\n                bottleneck_adj * hub_adj * triangle_adj * median_adj)\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    \n    The estimate starts from a simple baseline that grows with the number of\n    nodes and shrinks with the mean degree.  A series of multiplicative\n    corrections captures the influence of clustering, density, assortativity,\n    degree heterogeneity, minimum degree (bottlenecks), presence of hubs,\n    triangle abundance, and the median degree.\n    \n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n'                     : number of nodes\n            - 'm'                     : number of edges\n            - 'density'               : graph density (0–1)\n            - 'avg_degree'            : average degree\n            - 'max_degree'            : maximum degree\n            - 'min_degree'            : minimum degree\n            - 'std_degree'            : standard deviation of degrees\n            - 'avg_clustering'        : average clustering coefficient\n            - 'transitivity'          : global transitivity (optional)\n            - 'degree_assortativity'  : degree assortativity coefficient\n            - 'num_triangles'         : total number of triangles\n            - 'degrees'               : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Extract features with defaults\n    n          = float(s.get('n', 1))\n    m          = float(s.get('m', 0))\n    density    = float(s.get('density', 0.0))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    clust      = float(s.get('avg_clustering', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n    degrees    = s.get('degrees', None)\n\n    # Avoid division by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # Size grows like sqrt(n), denominator grows with avg_degree\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering tends to increase distances\n    clust_adj = 1.0 + clust\n\n    # Denser graphs shorten distances\n    dens_adj = 1.0 / (1.0 + density)\n\n    # Assortative mixing elongates paths\n    assort_adj = 1.0 + abs(assort)\n\n    # Degree heterogeneity generally shortens paths\n    hetero_adj = 1.0 / (1.0 + std_deg)\n\n    # Low minimum degree can create bottlenecks\n    bottleneck_adj = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Presence of hubs reduces typical distances\n    hub_adj = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Abundant triangles typically reduce distances\n    tri_adj = 1.0 + pow(num_tri, 0.5) / (pow(n, 0.5) + eps)\n\n    # Median degree adjustment (similar effect to mean but less sensitive to extremes)\n    if degrees:\n        k = len(degrees)\n        mid = k // 2\n        if k % 2 == 0:\n            median_deg = (degrees[mid - 1] + degrees[mid]) * 0.5\n        else:\n            median_deg = degrees[mid]\n    else:\n        median_deg = avg_deg\n    median_adj = (median_deg / (avg_deg + 1.0)) ** 0.25\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_adj *\n                dens_adj *\n                assort_adj *\n                hetero_adj *\n                bottleneck_adj *\n                hub_adj *\n                tri_adj *\n                median_adj)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    \n    The estimate starts from a simple baseline that grows with the number of\n    nodes and shrinks with the mean degree.  A series of multiplicative\n    corrections captures the influence of clustering, density, assortativity,\n    degree heterogeneity, minimum degree (bottlenecks), presence of hubs,\n    triangle abundance, and the median degree.\n    \n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n'                     : number of nodes\n            - 'm'                     : number of edges\n            - 'density'               : graph density (0–1)\n            - 'avg_degree'            : average degree\n            - 'max_degree'            : maximum degree\n            - 'min_degree'            : minimum degree\n            - 'std_degree'            : standard deviation of degrees\n            - 'avg_clustering'        : average clustering coefficient\n            - 'transitivity'          : global transitivity (optional)\n            - 'degree_assortativity'  : degree assortativity coefficient\n            - 'num_triangles'         : total number of triangles\n            - 'degrees'               : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Extract features with defaults\n    n          = float(s.get('n', 1))\n    m          = float(s.get('m', 0))\n    density    = float(s.get('density', 0.0))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    clust      = float(s.get('avg_clustering', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n    degrees    = s.get('degrees', None)\n\n    # Avoid division by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # Size grows like sqrt(n), denominator grows with avg_degree\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering tends to increase distances\n    clust_adj = 1.0 + clust\n\n    # Denser graphs shorten distances\n    dens_adj = 1.0 / (1.0 + density)\n\n    # Assortative mixing elongates paths\n    assort_adj = 1.0 + abs(assort)\n\n    # Degree heterogeneity generally shortens paths\n    hetero_adj = 1.0 / (1.0 + std_deg)\n\n    # Low minimum degree can create bottlenecks\n    bottleneck_adj = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Presence of hubs reduces typical distances\n    hub_adj = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Abundant triangles typically reduce distances\n    tri_adj = 1.0 + pow(num_tri, 0.5) / (pow(n, 0.5) + eps)\n\n    # Median degree adjustment (similar effect to mean but less sensitive to extremes)\n    if degrees:\n        k = len(degrees)\n        mid = k // 2\n        if k % 2 == 0:\n            median_deg = (degrees[mid - 1] + degrees[mid]) * 0.5\n        else:\n            median_deg = degrees[mid]\n    else:\n        median_deg = avg_deg\n    median_adj = (median_deg / (avg_deg + 1.0)) ** 0.25\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_adj *\n                dens_adj *\n                assort_adj *\n                hetero_adj *\n                bottleneck_adj *\n                hub_adj *\n                tri_adj *\n                median_adj)\n\n    return float(estimate)", "spearman": 0.7198844971124279, "pearson": 0.6966606718414691, "rmse": 1.251620126217275, "mae": 1.1281203408874874}}
{"timestamp": "2026-02-16T18:27:16.204141+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 16, "model_name": "gpt-oss:20b", "best_val_score": 0.5466511641442053, "no_improve_count": 0}}
{"timestamp": "2026-02-16T18:28:22.431020+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i0_p0_269753045", "generation": 16, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.874765906362545, "fitness_mode": "correlation", "simplicity_score": 0.22084478163114366, "novelty_bonus": 0.17365334133353327, "total_score": 0.5492830341781751, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.7 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.9)\n    base *= (1.0 + trans * 0.9)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.7)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.5\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.8)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base", "spearman": 0.9060361509037728, "pearson": 0.8200369768603142, "rmse": 0.6163213732387145, "mae": 0.42197898014213264}}
{"timestamp": "2026-02-16T18:29:07.708780+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i0_p1_441135345", "generation": 16, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.8473949579831932, "fitness_mode": "correlation", "simplicity_score": 0.22137394722358028, "novelty_bonus": 0.1695072376809419, "total_score": 0.5366959999749793, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.7 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.9)\n    base *= (1.0 + trans * 0.9)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.7)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.5\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.8)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base", "spearman": 0.8831380784519614, "pearson": 0.8183468779684626, "rmse": 0.9984024614318124, "mae": 0.6678555369210403}}
{"timestamp": "2026-02-16T18:32:52.924829+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i0_p2_746578068", "generation": 16, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.8473949579831932, "fitness_mode": "correlation", "simplicity_score": 0.2214354802823629, "novelty_bonus": 0.1695072376809419, "total_score": 0.5367083065867359, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.7 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.9)\n    base *= (1.0 + trans * 0.9)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.7)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.5\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.8)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    base /= (1.0 + 0.5 * abs(assort))\n\n    base += 0.1 * triangles / (m + 1.0)\n\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    base /= (1.0 + density ** 1.5)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    base /= (1.0 + 0.5 * abs(assort))\n\n    base += 0.1 * triangles / (m + 1.0)\n\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    base /= (1.0 + density ** 1.5)\n\n    return base", "spearman": 0.8831380784519614, "pearson": 0.8183468779684626, "rmse": 0.9984024614318124, "mae": 0.6678555369210403}}
{"timestamp": "2026-02-16T18:43:45.329216+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i0_p3_64161739", "generation": 16, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.8685234093637455, "fitness_mode": "correlation", "simplicity_score": 0.22084478163114366, "novelty_bonus": 0.17808295207380165, "total_score": 0.5474963395108083, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.7 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.9)\n    base *= (1.0 + trans * 0.9)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.7)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.5\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.8)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base", "spearman": 0.8998049951248781, "pearson": 0.8255859120563532, "rmse": 0.5899685556943213, "mae": 0.3941972272155331}}
{"timestamp": "2026-02-16T18:44:55.762348+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i0_p4_842953113", "generation": 16, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.8501800720288114, "fitness_mode": "correlation", "simplicity_score": 0.2209014926046282, "novelty_bonus": 0.18298357458936465, "total_score": 0.5429897187564315, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.7 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.9)\n    base *= (1.0 + trans * 0.9)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.7)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.5\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.8)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is deliberately compact and interpretable, combining\n    size, degree distribution, density, clustering, transitivity,\n    assortativity, triangle counts, and the fraction of leaf nodes.\n    No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths (moderated effect)\n    base /= (1.0 + 0.5 * abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles per edge\n    base += 0.1 * triangles / (m + 1.0)\n\n    # 7. Fraction of leaf nodes tends to increase path lengths (moderated)\n    base *= (1.0 + 0.5 * leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.6)\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.9)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.7)\n\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    base /= (1.0 + abs(assort) * 0.8)\n\n    base += triangles / (n ** 2 + 1.0) * 0.6\n\n    base *= (1.0 + leaf_frac * 0.6)\n\n    base /= (1.0 + density ** 1.6)\n\n    return base", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.6)\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.9)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.7)\n\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    base /= (1.0 + abs(assort) * 0.8)\n\n    base += triangles / (n ** 2 + 1.0) * 0.6\n\n    base *= (1.0 + leaf_frac * 0.6)\n\n    base /= (1.0 + density ** 1.6)\n\n    return base", "spearman": 0.8878286957173931, "pearson": 0.8025369716426574, "rmse": 0.6650082210571189, "mae": 0.3982556820806813}}
{"timestamp": "2026-02-16T18:45:38.522468+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i1_p0_494046353", "generation": 16, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22165548823651432, "novelty_bonus": 0.25138613993252834, "total_score": 0.527282378013021, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.296134\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.194430\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T18:47:00.495105+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i1_p1_342317319", "generation": 16, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.2217197160851846, "novelty_bonus": 0.25138613993252834, "total_score": 0.5272952235827552, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.296134\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.194430\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic graph features\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0   # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic graph features\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0   # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T18:48:45.345933+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i1_p2_650964716", "generation": 16, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7171668667466987, "fitness_mode": "correlation", "simplicity_score": 0.22081661192144697, "novelty_bonus": 0.25002261511728785, "total_score": 0.5254972650984303, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.296134\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.194430\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, leaf‑node fraction, and\n    edge count.  No graph traversal is performed; only arithmetic on the\n    supplied features is used.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = max(s['max_degree'], 1)\n    min_deg = max(s['min_degree'], 1)\n    std_deg = max(s['std_degree'], 0.0)\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    # Small adjustment based on the edge count\n    base += m / (n ** 2 + 1.0)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, leaf‑node fraction, and\n    edge count.  No graph traversal is performed; only arithmetic on the\n    supplied features is used.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = max(s['max_degree'], 1)\n    min_deg = max(s['min_degree'], 1)\n    std_deg = max(s['std_degree'], 0.0)\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    # Small adjustment based on the edge count\n    base += m / (n ** 2 + 1.0)\n\n    return base", "spearman": 0.8126543163579092, "pearson": 0.7673409235111359, "rmse": 4.362313308828194, "mae": 3.866688650362811}}
{"timestamp": "2026-02-16T18:52:06.827671+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i1_p3_647536952", "generation": 16, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.6958463385354142, "fitness_mode": "correlation", "simplicity_score": 0.21975732605103246, "novelty_bonus": 0.22502519144323585, "total_score": 0.506688903390196, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.296134\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.194430\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    # Safely extract features with defaults\n    n          = s.get('n', 1)\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 1.0)\n    if avg_deg == 0:\n        avg_deg = 1.0\n    max_deg    = s.get('max_degree', 1)\n    min_deg    = s.get('min_degree', 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # Fraction of leaf nodes\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Influence of edge count (m) and density\n    base *= (1 + m ** 0.5 / (n ** 1.5 + 1))\n    base /= (1 + density ** 1.5 + (max_deg ** 0.5 / (n + 1)))\n\n    # Uneven degree distribution\n    base *= (1 + (avg_deg - min_deg) / (avg_deg + 1))\n    base *= (1 + std_deg ** 0.5 / (avg_deg + 1))\n\n    # Small‑world effects\n    base *= (1 + clustering ** 0.5)\n    base *= (1 + trans ** 0.5)\n\n    # Assortativity tends to lengthen paths\n    base /= (1 + abs(assort))\n\n    # Triangle contribution\n    base += triangles ** 0.5 / (n ** 2 + 1)\n\n    # Leaf nodes increase path lengths\n    base *= (1 + leaf_frac)\n\n    # Dampening for very dense graphs\n    base /= (1 + density ** 2)\n\n    return base", "extracted_code": "def new_invariant(s):\n    # Safely extract features with defaults\n    n          = s.get('n', 1)\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 1.0)\n    if avg_deg == 0:\n        avg_deg = 1.0\n    max_deg    = s.get('max_degree', 1)\n    min_deg    = s.get('min_degree', 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # Fraction of leaf nodes\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Influence of edge count (m) and density\n    base *= (1 + m ** 0.5 / (n ** 1.5 + 1))\n    base /= (1 + density ** 1.5 + (max_deg ** 0.5 / (n + 1)))\n\n    # Uneven degree distribution\n    base *= (1 + (avg_deg - min_deg) / (avg_deg + 1))\n    base *= (1 + std_deg ** 0.5 / (avg_deg + 1))\n\n    # Small‑world effects\n    base *= (1 + clustering ** 0.5)\n    base *= (1 + trans ** 0.5)\n\n    # Assortativity tends to lengthen paths\n    base /= (1 + abs(assort))\n\n    # Triangle contribution\n    base += triangles ** 0.5 / (n ** 2 + 1)\n\n    # Leaf nodes increase path lengths\n    base *= (1 + leaf_frac)\n\n    # Dampening for very dense graphs\n    base /= (1 + density ** 2)\n\n    return base", "spearman": 0.7904597614940375, "pearson": 0.7227652345264124, "rmse": 7.309867030313297, "mae": 7.015917944736457}}
{"timestamp": "2026-02-16T18:53:00.128955+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i1_p4_890986217", "generation": 16, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7102521008403362, "fitness_mode": "correlation", "simplicity_score": 0.220226290956892, "novelty_bonus": 0.2463077847257662, "total_score": 0.5157280383702273, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.296134\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.194430\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, leaf‑node fraction, and\n    the total number of edges.  No graph traversal is performed; only\n    arithmetic on the supplied features is used.\n    \"\"\"\n    # Extract features with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 1\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + max_deg / (n + 1.0))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + pow(density, 2))\n\n    # 9. Slight adjustment for the total number of edges\n    base *= (1.0 + m / (n * n + 1.0))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, leaf‑node fraction, and\n    the total number of edges.  No graph traversal is performed; only\n    arithmetic on the supplied features is used.\n    \"\"\"\n    # Extract features with safe defaults\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 1\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = pow(n, 0.5) / pow(avg_deg, 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + max_deg / (n + 1.0))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + pow(density, 2))\n\n    # 9. Slight adjustment for the total number of edges\n    base *= (1.0 + m / (n * n + 1.0))\n\n    return base", "spearman": 0.7955808895222382, "pearson": 0.7655103209388878, "rmse": 4.6297018181707665, "mae": 4.164612068204043}}
{"timestamp": "2026-02-16T18:53:59.489241+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i2_p0_200932589", "generation": 16, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8622809123649459, "fitness_mode": "correlation", "simplicity_score": 0.12030564346642067, "novelty_bonus": 0.2439650011795802, "total_score": 0.5371816273221152, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.105557\nbelow_novelty_threshold: novelty_bonus=0.109158\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering                # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                      # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)          # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)      # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)          # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n\n    # Basic random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering                # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                      # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)            # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)          # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)      # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)          # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)", "spearman": 0.8798619965499139, "pearson": 0.856530736217558, "rmse": 10.889728766202964, "mae": 9.3389863953469}}
{"timestamp": "2026-02-16T18:54:49.309545+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i2_p1_325140533", "generation": 16, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8084993997599039, "fitness_mode": "correlation", "simplicity_score": 0.11773379106364659, "novelty_bonus": 0.30118268596911857, "total_score": 0.5094082016694066, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.105557\nbelow_novelty_threshold: novelty_bonus=0.109158\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic builds on a random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of\n    density, clustering, transitivity, degree heterogeneity, assortativity,\n    low‑degree vertices, high‑degree hubs, and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n\n    # Basic random‑graph estimate\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + 0.8 * clustering          # higher clustering → longer paths\n    trans_factor       = 1.0 + 0.8 * trans                # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)           # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n                                                    # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.4 * abs(assort)          # more assortative → longer paths\n    min_factor         = 1.0 + 2.0 / (min_deg + 1.0)     # very low min degree lengthens paths\n    max_factor         = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n                                                    # high max degree (hubs) shortens paths\n    tri_factor         = 1.0 / (1.0 + 3.0 * tri_ratio)   # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            max_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic builds on a random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of\n    density, clustering, transitivity, degree heterogeneity, assortativity,\n    low‑degree vertices, high‑degree hubs, and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n\n    # Basic random‑graph estimate\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + 0.8 * clustering          # higher clustering → longer paths\n    trans_factor       = 1.0 + 0.8 * trans                # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)           # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n                                                    # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.4 * abs(assort)          # more assortative → longer paths\n    min_factor         = 1.0 + 2.0 / (min_deg + 1.0)     # very low min degree lengthens paths\n    max_factor         = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n                                                    # high max degree (hubs) shortens paths\n    tri_factor         = 1.0 / (1.0 + 3.0 * tri_ratio)   # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            max_factor *\n            tri_factor)", "spearman": 0.7910132753318835, "pearson": 0.7254067765388104, "rmse": 2.894916397829814, "mae": 2.083744964566711}}
{"timestamp": "2026-02-16T18:55:33.934356+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i2_p2_998931533", "generation": 16, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8901320528211285, "fitness_mode": "correlation", "simplicity_score": 0.12043286804124097, "novelty_bonus": 0.17533638340958513, "total_score": 0.5309460950962853, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.105557\nbelow_novelty_threshold: novelty_bonus=0.109158\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture density, clustering, transitivity, degree heterogeneity,\n    assortativity, the presence of very low‑degree vertices and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg <= 0.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n\n    # Multiplicative correction factors\n    density_factor = 1.0 / (1.0 + density)                     # denser → shorter paths\n    clustering_factor = 1.0 + clustering                       # more clustering → longer paths\n    trans_factor = 1.0 + trans                                 # higher transitivity → longer paths\n    hetero_factor = 1.0 / (1.0 + std_deg)                       # heterogeneous degrees → shorter paths\n    assort_factor = 1.0 + 0.5 * abs(assort)                     # more assortative → longer paths\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)                    # very low min degree lengthens paths\n    tri_factor = 1.0 / (1.0 + tri_ratio)                       # more triangles → shorter paths\n\n    return (base *\n            density_factor *\n            clustering_factor *\n            trans_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture density, clustering, transitivity, degree heterogeneity,\n    assortativity, the presence of very low‑degree vertices and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg <= 0.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n\n    # Multiplicative correction factors\n    density_factor = 1.0 / (1.0 + density)                     # denser → shorter paths\n    clustering_factor = 1.0 + clustering                       # more clustering → longer paths\n    trans_factor = 1.0 + trans                                 # higher transitivity → longer paths\n    hetero_factor = 1.0 / (1.0 + std_deg)                       # heterogeneous degrees → shorter paths\n    assort_factor = 1.0 + 0.5 * abs(assort)                     # more assortative → longer paths\n    min_factor = 1.0 + 1.0 / (min_deg + 1.0)                    # very low min degree lengthens paths\n    tri_factor = 1.0 / (1.0 + tri_ratio)                       # more triangles → shorter paths\n\n    return (base *\n            density_factor *\n            clustering_factor *\n            trans_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)", "spearman": 0.9085172129303233, "pearson": 0.8500269574894003, "rmse": 3.79098479466426, "mae": 2.5925981163935177}}
{"timestamp": "2026-02-16T18:56:07.721079+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i2_p3_786729021", "generation": 16, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8643937575030012, "fitness_mode": "correlation", "simplicity_score": 0.12800640688498063, "novelty_bonus": 0.219477254893663, "total_score": 0.5300756736254896, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.105557\nbelow_novelty_threshold: novelty_bonus=0.109158\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed statistics:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri\n\n    # Multiplicative correction factors\n    f_clust = 1.0 + clustering                     # higher clustering → longer paths\n    f_trans = 1.0 + trans                           # higher transitivity → longer paths\n    f_density = 1.0 / (1.0 + density ** 0.5)        # denser graphs → shorter paths (dampened)\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0)) # degree heterogeneity → shorter paths\n    f_assort = 1.0 + 0.4 * abs(assort)              # assortativity → longer paths\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)             # very low min degree lengthens paths\n    f_tri = 1.0 / (1.0 + tri_ratio ** 0.7)          # more triangles → shorter paths\n\n    return (base *\n            f_clust *\n            f_trans *\n            f_density *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed statistics:\n        - 'n' (int)\n        - 'm' (int)\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri\n\n    # Multiplicative correction factors\n    f_clust = 1.0 + clustering                     # higher clustering → longer paths\n    f_trans = 1.0 + trans                           # higher transitivity → longer paths\n    f_density = 1.0 / (1.0 + density ** 0.5)        # denser graphs → shorter paths (dampened)\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0)) # degree heterogeneity → shorter paths\n    f_assort = 1.0 + 0.4 * abs(assort)              # assortativity → longer paths\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)             # very low min degree lengthens paths\n    f_tri = 1.0 / (1.0 + tri_ratio ** 0.7)          # more triangles → shorter paths\n\n    return (base *\n            f_clust *\n            f_trans *\n            f_density *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)", "spearman": 0.8772624315607891, "pearson": 0.8553405384203794, "rmse": 8.442699423268298, "mae": 7.123094605415696}}
{"timestamp": "2026-02-16T18:56:48.925095+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i2_p4_355638731", "generation": 16, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8622809123649459, "fitness_mode": "correlation", "simplicity_score": 0.12021180779610383, "novelty_bonus": 0.2439650011795802, "total_score": 0.5371628601880518, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.105557\nbelow_novelty_threshold: novelty_bonus=0.109158\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the influence of density, clustering, transitivity,\n    degree heterogeneity, assortativity, very low‑degree vertices and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 0.0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n\n    # Multiplicative correction factors\n    density_factor   = 1.0 / (1.0 + density)                     # denser → shorter paths\n    clustering_factor = 1.0 + clustering                          # higher clustering → longer paths\n    trans_factor      = 1.0 + trans                                # higher transitivity → longer paths\n    hetero_factor     = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))    # heterogeneous degrees → shorter paths\n    assort_factor     = 1.0 + 0.5 * abs(assort)                    # more assortative → longer paths\n    min_factor        = 1.0 + 1.0 / (min_deg + 1.0)                # very low min degree → longer paths\n    tri_factor        = 1.0 / (1.0 + tri_ratio)                    # more triangles → shorter paths\n\n    return (base *\n            density_factor *\n            clustering_factor *\n            trans_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic starts from a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the influence of density, clustering, transitivity,\n    degree heterogeneity, assortativity, very low‑degree vertices and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 0.0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n\n    # Multiplicative correction factors\n    density_factor   = 1.0 / (1.0 + density)                     # denser → shorter paths\n    clustering_factor = 1.0 + clustering                          # higher clustering → longer paths\n    trans_factor      = 1.0 + trans                                # higher transitivity → longer paths\n    hetero_factor     = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))    # heterogeneous degrees → shorter paths\n    assort_factor     = 1.0 + 0.5 * abs(assort)                    # more assortative → longer paths\n    min_factor        = 1.0 + 1.0 / (min_deg + 1.0)                # very low min degree → longer paths\n    tri_factor        = 1.0 / (1.0 + tri_ratio)                    # more triangles → shorter paths\n\n    return (base *\n            density_factor *\n            clustering_factor *\n            trans_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)", "spearman": 0.8798619965499139, "pearson": 0.856530736217558, "rmse": 10.889728766202962, "mae": 9.3389863953469}}
{"timestamp": "2026-02-16T18:57:30.718443+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i3_p0_669801635", "generation": 16, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6289075630252101, "fitness_mode": "correlation", "simplicity_score": 0.15553449595166186, "novelty_bonus": 0.4405434441167938, "total_score": 0.49114287924904115, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length of a graph from pre‑computed\n    global features.  The estimate uses a baseline that grows with the\n    square‑root of the number of nodes and is inversely related to the\n    average degree.  Several multiplicative corrections capture how\n    clustering, density, degree heterogeneity, assortativity, bottlenecks\n    (low minimum degree), hubs (high maximum degree) and triangles influence\n    typical distances.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph statistics with possible keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (float)\n        - 'min_degree' (float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Numeric estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Pull values with defaults, converting to float for consistency\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    clust      = float(s.get('avg_clustering', 0.0))\n    density    = float(s.get('density', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Guard against division by zero\n    eps       = 1e-12\n    avg_deg   = max(avg_deg, eps)\n    max_deg   = max(max_deg, eps)\n    std_deg   = max(std_deg, eps)\n    min_deg   = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # Square‑root dependence on n, scaled by average degree\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering tends to increase distances\n    clust_factor   = 1.0 + clust\n\n    # Density shortens paths\n    dens_factor    = 1.0 / (1.0 + density)\n\n    # Assortative mixing can elongate paths\n    assort_factor  = 1.0 + abs(assort)\n\n    # Degree heterogeneity (large std) usually shortens distances\n    hetero_factor  = 1.0 / (1.0 + std_deg)\n\n    # Very low minimum degree can create bottlenecks\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Hubs (high maximum degree) tend to reduce typical distances\n    hub_factor     = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangles create shortcuts\n    tri_factor = 1.0 + ((num_tri ** 0.5) / (n ** 0.5 + eps))\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics.\n\n    The estimate is a multiplicative combination of a baseline term (scaling\n    with sqrt(n) and inversely with average degree) and several correction\n    factors that capture the effects of clustering, density, assortativity,\n    degree heterogeneity, bottlenecks, hubs, triangles and the mean degree.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features with the following\n        optional keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (float)\n        - 'min_degree' (float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # pull values with reasonable defaults\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 1.0))\n    std_deg    = float(s.get('std_degree', 1.0))\n    clust      = float(s.get('avg_clustering', 0.0))\n    density    = float(s.get('density', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n    degrees    = s.get('degrees', [])\n\n    # mean degree from the degree list if available\n    deg_mean = sum(degrees) / len(degrees) if degrees else avg_deg\n\n    # baseline: grows with sqrt(n) and shrinks with average degree\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # correction factors\n    f_clust     = 1.0 + clust                  # higher clustering → longer paths\n    f_density   = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    f_assort    = 1.0 + abs(assort)            # assortativity can elongate paths\n    f_std       = 1.0 / (1.0 + std_deg)        # degree heterogeneity → shorter paths\n    f_min       = 1.0 + min_deg / (avg_deg + 1)\n    f_hub       = (max_deg / (avg_deg + 1)) ** 0.5  # hubs reduce distances\n    f_tri       = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)\n    f_deg_mean  = deg_mean / (avg_deg + 1)    # adjust for mean degree\n\n    # combine all components\n    estimate = (base *\n                f_clust *\n                f_density *\n                f_assort *\n                f_std *\n                f_min *\n                f_hub *\n                f_tri *\n                f_deg_mean)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics.\n\n    The estimate is a multiplicative combination of a baseline term (scaling\n    with sqrt(n) and inversely with average degree) and several correction\n    factors that capture the effects of clustering, density, assortativity,\n    degree heterogeneity, bottlenecks, hubs, triangles and the mean degree.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features with the following\n        optional keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (float)\n        - 'min_degree' (float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # pull values with reasonable defaults\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 1.0))\n    std_deg    = float(s.get('std_degree', 1.0))\n    clust      = float(s.get('avg_clustering', 0.0))\n    density    = float(s.get('density', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n    degrees    = s.get('degrees', [])\n\n    # mean degree from the degree list if available\n    deg_mean = sum(degrees) / len(degrees) if degrees else avg_deg\n\n    # baseline: grows with sqrt(n) and shrinks with average degree\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # correction factors\n    f_clust     = 1.0 + clust                  # higher clustering → longer paths\n    f_density   = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    f_assort    = 1.0 + abs(assort)            # assortativity can elongate paths\n    f_std       = 1.0 / (1.0 + std_deg)        # degree heterogeneity → shorter paths\n    f_min       = 1.0 + min_deg / (avg_deg + 1)\n    f_hub       = (max_deg / (avg_deg + 1)) ** 0.5  # hubs reduce distances\n    f_tri       = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)\n    f_deg_mean  = deg_mean / (avg_deg + 1)    # adjust for mean degree\n\n    # combine all components\n    estimate = (base *\n                f_clust *\n                f_density *\n                f_assort *\n                f_std *\n                f_min *\n                f_hub *\n                f_tri *\n                f_deg_mean)\n\n    return float(estimate)", "spearman": 0.6557458936473413, "pearson": 0.6515297533108739, "rmse": 1.3903324564497577, "mae": 1.251673983437277}}
{"timestamp": "2026-02-16T18:58:16.881991+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i3_p1_527083845", "generation": 16, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5228811524609843, "fitness_mode": "correlation", "simplicity_score": 0.15654384256035908, "novelty_bonus": 0.5037869789136848, "total_score": 0.4587457697088654, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length of a graph from pre‑computed\n    global features.  The estimate uses a baseline that grows with the\n    square‑root of the number of nodes and is inversely related to the\n    average degree.  Several multiplicative corrections capture how\n    clustering, density, degree heterogeneity, assortativity, bottlenecks\n    (low minimum degree), hubs (high maximum degree) and triangles influence\n    typical distances.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph statistics with possible keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (float)\n        - 'min_degree' (float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Numeric estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Pull values with defaults, converting to float for consistency\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    clust      = float(s.get('avg_clustering', 0.0))\n    density    = float(s.get('density', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Guard against division by zero\n    eps       = 1e-12\n    avg_deg   = max(avg_deg, eps)\n    max_deg   = max(max_deg, eps)\n    std_deg   = max(std_deg, eps)\n    min_deg   = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # Square‑root dependence on n, scaled by average degree\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering tends to increase distances\n    clust_factor   = 1.0 + clust\n\n    # Density shortens paths\n    dens_factor    = 1.0 / (1.0 + density)\n\n    # Assortative mixing can elongate paths\n    assort_factor  = 1.0 + abs(assort)\n\n    # Degree heterogeneity (large std) usually shortens distances\n    hetero_factor  = 1.0 / (1.0 + std_deg)\n\n    # Very low minimum degree can create bottlenecks\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Hubs (high maximum degree) tend to reduce typical distances\n    hub_factor     = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangles create shortcuts\n    tri_factor = 1.0 + ((num_tri ** 0.5) / (n ** 0.5 + eps))\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The estimate combines a baseline that grows with the number of nodes and\n    inversely with the average degree, with multiplicative corrections that\n    capture the influence of clustering, density, degree heterogeneity,\n    assortativity, minimum/maximum degrees, and the abundance of triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys (with defaults if missing):\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity, num_triangles.\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Retrieve values with defaults to avoid missing keys\n    n           = s.get('n', 1)\n    m           = s.get('m', 0)\n    density     = s.get('density', 0.0)\n    avg_deg     = s.get('avg_degree', 1.0)\n    max_deg     = s.get('max_degree', 1.0)\n    min_deg     = s.get('min_degree', 1.0)\n    std_deg     = s.get('std_degree', 0.0)\n    avg_clust   = s.get('avg_clustering', 0.0)\n    trans       = s.get('transitivity', 0.0)\n    assort      = s.get('degree_assortativity', 0.0)\n    num_tri     = s.get('num_triangles', 0)\n\n    # Ensure no division by zero\n    if avg_deg == 0:\n        avg_deg = 1e-12\n\n    # ---------- Baseline ----------\n    # The core scaling grows with the size of the graph and shrinks with the mean degree\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering tends to increase typical path lengths\n    f_clust = 1.0 + avg_clust\n\n    # Higher global transitivity also lengthens paths\n    f_trans = 1.0 + trans\n\n    # Assortative mixing can stretch distances\n    f_assort = 1.0 + abs(assort)\n\n    # A denser graph shortens the average shortest path\n    f_density = 1.0 / (1.0 + density)\n\n    # Degree heterogeneity (large std) often shortens distances\n    f_std = 1.0 / (1.0 + std_deg)\n\n    # Very low minimum degree may act as a bottleneck\n    f_min = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Presence of hubs (high maximum degree) usually reduces distances\n    f_max = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Abundant triangles create shortcuts\n    f_tri = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)\n\n    # ---------- Combine ----------\n    estimate = (base *\n                f_clust *\n                f_trans *\n                f_assort *\n                f_density *\n                f_std *\n                f_min *\n                f_max *\n                f_tri)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The estimate combines a baseline that grows with the number of nodes and\n    inversely with the average degree, with multiplicative corrections that\n    capture the influence of clustering, density, degree heterogeneity,\n    assortativity, minimum/maximum degrees, and the abundance of triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys (with defaults if missing):\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity, num_triangles.\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Retrieve values with defaults to avoid missing keys\n    n           = s.get('n', 1)\n    m           = s.get('m', 0)\n    density     = s.get('density', 0.0)\n    avg_deg     = s.get('avg_degree', 1.0)\n    max_deg     = s.get('max_degree', 1.0)\n    min_deg     = s.get('min_degree', 1.0)\n    std_deg     = s.get('std_degree', 0.0)\n    avg_clust   = s.get('avg_clustering', 0.0)\n    trans       = s.get('transitivity', 0.0)\n    assort      = s.get('degree_assortativity', 0.0)\n    num_tri     = s.get('num_triangles', 0)\n\n    # Ensure no division by zero\n    if avg_deg == 0:\n        avg_deg = 1e-12\n\n    # ---------- Baseline ----------\n    # The core scaling grows with the size of the graph and shrinks with the mean degree\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering tends to increase typical path lengths\n    f_clust = 1.0 + avg_clust\n\n    # Higher global transitivity also lengthens paths\n    f_trans = 1.0 + trans\n\n    # Assortative mixing can stretch distances\n    f_assort = 1.0 + abs(assort)\n\n    # A denser graph shortens the average shortest path\n    f_density = 1.0 / (1.0 + density)\n\n    # Degree heterogeneity (large std) often shortens distances\n    f_std = 1.0 / (1.0 + std_deg)\n\n    # Very low minimum degree may act as a bottleneck\n    f_min = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Presence of hubs (high maximum degree) usually reduces distances\n    f_max = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Abundant triangles create shortcuts\n    f_tri = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)\n\n    # ---------- Combine ----------\n    estimate = (base *\n                f_clust *\n                f_trans *\n                f_assort *\n                f_density *\n                f_std *\n                f_min *\n                f_max *\n                f_tri)\n\n    return float(estimate)", "spearman": 0.5526018150453762, "pearson": 0.6242644597581453, "rmse": 18.22768238862145, "mae": 14.889029043937766}}
{"timestamp": "2026-02-16T18:59:11.554013+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i3_p2_928637049", "generation": 16, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6901800720288115, "fitness_mode": "correlation", "simplicity_score": 0.15558659087281873, "novelty_bonus": 0.371845035328932, "total_score": 0.5133405955174121, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length of a graph from pre‑computed\n    global features.  The estimate uses a baseline that grows with the\n    square‑root of the number of nodes and is inversely related to the\n    average degree.  Several multiplicative corrections capture how\n    clustering, density, degree heterogeneity, assortativity, bottlenecks\n    (low minimum degree), hubs (high maximum degree) and triangles influence\n    typical distances.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph statistics with possible keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (float)\n        - 'min_degree' (float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Numeric estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Pull values with defaults, converting to float for consistency\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    clust      = float(s.get('avg_clustering', 0.0))\n    density    = float(s.get('density', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Guard against division by zero\n    eps       = 1e-12\n    avg_deg   = max(avg_deg, eps)\n    max_deg   = max(max_deg, eps)\n    std_deg   = max(std_deg, eps)\n    min_deg   = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # Square‑root dependence on n, scaled by average degree\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering tends to increase distances\n    clust_factor   = 1.0 + clust\n\n    # Density shortens paths\n    dens_factor    = 1.0 / (1.0 + density)\n\n    # Assortative mixing can elongate paths\n    assort_factor  = 1.0 + abs(assort)\n\n    # Degree heterogeneity (large std) usually shortens distances\n    hetero_factor  = 1.0 / (1.0 + std_deg)\n\n    # Very low minimum degree can create bottlenecks\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Hubs (high maximum degree) tend to reduce typical distances\n    hub_factor     = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangles create shortcuts\n    tri_factor = 1.0 + ((num_tri ** 0.5) / (n ** 0.5 + eps))\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length of a graph from pre‑computed\n    global features using a purely algebraic combination of those features.\n    No external modules are imported and no graph traversal algorithms are\n    invoked.  All operations rely on Python built‑ins.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Keys may include:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (float)\n        - 'min_degree' (float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average\n        shortest‑path length.\n    \"\"\"\n    # Basic safety defaults and prevention of division by zero\n    eps = 1e-12\n\n    n            = float(s.get('n', 1))\n    avg_deg      = float(s.get('avg_degree', 1.0))\n    max_deg      = float(s.get('max_degree', avg_deg))\n    min_deg      = float(s.get('min_degree', 0.0))\n    std_deg      = float(s.get('std_degree', 0.0))\n    clust        = float(s.get('avg_clustering', 0.0))\n    density      = float(s.get('density', 0.0))\n    assort       = float(s.get('degree_assortativity', 0.0))\n    num_tri      = float(s.get('num_triangles', 0.0))\n\n    avg_deg   = max(avg_deg, eps)\n    max_deg   = max(max_deg, eps)\n    std_deg   = max(std_deg, eps)\n    min_deg   = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # Scale with sqrt(n) and inversely with average degree.\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                           # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)                 # higher density shortens paths\n    assort_factor  = 1.0 + abs(assort)                     # assortativity can elongate paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)                 # heterogeneity typically shortens distances\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # low minimum degree creates bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1.0)) ** 0.5     # hubs reduce typical distances\n    tri_factor     = 1.0 + (num_tri ** 0.5) / ((n ** 0.5) + eps)\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length of a graph from pre‑computed\n    global features using a purely algebraic combination of those features.\n    No external modules are imported and no graph traversal algorithms are\n    invoked.  All operations rely on Python built‑ins.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Keys may include:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (float)\n        - 'min_degree' (float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average\n        shortest‑path length.\n    \"\"\"\n    # Basic safety defaults and prevention of division by zero\n    eps = 1e-12\n\n    n            = float(s.get('n', 1))\n    avg_deg      = float(s.get('avg_degree', 1.0))\n    max_deg      = float(s.get('max_degree', avg_deg))\n    min_deg      = float(s.get('min_degree', 0.0))\n    std_deg      = float(s.get('std_degree', 0.0))\n    clust        = float(s.get('avg_clustering', 0.0))\n    density      = float(s.get('density', 0.0))\n    assort       = float(s.get('degree_assortativity', 0.0))\n    num_tri      = float(s.get('num_triangles', 0.0))\n\n    avg_deg   = max(avg_deg, eps)\n    max_deg   = max(max_deg, eps)\n    std_deg   = max(std_deg, eps)\n    min_deg   = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # Scale with sqrt(n) and inversely with average degree.\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                           # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)                 # higher density shortens paths\n    assort_factor  = 1.0 + abs(assort)                     # assortativity can elongate paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)                 # heterogeneity typically shortens distances\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # low minimum degree creates bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1.0)) ** 0.5     # hubs reduce typical distances\n    tri_factor     = 1.0 + (num_tri ** 0.5) / ((n ** 0.5) + eps)\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return float(estimate)", "spearman": 0.7413395334883374, "pearson": 0.740784516881863, "rmse": 1.1368805512560611, "mae": 1.0163434818161656}}
{"timestamp": "2026-02-16T18:59:56.587467+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i3_p3_14277098", "generation": 16, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6901800720288115, "fitness_mode": "correlation", "simplicity_score": 0.154940803466983, "novelty_bonus": 0.371845035328932, "total_score": 0.5132114380362449, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length of a graph from pre‑computed\n    global features.  The estimate uses a baseline that grows with the\n    square‑root of the number of nodes and is inversely related to the\n    average degree.  Several multiplicative corrections capture how\n    clustering, density, degree heterogeneity, assortativity, bottlenecks\n    (low minimum degree), hubs (high maximum degree) and triangles influence\n    typical distances.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph statistics with possible keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (float)\n        - 'min_degree' (float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Numeric estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Pull values with defaults, converting to float for consistency\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    clust      = float(s.get('avg_clustering', 0.0))\n    density    = float(s.get('density', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Guard against division by zero\n    eps       = 1e-12\n    avg_deg   = max(avg_deg, eps)\n    max_deg   = max(max_deg, eps)\n    std_deg   = max(std_deg, eps)\n    min_deg   = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # Square‑root dependence on n, scaled by average degree\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering tends to increase distances\n    clust_factor   = 1.0 + clust\n\n    # Density shortens paths\n    dens_factor    = 1.0 / (1.0 + density)\n\n    # Assortative mixing can elongate paths\n    assort_factor  = 1.0 + abs(assort)\n\n    # Degree heterogeneity (large std) usually shortens distances\n    hetero_factor  = 1.0 / (1.0 + std_deg)\n\n    # Very low minimum degree can create bottlenecks\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Hubs (high maximum degree) tend to reduce typical distances\n    hub_factor     = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangles create shortcuts\n    tri_factor = 1.0 + ((num_tri ** 0.5) / (n ** 0.5 + eps))\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics.\n    The formula blends a baseline that scales with the square root of the\n    node count and several multiplicative correction factors that capture\n    clustering, density, assortativity, degree heterogeneity, bottlenecks\n    (low minimum degree), hubs (high maximum degree) and the abundance of\n    triangles.  All calculations use only basic arithmetic and built‑in\n    operations, avoiding any imports or graph traversal algorithms.\n    \"\"\"\n    # Pull features with defaults; convert to float for consistency\n    n             = float(s.get('n', 1))\n    m             = float(s.get('m', 1))\n    density       = float(s.get('density', 0.0))\n    avg_deg       = float(s.get('avg_degree', 1.0))\n    max_deg       = float(s.get('max_degree', avg_deg))\n    min_deg       = float(s.get('min_degree', 0.0))\n    std_deg       = float(s.get('std_degree', 0.0))\n    avg_clust     = float(s.get('avg_clustering', 0.0))\n    transitivity  = float(s.get('transitivity', 0.0))\n    assortativity = float(s.get('degree_assortativity', 0.0))\n    num_tri       = float(s.get('num_triangles', 0.0))\n\n    # Ensure denominators never hit zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    min_deg = max(min_deg, eps)\n    std_deg = max(std_deg, eps)\n\n    # ---------- Baseline ----------\n    # Roughly scales with √n and inversely with avg degree\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering (higher → longer paths)\n    clust_factor = 1.0 + avg_clust\n\n    # Density (higher → shorter paths)\n    dens_factor = 1.0 / (1.0 + density)\n\n    # Assortativity (more assortative or disassortative → longer paths)\n    assort_factor = 1.0 + abs(assortativity)\n\n    # Degree heterogeneity (larger std → shorter paths)\n    hetero_factor = 1.0 / (1.0 + std_deg)\n\n    # Bottleneck due to low minimum degree\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Presence of hubs reduces typical distances\n    hub_factor = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangles provide shortcuts\n    tri_factor = 1.0 + ((num_tri ** 0.5) / ((n ** 0.5) + eps))\n\n    # Combine all components multiplicatively\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics.\n    The formula blends a baseline that scales with the square root of the\n    node count and several multiplicative correction factors that capture\n    clustering, density, assortativity, degree heterogeneity, bottlenecks\n    (low minimum degree), hubs (high maximum degree) and the abundance of\n    triangles.  All calculations use only basic arithmetic and built‑in\n    operations, avoiding any imports or graph traversal algorithms.\n    \"\"\"\n    # Pull features with defaults; convert to float for consistency\n    n             = float(s.get('n', 1))\n    m             = float(s.get('m', 1))\n    density       = float(s.get('density', 0.0))\n    avg_deg       = float(s.get('avg_degree', 1.0))\n    max_deg       = float(s.get('max_degree', avg_deg))\n    min_deg       = float(s.get('min_degree', 0.0))\n    std_deg       = float(s.get('std_degree', 0.0))\n    avg_clust     = float(s.get('avg_clustering', 0.0))\n    transitivity  = float(s.get('transitivity', 0.0))\n    assortativity = float(s.get('degree_assortativity', 0.0))\n    num_tri       = float(s.get('num_triangles', 0.0))\n\n    # Ensure denominators never hit zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    min_deg = max(min_deg, eps)\n    std_deg = max(std_deg, eps)\n\n    # ---------- Baseline ----------\n    # Roughly scales with √n and inversely with avg degree\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering (higher → longer paths)\n    clust_factor = 1.0 + avg_clust\n\n    # Density (higher → shorter paths)\n    dens_factor = 1.0 / (1.0 + density)\n\n    # Assortativity (more assortative or disassortative → longer paths)\n    assort_factor = 1.0 + abs(assortativity)\n\n    # Degree heterogeneity (larger std → shorter paths)\n    hetero_factor = 1.0 / (1.0 + std_deg)\n\n    # Bottleneck due to low minimum degree\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Presence of hubs reduces typical distances\n    hub_factor = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangles provide shortcuts\n    tri_factor = 1.0 + ((num_tri ** 0.5) / ((n ** 0.5) + eps))\n\n    # Combine all components multiplicatively\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return float(estimate)", "spearman": 0.7413395334883374, "pearson": 0.740784516881863, "rmse": 1.1368805512560611, "mae": 1.0163434818161656}}
{"timestamp": "2026-02-16T19:00:34.678646+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i3_p4_334611707", "generation": 16, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6901800720288115, "fitness_mode": "correlation", "simplicity_score": 0.17979979747219746, "novelty_bonus": 0.371845035328932, "total_score": 0.5181832368372877, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length of a graph from pre‑computed\n    global features.  The estimate uses a baseline that grows with the\n    square‑root of the number of nodes and is inversely related to the\n    average degree.  Several multiplicative corrections capture how\n    clustering, density, degree heterogeneity, assortativity, bottlenecks\n    (low minimum degree), hubs (high maximum degree) and triangles influence\n    typical distances.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph statistics with possible keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (float)\n        - 'min_degree' (float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Numeric estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Pull values with defaults, converting to float for consistency\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    clust      = float(s.get('avg_clustering', 0.0))\n    density    = float(s.get('density', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Guard against division by zero\n    eps       = 1e-12\n    avg_deg   = max(avg_deg, eps)\n    max_deg   = max(max_deg, eps)\n    std_deg   = max(std_deg, eps)\n    min_deg   = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # Square‑root dependence on n, scaled by average degree\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering tends to increase distances\n    clust_factor   = 1.0 + clust\n\n    # Density shortens paths\n    dens_factor    = 1.0 / (1.0 + density)\n\n    # Assortative mixing can elongate paths\n    assort_factor  = 1.0 + abs(assort)\n\n    # Degree heterogeneity (large std) usually shortens distances\n    hetero_factor  = 1.0 / (1.0 + std_deg)\n\n    # Very low minimum degree can create bottlenecks\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Hubs (high maximum degree) tend to reduce typical distances\n    hub_factor     = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangles create shortcuts\n    tri_factor = 1.0 + ((num_tri ** 0.5) / (n ** 0.5 + eps))\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    The estimate uses a square‑root dependence on the number of nodes and an inverse\n    dependence on the average degree.  Several multiplicative correction factors\n    capture the effects of clustering, density, degree heterogeneity, assortativity,\n    bottlenecks (low minimum degree), hubs (high maximum degree) and triangles.\n    \"\"\"\n    # Feature extraction with sensible defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure numerical stability\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1 + clust                      # higher clustering → longer paths\n    dens_factor    = 1 / (1 + density)              # denser graphs → shorter paths\n    assort_factor  = 1 + abs(assort)                # assortative mixing elongates paths\n    hetero_factor  = 1 / (1 + std_deg)              # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n    tri_factor     = 1 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    The estimate uses a square‑root dependence on the number of nodes and an inverse\n    dependence on the average degree.  Several multiplicative correction factors\n    capture the effects of clustering, density, degree heterogeneity, assortativity,\n    bottlenecks (low minimum degree), hubs (high maximum degree) and triangles.\n    \"\"\"\n    # Feature extraction with sensible defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure numerical stability\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1 + clust                      # higher clustering → longer paths\n    dens_factor    = 1 / (1 + density)              # denser graphs → shorter paths\n    assort_factor  = 1 + abs(assort)                # assortative mixing elongates paths\n    hetero_factor  = 1 / (1 + std_deg)              # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n    tri_factor     = 1 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate", "spearman": 0.7413395334883374, "pearson": 0.740784516881863, "rmse": 1.1368805512560611, "mae": 1.0163434818161656}}
{"timestamp": "2026-02-16T19:00:34.693945+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 17, "model_name": "gpt-oss:20b", "best_val_score": 0.5492830341781751, "no_improve_count": 0}}
{"timestamp": "2026-02-16T19:01:51.264499+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i0_p0_438520665", "generation": 17, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.828859543817527, "fitness_mode": "correlation", "simplicity_score": 0.22107466943064283, "novelty_bonus": 0.2043064947762897, "total_score": 0.5466394106322233, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base", "spearman": 0.8822650566264157, "pearson": 0.817347552090235, "rmse": 0.5746952936508153, "mae": 0.35687948558486027}}
{"timestamp": "2026-02-16T19:06:50.308885+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i0_p1_202317580", "generation": 17, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.7577911164465786, "fitness_mode": "correlation", "simplicity_score": 0.21987737539002666, "novelty_bonus": 0.22596802307842279, "total_score": 0.5285655519932819, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    or external libraries are used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    # Small hub‑effect adjustment\n    base *= (1.0 + (max_deg / (avg_deg + 1.0)) ** 0.5 * 0.20)\n\n    # Slight adjustment based on triangle density\n    base += (triangles / (max(s['m'], 1) + 1.0)) * 0.10\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    or external libraries are used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    # Small hub‑effect adjustment\n    base *= (1.0 + (max_deg / (avg_deg + 1.0)) ** 0.5 * 0.20)\n\n    # Slight adjustment based on triangle density\n    base += (triangles / (max(s['m'], 1) + 1.0)) * 0.10\n\n    return base", "spearman": 0.8335993399834997, "pearson": 0.7716911658887526, "rmse": 1.451060828947561, "mae": 1.1274219089580262}}
{"timestamp": "2026-02-16T19:09:08.378860+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i0_p2_248953978", "generation": 17, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.828859543817527, "fitness_mode": "correlation", "simplicity_score": 0.22125258623001443, "novelty_bonus": 0.2043064947762897, "total_score": 0.5466749939920976, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base", "spearman": 0.8822650566264157, "pearson": 0.817347552090235, "rmse": 0.5746952936508153, "mae": 0.35687948558486027}}
{"timestamp": "2026-02-16T19:09:43.802401+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i0_p3_11445063", "generation": 17, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.828859543817527, "fitness_mode": "correlation", "simplicity_score": 0.22113343699055302, "novelty_bonus": 0.2043064947762897, "total_score": 0.5466511641442053, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base", "spearman": 0.8822650566264157, "pearson": 0.817347552090235, "rmse": 0.5746952936508153, "mae": 0.35687948558486027}}
{"timestamp": "2026-02-16T19:11:03.604084+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i0_p4_907737412", "generation": 17, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.8137815126050421, "fitness_mode": "correlation", "simplicity_score": 0.22113343699055302, "novelty_bonus": 0.21690916854166398, "total_score": 0.5460676071648399, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.46) / (avg_deg ** 0.54)\n    base /= (1.0 + density ** 0.62 + (max_deg / (n + 1.0)) ** 0.48)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.72)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.53)\n    base *= (1.0 + clustering * 0.84)\n    base *= (1.0 + trans * 0.84)\n    base /= (1.0 + abs(assort) * 0.66)\n    base += triangles / (n ** 2 + 1.0) * 0.44\n    base *= (1.0 + leaf_frac * 0.53)\n    base /= (1.0 + density ** 1.78)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.46) / (avg_deg ** 0.54)\n    base /= (1.0 + density ** 0.62 + (max_deg / (n + 1.0)) ** 0.48)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.72)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.53)\n    base *= (1.0 + clustering * 0.84)\n    base *= (1.0 + trans * 0.84)\n    base /= (1.0 + abs(assort) * 0.66)\n    base += triangles / (n ** 2 + 1.0) * 0.44\n    base *= (1.0 + leaf_frac * 0.53)\n    base /= (1.0 + density ** 1.78)\n\n    return base", "spearman": 0.8735363384084602, "pearson": 0.8108433959354524, "rmse": 0.7190763340064431, "mae": 0.4897599888087013}}
{"timestamp": "2026-02-16T19:12:55.627498+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i1_p0_551405645", "generation": 17, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22168752438400124, "novelty_bonus": 0.25138613993252834, "total_score": 0.5272887852425184, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.296134\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.194430\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T19:13:43.654002+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i1_p1_398063171", "generation": 17, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.220226290956892, "novelty_bonus": 0.25138613993252834, "total_score": 0.5269965385570966, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.296134\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.194430\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Safely extract features with defaults\n    n          = s.get('n', 1)\n    if n <= 0:\n        n = 1\n    avg_deg    = s.get('avg_degree', 1.0)\n    if avg_deg <= 0:\n        avg_deg = 1.0\n    max_deg    = s.get('max_degree', 1)\n    if max_deg <= 0:\n        max_deg = 1\n    min_deg    = s.get('min_degree', 1)\n    if min_deg <= 0:\n        min_deg = 1\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n    density    = s.get('density', 0.0)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    # Safely extract features with defaults\n    n          = s.get('n', 1)\n    if n <= 0:\n        n = 1\n    avg_deg    = s.get('avg_degree', 1.0)\n    if avg_deg <= 0:\n        avg_deg = 1.0\n    max_deg    = s.get('max_degree', 1)\n    if max_deg <= 0:\n        max_deg = 1\n    min_deg    = s.get('min_degree', 1)\n    if min_deg <= 0:\n        min_deg = 1\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n    density    = s.get('density', 0.0)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T19:15:59.683846+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i1_p2_596112292", "generation": 17, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7171668667466987, "fitness_mode": "correlation", "simplicity_score": 0.21954690955517187, "novelty_bonus": 0.24998465334686348, "total_score": 0.5251314335814852, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.296134\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.194430\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # safe defaults to avoid division by zero\n    avg_deg = avg_deg if avg_deg > 0 else 1.0\n    max_deg = max_deg if max_deg > 0 else 1\n    min_deg = min_deg if min_deg > 0 else 1\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / (n if n > 0 else 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    # 9. Extra small adjustments to capture remaining structure\n    base += m / (n**2 + 1.0)\n    base += triangles / (n**3 + 1.0)\n    base += leaf_frac / (n + 1.0)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # safe defaults to avoid division by zero\n    avg_deg = avg_deg if avg_deg > 0 else 1.0\n    max_deg = max_deg if max_deg > 0 else 1\n    min_deg = min_deg if min_deg > 0 else 1\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / (n if n > 0 else 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    # 9. Extra small adjustments to capture remaining structure\n    base += m / (n**2 + 1.0)\n    base += triangles / (n**3 + 1.0)\n    base += leaf_frac / (n + 1.0)\n\n    return base", "spearman": 0.8124533113327834, "pearson": 0.7674035364011762, "rmse": 4.364659487440817, "mae": 3.8681916853132794}}
{"timestamp": "2026-02-16T19:16:40.829880+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i1_p3_374191174", "generation": 17, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22104548362902313, "novelty_bonus": 0.25138613993252834, "total_score": 0.5271603770915229, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.296134\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.194430\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    if avg_deg == 0:\n        avg_deg = 1.0\n    density    = s.get('density', 0.0)\n    max_deg    = s.get('max_degree', 1)\n    min_deg    = s.get('min_degree', 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    # Extract features with safe defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    if avg_deg == 0:\n        avg_deg = 1.0\n    density    = s.get('density', 0.0)\n    max_deg    = s.get('max_degree', 1)\n    min_deg    = s.get('min_degree', 1)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T19:17:25.628482+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i1_p4_394371761", "generation": 17, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22165548823651432, "novelty_bonus": 0.25138613993252834, "total_score": 0.527282378013021, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.296134\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.194430\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T19:18:19.341408+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i2_p0_891576010", "generation": 17, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7846818727490995, "fitness_mode": "correlation", "simplicity_score": 0.11824246151894066, "novelty_bonus": 0.3115780132253101, "total_score": 0.4908029882986819, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.105557\nbelow_novelty_threshold: novelty_bonus=0.109158\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of\n    density, clustering, transitivity, degree heterogeneity, assortativity,\n    the presence of very low‑degree vertices, a very high‑degree vertex, and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted) – not used directly here\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n\n    # Multiplicative correction factors\n    density_factor   = 1.0 / (1.0 + density)                     # denser → shorter paths\n    clustering_factor = 1.0 + clustering                         # higher clustering → longer paths\n    trans_factor      = 1.0 + trans                               # higher transitivity → longer paths\n    hetero_factor     = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))   # more heterogeneous → shorter paths\n    assort_factor     = 1.0 + abs(assort)                         # more assortative → longer paths\n    min_factor        = 1.0 + 1.0 / (min_deg + 1.0)               # very low min degree → longer paths\n    max_factor        = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))   # very high max degree → shorter paths\n    tri_factor        = 1.0 / (1.0 + tri_ratio)                   # more triangles → shorter paths\n\n    return (base *\n            density_factor *\n            clustering_factor *\n            trans_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            max_factor *\n            tri_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of\n    density, clustering, transitivity, degree heterogeneity, assortativity,\n    the presence of very low‑degree vertices, a very high‑degree vertex, and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted) – not used directly here\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0\n\n    # Multiplicative correction factors\n    density_factor   = 1.0 / (1.0 + density)                     # denser → shorter paths\n    clustering_factor = 1.0 + clustering                         # higher clustering → longer paths\n    trans_factor      = 1.0 + trans                               # higher transitivity → longer paths\n    hetero_factor     = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))   # more heterogeneous → shorter paths\n    assort_factor     = 1.0 + abs(assort)                         # more assortative → longer paths\n    min_factor        = 1.0 + 1.0 / (min_deg + 1.0)               # very low min degree → longer paths\n    max_factor        = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))   # very high max degree → shorter paths\n    tri_factor        = 1.0 / (1.0 + tri_ratio)                   # more triangles → shorter paths\n\n    return (base *\n            density_factor *\n            clustering_factor *\n            trans_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            max_factor *\n            tri_factor)", "spearman": 0.7473621840546015, "pearson": 0.7060600514550663, "rmse": 2.902089991062705, "mae": 1.9793292965000462}}
{"timestamp": "2026-02-16T19:19:22.709940+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i2_p1_872000872", "generation": 17, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7669147659063624, "fitness_mode": "correlation", "simplicity_score": 0.12464107966027335, "novelty_bonus": 0.3499434179841313, "total_score": 0.49007624545239725, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.105557\nbelow_novelty_threshold: novelty_bonus=0.109158\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the influence of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices, high‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)                     # denser → shorter\n    f_clustering = 1.0 + clustering                       # more clustering → longer\n    f_trans = 1.0 + trans                                 # more transitivity → longer\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))        # more heterogeneity → shorter\n    f_assort = 1.0 + 0.5 * abs(assort)                    # more assortative → longer\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)                   # very low min degree → longer\n    f_max = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))       # very high max degree → shorter\n    f_tri = 1.0 / (1.0 + tri_ratio)                       # more triangles → shorter\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_max *\n            f_tri)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the influence of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices, high‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)                     # denser → shorter\n    f_clustering = 1.0 + clustering                       # more clustering → longer\n    f_trans = 1.0 + trans                                 # more transitivity → longer\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))        # more heterogeneity → shorter\n    f_assort = 1.0 + 0.5 * abs(assort)                    # more assortative → longer\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)                   # very low min degree → longer\n    f_max = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))       # very high max degree → shorter\n    f_tri = 1.0 / (1.0 + tri_ratio)                       # more triangles → shorter\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_max *\n            f_tri)", "spearman": 0.7203300082502063, "pearson": 0.674047798500587, "rmse": 2.4878172197661046, "mae": 1.7304965774658472}}
{"timestamp": "2026-02-16T19:20:02.009532+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.140599", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:20:02.009902+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 17, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.140599", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:20:30.532662+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i2_p2_242142270", "generation": 17, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.6914285714285715, "fitness_mode": "correlation", "simplicity_score": 0.12455802338954883, "novelty_bonus": 0.4152996415146365, "total_score": 0.4618483058025175, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.105557\nbelow_novelty_threshold: novelty_bonus=0.109158\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.140599\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n\n    The estimate is based on a simple random‑graph baseline (n / (avg_degree + 1))\n    followed by multiplicative corrections that account for density, clustering,\n    transitivity, degree heterogeneity, assortativity, the presence of very low\n    and very high degree vertices, and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density   = 1.0 / (1.0 + density)                          # denser → shorter\n    f_clustering = 1.0 + clustering                              # more clustering → longer\n    f_trans     = 1.0 + trans                                    # more transitivity → longer\n    f_std       = 1.0 / (1.0 + std_deg)                          # heterogeneous → shorter\n    f_assort    = 1.0 + abs(assort)                              # assortative → longer\n    f_min       = 1.0 / (1.0 + min_deg)                          # very low min degree → longer\n    f_max       = 1.0 / (1.0 + max_deg / avg_deg)                # very high max degree → shorter\n    f_tri       = 1.0 / (1.0 + tri_ratio)                        # more triangles → shorter\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_max *\n            f_tri)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n\n    The estimate is a simple random‑graph baseline (n / (avg_degree + 1))\n    multiplied by correction factors that capture the influence of\n    density, clustering, transitivity, degree heterogeneity,\n    assortativity, extreme degree values and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics. Expected keys:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Base random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_ratio = num_tri / possible_tri\n    else:\n        tri_ratio = 0.0\n\n    # Correction factors\n    f_density   = 1.0 / (1.0 + density)                       # denser → shorter\n    f_clustering = 1.0 + clustering                           # more clustering → longer\n    f_trans     = 1.0 + trans                                 # more transitivity → longer\n    f_std       = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))     # heterogeneous → shorter\n    f_assort    = 1.0 + 0.5 * abs(assort)                     # more assortative → longer\n    f_min       = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))     # very low min degree → longer\n    f_max       = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))     # very high max degree → shorter\n    f_tri       = 1.0 / (1.0 + tri_ratio)                     # more triangles → shorter\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_max *\n            f_tri)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n\n    The estimate is a simple random‑graph baseline (n / (avg_degree + 1))\n    multiplied by correction factors that capture the influence of\n    density, clustering, transitivity, degree heterogeneity,\n    assortativity, extreme degree values and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics. Expected keys:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Base random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_ratio = num_tri / possible_tri\n    else:\n        tri_ratio = 0.0\n\n    # Correction factors\n    f_density   = 1.0 / (1.0 + density)                       # denser → shorter\n    f_clustering = 1.0 + clustering                           # more clustering → longer\n    f_trans     = 1.0 + trans                                 # more transitivity → longer\n    f_std       = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))     # heterogeneous → shorter\n    f_assort    = 1.0 + 0.5 * abs(assort)                     # more assortative → longer\n    f_min       = 1.0 / (1.0 + min_deg / (avg_deg + 1.0))     # very low min degree → longer\n    f_max       = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))     # very high max degree → shorter\n    f_tri       = 1.0 / (1.0 + tri_ratio)                     # more triangles → shorter\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_max *\n            f_tri)", "spearman": 0.6246936173404336, "pearson": 0.6286487471906984, "rmse": 1.0625986618654766, "mae": 0.7742695513906978}}
{"timestamp": "2026-02-16T19:20:30.533662+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 17, "island_id": 2, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:21:17.300344+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i2_p3_75162041", "generation": 17, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8370228091236495, "fitness_mode": "correlation", "simplicity_score": 0.12086512168362601, "novelty_bonus": 0.2459506341917741, "total_score": 0.50761020589404, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.105557\nbelow_novelty_threshold: novelty_bonus=0.109158\nbelow_novelty_threshold: novelty_bonus=0.140599\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic builds on a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies a set of multiplicative corrections that capture the influence\n    of density, clustering, transitivity, degree heterogeneity, assortativity,\n    very low‑degree vertices, triangle density, and the presence of high‑degree\n    hubs.  All corrections are bounded and use only the supplied statistics,\n    keeping the formula compact while improving accuracy over the baseline.\n    \n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n    \n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # --- Basic random‑graph baseline ------------------------------------\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)   # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # --- Feature extraction ----------------------------------------------\n    density      = s.get('density', 0.0)\n    clustering   = s.get('avg_clustering', 0.0)\n    trans        = s.get('transitivity', 0.0)\n    std_deg      = s.get('std_degree', 0.0)\n    assort       = s.get('degree_assortativity', 0.0)\n    min_deg      = s.get('min_degree', avg_deg)\n    max_deg      = s.get('max_degree', avg_deg)\n    num_tri      = s.get('num_triangles', 0)\n    degrees      = s.get('degrees', [])\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Low‑degree ratio (fraction of nodes with degree ≤ 1)\n    low_deg_count = sum(1 for d in degrees if d <= 1)\n    low_deg_ratio = low_deg_count / n if n else 0\n\n    # --- Multiplicative correction factors -------------------------------\n    f_density      = 1.0 / (1.0 + density)                           # denser → shorter\n    f_clustering   = 1.0 + clustering                                 # more clustering → longer\n    f_trans        = 1.0 + trans                                       # more transitivity → longer\n    f_hetero       = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))           # more heterogeneous → shorter\n    f_assort       = 1.0 + 0.5 * abs(assort)                          # more assortative → longer\n    f_min          = 1.0 + 1.0 / (min_deg + 1.0)                      # very low min degree → longer\n    f_max          = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))           # high max degree (hub) → shorter\n    f_tri          = 1.0 / (1.0 + tri_ratio)                          # many triangles → shorter\n    f_low_deg      = 1.0 + low_deg_ratio                               # many degree‑1 nodes → longer\n\n    # --- Combine all corrections ----------------------------------------\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_hetero *\n            f_assort *\n            f_min *\n            f_max *\n            f_tri *\n            f_low_deg)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic builds on a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies a set of multiplicative corrections that capture the influence\n    of density, clustering, transitivity, degree heterogeneity, assortativity,\n    very low‑degree vertices, triangle density, and the presence of high‑degree\n    hubs.  All corrections are bounded and use only the supplied statistics,\n    keeping the formula compact while improving accuracy over the baseline.\n    \n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n    \n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # --- Basic random‑graph baseline ------------------------------------\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)   # avoid division by zero\n    base = n / (avg_deg + 1.0)\n\n    # --- Feature extraction ----------------------------------------------\n    density      = s.get('density', 0.0)\n    clustering   = s.get('avg_clustering', 0.0)\n    trans        = s.get('transitivity', 0.0)\n    std_deg      = s.get('std_degree', 0.0)\n    assort       = s.get('degree_assortativity', 0.0)\n    min_deg      = s.get('min_degree', avg_deg)\n    max_deg      = s.get('max_degree', avg_deg)\n    num_tri      = s.get('num_triangles', 0)\n    degrees      = s.get('degrees', [])\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Low‑degree ratio (fraction of nodes with degree ≤ 1)\n    low_deg_count = sum(1 for d in degrees if d <= 1)\n    low_deg_ratio = low_deg_count / n if n else 0\n\n    # --- Multiplicative correction factors -------------------------------\n    f_density      = 1.0 / (1.0 + density)                           # denser → shorter\n    f_clustering   = 1.0 + clustering                                 # more clustering → longer\n    f_trans        = 1.0 + trans                                       # more transitivity → longer\n    f_hetero       = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))           # more heterogeneous → shorter\n    f_assort       = 1.0 + 0.5 * abs(assort)                          # more assortative → longer\n    f_min          = 1.0 + 1.0 / (min_deg + 1.0)                      # very low min degree → longer\n    f_max          = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))           # high max degree (hub) → shorter\n    f_tri          = 1.0 / (1.0 + tri_ratio)                          # many triangles → shorter\n    f_low_deg      = 1.0 + low_deg_ratio                               # many degree‑1 nodes → longer\n\n    # --- Combine all corrections ----------------------------------------\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_hetero *\n            f_assort *\n            f_min *\n            f_max *\n            f_tri *\n            f_low_deg)", "spearman": 0.8193039825995652, "pearson": 0.7888413359897465, "rmse": 2.606696816209533, "mae": 1.8523567503548053}}
{"timestamp": "2026-02-16T19:21:59.385097+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:21:59.386169+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 17, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:22:41.702476+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i2_p4_808208597", "generation": 17, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8622809123649459, "fitness_mode": "correlation", "simplicity_score": 0.12747687333604735, "novelty_bonus": 0.2439650011795802, "total_score": 0.5386158732960404, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.105557\nbelow_novelty_threshold: novelty_bonus=0.109158\nbelow_novelty_threshold: novelty_bonus=0.140599\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport math\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic starts from a logarithmic random‑graph baseline and applies\n    multiplicative corrections that capture density, clustering, transitivity,\n    degree heterogeneity, assortativity, very low degrees and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys include:\n            - 'n' (int)\n            - 'avg_degree' (float)\n            - 'avg_clustering' (float)\n            - 'transitivity' (float)\n            - 'density' (float)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline (logarithmic scaling)\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = math.log(n + 1) / (math.log(avg_deg + 1) + 0.5)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri\n\n    # Multiplicative correction factors\n    f_clust = 1.0 + clustering                     # higher clustering → longer paths\n    f_trans = 1.0 + trans                           # higher transitivity → longer paths\n    f_density = 1.0 / (1.0 + density)               # denser graphs → shorter paths\n    f_hetero = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    f_assort = 1.0 + 0.3 * abs(assort)              # more assortative → longer paths\n    f_min = 1.0 + 0.5 / (min_deg + 1.0)             # very low min degree lengthens paths\n    f_tri = 1.0 / (1.0 + tri_ratio)                 # more triangles → shorter paths\n\n    return (base *\n            f_clust *\n            f_trans *\n            f_density *\n            f_hetero *\n            f_assort *\n            f_min *\n            f_tri)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture density, clustering, transitivity, degree heterogeneity,\n    assortativity, low‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys include:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    possible_tri = n * (n - 1) * (n - 2) // 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_density = 1.0 / (1.0 + density)\n    f_hetero = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return base * f_clust * f_trans * f_density * f_hetero * f_assort * f_min * f_tri\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture density, clustering, transitivity, degree heterogeneity,\n    assortativity, low‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys include:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    possible_tri = n * (n - 1) * (n - 2) // 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_density = 1.0 / (1.0 + density)\n    f_hetero = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return base * f_clust * f_trans * f_density * f_hetero * f_assort * f_min * f_tri", "spearman": 0.8798619965499139, "pearson": 0.856530736217558, "rmse": 10.889728766202964, "mae": 9.3389863953469}}
{"timestamp": "2026-02-16T19:22:41.703093+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 17, "island_id": 2, "population_idx": 4, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:23:28.630443+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i3_p0_140217414", "generation": 17, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6061464585834333, "fitness_mode": "correlation", "simplicity_score": 0.15545714783547843, "novelty_bonus": 0.39107848252390975, "total_score": 0.4740513652340415, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    The estimate uses a square‑root dependence on the number of nodes and an inverse\n    dependence on the average degree.  Several multiplicative correction factors\n    capture the effects of clustering, density, degree heterogeneity, assortativity,\n    bottlenecks (low minimum degree), hubs (high maximum degree) and triangles.\n    \"\"\"\n    # Feature extraction with sensible defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure numerical stability\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1 + clust                      # higher clustering → longer paths\n    dens_factor    = 1 / (1 + density)              # denser graphs → shorter paths\n    assort_factor  = 1 + abs(assort)                # assortative mixing elongates paths\n    hetero_factor  = 1 / (1 + std_deg)              # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n    tri_factor     = 1 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines a simple size–degree baseline with multiplicative\n    corrections that reflect clustering, density, assortativity, degree\n    heterogeneity, bottlenecks, hubs, triangles and global transitivity.\n    \n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed features of a graph. Expected keys:\n        'n', 'm', 'density', 'avg_degree', 'max_degree', 'min_degree',\n        'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'num_triangles', 'degrees'.\n    \n    Returns\n    -------\n    float\n        Numerical estimate of the graph's average shortest‑path length.\n    \"\"\"\n    # Fetch features with safe defaults\n    n          = s.get('n', 1)\n    m          = s.get('m', 1)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure denominators are never zero\n    eps        = 1e-12\n    avg_deg    = max(avg_deg, eps)\n    max_deg    = max(max_deg, eps)\n    std_deg    = max(std_deg, eps)\n    min_deg    = max(min_deg, eps)\n\n    # -------- Baseline --------\n    # Roughly grows with sqrt(n) and shrinks with avg_degree\n    base = (n + 1) ** 0.5 / (avg_deg + 1.0)\n\n    # -------- Correction factors --------\n    # 1. Clustering tends to lengthen typical paths\n    cf_clust = 1.0 + clust\n    # 2. Higher density shortens distances\n    cf_dens  = 1.0 / (1.0 + density)\n    # 3. Assortativity elongates paths (positive or negative)\n    cf_assort = 1.0 + abs(assort)\n    # 4. Heterogeneous degrees tend to shorten paths\n    cf_std = 1.0 / (1.0 + std_deg)\n    # 5. Very low minimum degree creates bottlenecks\n    cf_bottleneck = 1.0 + (min_deg / (avg_deg + 1.0))\n    # 6. Presence of hubs can reduce distances\n    cf_hub = (max_deg / (avg_deg + 1.0)) ** 0.5\n    # 7. Abundant triangles tend to shorten paths\n    cf_tri = 1.0 + (num_tri ** 0.5) / ((n ** 0.5) + eps)\n    # 8. Global transitivity (similar effect to clustering)\n    cf_trans = 1.0 + trans\n\n    # -------- Combine --------\n    estimate = (base *\n                cf_clust *\n                cf_dens *\n                cf_assort *\n                cf_std *\n                cf_bottleneck *\n                cf_hub *\n                cf_tri *\n                cf_trans)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines a simple size–degree baseline with multiplicative\n    corrections that reflect clustering, density, assortativity, degree\n    heterogeneity, bottlenecks, hubs, triangles and global transitivity.\n    \n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed features of a graph. Expected keys:\n        'n', 'm', 'density', 'avg_degree', 'max_degree', 'min_degree',\n        'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'num_triangles', 'degrees'.\n    \n    Returns\n    -------\n    float\n        Numerical estimate of the graph's average shortest‑path length.\n    \"\"\"\n    # Fetch features with safe defaults\n    n          = s.get('n', 1)\n    m          = s.get('m', 1)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure denominators are never zero\n    eps        = 1e-12\n    avg_deg    = max(avg_deg, eps)\n    max_deg    = max(max_deg, eps)\n    std_deg    = max(std_deg, eps)\n    min_deg    = max(min_deg, eps)\n\n    # -------- Baseline --------\n    # Roughly grows with sqrt(n) and shrinks with avg_degree\n    base = (n + 1) ** 0.5 / (avg_deg + 1.0)\n\n    # -------- Correction factors --------\n    # 1. Clustering tends to lengthen typical paths\n    cf_clust = 1.0 + clust\n    # 2. Higher density shortens distances\n    cf_dens  = 1.0 / (1.0 + density)\n    # 3. Assortativity elongates paths (positive or negative)\n    cf_assort = 1.0 + abs(assort)\n    # 4. Heterogeneous degrees tend to shorten paths\n    cf_std = 1.0 / (1.0 + std_deg)\n    # 5. Very low minimum degree creates bottlenecks\n    cf_bottleneck = 1.0 + (min_deg / (avg_deg + 1.0))\n    # 6. Presence of hubs can reduce distances\n    cf_hub = (max_deg / (avg_deg + 1.0)) ** 0.5\n    # 7. Abundant triangles tend to shorten paths\n    cf_tri = 1.0 + (num_tri ** 0.5) / ((n ** 0.5) + eps)\n    # 8. Global transitivity (similar effect to clustering)\n    cf_trans = 1.0 + trans\n\n    # -------- Combine --------\n    estimate = (base *\n                cf_clust *\n                cf_dens *\n                cf_assort *\n                cf_std *\n                cf_bottleneck *\n                cf_hub *\n                cf_tri *\n                cf_trans)\n\n    return float(estimate)", "spearman": 0.6512727818195457, "pearson": 0.682572266544412, "rmse": 1.0290050721337642, "mae": 0.8463612187746244}}
{"timestamp": "2026-02-16T19:24:15.127870+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i3_p1_912225602", "generation": 17, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6061464585834333, "fitness_mode": "correlation", "simplicity_score": 0.17863697240640874, "novelty_bonus": 0.39107848252390975, "total_score": 0.47868733014822756, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    The estimate uses a square‑root dependence on the number of nodes and an inverse\n    dependence on the average degree.  Several multiplicative correction factors\n    capture the effects of clustering, density, degree heterogeneity, assortativity,\n    bottlenecks (low minimum degree), hubs (high maximum degree) and triangles.\n    \"\"\"\n    # Feature extraction with sensible defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure numerical stability\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1 + clust                      # higher clustering → longer paths\n    dens_factor    = 1 / (1 + density)              # denser graphs → shorter paths\n    assort_factor  = 1 + abs(assort)                # assortative mixing elongates paths\n    hetero_factor  = 1 / (1 + std_deg)              # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n    tri_factor     = 1 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a collection of global graph\n    statistics.  The formula uses a square‑root baseline that scales with the\n    number of nodes and inversely with the mean degree, and applies a set of\n    multiplicative correction factors that capture the influence of clustering,\n    density, degree heterogeneity, assortativity, bottlenecks, hubs and triangles.\n    \n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following pre‑computed features (missing\n        entries are replaced by sensible defaults):\n            - 'n'                  : number of nodes\n            - 'avg_degree'         : mean degree\n            - 'max_degree'         : maximum degree\n            - 'min_degree'         : minimum degree\n            - 'std_degree'         : standard deviation of the degree distribution\n            - 'avg_clustering'     : average clustering coefficient\n            - 'transitivity'       : global transitivity\n            - 'density'            : graph density\n            - 'degree_assortativity': degree assortativity coefficient\n            - 'num_triangles'      : total number of triangles\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path\n        length.\n    \"\"\"\n    # Extract features with safe defaults\n    n = s.get('n', 1)\n    avg_degree = s.get('avg_degree', 1.0)\n    max_degree = s.get('max_degree', avg_degree)\n    min_degree = s.get('min_degree', 0.0)\n    std_degree = s.get('std_degree', 0.0)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0.0)\n\n    # Numerical stability safeguards\n    eps = 1e-12\n    avg_degree = max(avg_degree, eps)\n    max_degree = max(max_degree, eps)\n    min_degree = max(min_degree, eps)\n    std_degree = max(std_degree, eps)\n    num_triangles = max(num_triangles, eps)\n\n    # ---------- Baseline ----------\n    # Size dependence (√n) moderated by mean degree\n    base = (n + 1)**0.5 / (avg_degree + 1.0)\n\n    # ---------- Multiplicative correction factors ----------\n    clust_factor   = 1.0 + avg_clustering            # higher clustering → longer paths\n    trans_factor   = 1.0 + transitivity              # higher transitivity → longer paths\n    dens_factor    = 1.0 / (1.0 + density)           # denser graphs → shorter paths\n    assort_factor  = 1.0 + abs(degree_assortativity) # assortativity elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_degree)        # heterogeneous degrees shorten paths\n    bottleneck_factor = 1.0 + (min_degree / (avg_degree + 1.0))  # low min degree → bottleneck\n    hub_factor     = (max_degree / (avg_degree + 1.0))**0.5     # hubs reduce distances\n    tri_factor     = 1.0 + (num_triangles**0.5) / ((n**0.5) + eps)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                trans_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a collection of global graph\n    statistics.  The formula uses a square‑root baseline that scales with the\n    number of nodes and inversely with the mean degree, and applies a set of\n    multiplicative correction factors that capture the influence of clustering,\n    density, degree heterogeneity, assortativity, bottlenecks, hubs and triangles.\n    \n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following pre‑computed features (missing\n        entries are replaced by sensible defaults):\n            - 'n'                  : number of nodes\n            - 'avg_degree'         : mean degree\n            - 'max_degree'         : maximum degree\n            - 'min_degree'         : minimum degree\n            - 'std_degree'         : standard deviation of the degree distribution\n            - 'avg_clustering'     : average clustering coefficient\n            - 'transitivity'       : global transitivity\n            - 'density'            : graph density\n            - 'degree_assortativity': degree assortativity coefficient\n            - 'num_triangles'      : total number of triangles\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path\n        length.\n    \"\"\"\n    # Extract features with safe defaults\n    n = s.get('n', 1)\n    avg_degree = s.get('avg_degree', 1.0)\n    max_degree = s.get('max_degree', avg_degree)\n    min_degree = s.get('min_degree', 0.0)\n    std_degree = s.get('std_degree', 0.0)\n    avg_clustering = s.get('avg_clustering', 0.0)\n    transitivity = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    degree_assortativity = s.get('degree_assortativity', 0.0)\n    num_triangles = s.get('num_triangles', 0.0)\n\n    # Numerical stability safeguards\n    eps = 1e-12\n    avg_degree = max(avg_degree, eps)\n    max_degree = max(max_degree, eps)\n    min_degree = max(min_degree, eps)\n    std_degree = max(std_degree, eps)\n    num_triangles = max(num_triangles, eps)\n\n    # ---------- Baseline ----------\n    # Size dependence (√n) moderated by mean degree\n    base = (n + 1)**0.5 / (avg_degree + 1.0)\n\n    # ---------- Multiplicative correction factors ----------\n    clust_factor   = 1.0 + avg_clustering            # higher clustering → longer paths\n    trans_factor   = 1.0 + transitivity              # higher transitivity → longer paths\n    dens_factor    = 1.0 / (1.0 + density)           # denser graphs → shorter paths\n    assort_factor  = 1.0 + abs(degree_assortativity) # assortativity elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_degree)        # heterogeneous degrees shorten paths\n    bottleneck_factor = 1.0 + (min_degree / (avg_degree + 1.0))  # low min degree → bottleneck\n    hub_factor     = (max_degree / (avg_degree + 1.0))**0.5     # hubs reduce distances\n    tri_factor     = 1.0 + (num_triangles**0.5) / ((n**0.5) + eps)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                trans_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate", "spearman": 0.6512727818195457, "pearson": 0.6825722957500477, "rmse": 1.0290050394368409, "mae": 0.8463611933295035}}
{"timestamp": "2026-02-16T19:24:51.545590+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i3_p2_78085767", "generation": 17, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6061464585834333, "fitness_mode": "correlation", "simplicity_score": 0.15550860811844236, "novelty_bonus": 0.39107848252390975, "total_score": 0.47406165729063426, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    The estimate uses a square‑root dependence on the number of nodes and an inverse\n    dependence on the average degree.  Several multiplicative correction factors\n    capture the effects of clustering, density, degree heterogeneity, assortativity,\n    bottlenecks (low minimum degree), hubs (high maximum degree) and triangles.\n    \"\"\"\n    # Feature extraction with sensible defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure numerical stability\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1 + clust                      # higher clustering → longer paths\n    dens_factor    = 1 / (1 + density)              # denser graphs → shorter paths\n    assort_factor  = 1 + abs(assort)                # assortative mixing elongates paths\n    hetero_factor  = 1 / (1 + std_deg)              # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n    tri_factor     = 1 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # extract features with sane defaults\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 1.0)\n    max_deg = s.get('max_degree', avg_deg)\n    min_deg = s.get('min_degree', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0.0)\n\n    # avoid divisions by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n\n    # ---------- baseline ----------\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n\n    # ---------- multiplicative correction factors ----------\n    factor_clust = 1.0 + clust                 # more clustering → longer paths\n    factor_trans = 1.0 + trans                 # more transitivity → longer paths\n    factor_density = 1.0 / (1.0 + density)     # denser → shorter paths\n    factor_assort = 1.0 + abs(assort)           # assortativity elongates distances\n    factor_std = 1.0 / (1.0 + std_deg)          # heterogeneous degrees shorten distances\n    factor_min = 1.0 + (min_deg / (avg_deg + 1.0))  # low min degree can lengthen paths\n    factor_max = (max_deg / (avg_deg + 1.0))**0.5   # hubs shorten paths\n    factor_tri = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # many triangles shorten paths\n\n    # ---------- combine ----------\n    estimate = (base *\n                factor_clust *\n                factor_trans *\n                factor_density *\n                factor_assort *\n                factor_std *\n                factor_min *\n                factor_max *\n                factor_tri)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    # extract features with sane defaults\n    n = s.get('n', 1)\n    m = s.get('m', 0)\n    density = s.get('density', 0.0)\n    avg_deg = s.get('avg_degree', 1.0)\n    max_deg = s.get('max_degree', avg_deg)\n    min_deg = s.get('min_degree', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    clust = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    num_tri = s.get('num_triangles', 0.0)\n\n    # avoid divisions by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n\n    # ---------- baseline ----------\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n\n    # ---------- multiplicative correction factors ----------\n    factor_clust = 1.0 + clust                 # more clustering → longer paths\n    factor_trans = 1.0 + trans                 # more transitivity → longer paths\n    factor_density = 1.0 / (1.0 + density)     # denser → shorter paths\n    factor_assort = 1.0 + abs(assort)           # assortativity elongates distances\n    factor_std = 1.0 / (1.0 + std_deg)          # heterogeneous degrees shorten distances\n    factor_min = 1.0 + (min_deg / (avg_deg + 1.0))  # low min degree can lengthen paths\n    factor_max = (max_deg / (avg_deg + 1.0))**0.5   # hubs shorten paths\n    factor_tri = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # many triangles shorten paths\n\n    # ---------- combine ----------\n    estimate = (base *\n                factor_clust *\n                factor_trans *\n                factor_density *\n                factor_assort *\n                factor_std *\n                factor_min *\n                factor_max *\n                factor_tri)\n\n    return float(estimate)", "spearman": 0.6512727818195457, "pearson": 0.6825722665444123, "rmse": 1.029005072133764, "mae": 0.8463612187746244}}
{"timestamp": "2026-02-16T19:25:47.463223+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i3_p3_438166888", "generation": 17, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6901800720288115, "fitness_mode": "correlation", "simplicity_score": 0.18055555555555555, "novelty_bonus": 0.371845035328932, "total_score": 0.5183343884539594, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    The estimate uses a square‑root dependence on the number of nodes and an inverse\n    dependence on the average degree.  Several multiplicative correction factors\n    capture the effects of clustering, density, degree heterogeneity, assortativity,\n    bottlenecks (low minimum degree), hubs (high maximum degree) and triangles.\n    \"\"\"\n    # Feature extraction with sensible defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure numerical stability\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1 + clust                      # higher clustering → longer paths\n    dens_factor    = 1 / (1 + density)              # denser graphs → shorter paths\n    assort_factor  = 1 + abs(assort)                # assortative mixing elongates paths\n    hetero_factor  = 1 / (1 + std_deg)              # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n    tri_factor     = 1 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    The formula uses a baseline that grows with the square root of the number of nodes\n    and decreases with the average degree.  A set of multiplicative correction\n    factors captures the effects of clustering, density, degree heterogeneity,\n    assortativity, low‑degree bottlenecks, triangles, and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all values are numbers):\n        - n                 : number of nodes\n        - m                 : number of edges\n        - density           : graph density (0–1)\n        - avg_degree        : average degree\n        - max_degree        : maximum degree\n        - min_degree        : minimum degree\n        - std_degree        : standard deviation of degrees\n        - avg_clustering    : average clustering coefficient\n        - transitivity      : global transitivity (unused here)\n        - degree_assortativity : degree assortativity coefficient\n        - num_triangles     : total number of triangles\n        - degrees           : sorted list of degrees (unused here)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Basic numeric extraction – no imports needed\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    density    = float(s['density'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n\n    # Small epsilon to avoid division by zero\n    eps = 1e-12\n\n    # ---------- Baseline ----------\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    clust_factor     = 1.0 + clust                  # more clustering → longer paths\n    dens_factor      = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    assort_factor    = 1.0 + abs(assort)             # assortative mixing elongates paths\n    hetero_factor    = 1.0 / (1.0 + std_deg)         # heterogeneous degrees shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # low min degree can create bottlenecks\n    tri_factor       = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)  # triangles tend to shorten paths\n    hub_factor       = (max_deg / (avg_deg + 1.0)) ** 0.5  # presence of hubs reduces distances\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    The formula uses a baseline that grows with the square root of the number of nodes\n    and decreases with the average degree.  A set of multiplicative correction\n    factors captures the effects of clustering, density, degree heterogeneity,\n    assortativity, low‑degree bottlenecks, triangles, and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all values are numbers):\n        - n                 : number of nodes\n        - m                 : number of edges\n        - density           : graph density (0–1)\n        - avg_degree        : average degree\n        - max_degree        : maximum degree\n        - min_degree        : minimum degree\n        - std_degree        : standard deviation of degrees\n        - avg_clustering    : average clustering coefficient\n        - transitivity      : global transitivity (unused here)\n        - degree_assortativity : degree assortativity coefficient\n        - num_triangles     : total number of triangles\n        - degrees           : sorted list of degrees (unused here)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Basic numeric extraction – no imports needed\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    density    = float(s['density'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n\n    # Small epsilon to avoid division by zero\n    eps = 1e-12\n\n    # ---------- Baseline ----------\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    clust_factor     = 1.0 + clust                  # more clustering → longer paths\n    dens_factor      = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    assort_factor    = 1.0 + abs(assort)             # assortative mixing elongates paths\n    hetero_factor    = 1.0 / (1.0 + std_deg)         # heterogeneous degrees shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # low min degree can create bottlenecks\n    tri_factor       = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)  # triangles tend to shorten paths\n    hub_factor       = (max_deg / (avg_deg + 1.0)) ** 0.5  # presence of hubs reduces distances\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return estimate", "spearman": 0.7413395334883374, "pearson": 0.740784516881863, "rmse": 1.1368805512560614, "mae": 1.0163434818161656}}
{"timestamp": "2026-02-16T19:26:24.808495+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i3_p4_41975711", "generation": 17, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6901800720288115, "fitness_mode": "correlation", "simplicity_score": 0.154940803466983, "novelty_bonus": 0.371845035328932, "total_score": 0.5132114380362449, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    The estimate uses a square‑root dependence on the number of nodes and an inverse\n    dependence on the average degree.  Several multiplicative correction factors\n    capture the effects of clustering, density, degree heterogeneity, assortativity,\n    bottlenecks (low minimum degree), hubs (high maximum degree) and triangles.\n    \"\"\"\n    # Feature extraction with sensible defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure numerical stability\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1 + clust                      # higher clustering → longer paths\n    dens_factor    = 1 / (1 + density)              # denser graphs → shorter paths\n    assort_factor  = 1 + abs(assort)                # assortative mixing elongates paths\n    hetero_factor  = 1 / (1 + std_deg)              # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n    tri_factor     = 1 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.276255\nno_valid_train_predictions: static_invalid: forbidden call detected: locals\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using a multiplicative model\n    built from a small set of global graph statistics.  The function uses\n    only built‑in arithmetic operations and avoids any explicit imports.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Missing keys are given\n        sensible defaults.\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    # Extract values with defaults\n    n          = float(s.get('n', 1))\n    m          = float(s.get('m', 1))\n    density    = float(s.get('density', 0.0))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    avg_clust  = float(s.get('avg_clustering', 0.0))\n    trans      = float(s.get('transitivity', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Guard against division by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # sqrt(n+1) captures size dependence; avg_deg + 1 in the denominator\n    # reflects connectivity (more edges => shorter paths).\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Multiplicative corrections ----------\n    # Each factor is expressed in terms of available statistics\n    # and keeps the estimate positive.\n\n    # Clustering: higher clustering tends to make paths longer.\n    clust_factor = 1.0 + avg_clust\n\n    # Density: denser graphs generally have shorter paths.\n    dens_factor = 1.0 / (1.0 + density)\n\n    # Assortativity: strong degree mixing (positive or negative)\n    # can inflate distances; use absolute value.\n    assort_factor = 1.0 + abs(assort)\n\n    # Degree heterogeneity: higher variance often reduces average\n    # distances because of hubs.\n    hetero_factor = 1.0 / (1.0 + std_deg)\n\n    # Bottleneck factor: low minimum degree creates narrow passages.\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1))\n\n    # Triangle factor: many triangles create alternative short routes.\n    tri_factor = 1.0 + (num_tri ** 0.5) / ((n ** 0.5) + eps)\n\n    # Hub factor: very high maximum degree typically reduces distances.\n    hub_factor = (max_deg / (avg_deg + 1)) ** 0.5\n\n    # ---------- Combine ----------\n    estimate = (\n        base *\n        clust_factor *\n        dens_factor *\n        assort_factor *\n        hetero_factor *\n        bottleneck_factor *\n        tri_factor *\n        hub_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using a multiplicative model\n    built from a small set of global graph statistics.  The function uses\n    only built‑in arithmetic operations and avoids any explicit imports.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Missing keys are given\n        sensible defaults.\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    # Extract values with defaults\n    n          = float(s.get('n', 1))\n    m          = float(s.get('m', 1))\n    density    = float(s.get('density', 0.0))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    avg_clust  = float(s.get('avg_clustering', 0.0))\n    trans      = float(s.get('transitivity', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Guard against division by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # sqrt(n+1) captures size dependence; avg_deg + 1 in the denominator\n    # reflects connectivity (more edges => shorter paths).\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Multiplicative corrections ----------\n    # Each factor is expressed in terms of available statistics\n    # and keeps the estimate positive.\n\n    # Clustering: higher clustering tends to make paths longer.\n    clust_factor = 1.0 + avg_clust\n\n    # Density: denser graphs generally have shorter paths.\n    dens_factor = 1.0 / (1.0 + density)\n\n    # Assortativity: strong degree mixing (positive or negative)\n    # can inflate distances; use absolute value.\n    assort_factor = 1.0 + abs(assort)\n\n    # Degree heterogeneity: higher variance often reduces average\n    # distances because of hubs.\n    hetero_factor = 1.0 / (1.0 + std_deg)\n\n    # Bottleneck factor: low minimum degree creates narrow passages.\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1))\n\n    # Triangle factor: many triangles create alternative short routes.\n    tri_factor = 1.0 + (num_tri ** 0.5) / ((n ** 0.5) + eps)\n\n    # Hub factor: very high maximum degree typically reduces distances.\n    hub_factor = (max_deg / (avg_deg + 1)) ** 0.5\n\n    # ---------- Combine ----------\n    estimate = (\n        base *\n        clust_factor *\n        dens_factor *\n        assort_factor *\n        hetero_factor *\n        bottleneck_factor *\n        tri_factor *\n        hub_factor\n    )\n\n    return float(estimate)", "spearman": 0.7413395334883374, "pearson": 0.740784516881863, "rmse": 1.1368805512560614, "mae": 1.0163434818161656}}
{"timestamp": "2026-02-16T19:26:24.811099+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 18, "model_name": "gpt-oss:20b", "best_val_score": 0.5492830341781751, "no_improve_count": 1}}
{"timestamp": "2026-02-16T19:27:25.915490+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i0_p0_37503038", "generation": 18, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.828859543817527, "fitness_mode": "correlation", "simplicity_score": 0.22093003582557502, "novelty_bonus": 0.2043064947762897, "total_score": 0.5466104839112098, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    base = pow(n, 0.45) / pow(avg_deg, 0.55)\n    base /= (1.0 + pow(density, 0.6) + pow(max_deg / (n + 1.0), 0.5))\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + pow(density, 1.7))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    base = pow(n, 0.45) / pow(avg_deg, 0.55)\n    base /= (1.0 + pow(density, 0.6) + pow(max_deg / (n + 1.0), 0.5))\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + pow(density, 1.7))\n\n    return base", "spearman": 0.8822650566264157, "pearson": 0.817347552090235, "rmse": 0.5746952936508153, "mae": 0.35687948558486027}}
{"timestamp": "2026-02-16T19:29:52.244932+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i0_p1_576558630", "generation": 18, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.828859543817527, "fitness_mode": "correlation", "simplicity_score": 0.22095870552600597, "novelty_bonus": 0.2043064947762897, "total_score": 0.546616217851296, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact, interpretable, and uses only arithmetic on the\n    supplied features.  No graph traversal is performed.\n    \"\"\"\n    n = s['n']\n    if n <= 0:\n        return 0.0\n\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.6)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.4\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.4)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.7)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact, interpretable, and uses only arithmetic on the\n    supplied features.  No graph traversal is performed.\n    \"\"\"\n    n = s['n']\n    if n <= 0:\n        return 0.0\n\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.6)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.4\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.4)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.7)\n\n    return base", "spearman": 0.8822650566264157, "pearson": 0.817347552090235, "rmse": 0.5746952936508153, "mae": 0.35687948558486027}}
{"timestamp": "2026-02-16T19:31:57.968049+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i0_p2_478999936", "generation": 18, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.7494357743097239, "fitness_mode": "correlation", "simplicity_score": 0.21901859382331743, "novelty_bonus": 0.22758877764391727, "total_score": 0.5304678117443309, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    mid = n // 2\n    median_deg = degrees[mid] if n % 2 else (degrees[mid-1] + degrees[mid]) / 2.0\n\n    base = (n ** 0.46) / (avg_deg ** 0.54)\n\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n    base *= (1.0 + (max_deg - min_deg) / (max_deg + 1.0) * 0.30)\n    base *= (1.0 + (avg_deg - median_deg) / (avg_deg + 1.0) * 0.20)\n\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    base /= (1.0 + abs(assort) * 0.65)\n\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    base *= (1.0 + leaf_frac * 0.45)\n\n    base /= (1.0 + density ** 1.75)\n\n    return base", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    mid = n // 2\n    median_deg = degrees[mid] if n % 2 else (degrees[mid-1] + degrees[mid]) / 2.0\n\n    base = (n ** 0.46) / (avg_deg ** 0.54)\n\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n    base *= (1.0 + (max_deg - min_deg) / (max_deg + 1.0) * 0.30)\n    base *= (1.0 + (avg_deg - median_deg) / (avg_deg + 1.0) * 0.20)\n\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    base /= (1.0 + abs(assort) * 0.65)\n\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    base *= (1.0 + leaf_frac * 0.45)\n\n    base /= (1.0 + density ** 1.75)\n\n    return base", "spearman": 0.8367749193729845, "pearson": 0.7850249494545828, "rmse": 1.4400245233986564, "mae": 1.1376455469624336}}
{"timestamp": "2026-02-16T19:34:38.411285+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i0_p3_398054772", "generation": 18, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.8185834333733493, "fitness_mode": "correlation", "simplicity_score": 0.22113343699055302, "novelty_bonus": 0.207337346688798, "total_score": 0.5435553195904547, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.46) / (avg_deg ** 0.56)\n    base /= (1.0 + density ** 0.66 + (max_deg / (n + 1.0)) ** 0.45)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.7)\n    base += triangles / (n ** 2 + 1.0) * 0.5\n    base *= (1.0 + leaf_frac * 0.5)\n    base /= (1.0 + density ** 1.8)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.46) / (avg_deg ** 0.56)\n    base /= (1.0 + density ** 0.66 + (max_deg / (n + 1.0)) ** 0.45)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.7)\n    base += triangles / (n ** 2 + 1.0) * 0.5\n    base *= (1.0 + leaf_frac * 0.5)\n    base /= (1.0 + density ** 1.8)\n\n    return base", "spearman": 0.8742548563714094, "pearson": 0.8044832007833974, "rmse": 0.6907984175018324, "mae": 0.45493700116009067}}
{"timestamp": "2026-02-16T19:35:57.157133+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i0_p4_949279734", "generation": 18, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.8685234093637455, "fitness_mode": "correlation", "simplicity_score": 0.22113343699055302, "novelty_bonus": 0.17808295207380165, "total_score": 0.5475540705826901, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    base /= (1.0 + abs(assort) * 0.65)\n\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    base *= (1.0 + leaf_frac * 0.45)\n\n    base /= (1.0 + density ** 1.75)\n\n    return base", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    base /= (1.0 + abs(assort) * 0.65)\n\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    base *= (1.0 + leaf_frac * 0.45)\n\n    base /= (1.0 + density ** 1.75)\n\n    return base", "spearman": 0.8998049951248781, "pearson": 0.8255859120563532, "rmse": 0.5899685556943213, "mae": 0.3941972272155331}}
{"timestamp": "2026-02-16T19:36:42.913085+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i1_p0_209695505", "generation": 18, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.2217197160851846, "novelty_bonus": 0.25138613993252834, "total_score": 0.5272952235827552, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.296134\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.194430\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T19:37:14.975878+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i1_p1_872924970", "generation": 18, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22165548823651432, "novelty_bonus": 0.25138613993252834, "total_score": 0.527282378013021, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.296134\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.194430\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    # Basic graph features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    # Basic graph features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T19:37:43.406575+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:37:43.407311+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 18, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:39:16.648565+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 1, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.113535", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:39:16.649086+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 18, "island_id": 1, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:40:11.653662+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i1_p3_441780514", "generation": 18, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.2217197160851846, "novelty_bonus": 0.25138613993252834, "total_score": 0.5272952235827552, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.194430\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.113535\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T19:43:24.330848+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i1_p4_451859334", "generation": 18, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.2217197160851846, "novelty_bonus": 0.25138613993252834, "total_score": 0.5272952235827552, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.194430\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.113535\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    density    = s['density']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "extracted_code": "def new_invariant(s):\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    density    = s['density']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # Reduce for dense graphs and hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # Increase when degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # Minor additive contribution from triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # Fraction of leaf nodes tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T19:44:18.875931+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i2_p0_673866246", "generation": 18, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7669147659063624, "fitness_mode": "correlation", "simplicity_score": 0.12439507060720881, "novelty_bonus": 0.3499434179841313, "total_score": 0.49002704364178434, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture density, clustering, transitivity, degree heterogeneity,\n    assortativity, low‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys include:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    possible_tri = n * (n - 1) * (n - 2) // 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_density = 1.0 / (1.0 + density)\n    f_hetero = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return base * f_clust * f_trans * f_density * f_hetero * f_assort * f_min * f_tri\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.109158\nbelow_novelty_threshold: novelty_bonus=0.140599\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic uses a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the influence of density, clustering, transitivity,\n    degree heterogeneity, assortativity, extreme degree values and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys\n        include: 'n', 'avg_degree', 'density', 'avg_clustering',\n        'transitivity', 'std_degree', 'degree_assortativity',\n        'min_degree', 'max_degree', 'num_triangles'.\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values (with fall‑backs)\n    density      = s.get('density', 0.0)\n    clustering   = s.get('avg_clustering', 0.0)\n    trans        = s.get('transitivity', 0.0)\n    std_deg      = s.get('std_degree', 0.0)\n    assort       = s.get('degree_assortativity', 0.0)\n    min_deg      = s.get('min_degree', avg_deg)\n    max_deg      = s.get('max_degree', avg_deg)\n    num_tri      = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = float(n) * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density   = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans     = 1.0 + trans\n    f_assort    = 1.0 + 0.5 * abs(assort)\n    f_std       = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_min       = 1.0 + 1.0 / (min_deg + 1.0)\n    f_max       = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    f_tri       = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_assort *\n            f_std *\n            f_min *\n            f_max *\n            f_tri)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic uses a simple random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture the influence of density, clustering, transitivity,\n    degree heterogeneity, assortativity, extreme degree values and\n    triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys\n        include: 'n', 'avg_degree', 'density', 'avg_clustering',\n        'transitivity', 'std_degree', 'degree_assortativity',\n        'min_degree', 'max_degree', 'num_triangles'.\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values (with fall‑backs)\n    density      = s.get('density', 0.0)\n    clustering   = s.get('avg_clustering', 0.0)\n    trans        = s.get('transitivity', 0.0)\n    std_deg      = s.get('std_degree', 0.0)\n    assort       = s.get('degree_assortativity', 0.0)\n    min_deg      = s.get('min_degree', avg_deg)\n    max_deg      = s.get('max_degree', avg_deg)\n    num_tri      = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = float(n) * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density   = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans     = 1.0 + trans\n    f_assort    = 1.0 + 0.5 * abs(assort)\n    f_std       = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_min       = 1.0 + 1.0 / (min_deg + 1.0)\n    f_max       = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    f_tri       = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_assort *\n            f_std *\n            f_min *\n            f_max *\n            f_tri)", "spearman": 0.7203300082502063, "pearson": 0.674047798500587, "rmse": 2.4878172197661046, "mae": 1.7304965774658472}}
{"timestamp": "2026-02-16T19:45:13.226728+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i2_p1_181906164", "generation": 18, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8622809123649459, "fitness_mode": "correlation", "simplicity_score": 0.12679266757920307, "novelty_bonus": 0.2439650011795802, "total_score": 0.5384790321446716, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture density, clustering, transitivity, degree heterogeneity,\n    assortativity, low‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys include:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    possible_tri = n * (n - 1) * (n - 2) // 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_density = 1.0 / (1.0 + density)\n    f_hetero = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return base * f_clust * f_trans * f_density * f_hetero * f_assort * f_min * f_tri\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.109158\nbelow_novelty_threshold: novelty_bonus=0.140599\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using a multiplicative\n    correction of a random‑graph baseline.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics. Expected keys:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'density' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float)\n        - 'min_degree' (int or float)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Retrieve features with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density   = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans     = 1.0 + trans\n    f_std       = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort    = 1.0 + 0.5 * abs(assort)\n    f_min       = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri       = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using a multiplicative\n    correction of a random‑graph baseline.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics. Expected keys:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'density' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float)\n        - 'min_degree' (int or float)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Retrieve features with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density   = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans     = 1.0 + trans\n    f_std       = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort    = 1.0 + 0.5 * abs(assort)\n    f_min       = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri       = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)", "spearman": 0.8798619965499139, "pearson": 0.856530736217558, "rmse": 10.889728766202962, "mae": 9.3389863953469}}
{"timestamp": "2026-02-16T19:45:51.793686+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i2_p2_204693084", "generation": 18, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.9093397358943576, "fitness_mode": "correlation", "simplicity_score": 0.12701693935836939, "novelty_bonus": 0.1578909472736817, "total_score": 0.5340539541358306, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture density, clustering, transitivity, degree heterogeneity,\n    assortativity, low‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys include:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    possible_tri = n * (n - 1) * (n - 2) // 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_density = 1.0 / (1.0 + density)\n    f_hetero = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return base * f_clust * f_trans * f_density * f_hetero * f_assort * f_min * f_tri\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.109158\nbelow_novelty_threshold: novelty_bonus=0.140599\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using a random‑graph baseline\n    and multiplicative corrections that capture density, clustering,\n    transitivity, degree heterogeneity, assortativity, low‑degree vertices\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6\n    else:\n        possible_tri = 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density    = 1.0 / (1.0 + density)                     # denser graphs → shorter paths\n    f_clustering = 1.0 + clustering                           # higher clustering → longer paths\n    f_trans      = 1.0 + trans                                 # higher transitivity → longer paths\n    f_std        = 1.0 / (1.0 + std_deg)                       # more heterogeneous degrees → shorter paths\n    f_assort     = 1.0 + abs(assort)                           # more assortative → longer paths\n    f_min        = 1.0 + 1.0 / (min_deg + 1.0)                 # very low min degree can lengthen paths\n    f_tri        = 1.0 / (1.0 + tri_ratio)                    # many triangles → shorter paths\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using a random‑graph baseline\n    and multiplicative corrections that capture density, clustering,\n    transitivity, degree heterogeneity, assortativity, low‑degree vertices\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float, 0–1)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6\n    else:\n        possible_tri = 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density    = 1.0 / (1.0 + density)                     # denser graphs → shorter paths\n    f_clustering = 1.0 + clustering                           # higher clustering → longer paths\n    f_trans      = 1.0 + trans                                 # higher transitivity → longer paths\n    f_std        = 1.0 / (1.0 + std_deg)                       # more heterogeneous degrees → shorter paths\n    f_assort     = 1.0 + abs(assort)                           # more assortative → longer paths\n    f_min        = 1.0 + 1.0 / (min_deg + 1.0)                 # very low min degree can lengthen paths\n    f_tri        = 1.0 / (1.0 + tri_ratio)                    # many triangles → shorter paths\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)", "spearman": 0.9225665641641043, "pearson": 0.8785234077342516, "rmse": 4.343963836079072, "mae": 2.9492180995506176}}
{"timestamp": "2026-02-16T19:46:51.425449+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.134283", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:46:51.426133+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 18, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.134283", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:47:19.717429+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i2_p3_848434682", "generation": 18, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8622809123649459, "fitness_mode": "correlation", "simplicity_score": 0.12676124042081421, "novelty_bonus": 0.2439650011795802, "total_score": 0.5384727467129939, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture density, clustering, transitivity, degree heterogeneity,\n    assortativity, low‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys include:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    possible_tri = n * (n - 1) * (n - 2) // 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_density = 1.0 / (1.0 + density)\n    f_hetero = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return base * f_clust * f_trans * f_density * f_hetero * f_assort * f_min * f_tri\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.109158\nbelow_novelty_threshold: novelty_bonus=0.140599\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.134283\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of\n    density, clustering, transitivity, degree heterogeneity, assortativity,\n    low‑degree vertices, high‑degree outliers and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'density' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float, can be negative)\n        - 'min_degree' (int or float)\n        - 'max_degree' (int or float)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n\n    # Basic random‑graph estimate\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n    else:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density    = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans      = 1.0 + trans\n    f_std        = 1.0 / (1.0 + std_deg)\n    f_assort     = 1.0 + 0.5 * abs(assort)\n    f_min        = 1.0 + 1.0 / (min_deg + 1.0)\n    f_max_avg    = 1.0 + (max_deg - avg_deg) / (avg_deg + 1.0)\n    f_tri        = 1.0 / (1.0 + tri_ratio)\n\n    return (base * f_density * f_clustering * f_trans *\n            f_std * f_assort * f_min * f_max_avg * f_tri)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture density, clustering, transitivity, degree heterogeneity,\n    assortativity and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys include:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'density' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float, can be negative)\n        - 'min_degree' (int or float)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n\n    # Random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = max(s.get('min_degree', avg_deg), 1.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio (avoid division by zero)\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n    else:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density    = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans      = 1.0 + trans\n    f_std        = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort     = 1.0 + 0.5 * abs(assort)\n    f_min        = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri        = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture density, clustering, transitivity, degree heterogeneity,\n    assortativity and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys include:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'density' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float, can be negative)\n        - 'min_degree' (int or float)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n\n    # Random‑graph baseline: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = max(s.get('min_degree', avg_deg), 1.0)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio (avoid division by zero)\n    if n > 2:\n        possible_tri = n * (n - 1) * (n - 2) / 6.0\n    else:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density    = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans      = 1.0 + trans\n    f_std        = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort     = 1.0 + 0.5 * abs(assort)\n    f_min        = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri        = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)", "spearman": 0.8798619965499139, "pearson": 0.856530736217558, "rmse": 10.889728766202962, "mae": 9.3389863953469}}
{"timestamp": "2026-02-16T19:47:19.717984+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 18, "island_id": 2, "population_idx": 3, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:48:00.301488+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i2_p4_655210373", "generation": 18, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8622809123649459, "fitness_mode": "correlation", "simplicity_score": 0.12679266757920307, "novelty_bonus": 0.2439650011795802, "total_score": 0.5384790321446716, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture density, clustering, transitivity, degree heterogeneity,\n    assortativity, low‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys include:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    possible_tri = n * (n - 1) * (n - 2) // 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_density = 1.0 / (1.0 + density)\n    f_hetero = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return base * f_clust * f_trans * f_density * f_hetero * f_assort * f_min * f_tri\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.140599\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.134283\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture density, clustering,\n    transitivity, degree heterogeneity, assortativity, low‑degree vertices\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'density' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float)\n        - 'min_degree' (int or float)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n\n    # Basic random‑graph estimate\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture density, clustering,\n    transitivity, degree heterogeneity, assortativity, low‑degree vertices\n    and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'density' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float)\n        - 'min_degree' (int or float)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n\n    # Basic random‑graph estimate\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)", "spearman": 0.8798619965499139, "pearson": 0.856530736217558, "rmse": 10.889728766202962, "mae": 9.3389863953469}}
{"timestamp": "2026-02-16T19:48:31.712107+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.077528", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:48:31.713055+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 18, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.077528", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:49:18.328974+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 3, "population_idx": 0, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.114910", "model_name": "gpt-oss:20b", "train_signal": 0.11490996398559422}}
{"timestamp": "2026-02-16T19:49:18.329685+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 18, "island_id": 3, "population_idx": 0, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:49:59.741057+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:49:59.741886+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 18, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:50:34.958388+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 3, "population_idx": 1, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.108860", "model_name": "gpt-oss:20b", "train_signal": 0.10885954381752701}}
{"timestamp": "2026-02-16T19:50:34.959226+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 18, "island_id": 3, "population_idx": 1, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T19:51:10.455645+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i3_p2_559792616", "generation": 18, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5228811524609843, "fitness_mode": "correlation", "simplicity_score": 0.18035000408094498, "novelty_bonus": 0.5037869789136848, "total_score": 0.46350700201298256, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    The formula uses a baseline that grows with the square root of the number of nodes\n    and decreases with the average degree.  A set of multiplicative correction\n    factors captures the effects of clustering, density, degree heterogeneity,\n    assortativity, low‑degree bottlenecks, triangles, and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all values are numbers):\n        - n                 : number of nodes\n        - m                 : number of edges\n        - density           : graph density (0–1)\n        - avg_degree        : average degree\n        - max_degree        : maximum degree\n        - min_degree        : minimum degree\n        - std_degree        : standard deviation of degrees\n        - avg_clustering    : average clustering coefficient\n        - transitivity      : global transitivity (unused here)\n        - degree_assortativity : degree assortativity coefficient\n        - num_triangles     : total number of triangles\n        - degrees           : sorted list of degrees (unused here)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Basic numeric extraction – no imports needed\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    density    = float(s['density'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n\n    # Small epsilon to avoid division by zero\n    eps = 1e-12\n\n    # ---------- Baseline ----------\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    clust_factor     = 1.0 + clust                  # more clustering → longer paths\n    dens_factor      = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    assort_factor    = 1.0 + abs(assort)             # assortative mixing elongates paths\n    hetero_factor    = 1.0 / (1.0 + std_deg)         # heterogeneous degrees shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # low min degree can create bottlenecks\n    tri_factor       = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)  # triangles tend to shorten paths\n    hub_factor       = (max_deg / (avg_deg + 1.0)) ** 0.5  # presence of hubs reduces distances\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    The estimate uses a square‑root dependence on the number of nodes and an inverse\n    dependence on the average degree.  Several multiplicative correction factors\n    capture the effects of clustering, density, degree heterogeneity, assortativity,\n    bottlenecks (low minimum degree), hubs (high maximum degree) and triangles.\n    \"\"\"\n    # Feature extraction with sensible defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure numerical stability\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1 + clust                      # higher clustering → longer paths\n    dens_factor    = 1 / (1 + density)              # denser graphs → shorter paths\n    assort_factor  = 1 + abs(assort)                # assortative mixing elongates paths\n    hetero_factor  = 1 / (1 + std_deg)              # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n    tri_factor     = 1 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate\nRecent failures:\nbelow_train_threshold: train_signal=0.114910\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.108860\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    \n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following numeric keys (may be float or int):\n        - 'n'                  : number of nodes\n        - 'm'                  : number of edges\n        - 'density'            : graph density (0–1)\n        - 'avg_degree'         : average degree\n        - 'max_degree'         : maximum degree\n        - 'min_degree'         : minimum degree\n        - 'std_degree'         : standard deviation of degrees\n        - 'avg_clustering'     : average clustering coefficient\n        - 'transitivity'       : global transitivity\n        - 'degree_assortativity': degree assortativity coefficient\n        - 'num_triangles'      : total number of triangles\n        - 'degrees'            : sorted list of degrees (unused here)\n    \n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Extract features with fallback defaults\n    n             = s.get('n', 1)\n    avg_deg       = s.get('avg_degree', 1.0)\n    max_deg       = s.get('max_degree', avg_deg)\n    min_deg       = s.get('min_degree', 0.0)\n    std_deg       = s.get('std_degree', 0.0)\n    density       = s.get('density', 0.0)\n    avg_clust     = s.get('avg_clustering', 0.0)\n    trans         = s.get('transitivity', 0.0)\n    assort        = s.get('degree_assortativity', 0.0)\n    num_tri       = s.get('num_triangles', 0.0)\n\n    # Baseline that grows with size and shrinks with connectivity\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # Multiplicative correction factors capturing structural effects\n    clust_factor      = 1.0 + avg_clust\n    trans_factor      = 1.0 + trans\n    assort_factor     = 1.0 + abs(assort)\n    density_factor    = 1.0 / (1.0 + density)\n    hetero_factor     = 1.0 / (1.0 + std_deg)\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))\n    tri_factor        = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)\n    hub_factor        = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Combine all components into a single estimate\n    estimate = (base *\n                clust_factor *\n                trans_factor *\n                assort_factor *\n                density_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    \n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following numeric keys (may be float or int):\n        - 'n'                  : number of nodes\n        - 'm'                  : number of edges\n        - 'density'            : graph density (0–1)\n        - 'avg_degree'         : average degree\n        - 'max_degree'         : maximum degree\n        - 'min_degree'         : minimum degree\n        - 'std_degree'         : standard deviation of degrees\n        - 'avg_clustering'     : average clustering coefficient\n        - 'transitivity'       : global transitivity\n        - 'degree_assortativity': degree assortativity coefficient\n        - 'num_triangles'      : total number of triangles\n        - 'degrees'            : sorted list of degrees (unused here)\n    \n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Extract features with fallback defaults\n    n             = s.get('n', 1)\n    avg_deg       = s.get('avg_degree', 1.0)\n    max_deg       = s.get('max_degree', avg_deg)\n    min_deg       = s.get('min_degree', 0.0)\n    std_deg       = s.get('std_degree', 0.0)\n    density       = s.get('density', 0.0)\n    avg_clust     = s.get('avg_clustering', 0.0)\n    trans         = s.get('transitivity', 0.0)\n    assort        = s.get('degree_assortativity', 0.0)\n    num_tri       = s.get('num_triangles', 0.0)\n\n    # Baseline that grows with size and shrinks with connectivity\n    base = (n + 1.0) / (avg_deg + 1.0)\n\n    # Multiplicative correction factors capturing structural effects\n    clust_factor      = 1.0 + avg_clust\n    trans_factor      = 1.0 + trans\n    assort_factor     = 1.0 + abs(assort)\n    density_factor    = 1.0 / (1.0 + density)\n    hetero_factor     = 1.0 / (1.0 + std_deg)\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))\n    tri_factor        = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)\n    hub_factor        = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Combine all components into a single estimate\n    estimate = (base *\n                clust_factor *\n                trans_factor *\n                assort_factor *\n                density_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return estimate", "spearman": 0.5526018150453762, "pearson": 0.6242644597581454, "rmse": 18.22768238862145, "mae": 14.889029043937764}}
{"timestamp": "2026-02-16T19:52:02.389191+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i3_p3_783651382", "generation": 18, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6087394957983192, "fitness_mode": "correlation", "simplicity_score": 0.1782838615130926, "novelty_bonus": 0.39112961470448115, "total_score": 0.4790490580489963, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    The formula uses a baseline that grows with the square root of the number of nodes\n    and decreases with the average degree.  A set of multiplicative correction\n    factors captures the effects of clustering, density, degree heterogeneity,\n    assortativity, low‑degree bottlenecks, triangles, and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all values are numbers):\n        - n                 : number of nodes\n        - m                 : number of edges\n        - density           : graph density (0–1)\n        - avg_degree        : average degree\n        - max_degree        : maximum degree\n        - min_degree        : minimum degree\n        - std_degree        : standard deviation of degrees\n        - avg_clustering    : average clustering coefficient\n        - transitivity      : global transitivity (unused here)\n        - degree_assortativity : degree assortativity coefficient\n        - num_triangles     : total number of triangles\n        - degrees           : sorted list of degrees (unused here)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Basic numeric extraction – no imports needed\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    density    = float(s['density'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n\n    # Small epsilon to avoid division by zero\n    eps = 1e-12\n\n    # ---------- Baseline ----------\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    clust_factor     = 1.0 + clust                  # more clustering → longer paths\n    dens_factor      = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    assort_factor    = 1.0 + abs(assort)             # assortative mixing elongates paths\n    hetero_factor    = 1.0 / (1.0 + std_deg)         # heterogeneous degrees shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # low min degree can create bottlenecks\n    tri_factor       = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)  # triangles tend to shorten paths\n    hub_factor       = (max_deg / (avg_deg + 1.0)) ** 0.5  # presence of hubs reduces distances\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    The estimate uses a square‑root dependence on the number of nodes and an inverse\n    dependence on the average degree.  Several multiplicative correction factors\n    capture the effects of clustering, density, degree heterogeneity, assortativity,\n    bottlenecks (low minimum degree), hubs (high maximum degree) and triangles.\n    \"\"\"\n    # Feature extraction with sensible defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure numerical stability\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1 + clust                      # higher clustering → longer paths\n    dens_factor    = 1 / (1 + density)              # denser graphs → shorter paths\n    assort_factor  = 1 + abs(assort)                # assortative mixing elongates paths\n    hetero_factor  = 1 / (1 + std_deg)              # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n    tri_factor     = 1 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate\nRecent failures:\nbelow_train_threshold: train_signal=0.114910\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.108860\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from a set of global\n    statistics.  The estimate is a product of a baseline that grows with the\n    square root of the node count and diminishes with the average degree, and\n    a number of multiplicative correction factors that encode clustering,\n    density, degree heterogeneity, assortativity, bottleneck effects,\n    hub‑presence and the abundance of triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all values are numbers):\n        - n                  : number of nodes\n        - m                  : number of edges\n        - density            : graph density (0–1)\n        - avg_degree         : average degree\n        - max_degree         : maximum degree\n        - min_degree         : minimum degree\n        - std_degree         : standard deviation of degrees\n        - avg_clustering     : average clustering coefficient\n        - transitivity       : global transitivity\n        - degree_assortativity : degree assortativity coefficient\n        - num_triangles      : total number of triangles\n        - degrees            : sorted list of degrees (unused)\n\n    Returns\n    -------\n    float\n        A dimensionless number that correlates with the average shortest‑path\n        length of the graph.  Higher values generally indicate longer\n        characteristic distances.\n    \"\"\"\n    # Pull features with sensible defaults\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0))\n    std_deg    = float(s.get('std_degree', 0))\n    clust      = float(s.get('avg_clustering', 0))\n    trans      = float(s.get('transitivity', 0))\n    density    = float(s.get('density', 0))\n    assort     = float(s.get('degree_assortativity', 0))\n    num_tri    = float(s.get('num_triangles', 0))\n\n    # Numerical safety\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    # Roughly sqrt(n) divided by avg degree → grows with size, shrinks with connectivity\n    base = (n + 1)**0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor      = 1 + clust                    # more clustering → longer paths\n    trans_factor      = 1 + trans                    # higher transitivity → longer paths\n    dens_factor       = 1 / (1 + density)            # denser graphs → shorter paths\n    assort_factor     = 1 + abs(assort)              # assortative mixing tends to lengthen paths\n    hetero_factor     = 1 / (1 + std_deg)            # heterogeneous degrees tend to shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1)) # very low minimum degree can be a bottleneck\n    hub_factor        = (max_deg / (avg_deg + 1))**0.5   # hubs reduce distances\n    tri_factor        = 1 + (num_tri**0.5) / ((n + 1)**0.5 + 1e-12)  # triangles tend to shorten paths\n\n    # ---------- Combine ----------\n    estimate = (\n        base\n        * clust_factor\n        * trans_factor\n        * dens_factor\n        * assort_factor\n        * hetero_factor\n        * bottleneck_factor\n        * hub_factor\n        * tri_factor\n    )\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from a set of global\n    statistics.  The estimate is a product of a baseline that grows with the\n    square root of the node count and diminishes with the average degree, and\n    a number of multiplicative correction factors that encode clustering,\n    density, degree heterogeneity, assortativity, bottleneck effects,\n    hub‑presence and the abundance of triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all values are numbers):\n        - n                  : number of nodes\n        - m                  : number of edges\n        - density            : graph density (0–1)\n        - avg_degree         : average degree\n        - max_degree         : maximum degree\n        - min_degree         : minimum degree\n        - std_degree         : standard deviation of degrees\n        - avg_clustering     : average clustering coefficient\n        - transitivity       : global transitivity\n        - degree_assortativity : degree assortativity coefficient\n        - num_triangles      : total number of triangles\n        - degrees            : sorted list of degrees (unused)\n\n    Returns\n    -------\n    float\n        A dimensionless number that correlates with the average shortest‑path\n        length of the graph.  Higher values generally indicate longer\n        characteristic distances.\n    \"\"\"\n    # Pull features with sensible defaults\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0))\n    std_deg    = float(s.get('std_degree', 0))\n    clust      = float(s.get('avg_clustering', 0))\n    trans      = float(s.get('transitivity', 0))\n    density    = float(s.get('density', 0))\n    assort     = float(s.get('degree_assortativity', 0))\n    num_tri    = float(s.get('num_triangles', 0))\n\n    # Numerical safety\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    # Roughly sqrt(n) divided by avg degree → grows with size, shrinks with connectivity\n    base = (n + 1)**0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor      = 1 + clust                    # more clustering → longer paths\n    trans_factor      = 1 + trans                    # higher transitivity → longer paths\n    dens_factor       = 1 / (1 + density)            # denser graphs → shorter paths\n    assort_factor     = 1 + abs(assort)              # assortative mixing tends to lengthen paths\n    hetero_factor     = 1 / (1 + std_deg)            # heterogeneous degrees tend to shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1)) # very low minimum degree can be a bottleneck\n    hub_factor        = (max_deg / (avg_deg + 1))**0.5   # hubs reduce distances\n    tri_factor        = 1 + (num_tri**0.5) / ((n + 1)**0.5 + 1e-12)  # triangles tend to shorten paths\n\n    # ---------- Combine ----------\n    estimate = (\n        base\n        * clust_factor\n        * trans_factor\n        * dens_factor\n        * assort_factor\n        * hetero_factor\n        * bottleneck_factor\n        * hub_factor\n        * tri_factor\n    )\n\n    return estimate", "spearman": 0.6521068026700668, "pearson": 0.6839956923933622, "rmse": 1.0289115756037142, "mae": 0.8469654848572047}}
{"timestamp": "2026-02-16T19:52:34.903678+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i3_p4_229603965", "generation": 18, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6061464585834333, "fitness_mode": "correlation", "simplicity_score": 0.17813840219771296, "novelty_bonus": 0.39107848252390975, "total_score": 0.4785876161064884, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    The formula uses a baseline that grows with the square root of the number of nodes\n    and decreases with the average degree.  A set of multiplicative correction\n    factors captures the effects of clustering, density, degree heterogeneity,\n    assortativity, low‑degree bottlenecks, triangles, and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all values are numbers):\n        - n                 : number of nodes\n        - m                 : number of edges\n        - density           : graph density (0–1)\n        - avg_degree        : average degree\n        - max_degree        : maximum degree\n        - min_degree        : minimum degree\n        - std_degree        : standard deviation of degrees\n        - avg_clustering    : average clustering coefficient\n        - transitivity      : global transitivity (unused here)\n        - degree_assortativity : degree assortativity coefficient\n        - num_triangles     : total number of triangles\n        - degrees           : sorted list of degrees (unused here)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Basic numeric extraction – no imports needed\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    density    = float(s['density'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n\n    # Small epsilon to avoid division by zero\n    eps = 1e-12\n\n    # ---------- Baseline ----------\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    clust_factor     = 1.0 + clust                  # more clustering → longer paths\n    dens_factor      = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    assort_factor    = 1.0 + abs(assort)             # assortative mixing elongates paths\n    hetero_factor    = 1.0 / (1.0 + std_deg)         # heterogeneous degrees shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # low min degree can create bottlenecks\n    tri_factor       = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)  # triangles tend to shorten paths\n    hub_factor       = (max_deg / (avg_deg + 1.0)) ** 0.5  # presence of hubs reduces distances\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    The estimate uses a square‑root dependence on the number of nodes and an inverse\n    dependence on the average degree.  Several multiplicative correction factors\n    capture the effects of clustering, density, degree heterogeneity, assortativity,\n    bottlenecks (low minimum degree), hubs (high maximum degree) and triangles.\n    \"\"\"\n    # Feature extraction with sensible defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure numerical stability\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1 + clust                      # higher clustering → longer paths\n    dens_factor    = 1 / (1 + density)              # denser graphs → shorter paths\n    assort_factor  = 1 + abs(assort)                # assortative mixing elongates paths\n    hetero_factor  = 1 / (1 + std_deg)              # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n    tri_factor     = 1 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate\nRecent failures:\nbelow_train_threshold: train_signal=0.114910\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.108860\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula is a product of a base term and several multiplicative corrections\n    that capture the effect of clustering, density, degree heterogeneity,\n    assortativity, bottlenecks, triangles and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Graph statistics with keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float, can be negative)\n        - 'num_triangles' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Feature extraction with safety checks\n    n                = float(s.get('n', 1))\n    avg_deg          = float(s.get('avg_degree', 1.0))\n    max_deg          = float(s.get('max_degree', avg_deg))\n    min_deg          = float(s.get('min_degree', 0.0))\n    std_deg          = float(s.get('std_degree', 0.0))\n    clust            = float(s.get('avg_clustering', 0.0))\n    density          = float(s.get('density', 0.0))\n    assort           = float(s.get('degree_assortativity', 0.0))\n    transitivity     = float(s.get('transitivity', 0.0))\n    num_tri          = float(s.get('num_triangles', 0.0))\n\n    # Avoid division by zero\n    eps          = 1e-12\n    avg_deg     = max(avg_deg, eps)\n    max_deg     = max(max_deg, eps)\n    std_deg     = max(std_deg, eps)\n    min_deg     = max(min_deg, eps)\n\n    # ---------- Base term ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Multiplicative corrections ----------\n    clust_factor      = 1 + clust                      # more clustering → longer paths\n    trans_factor      = 1 + transitivity               # higher transitivity → longer paths\n    dens_factor       = 1 / (1 + density)              # denser graphs → shorter paths\n    hetero_factor     = 1 / (1 + std_deg)              # heterogeneous degrees → shorter paths\n    assort_factor     = 1 + abs(assort)                # assortative mixing elongates paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    tri_factor        = 1 + (num_tri ** 0.5) / (n ** 0.5 + eps)  # triangles tend to shorten paths\n    hub_factor        = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                trans_factor *\n                dens_factor *\n                hetero_factor *\n                assort_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula is a product of a base term and several multiplicative corrections\n    that capture the effect of clustering, density, degree heterogeneity,\n    assortativity, bottlenecks, triangles and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Graph statistics with keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (int or float)\n        - 'min_degree' (int or float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float, can be negative)\n        - 'num_triangles' (int or float)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Feature extraction with safety checks\n    n                = float(s.get('n', 1))\n    avg_deg          = float(s.get('avg_degree', 1.0))\n    max_deg          = float(s.get('max_degree', avg_deg))\n    min_deg          = float(s.get('min_degree', 0.0))\n    std_deg          = float(s.get('std_degree', 0.0))\n    clust            = float(s.get('avg_clustering', 0.0))\n    density          = float(s.get('density', 0.0))\n    assort           = float(s.get('degree_assortativity', 0.0))\n    transitivity     = float(s.get('transitivity', 0.0))\n    num_tri          = float(s.get('num_triangles', 0.0))\n\n    # Avoid division by zero\n    eps          = 1e-12\n    avg_deg     = max(avg_deg, eps)\n    max_deg     = max(max_deg, eps)\n    std_deg     = max(std_deg, eps)\n    min_deg     = max(min_deg, eps)\n\n    # ---------- Base term ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Multiplicative corrections ----------\n    clust_factor      = 1 + clust                      # more clustering → longer paths\n    trans_factor      = 1 + transitivity               # higher transitivity → longer paths\n    dens_factor       = 1 / (1 + density)              # denser graphs → shorter paths\n    hetero_factor     = 1 / (1 + std_deg)              # heterogeneous degrees → shorter paths\n    assort_factor     = 1 + abs(assort)                # assortative mixing elongates paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    tri_factor        = 1 + (num_tri ** 0.5) / (n ** 0.5 + eps)  # triangles tend to shorten paths\n    hub_factor        = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                trans_factor *\n                dens_factor *\n                hetero_factor *\n                assort_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return estimate", "spearman": 0.6512727818195457, "pearson": 0.6825722665444123, "rmse": 1.029005072133764, "mae": 0.8463612187746243}}
{"timestamp": "2026-02-16T19:52:34.906505+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 19, "model_name": "gpt-oss:20b", "best_val_score": 0.5492830341781751, "no_improve_count": 2}}
{"timestamp": "2026-02-16T19:53:05.669039+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i0_p0_525793433", "generation": 19, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.8856182472989195, "fitness_mode": "correlation", "simplicity_score": 0.22107466943064283, "novelty_bonus": 0.1517827945698641, "total_score": 0.5472259591617605, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    base /= (1.0 + abs(assort) * 0.65)\n\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    base *= (1.0 + leaf_frac * 0.45)\n\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact, interpretable, and uses only arithmetic on the\n    supplied features.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.40) / (avg_deg ** 0.60)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.70 + (max_deg / (n + 1.0)) ** 0.50)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.80)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.50)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.80)\n    base *= (1.0 + trans * 0.80)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.60)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.40\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.50)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.80)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact, interpretable, and uses only arithmetic on the\n    supplied features.  No graph traversal is performed.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.40) / (avg_deg ** 0.60)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.70 + (max_deg / (n + 1.0)) ** 0.50)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.80)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.50)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.80)\n    base *= (1.0 + trans * 0.80)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.60)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.40\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.50)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.80)\n\n    return base", "spearman": 0.9149523738093454, "pearson": 0.8278701596143783, "rmse": 0.6963796629569402, "mae": 0.5430368942148569}}
{"timestamp": "2026-02-16T19:53:54.932230+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i0_p1_819948176", "generation": 19, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.8894597839135654, "fitness_mode": "correlation", "simplicity_score": 0.22107466943064283, "novelty_bonus": 0.15598889972249286, "total_score": 0.5497110712895636, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    base /= (1.0 + abs(assort) * 0.65)\n\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    base *= (1.0 + leaf_frac * 0.45)\n\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.40) / (avg_deg ** 0.60)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.70 + (max_deg / (n + 1.0)) ** 0.50)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.70)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.50)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.80)\n    base *= (1.0 + trans * 0.80)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.60)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.40\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.40)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.70)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.40) / (avg_deg ** 0.60)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.70 + (max_deg / (n + 1.0)) ** 0.50)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.70)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.50)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.80)\n    base *= (1.0 + trans * 0.80)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.60)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.40\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.40)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.70)\n\n    return base", "spearman": 0.9173989349733744, "pearson": 0.8318416404171645, "rmse": 0.7569872882963774, "mae": 0.6110423973767642}}
{"timestamp": "2026-02-16T19:55:06.571748+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i0_p2_338509905", "generation": 19, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.8696758703481393, "fitness_mode": "correlation", "simplicity_score": 0.22107466943064283, "novelty_bonus": 0.16068551713792834, "total_score": 0.5447201465164444, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    base /= (1.0 + abs(assort) * 0.65)\n\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    base *= (1.0 + leaf_frac * 0.45)\n\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.7)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.5\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.8)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.8)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.6)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.7)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.5\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.8)\n\n    return base", "spearman": 0.9045991149778746, "pearson": 0.8129814009668146, "rmse": 0.7314491676668491, "mae": 0.5744652074085532}}
{"timestamp": "2026-02-16T19:55:59.814782+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i0_p3_256682098", "generation": 19, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.8975270108043216, "fitness_mode": "correlation", "simplicity_score": 0.22107466943064283, "novelty_bonus": 0.1517227930698266, "total_score": 0.5539423770722082, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    base /= (1.0 + abs(assort) * 0.65)\n\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    base *= (1.0 + leaf_frac * 0.45)\n\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula uses only basic arithmetic on the supplied features, avoiding any\n    graph traversal or external libraries.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)) ** 0.3)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.4)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.6)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.4\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula uses only basic arithmetic on the supplied features, avoiding any\n    graph traversal or external libraries.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.5 + (max_deg / (n + 1.0)) ** 0.3)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.4)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.6)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.4\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.5)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.5)\n\n    return base", "spearman": 0.9284212105302634, "pearson": 0.8227157438949192, "rmse": 1.1711054627410382, "mae": 1.0610832993120736}}
{"timestamp": "2026-02-16T19:56:45.085442+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i0_p4_37618917", "generation": 19, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.8894597839135654, "fitness_mode": "correlation", "simplicity_score": 0.2209014926046282, "novelty_bonus": 0.15689342233555825, "total_score": 0.5496417850580891, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    base /= (1.0 + abs(assort) * 0.65)\n\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    base *= (1.0 + leaf_frac * 0.45)\n\n    base /= (1.0 + density ** 1.75)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.018776\nno_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    base /= (1.0 + density ** 0.7 + (max_deg / (n + 1.0)) ** 0.5)\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n\n    base /= (1.0 + abs(assort) * 0.6)\n\n    base += triangles / (n ** 2 + 1.0) * 0.4\n\n    base *= (1.0 + leaf_frac * 0.4)\n\n    base /= (1.0 + density ** 1.6)\n\n    return base", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = max(s['avg_degree'], 1.0)\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.4) / (avg_deg ** 0.6)\n\n    base /= (1.0 + density ** 0.7 + (max_deg / (n + 1.0)) ** 0.5)\n\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n\n    base /= (1.0 + abs(assort) * 0.6)\n\n    base += triangles / (n ** 2 + 1.0) * 0.4\n\n    base *= (1.0 + leaf_frac * 0.4)\n\n    base /= (1.0 + density ** 1.6)\n\n    return base", "spearman": 0.916786919672992, "pearson": 0.831289847671994, "rmse": 0.7669425524072214, "mae": 0.6225789071806829}}
{"timestamp": "2026-02-16T19:58:50.625076+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i1_p0_868564990", "generation": 19, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.2217197160851846, "novelty_bonus": 0.25138613993252834, "total_score": 0.5272952235827552, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.194430\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.113535\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    base = (n**0.5) / (avg_deg**0.5)\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n    base /= (1.0 + abs(assort))\n    base += triangles / (n**2 + 1.0)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n    base /= (1.0 + density**2)\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree'] if s['avg_degree'] > 0 else 1.0\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    base = (n**0.5) / (avg_deg**0.5)\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n    base /= (1.0 + abs(assort))\n    base += triangles / (n**2 + 1.0)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n    base /= (1.0 + density**2)\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T19:59:53.251370+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.190108", "model_name": "gpt-oss:20b", "train_signal": 0.1901080432172869}}
{"timestamp": "2026-02-16T20:00:55.891783+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i1_p2_442385102", "generation": 19, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.22165548823651432, "novelty_bonus": 0.25138613993252834, "total_score": 0.527282378013021, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.113535\nbelow_train_threshold: train_signal=0.190108\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T20:01:46.785570+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i1_p3_138361665", "generation": 19, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.7186074429771908, "fitness_mode": "correlation", "simplicity_score": 0.2217197160851846, "novelty_bonus": 0.25138613993252834, "total_score": 0.5272952235827552, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base\n\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.113535\nbelow_train_threshold: train_signal=0.190108\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base", "spearman": 0.8150708767719194, "pearson": 0.7682438008276297, "rmse": 4.314226370413069, "mae": 3.80238874290439}}
{"timestamp": "2026-02-16T20:03:05.864420+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.179256", "model_name": "gpt-oss:20b", "train_signal": 0.17925570228091237}}
{"timestamp": "2026-02-16T20:04:18.034957+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i2_p0_323800534", "generation": 19, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.3900600240096038, "fitness_mode": "correlation", "simplicity_score": 0.1242361744093704, "novelty_bonus": 0.2477127043116999, "total_score": 0.30732050016173373, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture density, clustering, transitivity, degree heterogeneity,\n    assortativity, low‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys include:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    possible_tri = n * (n - 1) * (n - 2) // 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_density = 1.0 / (1.0 + density)\n    f_hetero = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return base * f_clust * f_trans * f_density * f_hetero * f_assort * f_min * f_tri\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using a multiplicative\n    correction of a random‑graph baseline.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics. Expected keys:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'density' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float)\n        - 'min_degree' (int or float)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Retrieve features with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density   = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans     = 1.0 + trans\n    f_std       = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort    = 1.0 + 0.5 * abs(assort)\n    f_min       = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri       = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.140599\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.134283\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture density, clustering, transitivity, degree heterogeneity,\n    assortativity, low‑degree vertices, high‑degree vertices and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys include:\n            - 'n' (int)\n            - 'avg_degree' (float)\n            - 'density' (float)\n            - 'avg_clustering' (float)\n            - 'transitivity' (float)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n            - 'max_degree' (int or float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density   = 1.0 / (1.0 + density)\n    f_clustering = 1.0 / (1.0 + clustering)\n    f_trans     = 1.0 / (1.0 + trans)\n    f_std       = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort    = 1.0 + 0.5 * abs(assort)\n    f_min       = 1.0 / (1.0 + 1.0 / (min_deg + 1.0))\n    f_max       = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    f_tri       = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_max *\n            f_tri)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a random‑graph baseline\n    (n / (avg_degree + 1)) and applies multiplicative corrections that\n    capture density, clustering, transitivity, degree heterogeneity,\n    assortativity, low‑degree vertices, high‑degree vertices and triangle\n    density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys include:\n            - 'n' (int)\n            - 'avg_degree' (float)\n            - 'density' (float)\n            - 'avg_clustering' (float)\n            - 'transitivity' (float)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n            - 'max_degree' (int or float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density   = 1.0 / (1.0 + density)\n    f_clustering = 1.0 / (1.0 + clustering)\n    f_trans     = 1.0 / (1.0 + trans)\n    f_std       = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort    = 1.0 + 0.5 * abs(assort)\n    f_min       = 1.0 / (1.0 + 1.0 / (min_deg + 1.0))\n    f_max       = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n    f_tri       = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_max *\n            f_tri)", "spearman": 0.4163189079726994, "pearson": 0.35977477014139175, "rmse": 1.7949343853602355, "mae": 1.5855936775237687}}
{"timestamp": "2026-02-16T20:04:56.971776+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.085584", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:04:56.972324+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 19, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.085584", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:06:08.907156+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.108507", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:06:08.907802+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 19, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:06:59.446767+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i2_p2_61219205", "generation": 19, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.4836974789915966, "fitness_mode": "correlation", "simplicity_score": 0.12466900519172977, "novelty_bonus": 0.4375399384984624, "total_score": 0.34366521932380306, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture density, clustering, transitivity, degree heterogeneity,\n    assortativity, low‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys include:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    possible_tri = n * (n - 1) * (n - 2) // 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_density = 1.0 / (1.0 + density)\n    f_hetero = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return base * f_clust * f_trans * f_density * f_hetero * f_assort * f_min * f_tri\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using a multiplicative\n    correction of a random‑graph baseline.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics. Expected keys:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'density' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float)\n        - 'min_degree' (int or float)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Retrieve features with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density   = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans     = 1.0 + trans\n    f_std       = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort    = 1.0 + 0.5 * abs(assort)\n    f_min       = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri       = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.134283\nbelow_novelty_threshold: novelty_bonus=0.085584\nbelow_novelty_threshold: novelty_bonus=0.108507\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The estimator is a multiplicative correction of a\n    random‑graph baseline.  It uses density, clustering, transitivity,\n    degree heterogeneity, assortativity, the spread of low/high degrees\n    and triangle density to refine the estimate.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys\n        (with safe defaults if missing):\n\n        - 'n' (int)                     : number of nodes\n        - 'avg_degree' (float)          : average degree\n        - 'density' (float)             : edge density\n        - 'avg_clustering' (float)      : average clustering coefficient\n        - 'transitivity' (float)        : global transitivity\n        - 'std_degree' (float)          : standard deviation of degrees\n        - 'degree_assortativity' (float): assortativity coefficient\n        - 'min_degree' (int or float)   : minimum degree\n        - 'max_degree' (int or float)   : maximum degree\n        - 'num_triangles' (int)         : number of triangles\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density   = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans     = 1.0 + trans\n    f_std       = 1.0 / (1.0 + std_deg / avg_deg)\n    f_assort    = 1.0 + 0.5 * abs(assort)\n    # Low‑degree influence: the smaller min_deg relative to avg_deg, the larger the factor\n    f_min       = 1.0 + (avg_deg - min_deg) / (avg_deg + 1.0)\n    # High‑degree influence: the larger max_deg relative to avg_deg, the smaller the factor\n    f_max       = 1.0 / (1.0 + max_deg / avg_deg)\n    f_tri       = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_max *\n            f_tri)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The estimator is a multiplicative correction of a\n    random‑graph baseline.  It uses density, clustering, transitivity,\n    degree heterogeneity, assortativity, the spread of low/high degrees\n    and triangle density to refine the estimate.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys\n        (with safe defaults if missing):\n\n        - 'n' (int)                     : number of nodes\n        - 'avg_degree' (float)          : average degree\n        - 'density' (float)             : edge density\n        - 'avg_clustering' (float)      : average clustering coefficient\n        - 'transitivity' (float)        : global transitivity\n        - 'std_degree' (float)          : standard deviation of degrees\n        - 'degree_assortativity' (float): assortativity coefficient\n        - 'min_degree' (int or float)   : minimum degree\n        - 'max_degree' (int or float)   : maximum degree\n        - 'num_triangles' (int)         : number of triangles\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    max_deg = s.get('max_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density   = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans     = 1.0 + trans\n    f_std       = 1.0 / (1.0 + std_deg / avg_deg)\n    f_assort    = 1.0 + 0.5 * abs(assort)\n    # Low‑degree influence: the smaller min_deg relative to avg_deg, the larger the factor\n    f_min       = 1.0 + (avg_deg - min_deg) / (avg_deg + 1.0)\n    # High‑degree influence: the larger max_deg relative to avg_deg, the smaller the factor\n    f_max       = 1.0 / (1.0 + max_deg / avg_deg)\n    f_tri       = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_max *\n            f_tri)", "spearman": 0.3749388734718368, "pearson": 0.46744561959600495, "rmse": 2.67588751540799, "mae": 2.02348564087317}}
{"timestamp": "2026-02-16T20:07:40.953431+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.136257", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:07:40.953939+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 19, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.136257", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:08:15.552056+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 2, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:08:15.552715+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 19, "island_id": 2, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:08:46.115514+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.099367", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:08:46.115882+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 19, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.099367", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:09:37.378775+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i2_p4_904735627", "generation": 19, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.767875150060024, "fitness_mode": "correlation", "simplicity_score": 0.12008099630198497, "novelty_bonus": 0.16457315874138767, "total_score": 0.48526394377773574, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture density, clustering, transitivity, degree heterogeneity,\n    assortativity, low‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys include:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    possible_tri = n * (n - 1) * (n - 2) // 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_density = 1.0 / (1.0 + density)\n    f_hetero = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return base * f_clust * f_trans * f_density * f_hetero * f_assort * f_min * f_tri\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using a multiplicative\n    correction of a random‑graph baseline.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics. Expected keys:\n        - 'n' (int)\n        - 'avg_degree' (float)\n        - 'density' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'std_degree' (float)\n        - 'degree_assortativity' (float)\n        - 'min_degree' (int or float)\n        - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Retrieve features with safe defaults\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density   = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans     = 1.0 + trans\n    f_std       = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort    = 1.0 + 0.5 * abs(assort)\n    f_min       = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri       = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.108507\nbelow_novelty_threshold: novelty_bonus=0.136257\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.099367\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The heuristic starts from a random‑graph baseline (n / (avg_degree + 1))\n    and applies a set of multiplicative corrections that capture the effects\n    of density, clustering, transitivity, degree heterogeneity, assortativity,\n    low‑degree vertices, triangle density and degree range.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics. Expected keys include:\n            - 'n' (int)\n            - 'avg_degree' (float)\n            - 'density' (float)\n            - 'avg_clustering' (float)\n            - 'transitivity' (float)\n            - 'std_degree' (float)\n            - 'degree_assortativity' (float)\n            - 'min_degree' (int or float)\n            - 'max_degree' (int or float)\n            - 'num_triangles' (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Retrieve features with safe defaults\n    density      = s.get('density', 0.0)\n    clustering   = s.get('avg_clustering', 0.0)\n    trans        = s.get('transitivity', 0.0)\n    std_deg      = s.get('std_degree', 0.0)\n    assort       = s.get('degree_assortativity', 0.0)\n    min_deg      = s.get('min_degree', avg_deg)\n    max_deg      = s.get('max_degree', avg_deg)\n    num_tri      = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density      = 1.0 / (1.0 + density)\n    f_clustering   = 1.0 / (1.0 + clustering)\n    f_trans        = 1.0 / (1.0 + trans)\n    f_std          = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort       = 1.0 + 0.3 * abs(assort)\n    f_min          = 1.0 + 0.5 / (min_deg + 1.0)\n    f_max_range    = 1.0 + (max_deg - avg_deg) / (avg_deg + 1.0)\n    f_tri          = 1.0 / (1.0 + tri_ratio)\n\n    # Combine all factors\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_max_range *\n            f_tri)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a random‑graph baseline\n    (n / (avg_degree + 1)) and applies a number of multiplicative corrections\n    that capture the influence of density, clustering, transitivity,\n    degree heterogeneity, assortativity, low‑degree vertices, triangle\n    density, and the degree range.  The formula is deliberately kept\n    lightweight and free of external imports.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        and ``degrees`` (a sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Retrieve features with safe defaults\n    m           = s.get('m', 0)\n    density     = s.get('density', 0.0)\n    clustering  = s.get('avg_clustering', 0.0)\n    trans       = s.get('transitivity', 0.0)\n    std_deg     = s.get('std_degree', 0.0)\n    assort      = s.get('degree_assortativity', 0.0)\n    min_deg     = s.get('min_degree', avg_deg)\n    max_deg     = s.get('max_degree', avg_deg)\n    num_tri     = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density      = 1.0 / (1.0 + density)\n    f_clustering   = 1.0 + clustering\n    f_trans        = 1.0 + trans\n    f_std          = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort       = 1.0 + 0.2 * abs(assort)\n    f_min          = 1.0 + 1.0 / (min_deg + 1.0)\n    f_max_range    = 1.0 + ((max_deg - avg_deg) / (avg_deg + 1.0)) ** 0.5\n    f_tri          = 1.0 / (1.0 + tri_ratio)\n    f_edge_ratio   = 1.0 + (m / max(n, 1)) / (avg_deg + 1.0)\n\n    # Combine all factors\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_max_range *\n            f_tri *\n            f_edge_ratio)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a random‑graph baseline\n    (n / (avg_degree + 1)) and applies a number of multiplicative corrections\n    that capture the influence of density, clustering, transitivity,\n    degree heterogeneity, assortativity, low‑degree vertices, triangle\n    density, and the degree range.  The formula is deliberately kept\n    lightweight and free of external imports.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        and ``degrees`` (a sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph estimate\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    # Retrieve features with safe defaults\n    m           = s.get('m', 0)\n    density     = s.get('density', 0.0)\n    clustering  = s.get('avg_clustering', 0.0)\n    trans       = s.get('transitivity', 0.0)\n    std_deg     = s.get('std_degree', 0.0)\n    assort      = s.get('degree_assortativity', 0.0)\n    min_deg     = s.get('min_degree', avg_deg)\n    max_deg     = s.get('max_degree', avg_deg)\n    num_tri     = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0.0\n\n    # Multiplicative correction factors\n    f_density      = 1.0 / (1.0 + density)\n    f_clustering   = 1.0 + clustering\n    f_trans        = 1.0 + trans\n    f_std          = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort       = 1.0 + 0.2 * abs(assort)\n    f_min          = 1.0 + 1.0 / (min_deg + 1.0)\n    f_max_range    = 1.0 + ((max_deg - avg_deg) / (avg_deg + 1.0)) ** 0.5\n    f_tri          = 1.0 / (1.0 + tri_ratio)\n    f_edge_ratio   = 1.0 + (m / max(n, 1)) / (avg_deg + 1.0)\n\n    # Combine all factors\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_max_range *\n            f_tri *\n            f_edge_ratio)", "spearman": 0.8237515937898449, "pearson": 0.7997140944259997, "rmse": 35.541434584655704, "mae": 30.06462741820729}}
{"timestamp": "2026-02-16T20:09:37.379240+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 19, "island_id": 2, "population_idx": 4, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:10:30.400031+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i3_p0_746225448", "generation": 19, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6516686674669867, "fitness_mode": "correlation", "simplicity_score": 0.17613479811789534, "novelty_bonus": 0.39619590489762235, "total_score": 0.5143422375055262, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    The formula uses a baseline that grows with the square root of the number of nodes\n    and decreases with the average degree.  A set of multiplicative correction\n    factors captures the effects of clustering, density, degree heterogeneity,\n    assortativity, low‑degree bottlenecks, triangles, and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all values are numbers):\n        - n                 : number of nodes\n        - m                 : number of edges\n        - density           : graph density (0–1)\n        - avg_degree        : average degree\n        - max_degree        : maximum degree\n        - min_degree        : minimum degree\n        - std_degree        : standard deviation of degrees\n        - avg_clustering    : average clustering coefficient\n        - transitivity      : global transitivity (unused here)\n        - degree_assortativity : degree assortativity coefficient\n        - num_triangles     : total number of triangles\n        - degrees           : sorted list of degrees (unused here)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Basic numeric extraction – no imports needed\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    density    = float(s['density'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n\n    # Small epsilon to avoid division by zero\n    eps = 1e-12\n\n    # ---------- Baseline ----------\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    clust_factor     = 1.0 + clust                  # more clustering → longer paths\n    dens_factor      = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    assort_factor    = 1.0 + abs(assort)             # assortative mixing elongates paths\n    hetero_factor    = 1.0 / (1.0 + std_deg)         # heterogeneous degrees shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # low min degree can create bottlenecks\n    tri_factor       = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)  # triangles tend to shorten paths\n    hub_factor       = (max_deg / (avg_deg + 1.0)) ** 0.5  # presence of hubs reduces distances\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    The estimate uses a square‑root dependence on the number of nodes and an inverse\n    dependence on the average degree.  Several multiplicative correction factors\n    capture the effects of clustering, density, degree heterogeneity, assortativity,\n    bottlenecks (low minimum degree), hubs (high maximum degree) and triangles.\n    \"\"\"\n    # Feature extraction with sensible defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure numerical stability\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1 + clust                      # higher clustering → longer paths\n    dens_factor    = 1 / (1 + density)              # denser graphs → shorter paths\n    assort_factor  = 1 + abs(assort)                # assortative mixing elongates paths\n    hetero_factor  = 1 / (1 + std_deg)              # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n    tri_factor     = 1 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate\nRecent failures:\nbelow_train_threshold: train_signal=0.114910\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.108860\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics.\n    The estimate uses a baseline that grows with the square root of the\n    number of nodes and decreases with the average degree.  Several\n    multiplicative correction factors capture the influence of\n    clustering, density, assortativity, degree heterogeneity, bottlenecks,\n    hubs, triangles, and the spread of the degree distribution.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # Feature extraction with defaults and safety checks\n    # ------------------------------------------------------------------\n    n          = float(s.get('n', 1))\n    m          = float(s.get('m', 0))\n    density    = float(s.get('density', 0.0))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    avg_clust  = float(s.get('avg_clustering', 0.0))\n    trans      = float(s.get('transitivity', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n    degrees    = s.get('degrees', [])\n\n    # Prevent divisions by zero or very small numbers\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    min_deg = max(min_deg, eps)\n    std_deg = max(std_deg, eps)\n\n    # ------------------------------------------------------------------\n    # Baseline estimate: sqrt(n)/(avg_deg+1)\n    # ------------------------------------------------------------------\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ------------------------------------------------------------------\n    # Correction factors\n    # ------------------------------------------------------------------\n    # Higher clustering usually stretches paths\n    clust_factor = 1.0 + avg_clust\n\n    # Denser graphs have shorter paths\n    dens_factor  = 1.0 / (1.0 + density)\n\n    # Assortative mixing (positive or negative) tends to lengthen paths\n    assort_factor = 1.0 + abs(assort)\n\n    # Degree heterogeneity often shortens paths (hubs help connectivity)\n    hetero_factor = 1.0 / (1.0 + std_deg)\n\n    # Low minimum degree can act as a bottleneck\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Presence of hubs reduces distances\n    hub_factor = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangles create alternative short routes\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)\n\n    # Spread of degrees (median vs average) influences routing efficiency\n    if degrees:\n        # median degree\n        deg_len = len(degrees)\n        mid = deg_len // 2\n        if deg_len % 2 == 0:\n            median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n        else:\n            median_deg = degrees[mid]\n        # If median is significantly lower than average, add a bottleneck factor\n        spread_factor = 1.0 + ((avg_deg - median_deg) / (avg_deg + 1.0))\n    else:\n        spread_factor = 1.0\n\n    # Combine all factors multiplicatively\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor *\n                spread_factor)\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics.\n    The estimate uses a baseline that grows with the square root of the\n    number of nodes and decreases with the average degree.  Several\n    multiplicative correction factors capture the influence of\n    clustering, density, assortativity, degree heterogeneity, bottlenecks,\n    hubs, triangles, and the spread of the degree distribution.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # Feature extraction with defaults and safety checks\n    # ------------------------------------------------------------------\n    n          = float(s.get('n', 1))\n    m          = float(s.get('m', 0))\n    density    = float(s.get('density', 0.0))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    avg_clust  = float(s.get('avg_clustering', 0.0))\n    trans      = float(s.get('transitivity', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n    degrees    = s.get('degrees', [])\n\n    # Prevent divisions by zero or very small numbers\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    min_deg = max(min_deg, eps)\n    std_deg = max(std_deg, eps)\n\n    # ------------------------------------------------------------------\n    # Baseline estimate: sqrt(n)/(avg_deg+1)\n    # ------------------------------------------------------------------\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ------------------------------------------------------------------\n    # Correction factors\n    # ------------------------------------------------------------------\n    # Higher clustering usually stretches paths\n    clust_factor = 1.0 + avg_clust\n\n    # Denser graphs have shorter paths\n    dens_factor  = 1.0 / (1.0 + density)\n\n    # Assortative mixing (positive or negative) tends to lengthen paths\n    assort_factor = 1.0 + abs(assort)\n\n    # Degree heterogeneity often shortens paths (hubs help connectivity)\n    hetero_factor = 1.0 / (1.0 + std_deg)\n\n    # Low minimum degree can act as a bottleneck\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Presence of hubs reduces distances\n    hub_factor = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangles create alternative short routes\n    tri_factor = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)\n\n    # Spread of degrees (median vs average) influences routing efficiency\n    if degrees:\n        # median degree\n        deg_len = len(degrees)\n        mid = deg_len // 2\n        if deg_len % 2 == 0:\n            median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n        else:\n            median_deg = degrees[mid]\n        # If median is significantly lower than average, add a bottleneck factor\n        spread_factor = 1.0 + ((avg_deg - median_deg) / (avg_deg + 1.0))\n    else:\n        spread_factor = 1.0\n\n    # Combine all factors multiplicatively\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor *\n                spread_factor)\n\n    return estimate", "spearman": 0.7205130128253208, "pearson": 0.7325213423550255, "rmse": 1.0784182626637706, "mae": 0.9343908759233159}}
{"timestamp": "2026-02-16T20:11:14.418300+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i3_p1_197074103", "generation": 19, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6061464585834333, "fitness_mode": "correlation", "simplicity_score": 0.15466388761011965, "novelty_bonus": 0.39107848252390975, "total_score": 0.47389271318896975, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    The formula uses a baseline that grows with the square root of the number of nodes\n    and decreases with the average degree.  A set of multiplicative correction\n    factors captures the effects of clustering, density, degree heterogeneity,\n    assortativity, low‑degree bottlenecks, triangles, and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all values are numbers):\n        - n                 : number of nodes\n        - m                 : number of edges\n        - density           : graph density (0–1)\n        - avg_degree        : average degree\n        - max_degree        : maximum degree\n        - min_degree        : minimum degree\n        - std_degree        : standard deviation of degrees\n        - avg_clustering    : average clustering coefficient\n        - transitivity      : global transitivity (unused here)\n        - degree_assortativity : degree assortativity coefficient\n        - num_triangles     : total number of triangles\n        - degrees           : sorted list of degrees (unused here)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Basic numeric extraction – no imports needed\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    density    = float(s['density'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n\n    # Small epsilon to avoid division by zero\n    eps = 1e-12\n\n    # ---------- Baseline ----------\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    clust_factor     = 1.0 + clust                  # more clustering → longer paths\n    dens_factor      = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    assort_factor    = 1.0 + abs(assort)             # assortative mixing elongates paths\n    hetero_factor    = 1.0 / (1.0 + std_deg)         # heterogeneous degrees shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # low min degree can create bottlenecks\n    tri_factor       = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)  # triangles tend to shorten paths\n    hub_factor       = (max_deg / (avg_deg + 1.0)) ** 0.5  # presence of hubs reduces distances\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    The estimate uses a square‑root dependence on the number of nodes and an inverse\n    dependence on the average degree.  Several multiplicative correction factors\n    capture the effects of clustering, density, degree heterogeneity, assortativity,\n    bottlenecks (low minimum degree), hubs (high maximum degree) and triangles.\n    \"\"\"\n    # Feature extraction with sensible defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure numerical stability\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1 + clust                      # higher clustering → longer paths\n    dens_factor    = 1 / (1 + density)              # denser graphs → shorter paths\n    assort_factor  = 1 + abs(assort)                # assortative mixing elongates paths\n    hetero_factor  = 1 / (1 + std_deg)              # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n    tri_factor     = 1 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate\nRecent failures:\nbelow_train_threshold: train_signal=0.114910\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.108860\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed global graph statistics.\n\n    The estimate is built on a simple base that grows with the square root of the\n    number of vertices and decreases with the average degree.  Eight multiplicative\n    correction factors encode the effect of clustering, density, degree\n    heterogeneity, assortativity, bottlenecks, hubs, triangles and global\n    transitivity.  The formula never uses any graph traversal algorithm.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of global graph features.  Expected keys (with fall‑back\n        defaults) are:\n        - n                     (int)    – number of vertices\n        - avg_degree            (float)  – mean degree\n        - max_degree            (float)  – maximum degree\n        - min_degree            (float)  – minimum degree\n        - std_degree            (float)  – standard deviation of degrees\n        - avg_clustering        (float)  – average local clustering coefficient\n        - transitivity          (float)  – global transitivity (triangle fraction)\n        - density               (float)  – graph density (0–1)\n        - degree_assortativity  (float)  – degree assortativity coefficient\n        - num_triangles         (int)    – total number of triangles\n        - m                     (int)    – number of edges (unused in the formula)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest path length.\n    \"\"\"\n    # Feature extraction with sane defaults\n    n  = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    trans     = float(s.get('transitivity', 0.0))\n    dens      = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n\n    # Numerical stability\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    min_deg = max(min_deg, eps)\n    std_deg = max(std_deg, eps)\n    dens = min(max(dens, 0.0), 1.0)          # clamp to [0,1]\n\n    # ----- Base term -----\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ----- Multiplicative corrections -----\n    c_cluster   = 1.0 + clust                # more clustering -> longer paths\n    c_trans     = 1.0 + trans                # global transitivity effect\n    c_density   = 1.0 / (1.0 + dens)          # denser graphs -> shorter paths\n    c_assort    = 1.0 + abs(assort)           # assortative mixing elongates distances\n    c_hetero    = 1.0 / (1.0 + std_deg)       # heterogeneous degrees usually shorten distances\n    c_bottleneck= 1.0 + (min_deg / (avg_deg + 1.0))  # very low minimum degree can form bottlenecks\n    c_hub       = (max_deg / (avg_deg + 1.0)) ** 0.5  # presence of hubs reduces distances\n    c_tri       = 1.0 + (num_tri ** 0.5) / ((n + eps) ** 0.5)  # triangles tend to shorten paths\n\n    # ----- Combine all components -----\n    estimate = (base *\n                c_cluster *\n                c_trans *\n                c_density *\n                c_assort *\n                c_hetero *\n                c_bottleneck *\n                c_hub *\n                c_tri)\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed global graph statistics.\n\n    The estimate is built on a simple base that grows with the square root of the\n    number of vertices and decreases with the average degree.  Eight multiplicative\n    correction factors encode the effect of clustering, density, degree\n    heterogeneity, assortativity, bottlenecks, hubs, triangles and global\n    transitivity.  The formula never uses any graph traversal algorithm.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of global graph features.  Expected keys (with fall‑back\n        defaults) are:\n        - n                     (int)    – number of vertices\n        - avg_degree            (float)  – mean degree\n        - max_degree            (float)  – maximum degree\n        - min_degree            (float)  – minimum degree\n        - std_degree            (float)  – standard deviation of degrees\n        - avg_clustering        (float)  – average local clustering coefficient\n        - transitivity          (float)  – global transitivity (triangle fraction)\n        - density               (float)  – graph density (0–1)\n        - degree_assortativity  (float)  – degree assortativity coefficient\n        - num_triangles         (int)    – total number of triangles\n        - m                     (int)    – number of edges (unused in the formula)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest path length.\n    \"\"\"\n    # Feature extraction with sane defaults\n    n  = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    trans     = float(s.get('transitivity', 0.0))\n    dens      = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n\n    # Numerical stability\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    min_deg = max(min_deg, eps)\n    std_deg = max(std_deg, eps)\n    dens = min(max(dens, 0.0), 1.0)          # clamp to [0,1]\n\n    # ----- Base term -----\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ----- Multiplicative corrections -----\n    c_cluster   = 1.0 + clust                # more clustering -> longer paths\n    c_trans     = 1.0 + trans                # global transitivity effect\n    c_density   = 1.0 / (1.0 + dens)          # denser graphs -> shorter paths\n    c_assort    = 1.0 + abs(assort)           # assortative mixing elongates distances\n    c_hetero    = 1.0 / (1.0 + std_deg)       # heterogeneous degrees usually shorten distances\n    c_bottleneck= 1.0 + (min_deg / (avg_deg + 1.0))  # very low minimum degree can form bottlenecks\n    c_hub       = (max_deg / (avg_deg + 1.0)) ** 0.5  # presence of hubs reduces distances\n    c_tri       = 1.0 + (num_tri ** 0.5) / ((n + eps) ** 0.5)  # triangles tend to shorten paths\n\n    # ----- Combine all components -----\n    estimate = (base *\n                c_cluster *\n                c_trans *\n                c_density *\n                c_assort *\n                c_hetero *\n                c_bottleneck *\n                c_hub *\n                c_tri)\n\n    return float(estimate)", "spearman": 0.6512727818195457, "pearson": 0.6825722665443896, "rmse": 1.0290050721337718, "mae": 0.8463612187746201}}
{"timestamp": "2026-02-16T20:12:03.405770+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.079481", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:12:03.406241+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 19, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.079481", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:13:17.211632+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i3_p2_949243119", "generation": 19, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.3095798319327731, "fitness_mode": "correlation", "simplicity_score": 0.12042676042417899, "novelty_bonus": 0.16952523813095322, "total_score": 0.24101207525291501, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    The formula uses a baseline that grows with the square root of the number of nodes\n    and decreases with the average degree.  A set of multiplicative correction\n    factors captures the effects of clustering, density, degree heterogeneity,\n    assortativity, low‑degree bottlenecks, triangles, and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all values are numbers):\n        - n                 : number of nodes\n        - m                 : number of edges\n        - density           : graph density (0–1)\n        - avg_degree        : average degree\n        - max_degree        : maximum degree\n        - min_degree        : minimum degree\n        - std_degree        : standard deviation of degrees\n        - avg_clustering    : average clustering coefficient\n        - transitivity      : global transitivity (unused here)\n        - degree_assortativity : degree assortativity coefficient\n        - num_triangles     : total number of triangles\n        - degrees           : sorted list of degrees (unused here)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Basic numeric extraction – no imports needed\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    density    = float(s['density'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n\n    # Small epsilon to avoid division by zero\n    eps = 1e-12\n\n    # ---------- Baseline ----------\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    clust_factor     = 1.0 + clust                  # more clustering → longer paths\n    dens_factor      = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    assort_factor    = 1.0 + abs(assort)             # assortative mixing elongates paths\n    hetero_factor    = 1.0 / (1.0 + std_deg)         # heterogeneous degrees shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # low min degree can create bottlenecks\n    tri_factor       = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)  # triangles tend to shorten paths\n    hub_factor       = (max_deg / (avg_deg + 1.0)) ** 0.5  # presence of hubs reduces distances\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    The estimate uses a square‑root dependence on the number of nodes and an inverse\n    dependence on the average degree.  Several multiplicative correction factors\n    capture the effects of clustering, density, degree heterogeneity, assortativity,\n    bottlenecks (low minimum degree), hubs (high maximum degree) and triangles.\n    \"\"\"\n    # Feature extraction with sensible defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure numerical stability\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1 + clust                      # higher clustering → longer paths\n    dens_factor    = 1 / (1 + density)              # denser graphs → shorter paths\n    assort_factor  = 1 + abs(assort)                # assortative mixing elongates paths\n    hetero_factor  = 1 / (1 + std_deg)              # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n    tri_factor     = 1 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate\nRecent failures:\nbelow_train_threshold: train_signal=0.114910\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.108860\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.079481\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length of a graph from a set of\n    global statistics.  The expression is deliberately “novel” – it is\n    constructed from a baseline that grows with √n and falls with the average\n    degree, and is then multiplied by a number of corrective factors that\n    capture the influence of density, clustering, degree heterogeneity,\n    assortativity, bottlenecks, hubs and triangles.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed features that may contain (missing keys are treated as\n        neutral values):\n            n                (int)          – number of nodes\n            m                (int)          – number of edges\n            density          (float 0–1)    – graph density\n            avg_degree       (float)        – average degree\n            max_degree       (float)        – maximum degree\n            min_degree       (float)        – minimum degree\n            std_degree       (float)        – std dev of degrees\n            avg_clustering   (float 0–1)    – average clustering coefficient\n            transitivity     (float 0–1)    – global transitivity\n            degree_assortativity (float)   – degree assortativity\n            num_triangles    (float)        – total number of triangles\n    Returns\n    -------\n    float\n        A single scalar that is expected to correlate with the graph’s\n        average shortest‑path length.\n    \"\"\"\n    # Fetch with graceful fall‑backs\n    n            = float(s.get('n', 1))\n    avg_deg      = float(s.get('avg_degree', 1.0))\n    max_deg      = float(s.get('max_degree', avg_deg))\n    min_deg      = float(s.get('min_degree', avg_deg))\n    std_deg      = float(s.get('std_degree', 0.0))\n    clust        = float(s.get('avg_clustering', 0.0))\n    density      = float(s.get('density', 0.0))\n    assort       = float(s.get('degree_assortativity', 0.0))\n    num_tri      = float(s.get('num_triangles', 0.0))\n\n    # ---- 1. Baseline: size vs connectivity ----\n    #  √n grows with graph size; larger avg_deg shortens paths.\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---- 2. Density factor ----\n    #  Dense graphs should have shorter average paths.\n    dens_factor = 1.0 / (density + 0.1)\n\n    # ---- 3. Clustering factor ----\n    #  More triangles in a local neighbourhood often elongate global\n    #  paths by creating redundant short cycles that reduce long‑range\n    #  connectivity.  We make the effect additive on the multiplicative\n    #  baseline.\n    clust_factor = 1.0 + clust\n\n    # ---- 4. Assortativity factor ----\n    #  Assortative mixing tends to increase the average distance\n    #  (high‑degree nodes cluster together, leaving low‑degree nodes\n    #  peripheral).  The magnitude of assortativity is taken\n    #  in absolute value.\n    assort_factor = 1.0 + abs(assort)\n\n    # ---- 5. Degree heterogeneity factor ----\n    #  When degrees are very uneven, hubs can dramatically reduce\n    #  distances.  Higher standard deviation therefore shortens paths.\n    hetero_factor = 1.0 / (1.0 + std_deg)\n\n    # ---- 6. Bottleneck factor (minimum degree) ----\n    #  Very low min_deg can cause sparse “hanging” branches that\n    #  lengthen the average distance.\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # ---- 7. Triangle factor ----\n    #  Count of triangles, normalized by graph size, shortens distances.\n    tri_factor = 1.0 / (1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12))\n\n    # ---- 8. Hub factor ----\n    #  Presence of high‑degree nodes reduces distances.  The factor\n    #  penalises lack of hubs, so we use the reciprocal of the square‑root\n    #  of the ratio max_deg/avg_deg.\n    hub_factor = 1.0 / ((max_deg / (avg_deg + 1.0)) ** 0.5 + 1e-12)\n\n    # ---- Combine ----\n    estimate = (base *\n                dens_factor *\n                clust_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return estimate\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from global statistics.\n    The invariant is a product of a baseline term and several correction factors\n    that jointly capture size, connectivity, clustering, degree heterogeneity,\n    assortativity, bottlenecks, triangles and hub presence.  No graph traversal\n    is performed; all operations are simple arithmetic.\n\n    Parameters\n    ----------\n    s : dict\n        A dictionary that may contain any of the following keys; missing keys\n        are replaced by neutral default values:\n            n                 : number of nodes\n            m                 : number of edges\n            density           : graph density (unused)\n            avg_degree        : average degree\n            max_degree        : maximum degree\n            min_degree        : minimum degree\n            std_degree        : standard deviation of degrees\n            avg_clustering    : average clustering coefficient\n            transitivity      : global transitivity\n            degree_assortativity : degree assortativity coefficient\n            num_triangles     : total number of triangles\n\n    Returns\n    -------\n    float\n        A single scalar that is expected to correlate with the graph’s\n        average shortest‑path length.\n    \"\"\"\n    # Extract features with sensible defaults\n    n          = float(s.get('n', 1))\n    m          = float(s.get('m', 0))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', avg_deg))\n    std_deg    = float(s.get('std_degree', 0.0))\n    clust      = float(s.get('avg_clustering', 0.0))\n    trans      = float(s.get('transitivity', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Numerical safety constants\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    min_deg = max(min_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n\n    # ------------------------------------------------------------------\n    # 1. Baseline: sub‑linear growth with n, attenuated by edge density\n    # ------------------------------------------------------------------\n    edge_ratio = (m + 1.0) / (n + 1.0)\n    base = (n + 1.0)**0.30 * (edge_ratio + 0.10)**(-0.25)\n\n    # ------------------------------------------------------------------\n    # 2. Topology factor (clustering + transitivity)\n    # ------------------------------------------------------------------\n    topo_factor = 1.0 + 0.60*clust + 0.40*trans\n\n    # ------------------------------------------------------------------\n    # 3. Assortativity influence (absolute value, cubic root)\n    # ------------------------------------------------------------------\n    assort_factor = 1.0 + (abs(assort)**1.50)\n\n    # ------------------------------------------------------------------\n    # 4. Degree heterogeneity (high std ⇒ shorter paths)\n    # ------------------------------------------------------------------\n    hetero_factor = 1.0 / (1.0 + std_deg/(avg_deg + eps))\n\n    # ------------------------------------------------------------------\n    # 5. Bottleneck effect (very low minimum degree inflates distances)\n    # ------------------------------------------------------------------\n    bottleneck_factor = 1.0 + (avg_deg/(min_deg + eps))**0.50\n\n    # ------------------------------------------------------------------\n    # 6. Triangle density (more triangles → shorter paths)\n    # ------------------------------------------------------------------\n    tri_factor = 1.0 + (num_tri**0.40) / (n**0.20 + eps)\n\n    # ------------------------------------------------------------------\n    # 7. Hub presence (large max relative to average shortens distances)\n    # ------------------------------------------------------------------\n    hub_factor = (max_deg/(avg_deg + eps))**0.60\n\n    # ------------------------------------------------------------------\n    # 8. Combine all multiplicative contributions\n    # ------------------------------------------------------------------\n    return (\n        base\n        * topo_factor\n        * assort_factor\n        * hetero_factor\n        * bottleneck_factor\n        * tri_factor\n        * hub_factor\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from global statistics.\n    The invariant is a product of a baseline term and several correction factors\n    that jointly capture size, connectivity, clustering, degree heterogeneity,\n    assortativity, bottlenecks, triangles and hub presence.  No graph traversal\n    is performed; all operations are simple arithmetic.\n\n    Parameters\n    ----------\n    s : dict\n        A dictionary that may contain any of the following keys; missing keys\n        are replaced by neutral default values:\n            n                 : number of nodes\n            m                 : number of edges\n            density           : graph density (unused)\n            avg_degree        : average degree\n            max_degree        : maximum degree\n            min_degree        : minimum degree\n            std_degree        : standard deviation of degrees\n            avg_clustering    : average clustering coefficient\n            transitivity      : global transitivity\n            degree_assortativity : degree assortativity coefficient\n            num_triangles     : total number of triangles\n\n    Returns\n    -------\n    float\n        A single scalar that is expected to correlate with the graph’s\n        average shortest‑path length.\n    \"\"\"\n    # Extract features with sensible defaults\n    n          = float(s.get('n', 1))\n    m          = float(s.get('m', 0))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', avg_deg))\n    std_deg    = float(s.get('std_degree', 0.0))\n    clust      = float(s.get('avg_clustering', 0.0))\n    trans      = float(s.get('transitivity', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Numerical safety constants\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    min_deg = max(min_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n\n    # ------------------------------------------------------------------\n    # 1. Baseline: sub‑linear growth with n, attenuated by edge density\n    # ------------------------------------------------------------------\n    edge_ratio = (m + 1.0) / (n + 1.0)\n    base = (n + 1.0)**0.30 * (edge_ratio + 0.10)**(-0.25)\n\n    # ------------------------------------------------------------------\n    # 2. Topology factor (clustering + transitivity)\n    # ------------------------------------------------------------------\n    topo_factor = 1.0 + 0.60*clust + 0.40*trans\n\n    # ------------------------------------------------------------------\n    # 3. Assortativity influence (absolute value, cubic root)\n    # ------------------------------------------------------------------\n    assort_factor = 1.0 + (abs(assort)**1.50)\n\n    # ------------------------------------------------------------------\n    # 4. Degree heterogeneity (high std ⇒ shorter paths)\n    # ------------------------------------------------------------------\n    hetero_factor = 1.0 / (1.0 + std_deg/(avg_deg + eps))\n\n    # ------------------------------------------------------------------\n    # 5. Bottleneck effect (very low minimum degree inflates distances)\n    # ------------------------------------------------------------------\n    bottleneck_factor = 1.0 + (avg_deg/(min_deg + eps))**0.50\n\n    # ------------------------------------------------------------------\n    # 6. Triangle density (more triangles → shorter paths)\n    # ------------------------------------------------------------------\n    tri_factor = 1.0 + (num_tri**0.40) / (n**0.20 + eps)\n\n    # ------------------------------------------------------------------\n    # 7. Hub presence (large max relative to average shortens distances)\n    # ------------------------------------------------------------------\n    hub_factor = (max_deg/(avg_deg + eps))**0.60\n\n    # ------------------------------------------------------------------\n    # 8. Combine all multiplicative contributions\n    # ------------------------------------------------------------------\n    return (\n        base\n        * topo_factor\n        * assort_factor\n        * hetero_factor\n        * bottleneck_factor\n        * tri_factor\n        * hub_factor\n    )", "spearman": -0.3321383034575865, "pearson": -0.045412403482046934, "rmse": 55.54763514669303, "mae": 43.78885006303017}}
{"timestamp": "2026-02-16T20:13:17.212700+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 19, "island_id": 3, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:14:09.505198+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i3_p3_19810245", "generation": 19, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6901800720288115, "fitness_mode": "correlation", "simplicity_score": 0.17976881361569624, "novelty_bonus": 0.371845035328932, "total_score": 0.5181770400659875, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    The formula uses a baseline that grows with the square root of the number of nodes\n    and decreases with the average degree.  A set of multiplicative correction\n    factors captures the effects of clustering, density, degree heterogeneity,\n    assortativity, low‑degree bottlenecks, triangles, and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all values are numbers):\n        - n                 : number of nodes\n        - m                 : number of edges\n        - density           : graph density (0–1)\n        - avg_degree        : average degree\n        - max_degree        : maximum degree\n        - min_degree        : minimum degree\n        - std_degree        : standard deviation of degrees\n        - avg_clustering    : average clustering coefficient\n        - transitivity      : global transitivity (unused here)\n        - degree_assortativity : degree assortativity coefficient\n        - num_triangles     : total number of triangles\n        - degrees           : sorted list of degrees (unused here)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Basic numeric extraction – no imports needed\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    density    = float(s['density'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n\n    # Small epsilon to avoid division by zero\n    eps = 1e-12\n\n    # ---------- Baseline ----------\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    clust_factor     = 1.0 + clust                  # more clustering → longer paths\n    dens_factor      = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    assort_factor    = 1.0 + abs(assort)             # assortative mixing elongates paths\n    hetero_factor    = 1.0 / (1.0 + std_deg)         # heterogeneous degrees shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # low min degree can create bottlenecks\n    tri_factor       = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)  # triangles tend to shorten paths\n    hub_factor       = (max_deg / (avg_deg + 1.0)) ** 0.5  # presence of hubs reduces distances\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return estimate\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    The estimate uses a square‑root dependence on the number of nodes and an inverse\n    dependence on the average degree.  Several multiplicative correction factors\n    capture the effects of clustering, density, degree heterogeneity, assortativity,\n    bottlenecks (low minimum degree), hubs (high maximum degree) and triangles.\n    \"\"\"\n    # Feature extraction with sensible defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure numerical stability\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1 + clust                      # higher clustering → longer paths\n    dens_factor    = 1 / (1 + density)              # denser graphs → shorter paths\n    assort_factor  = 1 + abs(assort)                # assortative mixing elongates paths\n    hetero_factor  = 1 / (1 + std_deg)              # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n    tri_factor     = 1 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.108860\nbelow_novelty_threshold: novelty_bonus=0.079481\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines a square‑root baseline with multiplicative corrections\n    that reflect clustering, density, assortativity, degree heterogeneity,\n    bottlenecks (low minimum degree), hubs (high maximum degree), and\n    triangle abundance.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following numeric keys:\n            - 'n'                   (int)      : number of nodes\n            - 'avg_degree'          (float)    : average degree\n            - 'avg_clustering'      (float)    : average clustering coefficient\n            - 'density'             (float)    : graph density\n            - 'degree_assortativity'(float)    : degree assortativity coefficient\n            - 'std_degree'          (float)    : standard deviation of degrees\n            - 'min_degree'          (int/float): minimum degree\n            - 'max_degree'          (int/float): maximum degree\n            - 'num_triangles'       (int/float): total number of triangles\n        Missing keys are silently defaulted to reasonable values.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # --- Basic feature extraction with defaults ---\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    if avg_deg <= 0:\n        avg_deg = 1e-12  # avoid division by zero\n\n    # --- Optional features, with graceful fallbacks ---\n    clust      = float(s.get('avg_clustering', 0.0))\n    density    = float(s.get('density', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    min_deg    = float(s.get('min_degree', 0.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # --- Baseline estimate (scales with sqrt(n) and inversely with avg_degree) ---\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # --- Multiplicative correction factors ---\n    clust_factor      = 1.0 + clust                # higher clustering → longer paths\n    density_factor    = 1.0 / (1.0 + density)      # denser graphs → shorter paths\n    assort_factor     = 1.0 + abs(assort)          # assortativity elongates paths\n    hetero_factor     = 1.0 / (1.0 + std_deg)      # heterogeneous degrees shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # low minimum degree → bottleneck\n    hub_factor        = (max_deg / (avg_deg + 1.0)) ** 0.5   # hubs reduce distances\n    tri_factor        = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # --- Combine all components ---\n    estimate = (base *\n                clust_factor *\n                density_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines a square‑root baseline with multiplicative corrections\n    that reflect clustering, density, assortativity, degree heterogeneity,\n    bottlenecks (low minimum degree), hubs (high maximum degree), and\n    triangle abundance.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following numeric keys:\n            - 'n'                   (int)      : number of nodes\n            - 'avg_degree'          (float)    : average degree\n            - 'avg_clustering'      (float)    : average clustering coefficient\n            - 'density'             (float)    : graph density\n            - 'degree_assortativity'(float)    : degree assortativity coefficient\n            - 'std_degree'          (float)    : standard deviation of degrees\n            - 'min_degree'          (int/float): minimum degree\n            - 'max_degree'          (int/float): maximum degree\n            - 'num_triangles'       (int/float): total number of triangles\n        Missing keys are silently defaulted to reasonable values.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # --- Basic feature extraction with defaults ---\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    if avg_deg <= 0:\n        avg_deg = 1e-12  # avoid division by zero\n\n    # --- Optional features, with graceful fallbacks ---\n    clust      = float(s.get('avg_clustering', 0.0))\n    density    = float(s.get('density', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    min_deg    = float(s.get('min_degree', 0.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # --- Baseline estimate (scales with sqrt(n) and inversely with avg_degree) ---\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # --- Multiplicative correction factors ---\n    clust_factor      = 1.0 + clust                # higher clustering → longer paths\n    density_factor    = 1.0 / (1.0 + density)      # denser graphs → shorter paths\n    assort_factor     = 1.0 + abs(assort)          # assortativity elongates paths\n    hetero_factor     = 1.0 / (1.0 + std_deg)      # heterogeneous degrees shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # low minimum degree → bottleneck\n    hub_factor        = (max_deg / (avg_deg + 1.0)) ** 0.5   # hubs reduce distances\n    tri_factor        = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # --- Combine all components ---\n    estimate = (base *\n                clust_factor *\n                density_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate", "spearman": 0.7413395334883374, "pearson": 0.740784516881863, "rmse": 1.1368805512560611, "mae": 1.0163434818161656}}
{"timestamp": "2026-02-16T20:14:40.111623+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.118471", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:14:40.112073+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 19, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.118471", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:15:29.989641+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 3, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:15:29.990379+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 19, "island_id": 3, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:15:29.991710+00:00", "event_type": "generation_migration", "payload": {"generation": 19, "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T20:15:29.995513+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_33", "generation": 20, "model_name": "gpt-oss:20b", "best_val_score": 0.5539423770722082, "no_improve_count": 0}}
