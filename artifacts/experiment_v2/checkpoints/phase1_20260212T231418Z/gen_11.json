{
  "experiment_id": "phase1_20260212T231418Z",
  "generation": 11,
  "rng_seed": 42,
  "rng_state": {
    "bit_generator": "PCG64",
    "state": {
      "state": 157929203213340526819000811745501049102,
      "inc": 332724090758049132448979897138935081983
    },
    "has_uint32": 1,
    "uinteger": 2842909783
  },
  "best_val_score": 0.5491013268732999,
  "no_improve_count": 9,
  "island_stagnation": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_prompt_mode": {
    "0": "free",
    "1": "free",
    "2": "free",
    "3": "free"
  },
  "island_constrained_generations": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_recent_failures": {
    "0": [
      "below_novelty_threshold: novelty_bonus=0.056040",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_novelty_threshold: novelty_bonus=0.043167"
    ],
    "1": [
      "below_train_threshold: train_signal=0.041056",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_train_threshold: train_signal=0.090900"
    ],
    "2": [
      "below_novelty_threshold: novelty_bonus=0.135127",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_novelty_threshold: novelty_bonus=0.133768"
    ],
    "3": [
      "below_train_threshold: train_signal=0.288547",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_train_threshold: train_signal=0.136230"
    ]
  },
  "islands": {
    "0": [
      {
        "id": "g6_i0_p1_226909348",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features.\n    The formula is a weighted product of factors that tend to shorten or lengthen\n    paths, with coefficients tuned to keep the expression compact while\n    capturing the main structural influences.\n    \"\"\"\n    # Basic quantities\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    density    = s['density']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    degrees    = s['degrees']          # sorted list\n\n    # Base estimate: larger n and smaller avg_degree → longer paths\n    val = n / (avg_deg + 1)\n\n    # Factors that tend to shorten paths\n    val *= (1 + 1.3 * density)\n    val *= (1 + 1.1 * clustering)\n    val *= (1 + 1.2 * trans)\n\n    # Positive assortativity clusters similar‑degree nodes, often shortening paths\n    val /= (1 + 0.5 * abs(assort))\n\n    # Triangles provide local shortcuts; dampen large counts with a square root\n    val *= (1 + (num_tri ** 0.5) / (n ** 2 + 1))\n\n    # Degree spread and variability can increase path length\n    val *= (1 + 0.3 * (max_deg - min_deg) / (max_deg + 1))\n    val *= (1 + 0.3 * std_deg / (avg_deg + 1))\n\n    # Median degree captures the central tendency of the degree distribution\n    mid = len(degrees) // 2\n    median_deg = degrees[mid] if len(degrees) % 2 else (degrees[mid - 1] + degrees[mid]) / 2\n    val *= (1 + 0.2 * median_deg / (avg_deg + 1))\n\n    return val",
        "island_id": 0,
        "generation": 6,
        "train_score": 0.7511644657863146,
        "val_score": 0.507842254236618,
        "simplicity_score": 0.24783440638124699,
        "novelty_bonus": 0.31979642891023075
      },
      {
        "id": "g6_i0_p2_564499893",
        "code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n\n    val = n / (avg_deg + 1)\n    val *= (1 + 1.3 * density)\n    val *= (1 + 1.1 * trans)\n    val *= (1 + 1.0 * clustering)\n    val /= (1 + 0.4 * abs(assort))\n    val *= (1 + 0.3 * (num_tri ** 0.5) / (n + 1))\n    val *= (1 + 0.4 * (max_deg - min_deg) / (max_deg + 1))\n    val *= (1 + 0.4 * std_deg / (avg_deg + 1))\n    return val",
        "island_id": 0,
        "generation": 6,
        "train_score": 0.7615366146458583,
        "val_score": 0.4958723368726672,
        "simplicity_score": 0.25062504096016025,
        "novelty_bonus": 0.3677885587751666
      },
      {
        "id": "g6_i0_p3_669813994",
        "code": "def new_invariant(s):\n    # unpack features\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    degrees    = s['degrees']\n\n    # Base estimate: larger n and smaller avg_degree → longer paths\n    val = n / (avg_deg + 1)\n\n    # Factors that tend to shorten paths\n    val *= (1 + 1.1 * density) * (1 + 1.1 * trans) * (1 + 1.0 * clustering)\n\n    # Positive assortativity clusters similar‑degree nodes, often shortening paths\n    val /= (1 + 0.4 * abs(assort))\n\n    # Triangles provide local shortcuts; dampen large counts with sqrt\n    val *= (1 + 0.4 * (num_tri ** 0.5) / (n**2 + 1))\n\n    # Degree spread and variability can increase path length\n    val *= (1 + 0.3 * (max_deg - min_deg) / (max_deg + 1))\n    val *= (1 + 0.3 * std_deg / (avg_deg + 1))\n\n    # Edge density expressed as ratio of actual to possible edges\n    max_edges = n * (n - 1) // 2\n    val *= (1 + m / (max_edges + 1))\n\n    # Median degree captures the central tendency of the degree distribution\n    mid = len(degrees) // 2\n    median_deg = degrees[mid] if len(degrees) % 2 else (degrees[mid - 1] + degrees[mid]) / 2\n    val *= (1 + 0.2 * median_deg / (avg_deg + 1))\n\n    # Sum of squared degrees captures higher‑order degree effects\n    sum_sq = sum(d * d for d in degrees)\n    val *= (1 + 0.2 * sum_sq / (n * (avg_deg ** 2 + 1)))\n\n    return val",
        "island_id": 0,
        "generation": 6,
        "train_score": 0.7527971188475389,
        "val_score": 0.49508617938920296,
        "simplicity_score": 0.2458419268201938,
        "novelty_bonus": 0.3733806540711546
      },
      {
        "id": "g10_i0_p0_982738393",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features.\n    The expression is a compact product of factors that capture the main\n    structural influences on path length.  All operations use only built‑in\n    Python functions; no external imports are required.\n    \"\"\"\n    # Basic quantities\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    density    = s['density']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    degrees    = s['degrees']          # sorted list\n\n    # Base estimate: larger n and smaller avg_degree → longer paths\n    val = n / (avg_deg + 1)\n\n    # Factors that tend to shorten paths\n    val *= (1 + 1.2 * density)\n    val *= (1 + 1.0 * clustering)\n    val *= (1 + 1.1 * trans)\n\n    # Positive assortativity clusters similar‑degree nodes, often shortening paths\n    val /= (1 + 0.4 * abs(assort))\n\n    # Triangles provide local shortcuts; dampen large counts with a square root\n    val *= (1 + 0.3 * (num_tri ** 0.5) / (n + 1))\n\n    # Degree spread and variability can increase path length\n    val *= (1 + 0.3 * (max_deg - min_deg) / (max_deg + 1))\n    val *= (1 + 0.3 * std_deg / (avg_deg + 1))\n\n    # Median degree captures the central tendency of the degree distribution\n    mid = len(degrees) // 2\n    if len(degrees) % 2 == 0:\n        median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n    else:\n        median_deg = degrees[mid]\n    val *= (1 + 0.2 * median_deg / (avg_deg + 1))\n\n    return val",
        "island_id": 0,
        "generation": 10,
        "train_score": 0.7378151260504201,
        "val_score": 0.49456827935872105,
        "simplicity_score": 0.24766122955523237,
        "novelty_bonus": 0.3717377350393678
      },
      {
        "id": "g5_i0_p4_744762155",
        "code": "def new_invariant(s):\n    # unpack features\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    density    = s['density']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    degrees    = s['degrees']          # already sorted\n\n    # Base estimate: larger n and smaller avg_degree → longer paths\n    val = n / (avg_deg + 1)\n\n    # Factors that tend to shorten paths\n    val *= (1 + 1.5 * density)\n    val *= (1 + 1.2 * clustering)\n    val *= (1 + trans)\n\n    # Positive assortativity tends to cluster similar‑degree nodes, often shortening paths\n    val /= (1 + 0.5 * abs(assort))\n\n    # Triangles provide local shortcuts; moderate their influence\n    val *= (1 + 0.5 * (num_tri ** 0.5) / (n ** 2 + 1))\n\n    # Degree spread can increase path length; moderate its effect\n    val *= (1 + 0.5 * (max_deg - min_deg) / (max_deg + 1))\n\n    # Degree variability often increases path length; moderate its effect\n    val *= (1 + 0.5 * std_deg / (avg_deg + 1))\n\n    # Median degree captures the central tendency of the degree distribution\n    mid = len(degrees) // 2\n    if len(degrees) % 2 == 1:\n        median_deg = degrees[mid]\n    else:\n        median_deg = (degrees[mid - 1] + degrees[mid]) / 2\n    val *= (1 + 0.5 * median_deg / (avg_deg + 1))\n\n    # Sum of squared degrees captures higher‑order degree effects\n    sum_sq = sum(d * d for d in degrees)\n    val *= (1 + 0.5 * sum_sq / (n * (avg_deg ** 2 + 1)))\n\n    return val",
        "island_id": 0,
        "generation": 5,
        "train_score": 0.7438655462184873,
        "val_score": 0.4933254659359554,
        "simplicity_score": 0.24656480581498377,
        "novelty_bonus": 0.3336725934608116
      }
    ],
    "1": [
      {
        "id": "g6_i0_p1_226909348",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features.\n    The formula is a weighted product of factors that tend to shorten or lengthen\n    paths, with coefficients tuned to keep the expression compact while\n    capturing the main structural influences.\n    \"\"\"\n    # Basic quantities\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    density    = s['density']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    degrees    = s['degrees']          # sorted list\n\n    # Base estimate: larger n and smaller avg_degree → longer paths\n    val = n / (avg_deg + 1)\n\n    # Factors that tend to shorten paths\n    val *= (1 + 1.3 * density)\n    val *= (1 + 1.1 * clustering)\n    val *= (1 + 1.2 * trans)\n\n    # Positive assortativity clusters similar‑degree nodes, often shortening paths\n    val /= (1 + 0.5 * abs(assort))\n\n    # Triangles provide local shortcuts; dampen large counts with a square root\n    val *= (1 + (num_tri ** 0.5) / (n ** 2 + 1))\n\n    # Degree spread and variability can increase path length\n    val *= (1 + 0.3 * (max_deg - min_deg) / (max_deg + 1))\n    val *= (1 + 0.3 * std_deg / (avg_deg + 1))\n\n    # Median degree captures the central tendency of the degree distribution\n    mid = len(degrees) // 2\n    median_deg = degrees[mid] if len(degrees) % 2 else (degrees[mid - 1] + degrees[mid]) / 2\n    val *= (1 + 0.2 * median_deg / (avg_deg + 1))\n\n    return val",
        "island_id": 0,
        "generation": 6,
        "train_score": 0.7511644657863146,
        "val_score": 0.507842254236618,
        "simplicity_score": 0.24783440638124699,
        "novelty_bonus": 0.31979642891023075
      },
      {
        "id": "g10_i1_p1_34692964",
        "code": "def new_invariant(s):\n    # Extract features\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Base factors combining the two top formulas\n    base1 = n / (avg_deg + 1)\n    base2 = n / (m + 1)\n    base = base1 * base2\n\n    # Degree balance\n    deg_factor = (avg_deg + 1) / (max_deg + 1)\n\n    # Structural cohesion\n    struct_factor = (density + clustering) * (1 + trans)\n\n    # Size scaling\n    sqrt_factor = n ** 0.5\n\n    # Assortativity penalty\n    assort_factor = 1 / (1 + 0.5 * abs(assort))\n\n    # Triangle influence (both raw and normalized)\n    max_triangles = max(1, n * (n - 1) / 2)\n    tri_factor1 = 1 + (triangles ** 0.5) / (n ** 2 + 1)\n    tri_factor2 = 1 + triangles / max_triangles\n    triangle_factor = tri_factor1 * tri_factor2\n\n    # Degree variance penalty\n    std_factor = (1 / (1 + std_deg)) * (1 + 0.3 * std_deg / (avg_deg + 1))\n\n    # Minimum degree encouragement\n    min_factor = (min_deg + 1) / (avg_deg + 1)\n\n    # Degree spread factor\n    spread_factor = 1 + (max_deg - min_deg) / (max_deg + 1)\n\n    # Degree range factor\n    degree_range_factor = 1 + (max_deg - min_deg + 1) / (avg_deg + 1)\n\n    # Median degree factor\n    mid = len(degrees) // 2\n    if len(degrees) % 2 == 0:\n        median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n    else:\n        median_deg = degrees[mid]\n    median_factor = (median_deg + 1) / (avg_deg + 1)\n\n    # Combine all multiplicatively\n    val = (base * deg_factor * struct_factor * sqrt_factor *\n           assort_factor * triangle_factor * std_factor *\n           min_factor * spread_factor * degree_range_factor *\n           median_factor)\n\n    return val",
        "island_id": 1,
        "generation": 10,
        "train_score": 0.6265066026410564,
        "val_score": 0.502691141133517,
        "simplicity_score": 0.24434197266276908,
        "novelty_bonus": 0.2827537777062503
      },
      {
        "id": "g10_i1_p3_821674449",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features.\n    The expression combines several structural factors multiplicatively, each\n    designed to capture a different aspect of graph connectivity.\n    \"\"\"\n    # Basic size / density factor\n    val = s['n'] / (s['m'] + 1)\n\n    # Structural cohesion factors\n    val *= (1 + s['density'])\n    val *= (1 + s['avg_clustering'])\n    val *= (1 + s['transitivity'])\n\n    # Triangle density relative to the maximum possible\n    max_triangles = max(1, s['n'] * (s['n'] - 1) / 2.0)\n    val *= (1 + s['num_triangles'] / max_triangles)\n\n    # Degree spread and variability\n    degree_range = s['max_degree'] - s['min_degree']\n    val *= (1 + degree_range / (s['max_degree'] + 1))\n    val *= (1 + s['std_degree'] / (s['avg_degree'] + 1))\n\n    # Assortativity effect\n    val *= (1 + s['degree_assortativity'])\n\n    # Median degree factor\n    degrees = s['degrees']\n    mid = len(degrees) // 2\n    if len(degrees) % 2 == 0:\n        median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n    else:\n        median_deg = degrees[mid]\n    val *= (1 + median_deg / (s['avg_degree'] + 1))\n\n    return val",
        "island_id": 1,
        "generation": 10,
        "train_score": 0.6293877551020408,
        "val_score": 0.401646966738774,
        "simplicity_score": 0.24905189471229217,
        "novelty_bonus": 0.28705490049437177
      },
      {
        "id": "g6_i1_p4_97226634",
        "code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n\n    base = n / (m + 1)\n    deg_factor = (avg_deg + 1) / (max_deg + 1)\n    struct_factor = (density + clustering) * (1 + trans)\n    sqrt_factor = pow(n, 0.5)\n    assort_factor = 1 + assort\n    max_triangles = max(1, n * (n - 1) / 2)\n    triangle_factor = 1 + triangles / max_triangles\n    std_factor = 1 / (1 + std_deg)\n    min_factor = (min_deg + 1) / (avg_deg + 1)\n    degree_range_factor = 1 + (max_deg - min_deg + 1) / (avg_deg + 1)\n\n    return (base * deg_factor * struct_factor * sqrt_factor *\n            assort_factor * triangle_factor * std_factor *\n            min_factor * degree_range_factor)",
        "island_id": 1,
        "generation": 6,
        "train_score": 0.38180072028811524,
        "val_score": 0.259167001342034,
        "simplicity_score": 0.11915354499011185,
        "novelty_bonus": 0.3467844519407486
      },
      {
        "id": "g10_i1_p4_58302741",
        "code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # Base: geometric mean of two common starting points\n    base = pow((n / (avg_deg + 1)) * (n / (m + 1)), 0.5)\n\n    # Degree‑related factors\n    deg_factor = (avg_deg + 1) / (max_deg + 1)\n    min_factor = (min_deg + 1) / (avg_deg + 1)\n    spread_factor = 1 + (max_deg - min_deg) / (max_deg + 1)\n    degree_range_factor = 1 + (max_deg - min_deg + 1) / (avg_deg + 1)\n\n    # Structural cohesion\n    struct_factor = (density + clustering) * (1 + trans)\n\n    # Size scaling\n    sqrt_factor = pow(n, 0.5)\n\n    # Assortativity\n    assort_factor = 1 + abs(assort)\n\n    # Triangle density\n    max_triangles = max(1, n * (n - 1) / 2.0)\n    triangle_factor = 1 + triangles / max_triangles\n\n    # Degree variance penalty\n    std_factor = 1 / (1 + std_deg)\n\n    # Median degree factor\n    mid = len(degrees) // 2\n    if len(degrees) % 2 == 0:\n        median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n    else:\n        median_deg = degrees[mid]\n    median_factor = (median_deg + 1) / (avg_deg + 1)\n\n    # Combine all multiplicatively\n    return (\n        base\n        * deg_factor\n        * struct_factor\n        * sqrt_factor\n        * assort_factor\n        * triangle_factor\n        * std_factor\n        * min_factor\n        * spread_factor\n        * degree_range_factor\n        * median_factor\n    )",
        "island_id": 1,
        "generation": 10,
        "train_score": 0.39476590636254505,
        "val_score": 0.25794226951744526,
        "simplicity_score": 0.11349211372235778,
        "novelty_bonus": 0.339798630591426
      }
    ],
    "2": [
      {
        "id": "g1_i2_p4_735752370",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The formula combines random‑graph theory with corrections for clustering,\n    degree heterogeneity, density, and assortativity.  All operations are\n    safeguarded against division by zero and missing values.\n    \"\"\"\n    # Basic graph statistics (safe defaults)\n    n          = s.get('n', 0)\n    avg_deg    = s.get('avg_degree', 0.0) or 1.0          # avoid zero\n    trans      = s.get('transitivity', 0.0) or 0.0\n    avg_clust  = s.get('avg_clustering', 0.0) or 0.0\n    std_deg    = s.get('std_degree', 0.0) or 1.0\n    density    = s.get('density', 0.0) or 1e-6            # avoid zero\n    assort     = s.get('degree_assortativity', 0.0) or 0.0\n\n    eps = 1e-6\n\n    # 1. Random‑graph baseline: log(n)/log(avg_deg+1)\n    base = np.log(max(n, 2)) / np.log(max(avg_deg + 1.0, 2.0))\n\n    # 2. Clustering adjustment: more triangles → longer paths\n    clustering_adj = 1.0 + 0.5 * (trans + avg_clust)\n\n    # 3. Degree variance adjustment: higher variance → shorter paths\n    variance_adj = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Density adjustment: sparser graphs tend to have longer paths\n    density_adj = np.sqrt(1.0 / (density + eps))\n\n    # 5. Assortativity adjustment: positive assortativity can lengthen paths\n    assort_adj = 1.0 + 0.5 * assort  # range roughly [0.5, 1.5]\n\n    return base * clustering_adj * variance_adj * density_adj * assort_adj",
        "island_id": 2,
        "generation": 1,
        "train_score": 0.9221128451380551,
        "val_score": 0.5491013268732999,
        "simplicity_score": 0.13119988577898903,
        "novelty_bonus": 0.1811952881995048
      },
      {
        "id": "g3_i2_p0_858291293",
        "code": "def new_invariant(s):\n    # Basic statistics with safe defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    if avg_deg <= 0:\n        avg_deg = 1.0\n\n    trans      = s.get('transitivity', 0.0)\n    std_deg    = s.get('std_degree', 1.0)\n    if std_deg <= 0:\n        std_deg = 1.0\n\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n\n    # 1. Baseline distance estimate (scales with sqrt(n))\n    base = (n ** 0.5) / (avg_deg + 1)\n\n    # 2. Adjust for clustering – more triangles → longer paths\n    clustering_adj = 1 + trans\n\n    # 3. Adjust for degree variance – higher variance → shorter paths\n    variance_adj = 1 / (1 + std_deg / (avg_deg + 1))\n\n    # 4. Adjust for density – denser graphs → shorter paths\n    density_adj = 1 / (1 + density)\n\n    # 5. Adjust for assortativity – positive assortativity can lengthen paths\n    assort_adj = 1 + 0.5 * assort\n\n    # Combined estimate\n    return base * clustering_adj * variance_adj * density_adj * assort_adj",
        "island_id": 2,
        "generation": 3,
        "train_score": 0.9177911164465786,
        "val_score": 0.5483243163606503,
        "simplicity_score": 0.13343273744596368,
        "novelty_bonus": 0.15721743043576064
      },
      {
        "id": "g9_i2_p3_30817834",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The formula is a product of a base term and several multiplicative\n    adjustments that capture the influence of clustering, degree variance,\n    density, assortativity, and degree extremes.\n    \"\"\"\n    # Basic statistics with safe defaults\n    n          = s.get('n', 1)\n    m          = s.get('m', 1)\n    density    = s.get('density', 1e-6)\n    avg_deg    = s.get('avg_degree', 1.0)\n    if avg_deg <= 0: avg_deg = 1.0\n    max_deg    = s.get('max_degree', 1.0)\n    if max_deg <= 0: max_deg = 1.0\n    min_deg    = s.get('min_degree', 1.0)\n    if min_deg <= 0: min_deg = 1.0\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    triangles  = s.get('num_triangles', 0)\n\n    # Base estimate: grows with sqrt(n) and shrinks with average degree\n    base = (n ** 0.5) / (avg_deg + 1.0)\n\n    # 1. Clustering & transitivity: more triangles → longer paths\n    clustering_adj = 1.0 + 0.5 * (clustering + trans)\n\n    # 2. Degree variance: higher variance tends to shorten paths\n    var_adj = 1.0 / (1.0 + (std_deg * std_deg) / (avg_deg + 1.0))\n\n    # 3. Density: denser graphs have shorter paths\n    density_adj = 1.0 / (density + 1e-6)\n\n    # 4. Assortativity: positive assortativity can lengthen paths\n    assort_adj = 1.0 + 0.5 * assort\n\n    # 5. Max degree: very high maximum degree usually shortens paths\n    max_adj = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # 6. Minimum degree: very low minimum degree can lengthen paths\n    min_adj = 1.0 + 1.0 / (min_deg + 1e-6)\n\n    # 7. Triangle count relative to edges: more triangles → longer paths\n    tri_adj = 1.0 + triangles / (m + 1.0)\n\n    # Combined estimate\n    estimate = (base *\n                clustering_adj *\n                var_adj *\n                density_adj *\n                assort_adj *\n                max_adj *\n                min_adj *\n                tri_adj)\n\n    return estimate",
        "island_id": 2,
        "generation": 9,
        "train_score": 0.8884033613445379,
        "val_score": 0.5300391885637957,
        "simplicity_score": 0.17909397257846857,
        "novelty_bonus": 0.22039635324270634
      },
      {
        "id": "g7_i2_p4_471567144",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The formula is a simple product of a base term and multiplicative\n    corrections that capture the effects of clustering, degree heterogeneity,\n    density, assortativity, and degree extremes.  No external libraries or\n    graph traversal algorithms are used.\n    \"\"\"\n    # ---------- Basic statistics with safe defaults ----------\n    n          = s.get('n', 1)\n    m          = s.get('m', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', 1.0)\n    min_deg    = s.get('min_degree', 1.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    density    = s.get('density', 0.0)\n    triangles  = s.get('num_triangles', 0)\n\n    # Avoid division by zero or negative values\n    if avg_deg <= 0:   avg_deg = 1.0\n    if max_deg <= 0:   max_deg = 1.0\n    if min_deg <= 0:   min_deg = 1.0\n    if density <= 0:   density = 1e-6\n    if m <= 0:         m = 1\n\n    # ---------- Base estimate ----------\n    base = pow(n, 0.5) / (avg_deg + 1.0)\n\n    # ---------- Adjustments ----------\n    # 1. Clustering & transitivity: more triangles → longer paths\n    clustering_adj = 1.0 + 0.5 * (clustering + trans)\n\n    # 2. Degree variance: higher variance → shorter paths\n    var_adj = 1.0 / (1.0 + (std_deg * std_deg) / (avg_deg + 1.0))\n\n    # 3. Density: denser graphs have shorter paths\n    density_adj = 1.0 / (density + 1e-6)\n\n    # 4. Assortativity: positive assortativity tends to lengthen paths\n    assort_adj = 1.0 + 0.5 * assort\n\n    # 5. Max degree: very high maximum degree usually shortens paths\n    max_deg_adj = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # 6. Minimum degree: very low minimum degree can lengthen paths\n    min_deg_adj = 1.0 + 1.0 / (min_deg + 1e-6)\n\n    # 7. Triangle count relative to edges: more triangles → longer paths\n    tri_adj = 1.0 + triangles / (m + 1.0)\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clustering_adj *\n                var_adj *\n                density_adj *\n                assort_adj *\n                max_deg_adj *\n                min_deg_adj *\n                tri_adj)\n\n    return estimate",
        "island_id": 2,
        "generation": 7,
        "train_score": 0.8884033613445379,
        "val_score": 0.529927204111338,
        "simplicity_score": 0.17853405031618008,
        "novelty_bonus": 0.22039635324270634
      },
      {
        "id": "g8_i2_p3_668402961",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The formula is a product of a base term and several multiplicative\n    corrections that capture the effects of clustering, degree variance,\n    density, assortativity, degree extremes and triangle density.\n    No external libraries or graph traversal algorithms are used.\n    \"\"\"\n    # ---------- Basic statistics with safe defaults ----------\n    n          = s.get('n', 1)\n    m          = s.get('m', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', 1.0)\n    min_deg    = s.get('min_degree', 1.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    density    = s.get('density', 0.0)\n    triangles  = s.get('num_triangles', 0)\n\n    # Avoid division by zero or negative values\n    if avg_deg <= 0:\n        avg_deg = 1.0\n    if max_deg <= 0:\n        max_deg = 1.0\n    if min_deg <= 0:\n        min_deg = 1.0\n    if density <= 0:\n        density = 1e-6\n    if m <= 0:\n        m = 1\n\n    # ---------- Base estimate ----------\n    base = pow(n, 0.5) / (avg_deg + 1.0)\n\n    # ---------- Adjustments ----------\n    # 1. Clustering & transitivity: more triangles → longer paths\n    clustering_adj = 1.0 + 0.5 * (clustering + trans)\n\n    # 2. Degree variance: higher variance → shorter paths\n    var_adj = 1.0 / (1.0 + (std_deg * std_deg) / (avg_deg + 1.0))\n\n    # 3. Density: denser graphs have shorter paths\n    density_adj = 1.0 / (density + 1e-6)\n\n    # 4. Assortativity: positive assortativity tends to lengthen paths\n    assort_adj = 1.0 + 0.5 * assort\n\n    # 5. Max degree: very high maximum degree usually shortens paths\n    max_deg_adj = 1.0 / (1.0 + max_deg / (avg_deg + 1.0))\n\n    # 6. Minimum degree: very low minimum degree can lengthen paths\n    min_deg_adj = 1.0 + 1.0 / (min_deg + 1e-6)\n\n    # 7. Triangle density relative to edges: more triangles → longer paths\n    tri_adj = 1.0 + triangles / (m + 1.0)\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clustering_adj *\n                var_adj *\n                density_adj *\n                assort_adj *\n                max_deg_adj *\n                min_deg_adj *\n                tri_adj)\n\n    return estimate",
        "island_id": 2,
        "generation": 8,
        "train_score": 0.8884033613445379,
        "val_score": 0.529927204111338,
        "simplicity_score": 0.17853405031618008,
        "novelty_bonus": 0.22039635324270634
      }
    ],
    "3": [
      {
        "id": "g1_i2_p4_735752370",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The formula combines random‑graph theory with corrections for clustering,\n    degree heterogeneity, density, and assortativity.  All operations are\n    safeguarded against division by zero and missing values.\n    \"\"\"\n    # Basic graph statistics (safe defaults)\n    n          = s.get('n', 0)\n    avg_deg    = s.get('avg_degree', 0.0) or 1.0          # avoid zero\n    trans      = s.get('transitivity', 0.0) or 0.0\n    avg_clust  = s.get('avg_clustering', 0.0) or 0.0\n    std_deg    = s.get('std_degree', 0.0) or 1.0\n    density    = s.get('density', 0.0) or 1e-6            # avoid zero\n    assort     = s.get('degree_assortativity', 0.0) or 0.0\n\n    eps = 1e-6\n\n    # 1. Random‑graph baseline: log(n)/log(avg_deg+1)\n    base = np.log(max(n, 2)) / np.log(max(avg_deg + 1.0, 2.0))\n\n    # 2. Clustering adjustment: more triangles → longer paths\n    clustering_adj = 1.0 + 0.5 * (trans + avg_clust)\n\n    # 3. Degree variance adjustment: higher variance → shorter paths\n    variance_adj = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Density adjustment: sparser graphs tend to have longer paths\n    density_adj = np.sqrt(1.0 / (density + eps))\n\n    # 5. Assortativity adjustment: positive assortativity can lengthen paths\n    assort_adj = 1.0 + 0.5 * assort  # range roughly [0.5, 1.5]\n\n    return base * clustering_adj * variance_adj * density_adj * assort_adj",
        "island_id": 2,
        "generation": 1,
        "train_score": 0.9221128451380551,
        "val_score": 0.5491013268732999,
        "simplicity_score": 0.13119988577898903,
        "novelty_bonus": 0.1811952881995048
      },
      {
        "id": "g4_i3_p3_43803765",
        "code": "def new_invariant(s):\n    \"\"\"\n    Composite graph invariant that mixes size, sparsity, degree dispersion,\n    triangle abundance, clustering strength, and degree assortativity.\n    All operations use only built‑in arithmetic to avoid external imports.\n    \"\"\"\n    # Size to edge ratio – captures overall sparsity\n    size_edge = (s['n'] + 1.0) / (s['m'] + 1.0)\n\n    # Degree dispersion relative to variability – higher spread suggests\n    # longer paths through hubs\n    deg_disp = (s['max_degree'] - s['min_degree'] + 1.0) / (s['std_degree'] + 1.0)\n\n    # Triangle density – more triangles usually shorten paths\n    tri_dense = (s['num_triangles'] + 1.0) / (s['n'] + 1.0)\n\n    # Combined clustering factor – square to amplify the effect\n    cluster_factor = (s['avg_clustering'] ** 2 + s['transitivity'] ** 2) / 2.0\n\n    # Assortativity magnitude – strong correlation can create bottlenecks\n    assort_factor = (s['degree_assortativity'] ** 2 + 1.0)\n\n    # Final invariant: product of sparsity, dispersion, and triangle terms,\n    # divided by clustering and assortativity terms\n    invariant = (size_edge * deg_disp * tri_dense) / (cluster_factor * assort_factor)\n\n    return invariant",
        "island_id": 3,
        "generation": 4,
        "train_score": 0.7733580018501388,
        "val_score": 0.4168062307831738,
        "simplicity_score": 0.18156973355038536,
        "novelty_bonus": 0.40562853270443633
      },
      {
        "id": "g5_i3_p2_686478210",
        "code": "def new_invariant(s):\n    \"\"\"\n    A hand‑crafted composite invariant built only from arithmetic\n    operations on the supplied pre‑computed statistics.\n\n    The formula mixes size, sparsity, degree dispersion, triangle\n    abundance, clustering, and degree assortativity – all quantities\n    known to influence the average shortest‑path length.\n\n    Key assumptions:\n        • s contains the keys listed in the problem statement.\n        • No external modules may be imported; only built‑in\n          operations (addition, subtraction, multiplication,\n          division, pow, min, max, etc.) are used.\n\n    The structure is:\n\n        invariant = (size_factor * degree_factor * triangle_factor)\n                    / (clustering_factor * assortativity_factor)\n\n    The \"+ 1\" terms in denominators guarantee numerical stability\n    for very small or zero values.\n    \"\"\"\n\n    # 1. Size‑to‑edge ratio: captures overall sparsity.\n    size_factor = (s['n'] + 1.0) / (s['m'] + 1.0)\n\n    # 2. Degree spread relative to its standard deviation.\n    #    Larger spread tends to create longer paths, especially when\n    #    combined with a high variance of degrees.\n    degree_factor = (s['max_degree'] - s['min_degree'] + 1.0) / (s['std_degree'] + 1.0)\n\n    # 3. Triangle density (shifted to avoid division by zero).\n    triangle_factor = (s['num_triangles'] + 1.0) / (s['n'] + 1.0)\n\n    # 4. Clustering influence.  Square both local and global clustering\n    #    before averaging to give more weight to high‑clustering graphs.\n    clustering_factor = (pow(s['avg_clustering'], 2) + pow(s['transitivity'], 2)) / 2.0\n\n    # 5. Assortativity influence.  Strong positive or negative assortativity\n    #    usually creates bottlenecks, so we penalise large absolute values.\n    assortativity_factor = pow(s['degree_assortativity'], 2) + 1.0\n\n    # 6. Combine all pieces.  We multiply the first three terms – each\n    #    known to *shorten* paths – and divide by the last two, which\n    #    typically *enlarge* the average shortest path.\n    invariant = (size_factor * degree_factor * triangle_factor) / (clustering_factor * assortativity_factor)\n\n    return invariant",
        "island_id": 3,
        "generation": 5,
        "train_score": 0.7733580018501388,
        "val_score": 0.41675922015805367,
        "simplicity_score": 0.18133468042478507,
        "novelty_bonus": 0.40562853270443633
      },
      {
        "id": "g3_i3_p3_700522966",
        "code": "def new_invariant(s):\n    \"\"\"\n    A composite invariant that mixes several pre‑computed graph statistics\n    to produce a value correlated with the average shortest‑path length.\n    It uses only arithmetic, comparisons, and basic Python built‑ins.\n\n    Keys required from the dictionary `s`:\n        - n                 (int) number of nodes\n        - m                 (int) number of edges\n        - density           (float) edge density\n        - avg_degree        (float) average degree\n        - max_degree        (int) maximum degree\n        - min_degree        (int) minimum degree\n        - std_degree        (float) degree standard deviation\n        - avg_clustering    (float) average local clustering coefficient\n        - transitivity      (float) global transitivity (overall clustering)\n        - degree_assortativity (float) degree assortativity coefficient\n        - num_triangles     (int) number of triangles\n        - degrees           (list[int]) sorted degree sequence\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 1. Size to sparsity ratio\n    size_edge_ratio = (s['n'] + 1.0) / (s['m'] + 1.0)\n\n    # 2. Degree dispersion: relative spread compared to variation\n    degree_spread = (s['max_degree'] - s['min_degree'] + 1.0)\n    degree_variation = s['std_degree'] + 1.0\n    degree_dispersion = degree_spread / degree_variation\n\n    # 3. Triangle density: triangles per node (shifted to avoid zero)\n    triangle_density = (s['num_triangles'] + 1.0) / (s['n'] + 1.0)\n\n    # 4. Local triangle power: square of clustering and transitivity\n    clustering_power = (s['avg_clustering'] ** 2 + s['transitivity'] ** 2) / 2.0\n\n    # 5. Assortativity magnitude: square to make always positive\n    assort_magnitude = s['degree_assortativity'] ** 2 + 1.0\n\n    # ------------------------------------------------------------------\n    # Combine everything into one scalar\n    # The product of the first three components emphasizes sparsity,\n    # degree spread, and triangle abundance – all of which can affect\n    # path lengths.  Dividing by the clustering and assortativity terms\n    # dampens the effect of very high clustering or strong degree\n    # correlations.\n    invariant = (\n        size_edge_ratio\n        * degree_dispersion\n        * triangle_density\n    ) / (\n        clustering_power\n        * assort_magnitude\n    )\n\n    return invariant",
        "island_id": 3,
        "generation": 3,
        "train_score": 0.7733580018501388,
        "val_score": 0.41665460973069646,
        "simplicity_score": 0.18081162828799893,
        "novelty_bonus": 0.40562853270443633
      },
      {
        "id": "g7_i3_p0_705165378",
        "code": "def new_invariant(s):\n    \"\"\"\n    Novel composite invariant for the average shortest‑path length.\n\n    The expression mixes six pre‑computed graph descriptors in a way that\n    reflects several intuitive aspects of graph connectivity:\n\n        * **Size‑to‑edge ratio** – higher when the graph is sparse.\n        * **Density bonus** – grows with overall edge density.\n        * **Degree ratio** – penalises extremely unbalanced degree\n          distributions (high max/min).\n        * **Degree variance term** – stabilises the value for graphs\n          with very little degree spread.\n        * **Triangle bonus** – rewards abundance of triangles.\n        * **Clustering‑assortativity penalty** – dampens the value when\n          clustering is high or degree assortativity is strong.\n\n    All calculations are pure arithmetic; no external modules are used.\n    \"\"\"\n    # 1. Size‑to‑edge ratio (captures sparsity)\n    size_edge_ratio = (s['n'] + 1.0) / (s['m'] + 1.0)\n\n    # 2. Density bonus (tends to grow with edge density)\n    density_bonus = 1.0 + s['density']\n\n    # 3. Degree ratio (high when max/min is large)\n    degree_ratio = (s['max_degree'] + 1.0) / (s['min_degree'] + 1.0)\n\n    # 4. Degree variance stabiliser (avoids division by zero)\n    degree_variance_term = s['std_degree'] + 1.0\n\n    # 5. Triangle bonus (triangles per node, shifted to avoid zero)\n    triangle_bonus = (s['num_triangles'] + 1.0) / (s['n'] + 1.0)\n\n    # 6. Clustering‑assortativity penalty\n    clustering_penalty = (s['avg_clustering'] + s['transitivity']) * (abs(s['degree_assortativity']) + 1.0)\n\n    # Combine all components\n    invariant = (\n        size_edge_ratio\n        * density_bonus\n        * degree_ratio\n        * triangle_bonus\n    ) / (\n        degree_variance_term\n        * clustering_penalty\n    )\n\n    return invariant",
        "island_id": 3,
        "generation": 7,
        "train_score": 0.5867252543940795,
        "val_score": 0.4129137490257713,
        "simplicity_score": 0.18088427959769293,
        "novelty_bonus": 0.26876402168687574
      }
    ]
  }
}