{
  "experiment_id": "phase1_20260215T112609Z",
  "generation": 18,
  "rng_seed": 42,
  "rng_state": {
    "bit_generator": "PCG64",
    "state": {
      "state": 244968854100925264798993686017693086551,
      "inc": 332724090758049132448979897138935081983
    },
    "has_uint32": 1,
    "uinteger": 1868727643
  },
  "best_val_score": 0.44897012276457193,
  "no_improve_count": 2,
  "island_stagnation": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_prompt_mode": {
    "0": "free",
    "1": "free",
    "2": "free",
    "3": "free"
  },
  "island_constrained_generations": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_recent_failures": {
    "0": [
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "no_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`",
      "below_novelty_threshold: novelty_bonus=0.010695"
    ],
    "1": [
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_novelty_threshold: novelty_bonus=0.001241",
      "no_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`"
    ],
    "2": [
      "below_novelty_threshold: novelty_bonus=0.000000",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "no_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`"
    ],
    "3": [
      "no_valid_train_predictions: static_invalid: non-whitelisted call detected: isinstance",
      "no_valid_train_predictions: static_invalid: disallowed syntax: Try",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ]
  },
  "islands": {
    "0": [
      {
        "id": "g17_i0_p0_370922283",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound for the average shortest path length (ASPL).\n\n    The bound is the minimum of several provably safe inequalities that\n    depend only on pre‑computed graph statistics.  Each inequality is\n    valid for every connected simple graph, so the returned value is\n    guaranteed to be ≥ the true ASPL while being as tight as possible\n    given the available features.\n\n    Inequalities used:\n\n    1. Trivial bound:  ASPL ≤ n – 1\n    2. Moore bound with maximum degree Δ:\n           ASPL ≤ 2·r   where r is the smallest integer such that\n           1 + Δ + Δ(Δ‑1) + … + Δ(Δ‑1)^(r‑1) ≥ n\n    3. Moore bound with minimum degree δ:\n           ASPL ≤ 2·r   where r is the smallest integer such that\n           1 + δ + δ(δ‑1) + … + δ(δ‑1)^(r‑1) ≥ n\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'          : number of nodes\n            - 'max_degree' : maximum degree\n            - 'min_degree' : minimum degree\n\n    Returns\n    -------\n    float\n        A numeric upper bound on the average shortest path length.\n    \"\"\"\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    bounds = [float(n - 1)]          # trivial bound\n\n    # Moore bound with maximum degree\n    max_deg = s.get('max_degree', 0)\n    if max_deg > 1:\n        count = 1          # vertices reachable within current radius\n        term = 1           # (max_deg-1)^i\n        r = 0\n        while count < n:\n            r += 1\n            count += max_deg * term\n            term *= (max_deg - 1)\n        bounds.append(float(2 * r))\n\n    # Moore bound with minimum degree\n    min_deg = s.get('min_degree', 0)\n    if min_deg > 1:\n        count = 1\n        term = 1\n        r = 0\n        while count < n:\n            r += 1\n            count += min_deg * term\n            term *= (min_deg - 1)\n        bounds.append(float(2 * r))\n\n    return min(bounds)",
        "island_id": 0,
        "generation": 17,
        "train_score": 0.33966277735920863,
        "val_score": 0.3796442481733225,
        "simplicity_score": 0.19786739006630882,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g15_i0_p3_520672402",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound for the average shortest path length (ASPL).\n\n    The bound is the minimum of several provably safe inequalities that\n    depend only on pre‑computed graph statistics.  Each inequality is\n    valid for every connected simple graph, so the returned value is\n    guaranteed to be ≥ the true ASPL while being as tight as possible\n    given the available features.\n\n    The inequalities used are:\n\n    1.  Trivial bound:  ASPL ≤ n – 1\n    2.  Density bound:  if density > 0.5 then ASPL ≤ 2\n    3.  Moore bound with maximum degree Δ:\n            ASPL ≤ 2·r   where r is the smallest integer such that\n            1 + Δ + Δ(Δ‑1) + … + Δ(Δ‑1)^(r‑1) ≥ n.\n    4.  Moore bound with minimum degree δ:\n            ASPL ≤ 2·r   where r is the smallest integer such that\n            1 + δ + δ(δ‑1) + … + δ(δ‑1)^(r‑1) ≥ n.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'          : number of nodes\n            - 'density'    : edge density\n            - 'max_degree' : maximum degree\n            - 'min_degree' : minimum degree\n\n    Returns\n    -------\n    float\n        A numeric upper bound on the average shortest path length.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    bounds = [float(n - 1)]          # trivial bound\n\n    # Density bound\n    if s['density'] > 0.5:\n        bounds.append(2.0)\n\n    # Moore bound with maximum degree\n    Δ = s['max_degree']\n    if Δ > 2:\n        count = 1          # vertices reachable within current radius\n        term = 1           # (Δ-1)^i\n        r = 0\n        while count < n:\n            r += 1\n            count += Δ * term\n            term *= (Δ - 1)\n        bounds.append(float(2 * r))\n\n    # Moore bound with minimum degree\n    δ = s['min_degree']\n    if δ > 1:\n        count = 1\n        term = 1\n        r = 0\n        while count < n:\n            r += 1\n            count += δ * term\n            term *= (δ - 1)\n        bounds.append(float(2 * r))\n\n    return min(bounds)",
        "island_id": 0,
        "generation": 15,
        "train_score": 0.33966277735920863,
        "val_score": 0.37954366219740066,
        "simplicity_score": 0.19736446018669984,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g15_i0_p0_953772862",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound for the average shortest path length (ASPL).\n\n    The bound is the minimum of several provably safe inequalities that\n    depend only on pre‑computed graph statistics.  Each inequality is\n    valid for every connected simple graph, so the returned value is\n    guaranteed to be ≥ the true ASPL while being as tight as possible\n    given the available features.\n\n    Inequalities used:\n\n    1. Trivial bound:  ASPL ≤ n – 1\n    2. Density bound:  if density > 0.5 then ASPL ≤ 2\n    3. Moore bound with maximum degree Δ:\n           ASPL ≤ 2·r   where r is the smallest integer such that\n           1 + Δ + Δ(Δ‑1) + … + Δ(Δ‑1)^(r‑1) ≥ n\n    4. Moore bound with minimum degree δ:\n           ASPL ≤ 2·r   where r is the smallest integer such that\n           1 + δ + δ(δ‑1) + … + δ(δ‑1)^(r‑1) ≥ n\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'          : number of nodes\n            - 'density'    : edge density\n            - 'max_degree' : maximum degree\n            - 'min_degree' : minimum degree\n\n    Returns\n    -------\n    float\n        A numeric upper bound on the average shortest path length.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    bounds = [float(n - 1)]          # trivial bound\n\n    # Density bound\n    density = s.get('density', 0.0)\n    if density > 0.5:\n        bounds.append(2.0)\n\n    # Moore bound with maximum degree\n    max_deg = s.get('max_degree', 0)\n    if max_deg > 1:\n        count = 1          # vertices reachable within current radius\n        term = 1           # (max_deg-1)^i\n        r = 0\n        while count < n:\n            r += 1\n            count += max_deg * term\n            term *= (max_deg - 1)\n        bounds.append(float(2 * r))\n\n    # Moore bound with minimum degree\n    min_deg = s.get('min_degree', 0)\n    if min_deg > 1:\n        count = 1\n        term = 1\n        r = 0\n        while count < n:\n            r += 1\n            count += min_deg * term\n            term *= (min_deg - 1)\n        bounds.append(float(2 * r))\n\n    return min(bounds)",
        "island_id": 0,
        "generation": 15,
        "train_score": 0.33966277735920863,
        "val_score": 0.37944052749441437,
        "simplicity_score": 0.1968487866717683,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g16_i0_p1_281233783",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound for the average shortest path length (ASPL).\n\n    The bound is the minimum of several provably safe inequalities that\n    depend only on pre‑computed graph statistics.  Each inequality is\n    valid for every connected simple graph, so the returned value is\n    guaranteed to be ≥ the true ASPL while being as tight as possible\n    given the available features.\n\n    Inequalities used:\n\n    1. Trivial bound:  ASPL ≤ n – 1\n    2. Density bound:  if density > 0.5 then ASPL ≤ 2\n    3. Moore bound with maximum degree Δ:\n           ASPL ≤ 2·r   where r is the smallest integer such that\n           1 + Δ + Δ(Δ‑1) + … + Δ(Δ‑1)^(r‑1) ≥ n\n    4. Moore bound with minimum degree δ:\n           ASPL ≤ 2·r   where r is the smallest integer such that\n           1 + δ + δ(δ‑1) + … + δ(δ‑1)^(r‑1) ≥ n\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'          : number of nodes\n            - 'density'    : edge density\n            - 'max_degree' : maximum degree\n            - 'min_degree' : minimum degree\n\n    Returns\n    -------\n    float\n        A numeric upper bound on the average shortest path length.\n    \"\"\"\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    bounds = [float(n - 1)]          # trivial bound\n\n    # Density bound\n    density = s.get('density', 0.0)\n    if density > 0.5:\n        bounds.append(2.0)\n\n    # Moore bound with maximum degree\n    max_deg = s.get('max_degree', 0)\n    if max_deg > 1:\n        count = 1          # vertices reachable within current radius\n        term = 1           # (max_deg-1)^i\n        r = 0\n        while count < n:\n            r += 1\n            count += max_deg * term\n            term *= (max_deg - 1)\n        bounds.append(float(2 * r))\n\n    # Moore bound with minimum degree\n    min_deg = s.get('min_degree', 0)\n    if min_deg > 1:\n        count = 1\n        term = 1\n        r = 0\n        while count < n:\n            r += 1\n            count += min_deg * term\n            term *= (min_deg - 1)\n        bounds.append(float(2 * r))\n\n    return min(bounds)",
        "island_id": 0,
        "generation": 16,
        "train_score": 0.33966277735920863,
        "val_score": 0.3794225476984193,
        "simplicity_score": 0.196758887691793,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g16_i0_p4_730295586",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound for the average shortest path length (ASPL).\n\n    The bound is the minimum of several provably safe inequalities that\n    depend only on pre‑computed graph statistics.  Each inequality is\n    valid for every connected simple graph, so the returned value is\n    guaranteed to be ≥ the true ASPL while being as tight as possible\n    given the available features.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'          : number of nodes\n            - 'density'    : edge density\n            - 'max_degree' : maximum degree\n            - 'min_degree' : minimum degree\n\n    Returns\n    -------\n    float\n        A numeric upper bound on the average shortest path length.\n    \"\"\"\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # Trivial bound\n    bounds = [float(n - 1)]\n\n    # Density bound: diameter ≤ 2 when density > 0.5\n    density = s.get('density', 0.0)\n    if density > 0.5:\n        bounds.append(2.0)\n\n    # Moore bound with maximum degree Δ\n    Δ = s.get('max_degree', 0)\n    if Δ > 1:\n        count = 1          # vertices reachable within current radius\n        term = 1           # (Δ-1)^i\n        r = 0\n        while count < n:\n            r += 1\n            count += Δ * term\n            term *= (Δ - 1)\n        bounds.append(float(2 * r))\n\n    # Moore bound with minimum degree δ\n    δ = s.get('min_degree', 0)\n    if δ > 1:\n        count = 1\n        term = 1\n        r = 0\n        while count < n:\n            r += 1\n            count += δ * term\n            term *= (δ - 1)\n        bounds.append(float(2 * r))\n\n    return min(bounds)",
        "island_id": 0,
        "generation": 16,
        "train_score": 0.33966277735920863,
        "val_score": 0.3794225476984193,
        "simplicity_score": 0.196758887691793,
        "novelty_bonus": 0.5521213665879059
      }
    ],
    "1": [
      {
        "id": "g15_i1_p3_21612079",
        "code": "def new_invariant(s):\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # Path-graph bound (maximum ASPL over all connected graphs)\n    path_bound = (n * n - 1) / (3 * (n - 1))\n\n    # Density bound: if density > 0.5, diameter ≤ 2\n    density = s.get('density', 0.0)\n    density_bound = 2.0 if density > 0.5 else n - 1\n\n    # Moore bound using maximum degree Δ\n    max_deg = s.get('max_degree', 1)\n    if max_deg <= 2:\n        moore_max = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += max_deg * power\n            power *= (max_deg - 1)\n            radius += 1\n        moore_max = radius + 1\n\n    # Moore bound using minimum degree δ\n    min_deg = s.get('min_degree', 1)\n    if min_deg <= 1:\n        moore_min = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += min_deg * power\n            power *= (min_deg - 1)\n            radius += 1\n        moore_min = radius + 1\n\n    # Moore bound using average degree\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg <= 1:\n        moore_avg = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += avg_deg * power\n            power *= (avg_deg - 1)\n            radius += 1\n        moore_avg = radius + 1\n\n    # Trivial bound\n    trivial = n - 1\n\n    # Take the tightest guaranteed upper bound\n    final = path_bound\n    if density_bound < final:\n        final = density_bound\n    if moore_max < final:\n        final = moore_max\n    if moore_min < final:\n        final = moore_min\n    if moore_avg < final:\n        final = moore_avg\n    if trivial < final:\n        final = trivial\n\n    return float(final)",
        "island_id": 1,
        "generation": 15,
        "train_score": 0.532044713370125,
        "val_score": 0.44897012276457193,
        "simplicity_score": 0.16144639652211454,
        "novelty_bonus": 0.5501320075867819
      },
      {
        "id": "g17_i1_p3_290917837",
        "code": "def new_invariant(s):\n    \"\"\"Safe upper bound on average shortest path length using pre‑computed graph features.\"\"\"\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # Path‑graph bound (maximum ASPL over all connected graphs)\n    path_bound = (n * n - 1) / (3 * (n - 1))\n\n    # Density bound: if density > 0.5, diameter ≤ 2\n    density = s.get('density', 0.0)\n    density_bound = 2.0 if density > 0.5 else n - 1\n\n    # Moore bound using maximum degree Δ\n    max_deg = s.get('max_degree', 1)\n    if max_deg <= 2:\n        moore_max = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += max_deg * power\n            power *= (max_deg - 1)\n            radius += 1\n        moore_max = radius + 1\n\n    # Moore bound using minimum degree δ\n    min_deg = s.get('min_degree', 1)\n    if min_deg <= 1:\n        moore_min = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += min_deg * power\n            power *= (min_deg - 1)\n            radius += 1\n        moore_min = radius + 1\n\n    # Moore bound using average degree\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg <= 1:\n        moore_avg = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += avg_deg * power\n            power *= (avg_deg - 1)\n            radius += 1\n        moore_avg = radius + 1\n\n    # Trivial bound\n    trivial = n - 1\n\n    # Take the tightest guaranteed upper bound\n    final = path_bound\n    if density_bound < final:\n        final = density_bound\n    if moore_max < final:\n        final = moore_max\n    if moore_min < final:\n        final = moore_min\n    if moore_avg < final:\n        final = moore_avg\n    if trivial < final:\n        final = trivial\n\n    return float(final)",
        "island_id": 1,
        "generation": 17,
        "train_score": 0.532044713370125,
        "val_score": 0.4489616580900323,
        "simplicity_score": 0.16140407314941654,
        "novelty_bonus": 0.5501320075867819
      },
      {
        "id": "g14_i1_p1_467107552",
        "code": "def new_invariant(s):\n    \"\"\"\n    Safe upper bound on the average shortest path length (ASPL) for any connected graph.\n    The bound is the minimum of two provably safe expressions that depend only on\n    pre‑computed graph features:\n\n    1. Path‑graph bound: (n + 1) / 3\n       – The maximum ASPL over all connected graphs (attained by a path).\n\n    2. Moore bound using the maximum degree Δ:\n       * If Δ ≤ 2, the bound is n – 1.\n       * Otherwise, bound = minimal D such that\n         1 + Δ + Δ(Δ–1) + … + Δ(Δ–1)^(D–1) ≥ n.\n       – This is an upper bound on the diameter, hence also on ASPL.\n\n    The minimum of these guarantees a valid upper bound while being tighter than\n    the trivial bound n – 1 for most graphs.\n    \"\"\"\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # 1. Path‑graph bound\n    path_bound = (n + 1) / 3.0\n\n    # 2. Moore bound using maximum degree\n    max_deg = s.get('max_degree', 1)\n    if max_deg <= 2:\n        moore_max = n - 1\n    else:\n        nodes = 1          # nodes reachable within current radius\n        power = 1          # (max_deg-1)^radius\n        radius = 0\n        while nodes < n:\n            nodes += max_deg * power\n            power *= (max_deg - 1)\n            radius += 1\n        moore_max = radius + 1   # add one to be safe\n\n    # Take the tightest guaranteed upper bound\n    final = path_bound\n    if moore_max < final:\n        final = moore_max\n\n    return float(final)",
        "island_id": 1,
        "generation": 14,
        "train_score": 0.5001220305679176,
        "val_score": 0.4477276757431705,
        "simplicity_score": 0.17112321600222977,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g17_i1_p2_634831088",
        "code": "def new_invariant(s):\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # Path‑graph bound: maximum ASPL over all connected graphs\n    path_bound = (n * n - 1) / (3 * (n - 1))\n\n    # Density bound: if density > 0.5, diameter ≤ 2\n    density = s.get('density', 0.0)\n    density_bound = 2.0 if density > 0.5 else n - 1\n\n    # Moore bound using maximum degree Δ\n    max_deg = s.get('max_degree', 1)\n    if max_deg <= 2:\n        moore_max = n - 1\n    else:\n        nodes = 1          # nodes reachable within current radius\n        power = 1          # (max_deg-1)^radius\n        radius = 0\n        while nodes < n:\n            nodes += max_deg * power\n            power *= (max_deg - 1)\n            radius += 1\n        moore_max = radius + 1   # add one to be safe\n\n    # Take the tightest guaranteed upper bound\n    bound = path_bound\n    if density_bound < bound:\n        bound = density_bound\n    if moore_max < bound:\n        bound = moore_max\n\n    return float(bound)",
        "island_id": 1,
        "generation": 17,
        "train_score": 0.5001220305679176,
        "val_score": 0.4471006106640525,
        "simplicity_score": 0.16798789060663963,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g16_i1_p1_938761242",
        "code": "def new_invariant(s):\n    \"\"\"\n    Safe upper bound on the average shortest path length (ASPL) for any connected graph.\n    The bound is the minimum of several provably safe expressions that depend only on\n    pre‑computed graph features.\n\n    1. Path‑graph bound: (n² – 1) / (3·(n – 1))\n       – The maximum ASPL over all connected graphs (attained by a path).\n\n    2. Density bound: 2 if density > 0.5, otherwise n – 1.\n       – If the graph is dense enough (density > 0.5) its diameter is at most 2.\n\n    3. Moore bound using maximum degree Δ:\n       * If Δ ≤ 2, the bound is n – 1.\n       * Otherwise, bound = minimal D such that\n         1 + Δ + Δ(Δ–1) + … + Δ(Δ–1)^(D–1) ≥ n.\n       – This is an upper bound on the diameter, hence also on ASPL.\n\n    The minimum of these guarantees a valid upper bound while being tighter than the\n    trivial bound n – 1 for most graphs.\n    \"\"\"\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # 1. Path‑graph bound\n    path_bound = (n * n - 1) / (3 * (n - 1))\n\n    # 2. Density bound\n    density = s.get('density', 0.0)\n    density_bound = 2.0 if density > 0.5 else n - 1\n\n    # 3. Moore bound using maximum degree\n    max_deg = s.get('max_degree', 1)\n    if max_deg <= 2:\n        moore_max = n - 1\n    else:\n        nodes = 1          # nodes reachable within current radius\n        power = 1          # (max_deg-1)^radius\n        radius = 0\n        while nodes < n:\n            nodes += max_deg * power\n            power *= (max_deg - 1)\n            radius += 1\n        moore_max = radius + 1   # add one to be safe\n\n    # Take the tightest guaranteed upper bound\n    final = path_bound\n    if density_bound < final:\n        final = density_bound\n    if moore_max < final:\n        final = moore_max\n\n    return float(final)",
        "island_id": 1,
        "generation": 16,
        "train_score": 0.5001220305679176,
        "val_score": 0.44707838093257324,
        "simplicity_score": 0.16787674194924368,
        "novelty_bonus": 0.5521213665879059
      }
    ],
    "2": [
      {
        "id": "g10_i2_p1_908580690",
        "code": "def new_invariant(s):\n    \"\"\"\n    A guaranteed upper bound on the average shortest path length (ASPL)\n    for any connected graph, expressed solely in terms of pre‑computed\n    graph statistics.  The bound is the minimum of several classical\n    bounds that are proven to be greater than or equal to the true ASPL.\n    The bounds used are:\n\n    1. **Path‑graph bound** – (n + 1) / 3.\n    2. **Average‑degree bound** – n / (avg_degree + 1).\n    3. **Maximum‑degree bound** – n / (max_degree + 1) + 1.\n    4. **Minimum‑degree (Moore‑like) bound** – the smallest integer r\n       such that 1 + δ * ((δ‑1)^r – 1)/(δ‑2) ≥ n, where δ is the\n       minimum degree (for δ ≤ 2 the bound is n – 1).\n    5. **Density bound** – (n – 1) * (1 – density) + 1.\n\n    The smallest of these bounds is returned, clamped to a minimum of\n    1.0 for graphs with at least two nodes.  For a single‑vertex graph\n    the ASPL is defined to be 0.0.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Required keys are:\n            - 'n'          : number of nodes\n            - 'avg_degree' : average degree (2m/n)\n            - 'max_degree' : maximum degree in the graph\n            - 'min_degree' : minimum degree in the graph\n            - 'density'    : edge density in [0, 1]\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n\n    # 1. Path‑graph bound\n    path_bound = (n + 1) / 3.0\n\n    # 2. Average‑degree bound\n    avg_deg_bound = n / (avg_deg + 1.0)\n\n    # 3. Maximum‑degree bound\n    max_deg_bound = n / (max_deg + 1.0) + 1.0\n\n    # 4. Minimum‑degree (Moore‑like) bound\n    if min_deg <= 2:\n        min_deg_bound = float(n - 1)\n    else:\n        r = 0\n        reachable = 1\n        power = 1  # (min_deg - 1)^r\n        while reachable < n:\n            r += 1\n            power *= (min_deg - 1)\n            reachable = 1 + min_deg * (power - 1) // (min_deg - 2)\n        min_deg_bound = float(r)\n\n    # 5. Density bound\n    density_bound = (n - 1) * (1.0 - density) + 1.0\n\n    # Choose the tightest (smallest) bound\n    bound = path_bound\n    if avg_deg_bound < bound:\n        bound = avg_deg_bound\n    if max_deg_bound < bound:\n        bound = max_deg_bound\n    if min_deg_bound < bound:\n        bound = min_deg_bound\n    if density_bound < bound:\n        bound = density_bound\n\n    # Ensure the bound is at least 1 for non‑trivial graphs\n    if bound < 1.0:\n        bound = 1.0\n\n    return bound",
        "island_id": 2,
        "generation": 10,
        "train_score": 0.3284155921582774,
        "val_score": 0.2876880254278286,
        "simplicity_score": 0.20607055338754615,
        "novelty_bonus": 0.2801582900665318
      },
      {
        "id": "g17_i2_p1_905532189",
        "code": "def new_invariant(s):\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    # Path‑graph bound: ASPL of a simple path of length n‑1\n    path_bound = (n + 1) / 3.0\n\n    # Moore diameter bound using maximum degree Δ\n    max_deg = s['max_degree']\n    if max_deg <= 2:\n        moore_bound = float(n - 1)\n    else:\n        r = 0\n        reachable = 1\n        while reachable < n:\n            r += 1\n            reachable = 1 + max_deg * ((pow(max_deg - 1, r) - 1) // (max_deg - 2))\n        moore_bound = float(r)\n\n    # Tightest bound\n    bound = path_bound if path_bound < moore_bound else moore_bound\n    if bound < 1.0:\n        bound = 1.0\n    return bound",
        "island_id": 2,
        "generation": 17,
        "train_score": 0.12019794560048529,
        "val_score": 0.28486016925849333,
        "simplicity_score": 0.21194344497270995,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g16_i2_p1_916011844",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound on the average shortest path length (ASPL) for any connected graph.\n    The bound is the minimum of two provably valid upper bounds:\n    1. Path‑graph bound: (n + 1) / 3.\n    2. Moore diameter bound: the smallest integer r such that\n       1 + Δ·((Δ‑1)^r – 1)/(Δ‑2) ≥ n  (Δ = max_degree).  For Δ ≤ 2 the bound\n       is simply n – 1.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Required keys are:\n            - 'n'          : number of nodes\n            - 'max_degree' : maximum degree in the graph\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    # 1. Path‑graph bound\n    path_bound = (n + 1) / 3.0\n\n    # 2. Moore diameter bound\n    max_deg = s['max_degree']\n    if max_deg <= 2:\n        moore_bound = float(n - 1)\n    else:\n        r = 0\n        reachable = 1\n        # Use integer arithmetic; the loop terminates quickly because growth is exponential\n        while reachable < n:\n            r += 1\n            reachable = 1 + max_deg * ((pow(max_deg - 1, r) - 1) // (max_deg - 2))\n        moore_bound = float(r)\n\n    # Take the tighter (smaller) bound\n    bound = path_bound if path_bound < moore_bound else moore_bound\n\n    # ASPL is at least 1 for any connected graph with n >= 2\n    if bound < 1.0:\n        bound = 1.0\n\n    return bound",
        "island_id": 2,
        "generation": 16,
        "train_score": 0.12019794560048529,
        "val_score": 0.28482957502398043,
        "simplicity_score": 0.21179047380014548,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g9_i2_p4_152312102",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound on the average shortest path length (ASPL) for any connected graph.\n\n    The bound is the minimum of several mathematically guaranteed upper bounds\n    that depend only on pre‑computed graph statistics.  Each individual bound is\n    proven to be greater than or equal to the true ASPL, so taking their minimum\n    preserves validity while usually giving a tighter estimate.\n\n    Proven bounds used:\n\n    1. **Path‑graph bound** – The ASPL of a simple path of length n‑1 is\n       (n + 1)/3.  No connected graph can have a larger average distance,\n       so ASPL ≤ (n + 1)/3.\n\n    2. **Moore diameter bound** – For a graph with maximum degree Δ,\n       the diameter is at most the smallest integer r such that\n           1 + Δ·((Δ‑1)^r – 1)/(Δ‑2) ≥ n   (for Δ > 2).\n       Since ASPL ≤ diameter, this gives a valid upper bound.\n\n    3. **Average‑degree bound** – Let d̄ be the average degree.\n       A simple counting argument shows that ASPL ≤ n/(d̄ + 1).\n\n    The smallest of these bounds is returned.  For a single‑vertex graph\n    the ASPL is defined to be 0.  The result is clamped to a minimum of\n    1.0 for non‑trivial graphs to avoid returning values below the\n    theoretical lower bound.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Required keys are:\n            - 'n'          : number of nodes\n            - 'm'          : number of edges\n            - 'avg_degree' : average degree (2m/n)\n            - 'max_degree' : maximum degree in the graph\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n\n    # 1. Path‑graph bound\n    path_bound = (n + 1) / 3.0\n\n    # 2. Moore diameter bound\n    if max_deg <= 2:\n        moore_bound = float(n - 1)\n    else:\n        r = 0\n        reachable = 1\n        power = 1  # (Δ‑1)^r\n        while reachable < n:\n            r += 1\n            power *= (max_deg - 1)\n            reachable = 1 + max_deg * (power - 1) // (max_deg - 2)\n        moore_bound = float(r)\n\n    # 3. Average‑degree bound\n    # (Average degree is always > 0 for n >= 2)\n    avg_deg_bound = n / (avg_deg + 1.0)\n\n    # Take the tightest bound\n    bound = min(path_bound, moore_bound, avg_deg_bound)\n\n    # ASPL is at least 1 for any connected graph with n >= 2\n    if bound < 1.0:\n        bound = 1.0\n\n    return bound",
        "island_id": 2,
        "generation": 9,
        "train_score": 0.12019794560048529,
        "val_score": 0.28451472212051826,
        "simplicity_score": 0.21021620928283472,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g17_i2_p2_255965090",
        "code": "def new_invariant(s):\n    \"\"\"\n    Guaranteed upper bound on the average shortest path length (ASPL) of a\n    connected graph, expressed solely in terms of pre‑computed graph\n    statistics.\n\n    The bound is the minimum of three provably valid upper bounds:\n\n    1. Path‑graph bound – the ASPL of a simple path on n vertices,\n       which is (n + 1) / 3.  No connected graph can have a larger\n       average distance, so ASPL ≤ (n + 1) / 3.\n\n    2. Moore diameter bound – for a graph with maximum degree Δ,\n       the diameter is at most the smallest integer r such that\n       1 + Δ·((Δ‑1)^r – 1)/(Δ‑2) ≥ n (for Δ > 2).  Since ASPL ≤\n       diameter, this provides a valid upper bound.\n\n    3. Average‑degree bound – let d̄ be the average degree.  A simple\n       counting argument shows ASPL ≤ n / (d̄ + 1).\n\n    The smallest of these bounds is returned, clamped to a minimum\n    of 1.0 for any non‑trivial graph (n ≥ 2).  For a single‑vertex\n    graph the ASPL is defined to be 0.0.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Required keys are:\n            - 'n'          : number of nodes\n            - 'avg_degree' : average degree (2m/n)\n            - 'max_degree' : maximum degree in the graph\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    # 1. Path‑graph bound\n    path_bound = (n + 1) / 3.0\n\n    # 2. Moore diameter bound\n    max_deg = s['max_degree']\n    if max_deg <= 2:\n        moore_bound = float(n - 1)\n    else:\n        r = 0\n        reachable = 1\n        # Grow reachable nodes exponentially until we cover all n nodes\n        while reachable < n:\n            r += 1\n            reachable = 1 + max_deg * ((pow(max_deg - 1, r) - 1) // (max_deg - 2))\n        moore_bound = float(r)\n\n    # 3. Average‑degree bound\n    avg_deg = s['avg_degree']\n    avg_deg_bound = n / (avg_deg + 1.0)\n\n    # Choose the tightest bound\n    bound = path_bound\n    if moore_bound < bound:\n        bound = moore_bound\n    if avg_deg_bound < bound:\n        bound = avg_deg_bound\n\n    # Ensure the bound is at least 1 for non‑trivial graphs\n    if bound < 1.0:\n        bound = 1.0\n\n    return bound",
        "island_id": 2,
        "generation": 17,
        "train_score": 0.12019794560048529,
        "val_score": 0.28437286882104684,
        "simplicity_score": 0.2095069427854777,
        "novelty_bonus": 0.5521213665879059
      }
    ],
    "3": [
      {
        "id": "g11_i3_p2_176772782",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound on the average shortest‑path length (ASPL) for any connected,\n    undirected, simple graph.  The bound is the minimum of two provable\n    inequalities that depend solely on the pre‑computed features in *s*.\n    \n    1. Path‑graph bound:  (n + 1) / 3.  \n       For a simple path on n vertices the ASPL is exactly this value and\n       no connected graph can have a larger ASPL.\n\n    2. Moore diameter bound:  r  (the smallest integer satisfying the\n       Moore inequality).  The Moore inequality guarantees that the\n       diameter of the graph is at most r, hence ASPL ≤ r.  This bound\n       uses the maximum degree Δ and the node count n.\n\n    The function returns the tighter of the two bounds.  All arithmetic\n    uses only built‑in operators; no external modules are imported,\n    respecting the sandbox restrictions.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n'          : number of vertices (int, >= 1)\n            - 'max_degree' : maximum degree (int, >= 1)\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    # Basic graph size\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # Path‑graph bound\n    path_bound = (n + 1) / 3.0\n\n    # Moore diameter bound\n    max_deg = s.get('max_degree', 0)\n    if max_deg <= 0:\n        moore_bound = float(n - 1)\n    elif max_deg <= 2:\n        # For Δ = 1 or 2 the worst case diameter is n-1\n        moore_bound = float(n - 1)\n    else:\n        # Find the smallest integer r such that\n        # 1 + Δ * ((Δ-1)^r - 1) / (Δ-2) >= n\n        r = 0\n        reachable = 1          # vertices reachable within r steps\n        power = 1              # (Δ-1)^r\n        # iterate until the bound is satisfied\n        while reachable < n:\n            r += 1\n            power *= (max_deg - 1)\n            # use floating arithmetic to avoid overflow\n            reachable = 1 + max_deg * (power - 1) / (max_deg - 2)\n        moore_bound = float(r)\n\n    # Return the tighter of the two bounds\n    if moore_bound < path_bound:\n        return moore_bound\n    else:\n        return path_bound",
        "island_id": 3,
        "generation": 11,
        "train_score": 0.12019794560048529,
        "val_score": 0.29323971130365156,
        "simplicity_score": 0.25384115519850103,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g16_i3_p2_141262147",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound on the average shortest‑path length (ASPL) for any\n    connected, undirected, simple graph.\n\n    The bound is the minimum of two provable inequalities that depend\n    only on pre‑computed graph statistics contained in *s*.\n\n    1.  **Path‑graph bound** – A path on *n* vertices has the largest\n        possible ASPL among all connected graphs:\n              ASPL ≤ (n + 1) / 3\n\n    2.  **Moore diameter bound** – If Δ is the maximum degree,\n        the diameter is at most the smallest integer *r* satisfying\n\n                 1 + Δ * ((Δ‑1)^r – 1) / (Δ‑2)  ≥  n     (Δ > 2)\n\n        For Δ = 1 or 2 the worst case diameter is n – 1.  Because\n        ASPL ≤ diameter, the same value of *r* is a valid upper bound\n        for the ASPL.\n\n    The minimum of these two bounds is returned.  All arithmetic uses\n    built‑in operators only; no external modules or graph traversal\n    algorithms are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Required keys:\n\n            'n'          : number of nodes (int, ≥ 1)\n            'max_degree' : maximum degree in the graph (int, ≥ 1)\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    # --- Basic graph size ---------------------------------------------\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # --- Path‑graph bound -----------------------------------------------\n    path_bound = (n + 1) / 3.0\n\n    # --- Moore diameter bound ------------------------------------------\n    max_deg = s.get('max_degree', 0)\n    if max_deg <= 1:\n        moore_bound = float(n - 1)\n    elif max_deg == 2:\n        moore_bound = float(n - 1)\n    else:\n        # Find the smallest integer r such that\n        #   1 + Δ * ((Δ-1)^r – 1) / (Δ-2)  ≥  n\n        r = 0\n        reach = 1            # vertices reachable within r steps\n        power = 1            # (Δ-1)^r\n        # iterate until the inequality holds\n        while reach < n:\n            r += 1\n            power *= (max_deg - 1)\n            reach = 1 + max_deg * (power - 1) // (max_deg - 2)\n        moore_bound = float(r)\n\n    # --- Final bound: the tighter of the two provable upper bounds -----\n    bound = path_bound if path_bound < moore_bound else moore_bound\n    return bound",
        "island_id": 3,
        "generation": 16,
        "train_score": 0.12019794560048529,
        "val_score": 0.28460400082058923,
        "simplicity_score": 0.2106626027831897,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g11_i3_p4_856614283",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound on the average shortest‑path length (ASPL) for a connected,\n    undirected, simple graph, expressed solely in terms of pre‑computed\n    features in ``s``.\n\n    The bound is the minimum of two provable inequalities:\n\n    1. **Path‑graph bound** – The ASPL of a simple path on *n* vertices is\n       (n + 1)/3.  No connected graph can have a larger ASPL, so\n       ASPL ≤ (n + 1)/3.\n\n    2. **Moore diameter bound** – Let Δ be the maximum degree.  In any\n       graph with maximum degree Δ the number of vertices reachable from a\n       source within *r* steps is at most\n\n            1 + Δ · ((Δ – 1)^r – 1) / (Δ – 2)    (Δ > 2)\n\n       The smallest integer *r* satisfying the inequality above is an\n       upper bound on the diameter, hence on the ASPL.\n\n    Because each inequality individually bounds ASPL from above, their\n    minimum also bounds ASPL.  The function therefore returns a\n    guaranteed upper bound without computing any shortest‑path\n    algorithms.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys:\n\n            'n'          : number of vertices\n            'max_degree' : maximum degree in the graph\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    # ---- basic graph size ----------------------------------------------------\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # ---- path‑graph bound ----------------------------------------------------\n    path_bound = (n + 1) / 3.0\n\n    # ---- Moore diameter bound ------------------------------------------------\n    max_deg = s.get('max_degree', 0)\n    if max_deg <= 1:\n        # The only connected graph with max degree 1 is a path:\n        moore = float(n - 1)\n    elif max_deg == 2:\n        # Path or cycle: diameter is ceil((n‑1)/2)\n        moore = float((n - 1 + 1) // 2)\n    else:\n        # General case: iteratively find the smallest r with the Moore bound\n        r = 0\n        reach = 1          # number of vertices reachable within r steps\n        power = 1          # (Δ‑1)^r\n        while reach < n:\n            r += 1\n            power *= (max_deg - 1)\n            # integer division gives a safe lower estimate; we stop only when\n            # the estimate is at least n, ensuring the bound is valid.\n            reach = 1 + max_deg * (power - 1) // (max_deg - 2)\n        moore = float(r)\n\n    # ---- final bound: the tighter of the two provable upper bounds ------------\n    bound = path_bound if path_bound < moore else moore\n    return bound",
        "island_id": 3,
        "generation": 11,
        "train_score": 0.12019794560048529,
        "val_score": 0.28452716315274457,
        "simplicity_score": 0.21027841444396633,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g9_i2_p4_152312102",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound on the average shortest path length (ASPL) for any connected graph.\n\n    The bound is the minimum of several mathematically guaranteed upper bounds\n    that depend only on pre‑computed graph statistics.  Each individual bound is\n    proven to be greater than or equal to the true ASPL, so taking their minimum\n    preserves validity while usually giving a tighter estimate.\n\n    Proven bounds used:\n\n    1. **Path‑graph bound** – The ASPL of a simple path of length n‑1 is\n       (n + 1)/3.  No connected graph can have a larger average distance,\n       so ASPL ≤ (n + 1)/3.\n\n    2. **Moore diameter bound** – For a graph with maximum degree Δ,\n       the diameter is at most the smallest integer r such that\n           1 + Δ·((Δ‑1)^r – 1)/(Δ‑2) ≥ n   (for Δ > 2).\n       Since ASPL ≤ diameter, this gives a valid upper bound.\n\n    3. **Average‑degree bound** – Let d̄ be the average degree.\n       A simple counting argument shows that ASPL ≤ n/(d̄ + 1).\n\n    The smallest of these bounds is returned.  For a single‑vertex graph\n    the ASPL is defined to be 0.  The result is clamped to a minimum of\n    1.0 for non‑trivial graphs to avoid returning values below the\n    theoretical lower bound.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Required keys are:\n            - 'n'          : number of nodes\n            - 'm'          : number of edges\n            - 'avg_degree' : average degree (2m/n)\n            - 'max_degree' : maximum degree in the graph\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n\n    # 1. Path‑graph bound\n    path_bound = (n + 1) / 3.0\n\n    # 2. Moore diameter bound\n    if max_deg <= 2:\n        moore_bound = float(n - 1)\n    else:\n        r = 0\n        reachable = 1\n        power = 1  # (Δ‑1)^r\n        while reachable < n:\n            r += 1\n            power *= (max_deg - 1)\n            reachable = 1 + max_deg * (power - 1) // (max_deg - 2)\n        moore_bound = float(r)\n\n    # 3. Average‑degree bound\n    # (Average degree is always > 0 for n >= 2)\n    avg_deg_bound = n / (avg_deg + 1.0)\n\n    # Take the tightest bound\n    bound = min(path_bound, moore_bound, avg_deg_bound)\n\n    # ASPL is at least 1 for any connected graph with n >= 2\n    if bound < 1.0:\n        bound = 1.0\n\n    return bound",
        "island_id": 2,
        "generation": 9,
        "train_score": 0.12019794560048529,
        "val_score": 0.28451472212051826,
        "simplicity_score": 0.21021620928283472,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g14_i3_p0_937826454",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound on the average shortest‑path length (ASPL) for any connected,\n    undirected, simple graph.\n\n    The bound is the minimum of three provable upper bounds that depend\n    solely on pre‑computed features:\n\n    1. **Path‑graph bound**  \n       For a simple path on n vertices the ASPL is (n+1)/3.  \n       No connected graph can have a larger ASPL, so\n\n           ASPL ≤ (n + 1) / 3\n\n    2. **Moore diameter bound**  \n       Let Δ be the maximum degree.  In any graph with maximum degree Δ,\n       the number of vertices that can be reached from a single vertex\n       within r steps is at most\n\n              1 + Δ·((Δ‑1)^r – 1) / (Δ‑2)      (Δ > 2)\n\n       The smallest integer r satisfying this inequality is an upper bound\n       on the diameter, hence on the ASPL.\n\n    3. **Average‑degree bound**  \n       If d̄ is the average degree, then an elementary counting argument\n       gives\n\n              ASPL ≤ n / (d̄ + 1)\n\n    The function returns the tightest of the three bounds, clamped to at\n    least 1.0 for non‑trivial graphs (the clique has ASPL = 1).\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics.  Required keys:\n\n            'n'          : number of vertices (int, ≥ 1)\n            'avg_degree' : average degree (float)\n            'max_degree' : maximum degree (int, ≥ 1)\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    max_deg = s['max_degree']\n    avg_deg = s['avg_degree']\n\n    # 1. Path‑graph bound\n    path_bound = (n + 1) / 3.0\n\n    # 2. Moore diameter bound\n    if max_deg <= 2:\n        moore_bound = float(n - 1)\n    else:\n        r = 0\n        reachable = 1          # vertices reachable within r steps\n        power = 1              # (Δ‑1)^r\n        while reachable < n:\n            r += 1\n            power *= (max_deg - 1)\n            reachable = 1 + max_deg * (power - 1) / (max_deg - 2)\n        moore_bound = float(r)\n\n    # 3. Average‑degree bound\n    avg_deg_bound = n / (avg_deg + 1.0)\n\n    # Take the tightest bound\n    bound = min(path_bound, moore_bound, avg_deg_bound)\n\n    # The ASPL of a connected graph with ≥ 2 vertices is at least 1\n    if bound < 1.0:\n        bound = 1.0\n\n    return bound",
        "island_id": 3,
        "generation": 14,
        "train_score": 0.12019794560048529,
        "val_score": 0.28451472212051826,
        "simplicity_score": 0.21021620928283472,
        "novelty_bonus": 0.5521213665879059
      }
    ]
  }
}