{
  "schema_version": 3,
  "experiment_id": "seed_44",
  "fitness_mode": "correlation",
  "model_name": "gpt-oss:20b",
  "best_candidate_id": "g17_i3_p2_898326347",
  "best_candidate_code_sha256": "7cfc7278a9816a7bbe7b54cc0007bbf497e95418ecee2c990aaf68896f9ca421",
  "best_val_score": 0.534056960060647,
  "stop_reason": "max_generations_reached",
  "success": false,
  "config": {
    "seed": 44,
    "target_name": "average_shortest_path_length",
    "num_train_graphs": 50,
    "num_val_graphs": 200,
    "num_test_graphs": 200,
    "max_generations": 20,
    "population_size": 5,
    "migration_interval": 10,
    "island_temperatures": [
      0.3,
      0.3,
      0.8,
      1.2
    ],
    "timeout_sec": 2.0,
    "memory_mb": 256,
    "sandbox_max_workers": null,
    "alpha": 0.5,
    "beta": 0.2,
    "gamma": 0.3,
    "train_score_threshold": 0.3,
    "early_stop_patience": 10,
    "artifacts_dir": "artifacts/benchmark_aspl/benchmark_20260215T230550Z/seed_44",
    "model_name": "gpt-oss:20b",
    "ollama_url": "http://localhost:11434/api/generate",
    "allow_remote_ollama": false,
    "checkpoint_keep_last": 3,
    "experiment_id": "seed_44",
    "enable_constrained_fallback": true,
    "stagnation_trigger_generations": 5,
    "constrained_recovery_generations": 3,
    "allow_late_constrained_recovery": true,
    "run_baselines": true,
    "persist_candidate_code_in_summary": true,
    "success_spearman_threshold": 0.85,
    "pysr_niterations": 30,
    "pysr_populations": 8,
    "pysr_procs": 0,
    "pysr_timeout_in_seconds": 60.0,
    "benchmark_seeds": [
      11,
      22,
      33,
      44,
      55
    ],
    "novelty_bootstrap_samples": 1000,
    "novelty_threshold": 0.7,
    "enforce_pysr_parity_for_success": true,
    "pysr_parity_epsilon": 0.0,
    "require_baselines_for_success": true,
    "persist_prompt_and_response_logs": true,
    "llm_timeout_sec": 600.0,
    "enable_self_correction": true,
    "self_correction_max_retries": 1,
    "self_correction_feedback_window": 3,
    "novelty_gate_threshold": 0.15,
    "fitness_mode": "correlation",
    "bound_tolerance": 1e-09,
    "success_bound_score_threshold": 0.7,
    "success_satisfaction_threshold": 0.95,
    "enable_map_elites": false,
    "map_elites_bins": 5
  },
  "final_generation": 20,
  "island_candidate_counts": {
    "0": 5,
    "1": 5,
    "2": 5,
    "3": 5
  },
  "train_metrics": {
    "spearman": 0.9059783913565426,
    "pearson": 0.7425193425743162,
    "rmse": 15.086354727226542,
    "mae": 9.472956181096553,
    "valid_count": 50,
    "novelty_bonus": null
  },
  "val_metrics": {
    "spearman": 0.9090632265806646,
    "pearson": 0.6940050794647314,
    "rmse": 24.229180903730708,
    "mae": 13.105276335722351,
    "valid_count": 200,
    "novelty_bonus": 0.15318172152652532
  },
  "test_metrics": {
    "spearman": 0.8731478286957175,
    "pearson": 0.6837157969370199,
    "rmse": 26.448236271447875,
    "mae": 12.68261496365077,
    "valid_count": 200,
    "novelty_bonus": 0.23372234305857642
  },
  "sanity_metrics": {
    "spearman": 0.5,
    "pearson": 0.7156777963679616,
    "rmse": 14.92304510671798,
    "mae": 12.913375668630295,
    "valid_count": 3,
    "novelty_bonus": null
  },
  "novelty_ci": {
    "validation": {
      "max_ci_upper_abs_rho": 0.8836300777097182,
      "novelty_passed": false,
      "threshold": 0.7,
      "per_invariant": {
        "density": {
          "point_abs_rho": 0.8468182784734747,
          "ci_upper_abs_rho": 0.8836300777097182
        },
        "clustering_coefficient": {
          "point_abs_rho": 0.2298895925042548,
          "ci_upper_abs_rho": 0.3485079695303988
        },
        "degree_assortativity": {
          "point_abs_rho": 0.285403135078377,
          "ci_upper_abs_rho": 0.39885043400585185
        },
        "transitivity": {
          "point_abs_rho": 0.350961699290909,
          "ci_upper_abs_rho": 0.45932764651754926
        },
        "average_degree": {
          "point_abs_rho": 0.7905725864523284,
          "ci_upper_abs_rho": 0.8379298881033741
        },
        "max_degree": {
          "point_abs_rho": 0.3961040398011498,
          "ci_upper_abs_rho": 0.5085042232344431
        },
        "spectral_radius": {
          "point_abs_rho": 0.6876456911422787,
          "ci_upper_abs_rho": 0.7550275446651301
        },
        "diameter": {
          "point_abs_rho": 0.7455021072113808,
          "ci_upper_abs_rho": 0.7973202581782615
        },
        "algebraic_connectivity": {
          "point_abs_rho": 0.7822290557263932,
          "ci_upper_abs_rho": 0.8329378042706862
        }
      }
    },
    "test": {
      "max_ci_upper_abs_rho": 0.8224239814816202,
      "novelty_passed": false,
      "threshold": 0.7,
      "per_invariant": {
        "density": {
          "point_abs_rho": 0.754140214340159,
          "ci_upper_abs_rho": 0.8120999539807096
        },
        "clustering_coefficient": {
          "point_abs_rho": 0.13595231111729872,
          "ci_upper_abs_rho": 0.2528146289881729
        },
        "degree_assortativity": {
          "point_abs_rho": 0.21917647941198534,
          "ci_upper_abs_rho": 0.3264109053796973
        },
        "transitivity": {
          "point_abs_rho": 0.2367730701137502,
          "ci_upper_abs_rho": 0.3544831303871414
        },
        "average_degree": {
          "point_abs_rho": 0.7576782728191298,
          "ci_upper_abs_rho": 0.8157413325985489
        },
        "max_degree": {
          "point_abs_rho": 0.4823590233864814,
          "ci_upper_abs_rho": 0.5820158186164643
        },
        "spectral_radius": {
          "point_abs_rho": 0.7141108527713194,
          "ci_upper_abs_rho": 0.7812140823345035
        },
        "diameter": {
          "point_abs_rho": 0.7023297501727607,
          "ci_upper_abs_rho": 0.7664523649058674
        },
        "algebraic_connectivity": {
          "point_abs_rho": 0.7662776569414236,
          "ci_upper_abs_rho": 0.8224239814816202
        }
      }
    }
  },
  "dataset_fingerprint": "73941d1f3864fe144a9289d5eb9288e3952bac578a0c9f0b3925f3154ec02624",
  "self_correction_stats": {
    "enabled": true,
    "max_retries": 1,
    "feedback_window": 3,
    "attempted_repairs": 76,
    "successful_repairs": 33,
    "failed_repairs": 43,
    "failure_categories": {
      "no_valid_train_predictions": 60,
      "below_novelty_threshold": 47,
      "below_train_threshold": 58
    }
  },
  "baseline_comparison": {
    "candidate": {
      "val_spearman": 0.9090632265806646,
      "test_spearman": 0.8731478286957175
    },
    "pysr": {
      "status": "ok",
      "val_spearman": 0.9723603090077254,
      "test_spearman": 0.9631065776644419
    }
  },
  "success_criteria": {
    "success_spearman_threshold": 0.85,
    "threshold_passed": true,
    "require_baselines_for_success": true,
    "baselines_available": true,
    "baselines_healthy": true,
    "stat_baseline_ok": true,
    "pysr_ok": true,
    "baselines_passed": true,
    "enforce_pysr_parity_for_success": true,
    "pysr_parity_epsilon": 0.0,
    "pysr_status": "ok",
    "candidate_val_spearman": 0.9090632265806646,
    "pysr_val_spearman": 0.9723603090077254,
    "pysr_parity_passed": false,
    "pysr_parity_reason": "ok"
  },
  "best_candidate_code": "def new_invariant(s):\n    \"\"\"\n    Compute a closed‑form estimate of the average shortest‑path length\n    from a handful of pre‑computed global graph statistics.\n    The expression mixes logarithms, exponentials, polynomial\n    exponents, and ratios of complementary metrics so that it is\n    highly nonlinear and does not collapse to a single feature.\n\n    Parameters\n    ----------\n    s : dict\n        A dictionary that may contain the keys listed below. Missing\n        keys are treated as neutral values (0, 1 or empty list as\n        appropriate).\n\n        - n                       : int          number of nodes\n        - density                 : float        edge density (0‑1)\n        - avg_degree              : float\n        - max_degree              : int\n        - min_degree              : int\n        - std_degree              : float\n        - avg_clustering          : float\n        - transitivity            : float\n        - degree_assortativity    : float\n        - num_triangles           : int\n        - degrees                 : list[int]    degree sequence\n\n    Returns\n    -------\n    float\n        A dimensionless estimate that tracks the real average shortest‑path\n        length, but is derived purely algebraically from the supplied\n        statistics.\n    \"\"\"\n    # Helper: guard against missing keys\n    n                = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    density          = s.get('density', 0.0)\n    avg_degree       = s.get('avg_degree', 0.0)\n    max_degree       = s.get('max_degree', 0)\n    min_degree       = s.get('min_degree', 0)\n    std_degree       = s.get('std_degree', 0.0)\n    avg_clust        = s.get('avg_clustering', 0.0)\n    transitivity     = s.get('transitivity', 0.0)\n    assort           = s.get('degree_assortativity', 0.0)\n    num_tri          = s.get('num_triangles', 0)\n    degrees          = s.get('degrees', [])\n\n    # --- 1. Size scaling (√n) --------------------------------------------------\n    val = n ** 0.5\n\n    # --- 2. Cohesion boost ----------------------------------------------------\n    # Higher local and global clustering reduces path length\n    val *= (1.0 + avg_clust) ** 2.0\n    val *= (1.0 + transitivity) ** 1.5\n\n    # --- 3. Density / degree penalty -----------------------------------------\n    # Sparse graphs inflate distances; dense graphs compress them\n    val /= max(density, 1e-4)                  # avoid division by zero\n\n    # Logistic decrease with average degree\n    val *= (1.0 + avg_degree) ** (-1.0)\n    # Further attenuation for graphs with extremely low average degree\n    val *= (1.0 + avg_degree) ** (-0.5)\n\n    # --- 4. Heterogeneity amplification --------------------------------------\n    # Coefficient of variation raised to a power\n    cv = std_degree / max(avg_degree, 1e-4)\n    val *= (1.0 + cv) ** 1.2\n\n    # Influence of extremes in degree distribution\n    min_ratio = min_degree / max(max_degree, 1) if max_degree else 0.0\n    val *= (1.0 + min_ratio) ** 0.8\n\n    # --- 5. Assortativity modulation -----------------------------------------\n    val /= (1.0 + abs(assort) ** 2.0)          # penalise extreme assortativity\n\n    # --- 6. Triangle density factor -----------------------------------------\n    tri_max = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    tri_density = num_tri / max(tri_max, 1e-4)\n    val *= (1.0 + tri_density) ** 0.9\n\n    # --- 7. Harmonic mean degree influence ------------------------------------\n    if degrees:\n        # robust harmonic mean (skip zeros)\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0.0:\n            h_mean = len(degrees) / inv_sum\n            # low harmonic mean (many low‑degree nodes) increases distances\n            val *= (h_mean / max(avg_degree, 1.0)) ** 0.7\n\n    return float(val)"
}