{
  "experiment_id": "seed_33",
  "generation": 18,
  "rng_seed": 33,
  "rng_state": {
    "bit_generator": "PCG64",
    "state": {
      "state": 138225776696792155462169757647145529446,
      "inc": 188490382446918006255810903505410875475
    },
    "has_uint32": 0,
    "uinteger": 180284307
  },
  "best_val_score": 0.5492830341781751,
  "no_improve_count": 1,
  "island_stagnation": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_prompt_mode": {
    "0": "free",
    "1": "free",
    "2": "free",
    "3": "free"
  },
  "island_constrained_generations": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_recent_failures": {
    "0": [
      "below_train_threshold: train_signal=0.018776",
      "no_valid_train_predictions: static_invalid: invalid syntax: leading zeros in decimal integer literals are not permitted; use an 0o prefix for octal integers",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ],
    "1": [
      "below_train_threshold: train_signal=0.296134",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_train_threshold: train_signal=0.194430"
    ],
    "2": [
      "below_novelty_threshold: novelty_bonus=0.109158",
      "below_novelty_threshold: novelty_bonus=0.140599",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ],
    "3": [
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_train_threshold: train_signal=0.276255",
      "no_valid_train_predictions: static_invalid: forbidden call detected: locals"
    ]
  },
  "islands": {
    "0": [
      {
        "id": "g16_i0_p0_269753045",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The expression is compact and interpretable, combining size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n\n    # Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.55)\n\n    # Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base",
        "island_id": 0,
        "generation": 16,
        "train_score": 0.874765906362545,
        "val_score": 0.5492830341781751,
        "simplicity_score": 0.22084478163114366,
        "novelty_bonus": 0.17365334133353327
      },
      {
        "id": "g16_i0_p3_64161739",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Fraction of leaf nodes (degree = 1)\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.42) / (avg_deg ** 0.58)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density ** 0.65 + (max_deg / (n + 1.0)) ** 0.45)\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.75)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.55)\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering * 0.85)\n    base *= (1.0 + trans * 0.85)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort) * 0.65)\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0) * 0.45\n\n    # 7. Fraction of leaf nodes tends to increase path lengths\n    base *= (1.0 + leaf_frac * 0.45)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 1.75)\n\n    return base",
        "island_id": 0,
        "generation": 16,
        "train_score": 0.8685234093637455,
        "val_score": 0.5474963395108083,
        "simplicity_score": 0.22084478163114366,
        "novelty_bonus": 0.17808295207380165
      },
      {
        "id": "g17_i0_p2_248953978",
        "code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / n\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base",
        "island_id": 0,
        "generation": 17,
        "train_score": 0.828859543817527,
        "val_score": 0.5466749939920976,
        "simplicity_score": 0.22125258623001443,
        "novelty_bonus": 0.2043064947762897
      },
      {
        "id": "g15_i0_p1_139821265",
        "code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base",
        "island_id": 0,
        "generation": 15,
        "train_score": 0.828859543817527,
        "val_score": 0.5466511641442053,
        "simplicity_score": 0.22113343699055302,
        "novelty_bonus": 0.2043064947762897
      },
      {
        "id": "g17_i0_p3_11445063",
        "code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n\n    base = (n ** 0.45) / (avg_deg ** 0.55)\n    base /= (1.0 + density ** 0.6 + (max_deg / (n + 1.0)) ** 0.5)\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0) * 0.7)\n    base *= (1.0 + std_deg / (avg_deg + 1.0) * 0.5)\n    base *= (1.0 + clustering * 0.8)\n    base *= (1.0 + trans * 0.8)\n    base /= (1.0 + abs(assort) * 0.6)\n    base += triangles / (n ** 2 + 1.0) * 0.4\n    base *= (1.0 + leaf_frac * 0.4)\n    base /= (1.0 + density ** 1.7)\n\n    return base",
        "island_id": 0,
        "generation": 17,
        "train_score": 0.828859543817527,
        "val_score": 0.5466511641442053,
        "simplicity_score": 0.22113343699055302,
        "novelty_bonus": 0.2043064947762897
      }
    ],
    "1": [
      {
        "id": "g8_i0_p0_87344662",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula is a compact, interpretable combination of size, degree\n    distribution, density, clustering, transitivity, assortativity,\n    triangle counts, and the fraction of leaf nodes.  No graph traversal\n    is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base",
        "island_id": 0,
        "generation": 8,
        "train_score": 0.7186074429771908,
        "val_score": 0.5273345223747135,
        "simplicity_score": 0.22191621004497614,
        "novelty_bonus": 0.25138613993252834
      },
      {
        "id": "g13_i1_p4_551192281",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features\n    is used.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n * n + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base",
        "island_id": 1,
        "generation": 13,
        "train_score": 0.7186074429771908,
        "val_score": 0.5273016933048652,
        "simplicity_score": 0.22175206469573494,
        "novelty_bonus": 0.25138613993252834
      },
      {
        "id": "g11_i1_p1_51017190",
        "code": "def new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base",
        "island_id": 1,
        "generation": 11,
        "train_score": 0.7186074429771908,
        "val_score": 0.5272952235827552,
        "simplicity_score": 0.2217197160851846,
        "novelty_bonus": 0.25138613993252834
      },
      {
        "id": "g14_i1_p4_930690498",
        "code": "def new_invariant(s):\n    # Extract features with safe defaults\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1.0)          # avoid division by zero\n    density    = s['density']\n    max_deg    = max(s['max_degree'], 1)\n    min_deg    = max(s['min_degree'], 1)\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n ** 0.5) / (avg_deg ** 0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n ** 2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density ** 2)\n\n    return base",
        "island_id": 1,
        "generation": 14,
        "train_score": 0.7186074429771908,
        "val_score": 0.5272952235827552,
        "simplicity_score": 0.2217197160851846,
        "novelty_bonus": 0.25138613993252834
      },
      {
        "id": "g16_i1_p1_342317319",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph statistics.\n    The formula combines size, degree distribution, density, clustering,\n    transitivity, assortativity, triangle counts, and leaf‑node fraction.\n    No graph traversal is performed; only arithmetic on the supplied features is used.\n    \"\"\"\n    # Basic graph features\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1.0   # avoid division by zero\n    density    = s['density']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Base scaling: larger graphs → longer paths, higher avg degree → shorter paths\n    base = (n**0.5) / (avg_deg**0.5)\n\n    # 2. Reduce for dense graphs and for the presence of hubs\n    base /= (1.0 + density + (max_deg / (n + 1.0)))\n\n    # 3. Increase when the degree distribution is uneven\n    base *= (1.0 + (avg_deg - min_deg) / (avg_deg + 1.0))\n    base *= (1.0 + std_deg / (avg_deg + 1.0))\n\n    # 4. Small‑world effect: higher clustering and transitivity shorten paths\n    base *= (1.0 + clustering)\n    base *= (1.0 + trans)\n\n    # 5. Assortativity tends to lengthen paths\n    base /= (1.0 + abs(assort))\n\n    # 6. Minor additive contribution from the number of triangles\n    base += triangles / (n**2 + 1.0)\n\n    # 7. Fraction of leaf nodes (degree = 1) tends to increase path lengths\n    leaf_frac = sum(1 for d in degrees if d == 1) / max(n, 1)\n    base *= (1.0 + leaf_frac)\n\n    # 8. Additional dampening for very dense graphs\n    base /= (1.0 + density**2)\n\n    return base",
        "island_id": 1,
        "generation": 16,
        "train_score": 0.7186074429771908,
        "val_score": 0.5272952235827552,
        "simplicity_score": 0.2217197160851846,
        "novelty_bonus": 0.25138613993252834
      }
    ],
    "2": [
      {
        "id": "g17_i2_p4_808208597",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture density, clustering, transitivity, degree heterogeneity,\n    assortativity, low‑degree vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys include:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float, can be negative)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    possible_tri = n * (n - 1) * (n - 2) // 6 if n > 2 else 1\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    f_clust = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_density = 1.0 / (1.0 + density)\n    f_hetero = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return base * f_clust * f_trans * f_density * f_hetero * f_assort * f_min * f_tri",
        "island_id": 2,
        "generation": 17,
        "train_score": 0.8622809123649459,
        "val_score": 0.5386158732960404,
        "simplicity_score": 0.12747687333604735,
        "novelty_bonus": 0.2439650011795802
      },
      {
        "id": "g15_i2_p3_300294398",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph features.\n    The heuristic starts from a simple random‑graph baseline (n / (avg_degree + 1))\n    and applies multiplicative corrections that capture the influence of density,\n    clustering, transitivity, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s.get('n', 1)\n    avg_deg = s.get('avg_degree', 1.0)\n    if avg_deg < 1.0:\n        avg_deg = 1.0\n    base = n / (avg_deg + 1.0)\n\n    density = s.get('density', 0.0)\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    f_density = 1.0 / (1.0 + density)\n    f_clustering = 1.0 + clustering\n    f_trans = 1.0 + trans\n    f_std = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n    f_assort = 1.0 + 0.5 * abs(assort)\n    f_min = 1.0 + 1.0 / (min_deg + 1.0)\n    f_tri = 1.0 / (1.0 + tri_ratio)\n\n    return (base *\n            f_density *\n            f_clustering *\n            f_trans *\n            f_std *\n            f_assort *\n            f_min *\n            f_tri)",
        "island_id": 2,
        "generation": 15,
        "train_score": 0.8622809123649459,
        "val_score": 0.5384790321446716,
        "simplicity_score": 0.12679266757920307,
        "novelty_bonus": 0.2439650011795802
      },
      {
        "id": "g7_i2_p2_71185593",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min",
        "island_id": 2,
        "generation": 7,
        "train_score": 0.9012725090036015,
        "val_score": 0.5376982263149925,
        "simplicity_score": 0.13591331712960092,
        "novelty_bonus": 0.16448511212780315
      },
      {
        "id": "g12_i2_p1_603953285",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The heuristic starts from a simple random‑graph\n    baseline (n / (avg_degree + 1)) and applies multiplicative corrections\n    that capture the effects of density, clustering, transitivity,\n    degree heterogeneity, assortativity, the presence of very low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n' (int): number of nodes\n            - 'm' (int): number of edges\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)",
        "island_id": 2,
        "generation": 12,
        "train_score": 0.8622809123649459,
        "val_score": 0.537219980299426,
        "simplicity_score": 0.12049740835297465,
        "novelty_bonus": 0.2439650011795802
      },
      {
        "id": "g13_i2_p3_789525634",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed graph\n    statistics.  The heuristic is based on a random‑graph baseline and\n    multiplicative corrections that capture the influence of clustering,\n    transitivity, density, degree heterogeneity, assortativity, low‑degree\n    vertices and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features.  Expected keys are:\n            - 'n' (int)\n            - 'm' (int)\n            - 'density' (float)\n            - 'avg_degree' (float)\n            - 'max_degree' (int or float)\n            - 'min_degree' (int or float)\n            - 'std_degree' (float)\n            - 'avg_clustering' (float, 0–1)\n            - 'transitivity' (float, 0–1)\n            - 'degree_assortativity' (float)\n            - 'num_triangles' (int)\n            - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic random‑graph baseline\n    n = s.get('n', 1)\n    avg_deg = max(s.get('avg_degree', 1.0), 1.0)\n    base = n / (avg_deg + 1.0)\n\n    # Feature values with safe defaults\n    clustering = s.get('avg_clustering', 0.0)\n    trans = s.get('transitivity', 0.0)\n    density = s.get('density', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    assort = s.get('degree_assortativity', 0.0)\n    min_deg = s.get('min_degree', avg_deg)\n    num_tri = s.get('num_triangles', 0)\n\n    # Triangle density ratio\n    possible_tri = n * (n - 1) * (n - 2) / 6 if n > 2 else 0\n    tri_ratio = num_tri / possible_tri if possible_tri else 0\n\n    # Multiplicative correction factors\n    clustering_factor = 1.0 + clustering            # higher clustering → longer paths\n    trans_factor       = 1.0 + trans                  # higher transitivity → longer paths\n    density_factor     = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    hetero_factor      = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))  # heterogeneous degrees → shorter paths\n    assort_factor      = 1.0 + 0.5 * abs(assort)      # more assortative → longer paths\n    min_factor         = 1.0 + 1.0 / (min_deg + 1.0)  # very low min degree lengthens paths\n    tri_factor         = 1.0 / (1.0 + tri_ratio)      # more triangles → shorter paths\n\n    return (base *\n            clustering_factor *\n            trans_factor *\n            density_factor *\n            hetero_factor *\n            assort_factor *\n            min_factor *\n            tri_factor)",
        "island_id": 2,
        "generation": 13,
        "train_score": 0.8622809123649459,
        "val_score": 0.537219980299426,
        "simplicity_score": 0.12049740835297465,
        "novelty_bonus": 0.2439650011795802
      }
    ],
    "3": [
      {
        "id": "g7_i2_p2_71185593",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula uses a simple random‑graph baseline and multiplicative corrections\n    that capture clustering, density, degree heterogeneity, assortativity and the\n    presence of low‑degree vertices.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed features.  Expected keys are:\n        - 'n' (int): number of nodes\n        - 'avg_degree' (float)\n        - 'avg_clustering' (float, 0–1)\n        - 'transitivity' (float, 0–1)\n        - 'density' (float, 0–1)\n        - 'std_degree' (float)\n        - 'min_degree' (int or float)\n        - 'degree_assortativity' (float, can be negative)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = max(s['avg_degree'], 1.0)          # avoid division by zero\n\n    # Basic random‑graph estimate: larger n and smaller avg_degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Multiplicative corrections\n    f_clust      = 1.0 + s['avg_clustering']          # higher clustering → longer paths\n    f_trans      = 1.0 + s['transitivity']            # higher transitivity → longer paths\n    f_assort     = 1.0 + abs(s['degree_assortativity'])  # more assortative → longer paths\n    f_density    = 1.0 / (1.0 + s['density'])        # denser graphs → shorter paths\n    f_std        = 1.0 / (1.0 + s['std_degree'])     # more heterogeneous degrees → shorter paths\n    f_min        = 1.0 / (1.0 + s['min_degree'] / avg_deg)  # very low min degree can lengthen paths\n\n    return base * f_clust * f_trans * f_assort * f_density * f_std * f_min",
        "island_id": 2,
        "generation": 7,
        "train_score": 0.9012725090036015,
        "val_score": 0.5376982263149925,
        "simplicity_score": 0.13591331712960092,
        "novelty_bonus": 0.16448511212780315
      },
      {
        "id": "g17_i3_p3_438166888",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    The formula uses a baseline that grows with the square root of the number of nodes\n    and decreases with the average degree.  A set of multiplicative correction\n    factors captures the effects of clustering, density, degree heterogeneity,\n    assortativity, low‑degree bottlenecks, triangles, and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys (all values are numbers):\n        - n                 : number of nodes\n        - m                 : number of edges\n        - density           : graph density (0–1)\n        - avg_degree        : average degree\n        - max_degree        : maximum degree\n        - min_degree        : minimum degree\n        - std_degree        : standard deviation of degrees\n        - avg_clustering    : average clustering coefficient\n        - transitivity      : global transitivity (unused here)\n        - degree_assortativity : degree assortativity coefficient\n        - num_triangles     : total number of triangles\n        - degrees           : sorted list of degrees (unused here)\n\n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Basic numeric extraction – no imports needed\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    density    = float(s['density'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n\n    # Small epsilon to avoid division by zero\n    eps = 1e-12\n\n    # ---------- Baseline ----------\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    clust_factor     = 1.0 + clust                  # more clustering → longer paths\n    dens_factor      = 1.0 / (1.0 + density)        # denser graphs → shorter paths\n    assort_factor    = 1.0 + abs(assort)             # assortative mixing elongates paths\n    hetero_factor    = 1.0 / (1.0 + std_deg)         # heterogeneous degrees shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # low min degree can create bottlenecks\n    tri_factor       = 1.0 + (num_tri ** 0.5) / (n ** 0.5 + eps)  # triangles tend to shorten paths\n    hub_factor       = (max_deg / (avg_deg + 1.0)) ** 0.5  # presence of hubs reduces distances\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n\n    return estimate",
        "island_id": 3,
        "generation": 17,
        "train_score": 0.6901800720288115,
        "val_score": 0.5183343884539594,
        "simplicity_score": 0.18055555555555555,
        "novelty_bonus": 0.371845035328932
      },
      {
        "id": "g16_i3_p4_334611707",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of global graph statistics.\n    The estimate uses a square‑root dependence on the number of nodes and an inverse\n    dependence on the average degree.  Several multiplicative correction factors\n    capture the effects of clustering, density, degree heterogeneity, assortativity,\n    bottlenecks (low minimum degree), hubs (high maximum degree) and triangles.\n    \"\"\"\n    # Feature extraction with sensible defaults\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1.0)\n    max_deg    = s.get('max_degree', avg_deg)\n    min_deg    = s.get('min_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    clust      = s.get('avg_clustering', 0.0)\n    density    = s.get('density', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0.0)\n\n    # Ensure numerical stability\n    avg_deg = max(avg_deg, 1e-12)\n    max_deg = max(max_deg, 1e-12)\n    std_deg = max(std_deg, 1e-12)\n    min_deg = max(min_deg, 1e-12)\n\n    # ---------- Baseline ----------\n    base = (n + 1) ** 0.5 / (avg_deg + 1)\n\n    # ---------- Correction factors ----------\n    clust_factor   = 1 + clust                      # higher clustering → longer paths\n    dens_factor    = 1 / (1 + density)              # denser graphs → shorter paths\n    assort_factor  = 1 + abs(assort)                # assortative mixing elongates paths\n    hetero_factor  = 1 / (1 + std_deg)              # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1 + (min_deg / (avg_deg + 1))  # low min degree can create bottlenecks\n    hub_factor     = (max_deg / (avg_deg + 1)) ** 0.5  # presence of hubs reduces distances\n    tri_factor     = 1 + (num_tri ** 0.5) / (n ** 0.5 + 1e-12)  # triangles shorten paths\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return estimate",
        "island_id": 3,
        "generation": 16,
        "train_score": 0.6901800720288115,
        "val_score": 0.5181832368372877,
        "simplicity_score": 0.17979979747219746,
        "novelty_bonus": 0.371845035328932
      },
      {
        "id": "g14_i3_p1_216775392",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph statistics.\n    \n    The estimate is built from a simple baseline that scales with the square root of\n    the number of nodes and is inversely related to the average degree.  Several\n    correction factors are applied multiplicatively to capture how clustering,\n    density, degree heterogeneity, assortativity, minimum degree, triangle\n    abundance and hubs influence the length of typical paths.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'                    : number of nodes\n            - 'm'                    : number of edges\n            - 'density'              : graph density (0–1)\n            - 'avg_degree'           : average degree\n            - 'max_degree'           : maximum degree\n            - 'min_degree'           : minimum degree\n            - 'std_degree'           : standard deviation of degrees\n            - 'avg_clustering'       : average clustering coefficient\n            - 'transitivity'         : global transitivity (optional)\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'        : total number of triangles\n            - 'degrees'              : sorted list of degrees (optional)\n    \n    Returns\n    -------\n    float\n        Numerical estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Core data, using sensible defaults if missing\n    n         = float(s.get('n', 1))\n    avg_deg   = float(s.get('avg_degree', 1.0))\n    max_deg   = float(s.get('max_degree', avg_deg))\n    min_deg   = float(s.get('min_degree', 0.0))\n    std_deg   = float(s.get('std_degree', 0.0))\n    clust     = float(s.get('avg_clustering', 0.0))\n    density   = float(s.get('density', 0.0))\n    assort    = float(s.get('degree_assortativity', 0.0))\n    num_tri   = float(s.get('num_triangles', 0.0))\n    \n    # Ensure we never divide by zero\n    eps = 1e-12\n    avg_deg = max(avg_deg, eps)\n    max_deg = max(max_deg, eps)\n    std_deg = max(std_deg, eps)\n    min_deg = max(min_deg, eps)\n    \n    # ---------- Baseline ----------\n    # Square‑root size dependence with a denominator that grows with the mean degree\n    base = (n + 1)**0.5 / (avg_deg + 1.0)\n    \n    # ---------- Correction factors ----------\n    clust_factor   = 1.0 + clust                    # high clustering tends to increase distances\n    dens_factor    = 1.0 / (1.0 + density)          # denser graphs shorten paths\n    assort_factor  = 1.0 + abs(assort)              # assortative mixing elongates paths\n    hetero_factor  = 1.0 / (1.0 + std_deg)          # heterogeneous degrees usually shorten paths\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))  # very low min degree can create bottlenecks\n    tri_factor     = 1.0 + (num_tri**0.5) / (n**0.5 + eps)  # abundant triangles tend to shorten paths\n    hub_factor     = (max_deg / (avg_deg + 1.0))**0.5    # presence of hubs can reduce typical distances\n    \n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                tri_factor *\n                hub_factor)\n    \n    return float(estimate)",
        "island_id": 3,
        "generation": 14,
        "train_score": 0.6901800720288115,
        "val_score": 0.5133405955174121,
        "simplicity_score": 0.15558659087281873,
        "novelty_bonus": 0.371845035328932
      },
      {
        "id": "g15_i3_p2_187974369",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length of a graph from pre‑computed\n    global features.  The estimate uses a baseline that grows with the\n    square‑root of the number of nodes and is inversely related to the\n    average degree.  Several multiplicative corrections capture how\n    clustering, density, degree heterogeneity, assortativity, bottlenecks\n    (low minimum degree), hubs (high maximum degree) and triangles influence\n    typical distances.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph statistics with possible keys:\n        - 'n' (int): number of nodes\n        - 'm' (int): number of edges\n        - 'density' (float)\n        - 'avg_degree' (float)\n        - 'max_degree' (float)\n        - 'min_degree' (float)\n        - 'std_degree' (float)\n        - 'avg_clustering' (float)\n        - 'transitivity' (float)\n        - 'degree_assortativity' (float)\n        - 'num_triangles' (int)\n        - 'degrees' (list of ints, sorted)\n\n    Returns\n    -------\n    float\n        Numeric estimate that correlates with the graph's average shortest‑path length.\n    \"\"\"\n    # Pull values with defaults, converting to float for consistency\n    n          = float(s.get('n', 1))\n    avg_deg    = float(s.get('avg_degree', 1.0))\n    max_deg    = float(s.get('max_degree', avg_deg))\n    min_deg    = float(s.get('min_degree', 0.0))\n    std_deg    = float(s.get('std_degree', 0.0))\n    clust      = float(s.get('avg_clustering', 0.0))\n    density    = float(s.get('density', 0.0))\n    assort     = float(s.get('degree_assortativity', 0.0))\n    num_tri    = float(s.get('num_triangles', 0.0))\n\n    # Guard against division by zero\n    eps       = 1e-12\n    avg_deg   = max(avg_deg, eps)\n    max_deg   = max(max_deg, eps)\n    std_deg   = max(std_deg, eps)\n    min_deg   = max(min_deg, eps)\n\n    # ---------- Baseline ----------\n    # Square‑root dependence on n, scaled by average degree\n    base = (n + 1.0) ** 0.5 / (avg_deg + 1.0)\n\n    # ---------- Correction factors ----------\n    # Clustering tends to increase distances\n    clust_factor   = 1.0 + clust\n\n    # Density shortens paths\n    dens_factor    = 1.0 / (1.0 + density)\n\n    # Assortative mixing can elongate paths\n    assort_factor  = 1.0 + abs(assort)\n\n    # Degree heterogeneity (large std) usually shortens distances\n    hetero_factor  = 1.0 / (1.0 + std_deg)\n\n    # Very low minimum degree can create bottlenecks\n    bottleneck_factor = 1.0 + (min_deg / (avg_deg + 1.0))\n\n    # Hubs (high maximum degree) tend to reduce typical distances\n    hub_factor     = (max_deg / (avg_deg + 1.0)) ** 0.5\n\n    # Triangles create shortcuts\n    tri_factor = 1.0 + ((num_tri ** 0.5) / (n ** 0.5 + eps))\n\n    # ---------- Combine ----------\n    estimate = (base *\n                clust_factor *\n                dens_factor *\n                assort_factor *\n                hetero_factor *\n                bottleneck_factor *\n                hub_factor *\n                tri_factor)\n\n    return float(estimate)",
        "island_id": 3,
        "generation": 15,
        "train_score": 0.6901800720288115,
        "val_score": 0.5133405955174121,
        "simplicity_score": 0.15558659087281873,
        "novelty_bonus": 0.371845035328932
      }
    ]
  }
}