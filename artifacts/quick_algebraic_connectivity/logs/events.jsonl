{"timestamp": "2026-02-14T02:31:22.802999+00:00", "event_type": "phase1_started", "payload": {"experiment_id": "phase1_20260214T023109Z", "resume": null, "model_name": "gemma3:12b", "dataset_fingerprint": "be233104b0f9f58593817158bd1dad771ec3ecea4f9f00950c3afd78560992e8"}}
{"timestamp": "2026-02-14T02:32:05.152200+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:32:05.152718+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:32:12.172882+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g0_i0_p0_89250953", "generation": 0, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.39255702280912363, "fitness_mode": "correlation", "simplicity_score": 0.15046957880235412, "novelty_bonus": 0.27169879602992086, "total_score": 0.3599552927587644, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\nNone yet.\nRecent failures:\nNone.\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)", "spearman": 0.4967034763786347, "pearson": 0.4435186673399549, "rmse": 1.9252001567927763, "mae": 1.3512514798784871}}
{"timestamp": "2026-02-14T02:32:12.173732+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 0, "population_idx": 0, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:32:21.995275+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.141475", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:32:28.539528+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:32:28.539842+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:32:34.253072+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g0_i0_p2_773956048", "generation": 0, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.39255702280912363, "fitness_mode": "correlation", "simplicity_score": 0.15046957880235412, "novelty_bonus": 0.27169879602992086, "total_score": 0.3599552927587644, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\nNone yet.\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.141475\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)", "spearman": 0.4967034763786347, "pearson": 0.4435186673399549, "rmse": 1.9252001567927763, "mae": 1.3512514798784871}}
{"timestamp": "2026-02-14T02:32:34.253358+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 0, "population_idx": 2, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:32:41.543709+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:32:41.544129+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:32:47.818687+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.102378", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:32:47.820193+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:32:53.987298+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:32:53.987919+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:32:58.769043+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.079458", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:32:58.769367+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 1, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:33:04.299989+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:33:04.300384+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:33:08.511522+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.102378", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:33:08.511733+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:33:13.381750+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g0_i2_p0_654571518", "generation": 0, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.6857623049219687, "fitness_mode": "correlation", "simplicity_score": 0.1499480920506402, "novelty_bonus": 0.19960423025032104, "total_score": 0.45376123474390584, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\nNone yet.\nRecent failures:\nNone.\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n```", "extracted_code": "def new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])", "spearman": 0.727780694517363, "pearson": 0.7285078386782512, "rmse": 16.041167214526062, "mae": 15.322301397766159}}
{"timestamp": "2026-02-14T02:33:18.425545+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:33:18.425838+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:33:24.032303+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g0_i2_p1_438878439", "generation": 0, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.5316206482593037, "fitness_mode": "correlation", "simplicity_score": 0.15502037213532274, "novelty_bonus": 0.23279064343696731, "total_score": 0.3842501026790353, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\nNone yet.\nRecent failures:\nNone.\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return np.log(s['n']) * s['avg_degree'] / (1 + s['std_degree'])\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['n'] * s['avg_degree'] / (1 + s['std_degree'])\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['n'] * s['avg_degree'] / (1 + s['std_degree'])", "spearman": 0.5668176704417611, "pearson": 0.5855407191857805, "rmse": 162.03615541823115, "mae": 139.33637013666024}}
{"timestamp": "2026-02-14T02:33:24.033996+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 2, "population_idx": 1, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:33:27.595653+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g0_i2_p2_433015235", "generation": 0, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.5854021608643457, "fitness_mode": "correlation", "simplicity_score": 0.17350031628920087, "novelty_bonus": 0.22472630450829612, "total_score": 0.4203006591779433, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\nNone yet.\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    return s['avg_degree'] / (1 + s['std_degree'])\n```", "extracted_code": "def new_invariant(s):\n    return s['avg_degree'] / (1 + s['std_degree'])", "spearman": 0.6363654091352285, "pearson": 0.6395391492468794, "rmse": 1.74455771757217, "mae": 1.3082676475979178}}
{"timestamp": "2026-02-14T02:33:40.975940+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:33:40.976507+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:33:54.365601+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.000852", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:33:54.365955+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 3, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:34:03.869797+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:34:03.870253+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:34:12.575241+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "runtime_exception: TypeError: unsupported operand type(s) for ** or pow(): 'list' and 'int'", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:34:12.575777+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 3, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:34:21.289126+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.089315", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:34:21.290720+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "phase1_20260214T023109Z", "generation": 1, "model_name": "gemma3:12b", "best_val_score": 0.45376123474390584, "no_improve_count": 0}}
{"timestamp": "2026-02-14T02:34:29.381146+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:34:29.381596+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:34:37.014459+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i0_p0_858597919", "generation": 1, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.35971188475390153, "fitness_mode": "correlation", "simplicity_score": 0.14992736624143446, "novelty_bonus": 0.30694962232679013, "total_score": 0.35689803175893914, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.141475\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)", "spearman": 0.4696553436252304, "pearson": 0.41301807540521507, "rmse": 1.9572504963748212, "mae": 1.4054856124803532}}
{"timestamp": "2026-02-14T02:34:37.014797+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 0, "population_idx": 0, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:34:43.128952+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:34:43.129473+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:34:49.006859+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i0_p1_201469535", "generation": 1, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.35971188475390153, "fitness_mode": "correlation", "simplicity_score": 0.14992736624143446, "novelty_bonus": 0.30694962232679013, "total_score": 0.35689803175893914, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.141475\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)", "spearman": 0.4696553436252304, "pearson": 0.41301807540521507, "rmse": 1.9572504963748212, "mae": 1.4054856124803532}}
{"timestamp": "2026-02-14T02:34:49.007186+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 0, "population_idx": 1, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:34:54.455829+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:34:54.456469+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:35:00.499900+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i0_p2_94177347", "generation": 1, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.35971188475390153, "fitness_mode": "correlation", "simplicity_score": 0.14992736624143446, "novelty_bonus": 0.30694962232679013, "total_score": 0.35689803175893914, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.141475\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)", "spearman": 0.4696553436252304, "pearson": 0.41301807540521507, "rmse": 1.9572504963748212, "mae": 1.4054856124803532}}
{"timestamp": "2026-02-14T02:35:00.500521+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 0, "population_idx": 2, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:35:06.442424+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:35:06.442751+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:35:10.852131+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 0, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.180792", "model_name": "gemma3:12b", "train_signal": 0.1807923169267707}}
{"timestamp": "2026-02-14T02:35:10.852648+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 0, "status": "failed", "reason": "below_train_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:35:16.517523+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:35:16.518096+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:35:20.879854+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.190396", "model_name": "gemma3:12b", "train_signal": 0.19039615846338534}}
{"timestamp": "2026-02-14T02:35:20.880130+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "status": "failed", "reason": "below_train_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:35:26.400782+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:35:26.401287+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:35:30.802367+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.190396", "model_name": "gemma3:12b", "train_signal": 0.19039615846338534}}
{"timestamp": "2026-02-14T02:35:30.802882+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "status": "failed", "reason": "below_train_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:35:38.918767+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i2_p0_526478978", "generation": 1, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.547563025210084, "fitness_mode": "correlation", "simplicity_score": 0.15019509001506276, "novelty_bonus": 0.2035951249481316, "total_score": 0.39856449166085645, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    return s['avg_degree'] / (1 + s['std_degree'])\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['n'] * s['avg_degree'] / (1 + s['std_degree'])\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])", "spearman": 0.6148938723468088, "pearson": 0.6295300081824711, "rmse": 17.116846972721916, "mae": 15.517932666505066}}
{"timestamp": "2026-02-14T02:35:44.926083+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i2_p1_975622351", "generation": 1, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.547563025210084, "fitness_mode": "correlation", "simplicity_score": 0.15019509001506276, "novelty_bonus": 0.2035951249481316, "total_score": 0.39856449166085645, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    return s['avg_degree'] / (1 + s['std_degree'])\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['n'] * s['avg_degree'] / (1 + s['std_degree'])\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])", "spearman": 0.6148938723468088, "pearson": 0.6295300081824711, "rmse": 17.116846972721916, "mae": 15.517932666505066}}
{"timestamp": "2026-02-14T02:35:50.719905+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i2_p2_735752370", "generation": 1, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.547563025210084, "fitness_mode": "correlation", "simplicity_score": 0.15019509001506276, "novelty_bonus": 0.2035951249481316, "total_score": 0.39856449166085645, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    return s['avg_degree'] / (1 + s['std_degree'])\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['n'] * s['avg_degree'] / (1 + s['std_degree'])\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])", "spearman": 0.6148938723468088, "pearson": 0.6295300081824711, "rmse": 17.116846972721916, "mae": 15.517932666505066}}
{"timestamp": "2026-02-14T02:36:00.273561+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:36:00.273937+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:36:08.304498+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 0, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.000000", "model_name": "gemma3:12b", "train_signal": 0.0}}
{"timestamp": "2026-02-14T02:36:08.305597+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 3, "population_idx": 0, "status": "failed", "reason": "below_train_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:36:17.475661+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.020696", "model_name": "gemma3:12b", "train_signal": 0.02069627851140456}}
{"timestamp": "2026-02-14T02:36:25.855888+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:36:25.857159+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:36:33.336817+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 2, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.256975", "model_name": "gemma3:12b", "train_signal": 0.2569754610133932}}
{"timestamp": "2026-02-14T02:36:33.338002+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 3, "population_idx": 2, "status": "failed", "reason": "below_train_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:36:33.340335+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "phase1_20260214T023109Z", "generation": 2, "model_name": "gemma3:12b", "best_val_score": 0.45376123474390584, "no_improve_count": 1}}
{"timestamp": "2026-02-14T02:36:41.477955+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:36:41.479021+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:36:47.138987+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i0_p0_761139701", "generation": 2, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.347611044417767, "fitness_mode": "correlation", "simplicity_score": 0.14992736624143446, "novelty_bonus": 0.3344656536807583, "total_score": 0.35374129731787235, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.141475\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)", "spearman": 0.4468322559307159, "pearson": 0.3927047410629399, "rmse": 1.980387983223501, "mae": 1.441270107616598}}
{"timestamp": "2026-02-14T02:36:47.139324+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 0, "population_idx": 0, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:36:52.270833+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:36:52.271121+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:36:58.010546+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i0_p1_717477276", "generation": 2, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.347611044417767, "fitness_mode": "correlation", "simplicity_score": 0.14992736624143446, "novelty_bonus": 0.3344656536807583, "total_score": 0.35374129731787235, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.141475\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)", "spearman": 0.4468322559307159, "pearson": 0.3927047410629399, "rmse": 1.980387983223501, "mae": 1.441270107616598}}
{"timestamp": "2026-02-14T02:36:58.011045+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 0, "population_idx": 1, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:37:03.376796+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:37:03.377044+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:37:11.034361+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i0_p2_786064305", "generation": 2, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.347611044417767, "fitness_mode": "correlation", "simplicity_score": 0.14992736624143446, "novelty_bonus": 0.3344656536807583, "total_score": 0.35374129731787235, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.141475\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)", "spearman": 0.4468322559307159, "pearson": 0.3927047410629399, "rmse": 1.980387983223501, "mae": 1.441270107616598}}
{"timestamp": "2026-02-14T02:37:11.034910+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 0, "population_idx": 2, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:37:16.685115+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.252245", "model_name": "gemma3:12b", "train_signal": 0.25224489795918364}}
{"timestamp": "2026-02-14T02:37:21.978223+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:37:21.978445+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:37:25.916249+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 1, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.252245", "model_name": "gemma3:12b", "train_signal": 0.25224489795918364}}
{"timestamp": "2026-02-14T02:37:25.916725+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 1, "population_idx": 1, "status": "failed", "reason": "below_train_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:37:31.741906+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:37:31.742463+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:37:36.246458+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 2, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.190396", "model_name": "gemma3:12b", "train_signal": 0.19039615846338534}}
{"timestamp": "2026-02-14T02:37:36.246714+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 1, "population_idx": 2, "status": "failed", "reason": "below_train_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:37:44.811310+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:37:44.811852+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:37:50.886119+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i2_p0_513226573", "generation": 2, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.547563025210084, "fitness_mode": "correlation", "simplicity_score": 0.15019509001506276, "novelty_bonus": 0.2035951249481316, "total_score": 0.39856449166085645, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    return s['avg_degree'] / (1 + s['std_degree'])\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'] + 1e-8)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])", "spearman": 0.6148938723468088, "pearson": 0.6295300081824711, "rmse": 17.116846972721916, "mae": 15.517932666505066}}
{"timestamp": "2026-02-14T02:37:50.886469+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 2, "population_idx": 0, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:37:56.586785+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i2_p1_128113632", "generation": 2, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.547563025210084, "fitness_mode": "correlation", "simplicity_score": 0.14713163210891897, "novelty_bonus": 0.2035951249481316, "total_score": 0.39795180007962766, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    return s['avg_degree'] / (1 + s['std_degree'])\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'] + 1e-9)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'] + 1e-9)", "spearman": 0.6148938723468088, "pearson": 0.6295300083166642, "rmse": 17.116846966757326, "mae": 15.517932661205332}}
{"timestamp": "2026-02-14T02:38:02.454699+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:38:02.454998+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:38:08.421237+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i2_p2_839748229", "generation": 2, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.547563025210084, "fitness_mode": "correlation", "simplicity_score": 0.15019509001506276, "novelty_bonus": 0.2035951249481316, "total_score": 0.39856449166085645, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    return s['avg_degree'] / (1 + s['std_degree'])\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'] + 1e-6)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])", "spearman": 0.6148938723468088, "pearson": 0.6295300081824711, "rmse": 17.116846972721916, "mae": 15.517932666505066}}
{"timestamp": "2026-02-14T02:38:08.421766+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 2, "population_idx": 2, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:38:21.586354+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.130564", "model_name": "gemma3:12b", "train_signal": 0.13056422569027612}}
{"timestamp": "2026-02-14T02:38:35.204278+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.122481", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:38:43.942640+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:38:43.943151+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:38:51.740768+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.081653", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:38:51.741206+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 3, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:38:51.741453+00:00", "event_type": "generation_migration", "payload": {"generation": 2, "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:38:51.742799+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "phase1_20260214T023109Z", "generation": 3, "model_name": "gemma3:12b", "best_val_score": 0.45376123474390584, "no_improve_count": 2}}
{"timestamp": "2026-02-14T02:39:00.332263+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:39:00.333594+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:39:06.181153+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i0_p0_450385937", "generation": 3, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.347611044417767, "fitness_mode": "correlation", "simplicity_score": 0.14992736624143446, "novelty_bonus": 0.3344656536807583, "total_score": 0.35374129731787235, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.141475\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)", "spearman": 0.4468322559307159, "pearson": 0.3927047410629399, "rmse": 1.980387983223501, "mae": 1.441270107616598}}
{"timestamp": "2026-02-14T02:39:06.181690+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 0, "population_idx": 0, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:39:11.479211+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:39:11.479487+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:39:17.264910+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i0_p1_500351915", "generation": 3, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.347611044417767, "fitness_mode": "correlation", "simplicity_score": 0.14992736624143446, "novelty_bonus": 0.3344656536807583, "total_score": 0.35374129731787235, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.141475\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)", "spearman": 0.4468322559307159, "pearson": 0.3927047410629399, "rmse": 1.980387983223501, "mae": 1.441270107616598}}
{"timestamp": "2026-02-14T02:39:17.265554+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 0, "population_idx": 1, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:39:22.732279+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:39:22.732629+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:39:28.358415+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i0_p2_370798024", "generation": 3, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.347611044417767, "fitness_mode": "correlation", "simplicity_score": 0.14992736624143446, "novelty_bonus": 0.3344656536807583, "total_score": 0.35374129731787235, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.141475\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)", "spearman": 0.4468322559307159, "pearson": 0.3927047410629399, "rmse": 1.980387983223501, "mae": 1.441270107616598}}
{"timestamp": "2026-02-14T02:39:28.358964+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 0, "population_idx": 2, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:39:36.894118+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:39:36.895200+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:39:43.596652+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i1_p0_182549636", "generation": 3, "island_id": 1, "model_name": "gemma3:12b", "train_signal": 0.39255702280912363, "fitness_mode": "correlation", "simplicity_score": 0.15046957880235412, "novelty_bonus": 0.27169879602992086, "total_score": 0.3599552927587644, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\nRecent failures:\nbelow_train_threshold: train_signal=0.252245\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.190396\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    Combines log(n) * avg_degree with a normalization factor based on max_degree.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1e-6)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    Combines log(n) * avg_degree with a normalization factor based on max_degree.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    Combines log(n) * avg_degree with a normalization factor based on max_degree.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)", "spearman": 0.4967034763786347, "pearson": 0.4435186673399549, "rmse": 1.9252001567927763, "mae": 1.3512514798784871}}
{"timestamp": "2026-02-14T02:39:43.596896+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 1, "population_idx": 0, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:39:50.038599+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:39:50.039015+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:39:55.521502+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i1_p1_926764988", "generation": 3, "island_id": 1, "model_name": "gemma3:12b", "train_signal": 0.39255702280912363, "fitness_mode": "correlation", "simplicity_score": 0.15046957880235412, "novelty_bonus": 0.27169879602992086, "total_score": 0.3599552927587644, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\nRecent failures:\nbelow_train_threshold: train_signal=0.252245\nbelow_train_threshold: train_signal=0.190396\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)", "spearman": 0.4967034763786347, "pearson": 0.4435186673399549, "rmse": 1.9252001567927763, "mae": 1.3512514798784871}}
{"timestamp": "2026-02-14T02:39:55.521798+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 1, "population_idx": 1, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:40:00.528715+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:40:00.528909+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:40:06.019887+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i1_p2_781567455", "generation": 3, "island_id": 1, "model_name": "gemma3:12b", "train_signal": 0.39255702280912363, "fitness_mode": "correlation", "simplicity_score": 0.15046957880235412, "novelty_bonus": 0.27169879602992086, "total_score": 0.3599552927587644, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\nRecent failures:\nbelow_train_threshold: train_signal=0.252245\nbelow_train_threshold: train_signal=0.190396\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)", "spearman": 0.4967034763786347, "pearson": 0.4435186673399549, "rmse": 1.9252001567927763, "mae": 1.3512514798784871}}
{"timestamp": "2026-02-14T02:40:06.020249+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 1, "population_idx": 2, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:40:14.280284+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:40:14.280815+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:40:20.143876+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i2_p0_643865119", "generation": 3, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.547563025210084, "fitness_mode": "correlation", "simplicity_score": 0.15019509001506276, "novelty_bonus": 0.2035951249481316, "total_score": 0.39856449166085645, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    return s['avg_degree'] / (1 + s['std_degree'])\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'] + 1e-6)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])", "spearman": 0.6148938723468088, "pearson": 0.6295300081824711, "rmse": 17.116846972721916, "mae": 15.517932666505066}}
{"timestamp": "2026-02-14T02:40:20.144428+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 2, "population_idx": 0, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:40:25.530305+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:40:25.530794+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:40:31.871799+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i2_p1_402414364", "generation": 3, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.5854021608643457, "fitness_mode": "correlation", "simplicity_score": 0.16227068089417623, "novelty_bonus": 0.22472630450829612, "total_score": 0.41805473209893834, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    return s['avg_degree'] / (1 + s['std_degree'])\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] / (1 + np.sqrt(s['std_degree']))\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] / (1 + s['std_degree'])\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] / (1 + s['std_degree'])", "spearman": 0.6363654091352285, "pearson": 0.6395391492468794, "rmse": 1.74455771757217, "mae": 1.3082676475979178}}
{"timestamp": "2026-02-14T02:40:31.872142+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 2, "population_idx": 1, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:40:37.651262+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:40:37.651481+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:40:43.565470+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i2_p2_822761613", "generation": 3, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.547563025210084, "fitness_mode": "correlation", "simplicity_score": 0.15019509001506276, "novelty_bonus": 0.2035951249481316, "total_score": 0.39856449166085645, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    return s['avg_degree'] / (1 + s['std_degree'])\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'] + 1e-8)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] * np.sqrt(s['n']) / (1 + s['std_degree'])", "spearman": 0.6148938723468088, "pearson": 0.6295300081824711, "rmse": 17.116846972721916, "mae": 15.517932666505066}}
{"timestamp": "2026-02-14T02:40:43.565745+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 2, "population_idx": 2, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:40:49.882920+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:40:49.883978+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:40:54.325594+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i3_p0_545429118", "generation": 3, "island_id": 3, "model_name": "gemma3:12b", "train_signal": 0.6570468187274909, "fitness_mode": "correlation", "simplicity_score": 0.14784629976982638, "novelty_bonus": 0.2596905344567161, "total_score": 0.45238904310655054, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. The Fiedler value is the 2nd-smallest Laplacian eigenvalue. Think about degree distribution, connectivity patterns, spectral relationships.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.122481\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.081653\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * (s['avg_degree'] + 1)) / (s['transitivity'] + 1)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * (s['avg_degree'] + 1)) / (s['transitivity'] + 1)\n```", "extracted_code": "def new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * (s['avg_degree'] + 1)) / (s['transitivity'] + 1)", "spearman": 0.6898252456311409, "pearson": 0.7025068834532542, "rmse": 17.43260895108733, "mae": 16.763905554563177}}
{"timestamp": "2026-02-14T02:40:54.326573+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 3, "population_idx": 0, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:00.090139+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:00.090565+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:04.215029+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i3_p1_443414198", "generation": 3, "island_id": 3, "model_name": "gemma3:12b", "train_signal": 0.6857623049219687, "fitness_mode": "correlation", "simplicity_score": 0.1499480920506402, "novelty_bonus": 0.19960423025032104, "total_score": 0.45376123474390584, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. The Fiedler value is the 2nd-smallest Laplacian eigenvalue. Think about degree distribution, connectivity patterns, spectral relationships.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.122481\nbelow_novelty_threshold: novelty_bonus=0.081653\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * (s['avg_degree'] + 1)) / (s['transitivity'] + 1)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n```", "extracted_code": "def new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])", "spearman": 0.727780694517363, "pearson": 0.7285078386782512, "rmse": 16.041167214526062, "mae": 15.322301397766159}}
{"timestamp": "2026-02-14T02:41:04.215290+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 3, "population_idx": 1, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:08.046944+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:08.047189+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:12.351660+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i3_p2_450459553", "generation": 3, "island_id": 3, "model_name": "gemma3:12b", "train_signal": 0.6857623049219687, "fitness_mode": "correlation", "simplicity_score": 0.1499480920506402, "novelty_bonus": 0.19960423025032104, "total_score": 0.45376123474390584, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. The Fiedler value is the 2nd-smallest Laplacian eigenvalue. Think about degree distribution, connectivity patterns, spectral relationships.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.122481\nbelow_novelty_threshold: novelty_bonus=0.081653\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['avg_degree'] * s['transitivity']) / (1 + s['avg_clustering'])\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n```", "extracted_code": "def new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])", "spearman": 0.727780694517363, "pearson": 0.7285078386782512, "rmse": 16.041167214526062, "mae": 15.322301397766159}}
{"timestamp": "2026-02-14T02:41:12.352071+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 3, "population_idx": 2, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:12.353177+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "phase1_20260214T023109Z", "generation": 4, "model_name": "gemma3:12b", "best_val_score": 0.45376123474390584, "no_improve_count": 3}}
{"timestamp": "2026-02-14T02:41:20.898812+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:20.899283+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:26.814890+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i0_p0_227238721", "generation": 4, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.347611044417767, "fitness_mode": "correlation", "simplicity_score": 0.14992736624143446, "novelty_bonus": 0.3344656536807583, "total_score": 0.35374129731787235, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.141475\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)", "spearman": 0.4468322559307159, "pearson": 0.3927047410629399, "rmse": 1.980387983223501, "mae": 1.441270107616598}}
{"timestamp": "2026-02-14T02:41:26.815164+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 0, "population_idx": 0, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:31.960799+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:31.961228+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:37.652787+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i0_p1_92135914", "generation": 4, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.347611044417767, "fitness_mode": "correlation", "simplicity_score": 0.14992736624143446, "novelty_bonus": 0.3344656536807583, "total_score": 0.35374129731787235, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.141475\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)", "spearman": 0.4468322559307159, "pearson": 0.3927047410629399, "rmse": 1.980387983223501, "mae": 1.441270107616598}}
{"timestamp": "2026-02-14T02:41:37.658937+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 0, "population_idx": 1, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:43.066371+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:43.066590+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:48.848024+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i0_p2_554584786", "generation": 4, "island_id": 0, "model_name": "gemma3:12b", "train_signal": 0.347611044417767, "fitness_mode": "correlation", "simplicity_score": 0.14992736624143446, "novelty_bonus": 0.3344656536807583, "total_score": 0.35374129731787235, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.5)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.141475\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 0.2)", "spearman": 0.4468322559307159, "pearson": 0.3927047410629399, "rmse": 1.980387983223501, "mae": 1.441270107616598}}
{"timestamp": "2026-02-14T02:41:48.848485+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 0, "population_idx": 2, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:59.479516+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:41:59.479960+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:42:06.816383+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p0_887889843", "generation": 4, "island_id": 1, "model_name": "gemma3:12b", "train_signal": 0.39255702280912363, "fitness_mode": "correlation", "simplicity_score": 0.15046957880235412, "novelty_bonus": 0.27169879602992086, "total_score": 0.3599552927587644, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    Combines log(n) * avg_degree with a normalization factor based on max_degree.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\nRecent failures:\nbelow_train_threshold: train_signal=0.252245\nbelow_train_threshold: train_signal=0.190396\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    Combines log(n) * avg_degree with a normalization factor based on max_degree and std_degree.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1 + 0.1 * s['std_degree'])\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    Combines log(n) * avg_degree with a normalization factor based on max_degree.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    Combines log(n) * avg_degree with a normalization factor based on max_degree.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)", "spearman": 0.4967034763786347, "pearson": 0.4435186673399549, "rmse": 1.9252001567927763, "mae": 1.3512514798784871}}
{"timestamp": "2026-02-14T02:42:06.816700+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 1, "population_idx": 0, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:42:14.007129+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:42:14.007716+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:42:21.359598+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p1_63817255", "generation": 4, "island_id": 1, "model_name": "gemma3:12b", "train_signal": 0.39255702280912363, "fitness_mode": "correlation", "simplicity_score": 0.15046957880235412, "novelty_bonus": 0.27169879602992086, "total_score": 0.3599552927587644, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    Combines log(n) * avg_degree with a normalization factor based on max_degree.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\nRecent failures:\nbelow_train_threshold: train_signal=0.252245\nbelow_train_threshold: train_signal=0.190396\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    Combines log(n) * avg_degree with a normalization factor based on max_degree and degree assortativity.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1 + s['degree_assortativity'])\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    Combines log(n) * avg_degree with a normalization factor based on max_degree and degree assortativity.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    Combines log(n) * avg_degree with a normalization factor based on max_degree and degree assortativity.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)", "spearman": 0.4967034763786347, "pearson": 0.4435186673399549, "rmse": 1.9252001567927763, "mae": 1.3512514798784871}}
{"timestamp": "2026-02-14T02:42:21.360163+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 1, "population_idx": 1, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:42:28.552295+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:42:28.552718+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:42:35.766117+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p2_858291293", "generation": 4, "island_id": 1, "model_name": "gemma3:12b", "train_signal": 0.39255702280912363, "fitness_mode": "correlation", "simplicity_score": 0.15046957880235412, "novelty_bonus": 0.27169879602992086, "total_score": 0.3599552927587644, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    Combines log(n) * avg_degree with a normalization factor based on max_degree.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\nRecent failures:\nbelow_train_threshold: train_signal=0.252245\nbelow_train_threshold: train_signal=0.190396\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    Combines log(n) * avg_degree with a normalization factor based on max_degree and std_degree.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1 + 0.1 * s['std_degree'])\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    Combines log(n) * avg_degree with a normalization factor based on max_degree.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    Combines log(n) * avg_degree with a normalization factor based on max_degree.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0\n    return np.log(s['n']) * s['avg_degree'] / (s['max_degree'] + 1)", "spearman": 0.4967034763786347, "pearson": 0.4435186673399549, "rmse": 1.9252001567927763, "mae": 1.3512514798784871}}
{"timestamp": "2026-02-14T02:42:35.767370+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 1, "population_idx": 2, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:42:43.118810+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.125955", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:42:49.569439+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.125955", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:42:54.634638+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:42:54.635071+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:42:59.971313+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i2_p2_827631171", "generation": 4, "island_id": 2, "model_name": "gemma3:12b", "train_signal": 0.5854021608643457, "fitness_mode": "correlation", "simplicity_score": 0.16227068089417623, "novelty_bonus": 0.22472630450829612, "total_score": 0.41805473209893834, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    return s['avg_degree'] / (1 + s['std_degree'])\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] / (1 + s['std_degree'])\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.125955\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] / (1 + 0.5 * s['std_degree'])\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] / (1 + s['std_degree'])\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A formula attempting to capture algebraic connectivity based on graph features.\n    \"\"\"\n    if s['n'] == 0:\n        return 0.0  # Handle empty graph case\n\n    return s['avg_degree'] / (1 + s['std_degree'])", "spearman": 0.6363654091352285, "pearson": 0.6395391492468794, "rmse": 1.74455771757217, "mae": 1.3082676475979178}}
{"timestamp": "2026-02-14T02:42:59.971587+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 2, "population_idx": 2, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:43:06.504474+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:43:06.504887+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:43:10.635386+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i3_p0_276759694", "generation": 4, "island_id": 3, "model_name": "gemma3:12b", "train_signal": 0.685858343337335, "fitness_mode": "correlation", "simplicity_score": 0.1504522061208684, "novelty_bonus": 0.20587874521241123, "total_score": 0.4564831805157903, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. The Fiedler value is the 2nd-smallest Laplacian eigenvalue. Think about degree distribution, connectivity patterns, spectral relationships.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.122481\nbelow_novelty_threshold: novelty_bonus=0.081653\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['transitivity'])\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['transitivity'])\n```", "extracted_code": "def new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['transitivity'])", "spearman": 0.7292582314557865, "pearson": 0.7228506756345976, "rmse": 16.278855098177022, "mae": 15.550738816156787}}
{"timestamp": "2026-02-14T02:43:10.635692+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 3, "population_idx": 0, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:43:15.108174+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:43:15.108674+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:43:19.300875+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i3_p1_165229079", "generation": 4, "island_id": 3, "model_name": "gemma3:12b", "train_signal": 0.6857623049219687, "fitness_mode": "correlation", "simplicity_score": 0.1499480920506402, "novelty_bonus": 0.19960423025032104, "total_score": 0.45376123474390584, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. The Fiedler value is the 2nd-smallest Laplacian eigenvalue. Think about degree distribution, connectivity patterns, spectral relationships.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.122481\nbelow_novelty_threshold: novelty_bonus=0.081653\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'] + s['transitivity'])\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n```", "extracted_code": "def new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])", "spearman": 0.727780694517363, "pearson": 0.7285078386782512, "rmse": 16.041167214526062, "mae": 15.322301397766159}}
{"timestamp": "2026-02-14T02:43:19.301163+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 3, "population_idx": 1, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:43:23.485458+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:43:23.485888+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:43:27.612951+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i3_p2_700522966", "generation": 4, "island_id": 3, "model_name": "gemma3:12b", "train_signal": 0.6857623049219687, "fitness_mode": "correlation", "simplicity_score": 0.1499480920506402, "novelty_bonus": 0.19960423025032104, "total_score": 0.45376123474390584, "prompt": "You are discovering graph invariant formulas for target `algebraic_connectivity`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. The Fiedler value is the 2nd-smallest Laplacian eigenvalue. Think about degree distribution, connectivity patterns, spectral relationships.\nBest formulas:\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.122481\nbelow_novelty_threshold: novelty_bonus=0.081653\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree'] * s['transitivity']) / (1 + s['avg_clustering'])\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])\n```", "extracted_code": "def new_invariant(s):\n    if s['n'] == 0:\n        return 0\n    return np.sqrt(s['n'] * s['avg_degree']) / (1 + s['avg_clustering'])", "spearman": 0.727780694517363, "pearson": 0.7285078386782512, "rmse": 16.041167214526062, "mae": 15.322301397766159}}
{"timestamp": "2026-02-14T02:43:27.613229+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 3, "population_idx": 2, "status": "success", "model_name": "gemma3:12b"}}
{"timestamp": "2026-02-14T02:43:27.614939+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "phase1_20260214T023109Z", "generation": 5, "model_name": "gemma3:12b", "best_val_score": 0.4564831805157903, "no_improve_count": 0}}
