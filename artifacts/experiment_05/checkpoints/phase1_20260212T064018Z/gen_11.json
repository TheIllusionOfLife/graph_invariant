{
  "experiment_id": "phase1_20260212T064018Z",
  "generation": 11,
  "rng_seed": 42,
  "rng_state": {
    "bit_generator": "PCG64",
    "state": {
      "state": 89334674732678455409947914835335686556,
      "inc": 332724090758049132448979897138935081983
    },
    "has_uint32": 1,
    "uinteger": 3679130335
  },
  "best_val_score": 0.6666372840718657,
  "no_improve_count": 8,
  "island_stagnation": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_prompt_mode": {
    "0": "free",
    "1": "free",
    "2": "free",
    "3": "free"
  },
  "island_constrained_generations": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_recent_failures": {
    "0": [
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "no_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`"
    ],
    "1": [
      "no_valid_train_predictions: static_invalid: non-whitelisted call detected: hasattr",
      "no_valid_train_predictions: static_invalid: disallowed syntax: Try",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ],
    "2": [
      "no_valid_train_predictions: static_invalid: target-related function forbidden: shortest_path_length",
      "no_valid_train_predictions: static_invalid: disallowed syntax: Try",
      "no_valid_train_predictions: static_invalid: non-whitelisted call detected: hasattr"
    ],
    "3": [
      "no_valid_train_predictions: static_invalid: non-whitelisted call detected: hasattr",
      "no_valid_train_predictions: static_invalid: disallowed syntax: Try",
      "no_valid_train_predictions: static_invalid: non-whitelisted call detected: dir"
    ]
  },
  "islands": {
    "0": [
      {
        "id": "g0_i0_p0_89250953",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For connected graphs this is the mean of the shortest path lengths over all\n    unordered pairs of distinct nodes.  For disconnected graphs the average is\n    taken over all reachable pairs only.  If the graph has no edges or only a\n    single node, the function returns 0.0.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    float\n        The average shortest path length.\n    \"\"\"\n    # Handle trivial cases\n    n = G.number_of_nodes()\n    if n <= 1:\n        return 0.0\n\n    total_len = 0\n    pair_count = 0\n\n    # Perform a breadth‑first search from each node to compute distances\n    for s in G.nodes():\n        visited = {s}\n        dist = {s: 0}\n        queue = [s]\n        while queue:\n            u = queue.pop(0)\n            for v in G.neighbors(u):\n                if v not in visited:\n                    visited.add(v)\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n\n        # Sum distances to all reachable nodes (excluding the source)\n        for t, d in dist.items():\n            if t == s:\n                continue\n            total_len += d\n            pair_count += 1\n\n    if pair_count == 0:\n        return 0.0\n\n    avg = total_len / pair_count\n    # For undirected graphs each unordered pair is counted twice\n    if not G.is_directed():\n        avg *= 2\n    return avg",
        "island_id": 0,
        "generation": 0,
        "train_score": 0.9999999999999999,
        "val_score": 0.6663896768077913,
        "simplicity_score": 0.25214148393893143,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g1_i0_p1_450385937",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For connected graphs this is the mean of the shortest path lengths over all\n    unordered pairs of distinct nodes.  For disconnected graphs the average is\n    taken over all reachable pairs only.  If the graph has no edges or only a\n    single node, the function returns 0.0.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    float\n        The average shortest path length.\n    \"\"\"\n    # Handle trivial cases\n    n = G.number_of_nodes()\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    # For each source node run a BFS to compute distances to all reachable nodes\n    for source in G.nodes():\n        # BFS\n        dist = {source: 0}\n        queue = [source]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n\n        # Accumulate distances to all reachable nodes (excluding the source)\n        for target, d in dist.items():\n            if target == source:\n                continue\n            total_dist += d\n            pair_count += 1\n\n    if pair_count == 0:\n        return 0.0\n\n    avg = total_dist / pair_count\n    # For undirected graphs each unordered pair is counted twice\n    if not G.is_directed():\n        avg *= 2\n    return avg",
        "island_id": 0,
        "generation": 1,
        "train_score": 0.9999999999999999,
        "val_score": 0.6663680918461247,
        "simplicity_score": 0.2520335591305985,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g2_i0_p0_858291293",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For connected graphs this is the mean of the shortest path lengths over all\n    unordered pairs of distinct nodes.  For disconnected graphs the average is\n    taken over all reachable pairs only.  If the graph has no edges or only a\n    single node, the function returns 0.0.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    float\n        The average shortest path length.\n    \"\"\"\n    # Handle trivial cases\n    n = G.number_of_nodes()\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    # For each source node run a BFS to compute distances to all reachable nodes\n    for source in G.nodes():\n        dist = {source: 0}\n        queue = [source]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n\n        # Accumulate distances to all reachable nodes (excluding the source)\n        for target, d in dist.items():\n            if target == source:\n                continue\n            total_dist += d\n            pair_count += 1\n\n    if pair_count == 0:\n        return 0.0\n\n    avg = total_dist / pair_count\n    # For undirected graphs each unordered pair is counted twice\n    if not G.is_directed():\n        avg /= 2.0\n    return avg",
        "island_id": 0,
        "generation": 2,
        "train_score": 0.9999999999999999,
        "val_score": 0.6663680918461247,
        "simplicity_score": 0.2520335591305985,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g2_i0_p1_827631171",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For connected graphs this is the mean of the shortest path lengths over all\n    unordered pairs of distinct nodes.  For disconnected graphs the average is\n    taken over all reachable pairs only.  If the graph has no edges or only a\n    single node, the function returns 0.0.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    float\n        The average shortest path length.\n    \"\"\"\n    # Handle trivial cases\n    n = G.number_of_nodes()\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    # For each source node run a BFS to compute distances to all reachable nodes\n    for source in G.nodes():\n        dist = {source: 0}\n        queue = [source]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n\n        # Accumulate distances to all reachable nodes (excluding the source)\n        for target, d in dist.items():\n            if target == source:\n                continue\n            total_dist += d\n            pair_count += 1\n\n    if pair_count == 0:\n        return 0.0\n\n    avg = total_dist / pair_count\n    # For undirected graphs each unordered pair is counted twice\n    if not G.is_directed():\n        avg /= 2.0\n    return avg",
        "island_id": 0,
        "generation": 2,
        "train_score": 0.9999999999999999,
        "val_score": 0.6663680918461247,
        "simplicity_score": 0.2520335591305985,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g2_i0_p3_165229079",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For connected graphs this is the mean of the shortest path lengths over all\n    unordered pairs of distinct nodes.  For disconnected graphs the average is\n    taken over all reachable pairs only.  If the graph has no edges or only a\n    single node, the function returns 0.0.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    float\n        The average shortest path length.\n    \"\"\"\n    # Handle trivial cases\n    n = G.number_of_nodes()\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    # For each source node run a BFS to compute distances to all reachable nodes\n    for source in G.nodes():\n        dist = {source: 0}\n        queue = [source]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n\n        # Accumulate distances to all reachable nodes (excluding the source)\n        for target, d in dist.items():\n            if target == source:\n                continue\n            total_dist += d\n            pair_count += 1\n\n    if pair_count == 0:\n        return 0.0\n\n    avg = total_dist / pair_count\n    # For undirected graphs each unordered pair is counted twice\n    if not G.is_directed():\n        avg *= 2\n    return avg",
        "island_id": 0,
        "generation": 2,
        "train_score": 0.9999999999999999,
        "val_score": 0.6663680918461247,
        "simplicity_score": 0.2520335591305985,
        "novelty_bonus": 0.07980690010002534
      }
    ],
    "1": [
      {
        "id": "g2_i1_p2_970698024",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable directed pairs.\n    For undirected graphs, each unordered pair is counted once.\n    Unreachable pairs are ignored.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes)\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source}\n        queue = [(source, 0)]\n        while queue:\n            current, dist = queue.pop(0)\n            for neighbor in G.neighbors(current):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n                    total_dist += dist + 1\n                    pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # Each unordered pair was counted twice in the BFS loops\n        return 2 * total_dist / pair_count",
        "island_id": 1,
        "generation": 2,
        "train_score": 0.9999999999999999,
        "val_score": 0.6666372840718657,
        "simplicity_score": 0.25337952025930366,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g2_i1_p3_445687486",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n    For directed graphs, the average is taken over all reachable directed pairs.\n    For undirected graphs, each unordered pair is counted twice during the\n    computation, but the resulting average is the same as for the undirected case.\n    Unreachable pairs are ignored.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float\n        The average shortest path length, or 0.0 if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes)\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source}\n        queue = [(source, 0)]\n        while queue:\n            current, dist = queue.pop(0)\n            for neighbor in G.neighbors(current):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n                    total_dist += dist + 1\n                    pair_count += 1\n\n    if pair_count == 0:\n        return 0.0\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # For undirected graphs each unordered pair was counted twice\n        return 2 * total_dist / pair_count",
        "island_id": 1,
        "generation": 2,
        "train_score": 0.9999999999999999,
        "val_score": 0.6666372840718657,
        "simplicity_score": 0.25337952025930366,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g3_i1_p1_905535765",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable directed pairs.\n    For undirected graphs, each unordered pair is counted twice during the\n    computation, so the final average is multiplied by 2 to compensate.\n\n    Unreachable pairs are ignored.  If no pairs are reachable, None is returned.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes)\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source}\n        queue = [(source, 0)]\n        while queue:\n            current, dist = queue.pop(0)\n            for neighbor in G.neighbors(current):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n                    total_dist += dist + 1\n                    pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # For undirected graphs each unordered pair was counted twice\n        return 2 * total_dist / pair_count",
        "island_id": 1,
        "generation": 3,
        "train_score": 0.9999999999999999,
        "val_score": 0.6666372840718657,
        "simplicity_score": 0.25337952025930366,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g3_i1_p3_76343185",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable directed pairs.\n    For undirected graphs, each unordered pair is counted twice during the\n    computation, but the resulting average is the same as for the undirected case.\n    Unreachable pairs are ignored.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes)\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source}\n        queue = [(source, 0)]\n        while queue:\n            current, dist = queue.pop(0)\n            for neighbor in G.neighbors(current):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n                    total_dist += dist + 1\n                    pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        return 2 * total_dist / pair_count",
        "island_id": 1,
        "generation": 3,
        "train_score": 0.9999999999999999,
        "val_score": 0.6666372840718657,
        "simplicity_score": 0.25337952025930366,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g4_i1_p0_312366641",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable directed pairs.\n    For undirected graphs, each unordered pair is counted twice during the\n    computation, so the final average is multiplied by 2 to compensate.\n\n    Unreachable pairs are ignored.  If no pairs are reachable, None is returned.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes)\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source}\n        queue = [(source, 0)]\n        while queue:\n            current, dist = queue.pop(0)\n            for neighbor in G.neighbors(current):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n                    total_dist += dist + 1\n                    pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # For undirected graphs each unordered pair was counted twice\n        return 2 * total_dist / pair_count",
        "island_id": 1,
        "generation": 4,
        "train_score": 0.9999999999999999,
        "val_score": 0.6666372840718657,
        "simplicity_score": 0.25337952025930366,
        "novelty_bonus": 0.07980690010002534
      }
    ],
    "2": [
      {
        "id": "g2_i1_p2_970698024",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable directed pairs.\n    For undirected graphs, each unordered pair is counted once.\n    Unreachable pairs are ignored.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes)\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source}\n        queue = [(source, 0)]\n        while queue:\n            current, dist = queue.pop(0)\n            for neighbor in G.neighbors(current):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n                    total_dist += dist + 1\n                    pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # Each unordered pair was counted twice in the BFS loops\n        return 2 * total_dist / pair_count",
        "island_id": 1,
        "generation": 2,
        "train_score": 0.9999999999999999,
        "val_score": 0.6666372840718657,
        "simplicity_score": 0.25337952025930366,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g10_i2_p4_305956623",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable directed pairs.\n    For undirected graphs, each unordered pair is counted once.\n    Unreachable pairs are ignored.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes)\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source}\n        queue = [(source, 0)]\n        while queue:\n            current, dist = queue.pop(0)\n            for neighbor in G.neighbors(current):\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n                    total_dist += dist + 1\n                    pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # Each unordered pair was counted twice in the BFS loops\n        return 2 * total_dist / pair_count",
        "island_id": 2,
        "generation": 10,
        "train_score": 0.9999999999999999,
        "val_score": 0.6666372840718657,
        "simplicity_score": 0.25337952025930366,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g10_i2_p2_202363364",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of a graph G.\n\n    For directed graphs, the average is taken over all reachable ordered pairs.\n    For undirected graphs, each unordered pair is counted once.\n    Unreachable pairs are ignored.\n\n    Parameters\n    ----------\n    G : networkx.Graph or networkx.DiGraph\n        The graph on which to compute the invariant.\n\n    Returns\n    -------\n    float or None\n        The average shortest path length, or None if no pairs are reachable.\n    \"\"\"\n    nodes = list(G.nodes())\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    for source in nodes:\n        visited = {source: 0}\n        queue = [source]\n        while queue:\n            v = queue.pop(0)\n            d = visited[v]\n            for nb in G[v]:\n                if nb not in visited:\n                    visited[nb] = d + 1\n                    queue.append(nb)\n\n        for target, dist in visited.items():\n            if target == source:\n                continue\n            total_dist += dist\n            pair_count += 1\n\n    if pair_count == 0:\n        return None\n\n    if G.is_directed():\n        return total_dist / pair_count\n    else:\n        # Each unordered pair was counted twice\n        return 2 * total_dist / pair_count",
        "island_id": 2,
        "generation": 10,
        "train_score": 0.9999999999999999,
        "val_score": 0.6664338096662339,
        "simplicity_score": 0.25236214823114467,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g0_i2_p2_526478978",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of the graph G.\n    For disconnected graphs, only pairs of nodes that are reachable\n    from each other are considered.  The result is a float; if no\n    reachable pairs exist, 0.0 is returned.\n    \"\"\"\n    total_sum = 0\n    total_pairs = 0\n    # Iterate over each node as source\n    for source in G.nodes():\n        # BFS from source\n        distances = {source: 0}\n        queue = [source]\n        while queue:\n            v = queue.pop(0)\n            dv = distances[v] + 1\n            for nb in G.adj[v]:\n                if nb not in distances:\n                    distances[nb] = dv\n                    queue.append(nb)\n        # Update totals (exclude source itself)\n        reachable = len(distances) - 1\n        if reachable > 0:\n            total_sum += sum(distances.values()) - 0  # sum includes source distance 0\n            total_pairs += reachable\n    # Compute average\n    if total_pairs == 0:\n        return 0.0\n    return total_sum / total_pairs",
        "island_id": 2,
        "generation": 0,
        "train_score": 0.9999999999999999,
        "val_score": 0.6466873613623285,
        "simplicity_score": 0.15362990671161764,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g3_i2_p3_129921505",
        "code": "def new_invariant(G):\n    \"\"\"\n    Compute the average shortest path length of an undirected graph G.\n    The average is taken over all unordered pairs of vertices that are\n    reachable from each other.  For disconnected graphs, only pairs that\n    lie in the same connected component contribute to the average.\n\n    Parameters\n    ----------\n    G : graph object\n        Must support iteration over nodes and adjacency lookup via G[node].\n\n    Returns\n    -------\n    float\n        The average shortest path length.  If the graph has fewer than\n        two vertices, or no reachable pairs, 0.0 is returned.\n    \"\"\"\n    # List of all nodes in the graph\n    nodes = list(G)\n\n    # If there are fewer than two nodes, there are no pairs to average\n    if len(nodes) <= 1:\n        return 0.0\n\n    total_dist = 0\n    pair_count = 0\n\n    # For each node, perform a breadth‑first search and accumulate\n    # distances to nodes that come after it in the list to avoid\n    # double counting unordered pairs.\n    for i, start in enumerate(nodes):\n        # BFS from start\n        visited = {start: 0}\n        queue = [start]\n        while queue:\n            v = queue.pop(0)\n            cur_dist = visited[v]\n            for nb in G[v]:\n                if nb not in visited:\n                    visited[nb] = cur_dist + 1\n                    queue.append(nb)\n\n        # Add distances to nodes with index > i\n        for target in nodes[i + 1:]:\n            if target in visited:\n                total_dist += visited[target]\n                pair_count += 1\n\n    # If there were no reachable pairs, return 0.0\n    if pair_count == 0:\n        return 0.0\n\n    return total_dist / pair_count",
        "island_id": 2,
        "generation": 3,
        "train_score": 0.9999999999999999,
        "val_score": 0.6464465246517107,
        "simplicity_score": 0.15242572315852856,
        "novelty_bonus": 0.07980690010002534
      }
    ],
    "3": [
      {
        "id": "g8_i3_p3_495625870",
        "code": "def new_invariant(G):\n    nodes = list(G.nodes())\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    idx = {node: i for i, node in enumerate(nodes)}\n    total = 0\n    pairs = 0\n\n    for src in nodes:\n        dist = {src: 0}\n        queue = [src]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = dist[u] + 1\n                    queue.append(v)\n\n        si = idx[src]\n        for tgt, d in dist.items():\n            if tgt == src:\n                continue\n            if idx[tgt] > si:  # count each unordered pair only once\n                total += d\n                pairs += 1\n\n    if pairs == 0:\n        return 0.0\n    return total / pairs",
        "island_id": 3,
        "generation": 8,
        "train_score": 0.9999999999999999,
        "val_score": 0.6498343399386541,
        "simplicity_score": 0.16936479959324566,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g4_i3_p2_139752483",
        "code": "def new_invariant(G):\n    nodes = list(G.nodes())\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n    idx = {node: i for i, node in enumerate(nodes)}\n    total = 0\n    pairs = 0\n    for src in nodes:\n        dist = {src: 0}\n        queue = [src]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            du = dist[u]\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = du + 1\n                    queue.append(v)\n        si = idx[src]\n        for tgt, d in dist.items():\n            if tgt == src:\n                continue\n            ti = idx[tgt]\n            if ti > si:\n                total += d\n                pairs += 1\n    if pairs == 0:\n        return 0.0\n    return total / pairs",
        "island_id": 3,
        "generation": 4,
        "train_score": 0.9999999999999999,
        "val_score": 0.6497482368633731,
        "simplicity_score": 0.16893428421684087,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g6_i3_p1_436717389",
        "code": "def new_invariant(G):\n    nodes = list(G.nodes())\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n    idx = {node: i for i, node in enumerate(nodes)}\n    total = 0\n    pairs = 0\n    for src in nodes:\n        dist = {src: 0}\n        queue = [src]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            du = dist[u]\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = du + 1\n                    queue.append(v)\n        si = idx[src]\n        for tgt, d in dist.items():\n            if tgt == src:\n                continue\n            ti = idx[tgt]\n            if ti > si:\n                total += d\n                pairs += 1\n    if pairs == 0:\n        return 0.0\n    return total / pairs",
        "island_id": 3,
        "generation": 6,
        "train_score": 0.9999999999999999,
        "val_score": 0.6497482368633731,
        "simplicity_score": 0.16893428421684087,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g9_i3_p0_457417486",
        "code": "def new_invariant(G):\n    nodes = list(G.nodes())\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n\n    idx = {node: i for i, node in enumerate(nodes)}\n    total = 0\n    pairs = 0\n\n    for src in nodes:\n        dist = {src: 0}\n        queue = [src]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            du = dist[u]\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = du + 1\n                    queue.append(v)\n\n        si = idx[src]\n        for tgt, d in dist.items():\n            if tgt == src:\n                continue\n            ti = idx[tgt]\n            if ti > si:\n                total += d\n                pairs += 1\n\n    if pairs == 0:\n        return 0.0\n    return total / pairs",
        "island_id": 3,
        "generation": 9,
        "train_score": 0.9999999999999999,
        "val_score": 0.6497482368633731,
        "simplicity_score": 0.16893428421684087,
        "novelty_bonus": 0.07980690010002534
      },
      {
        "id": "g10_i3_p3_176772782",
        "code": "def new_invariant(G):\n    nodes = list(G.nodes())\n    n = len(nodes)\n    if n <= 1:\n        return 0.0\n    idx = {node: i for i, node in enumerate(nodes)}\n    total = 0\n    pairs = 0\n    for src in nodes:\n        dist = {src: 0}\n        queue = [src]\n        qi = 0\n        while qi < len(queue):\n            u = queue[qi]\n            qi += 1\n            du = dist[u]\n            for v in G.neighbors(u):\n                if v not in dist:\n                    dist[v] = du + 1\n                    queue.append(v)\n        si = idx[src]\n        for tgt, d in dist.items():\n            if tgt == src:\n                continue\n            ti = idx[tgt]\n            if ti > si:\n                total += d\n                pairs += 1\n    if pairs == 0:\n        return 0.0\n    return total / pairs",
        "island_id": 3,
        "generation": 10,
        "train_score": 0.9999999999999999,
        "val_score": 0.6497482368633731,
        "simplicity_score": 0.16893428421684087,
        "novelty_bonus": 0.07980690010002534
      }
    ]
  }
}