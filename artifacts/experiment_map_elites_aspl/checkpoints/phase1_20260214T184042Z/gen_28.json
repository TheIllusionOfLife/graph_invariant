{
  "experiment_id": "phase1_20260214T184042Z",
  "generation": 28,
  "rng_seed": 42,
  "rng_state": {
    "bit_generator": "PCG64",
    "state": {
      "state": 3906502653825831485749613239869481206,
      "inc": 332724090758049132448979897138935081983
    },
    "has_uint32": 1,
    "uinteger": 1350509431
  },
  "best_val_score": 0.5524962124229404,
  "no_improve_count": 1,
  "island_stagnation": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_prompt_mode": {
    "0": "free",
    "1": "free",
    "2": "free",
    "3": "free"
  },
  "island_constrained_generations": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_recent_failures": {
    "0": [
      "no_valid_train_predictions: static_invalid: invalid syntax: unterminated string literal (detected at line 1)",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_novelty_threshold: novelty_bonus=0.038747"
    ],
    "1": [
      "below_novelty_threshold: novelty_bonus=0.138779",
      "below_novelty_threshold: novelty_bonus=0.122348",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ],
    "2": [
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_train_threshold: train_signal=0.010230",
      "below_novelty_threshold: novelty_bonus=0.145549"
    ],
    "3": [
      "below_novelty_threshold: novelty_bonus=0.121035",
      "below_novelty_threshold: novelty_bonus=0.129980",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ]
  },
  "islands": {
    "0": [
      {
        "id": "g19_i3_p3_146173244",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph\n    statistics.  The estimate is a smooth multiplicative combination of\n    non‑linear transforms that reflect (i) graph size versus average\n    degree, (ii) sparsity, (iii) local clustering, (iv) global transitivity,\n    (v) triangle abundance, (vi) degree heterogeneity, (vii) extremal\n    degrees, (viii) degree assortativity, and (ix) the median degree\n    (obtained from the sorted degree list).  No graph traversal or external\n    libraries are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n            n (int)                – number of nodes\n            m (int)                – number of edges\n            density (float)        – edge density (0‑1)\n            avg_degree (float)     – mean degree\n            max_degree (int)       – maximum degree\n            min_degree (int)       – minimum degree\n            std_degree (float)     – standard deviation of degrees\n            avg_clustering (float) – average clustering coefficient\n            transitivity (float)   – global transitivity\n            degree_assortativity (float)\n            num_triangles (int)    – number of triangles\n            degrees (list[int])    – sorted list of node degrees\n\n    Returns\n    -------\n    float\n        Continuous, non‑negative estimate of the average shortest‑path\n        length.\n    \"\"\"\n    eps = 1e-12   # to avoid division by zero\n\n    n        = float(s['n'])\n    m        = float(s['m'])\n    dens     = float(s['density']) + eps\n    a_deg    = float(s['avg_degree']) + eps\n    max_deg  = float(s['max_degree']) + eps\n    min_deg  = float(s['min_degree']) + eps\n    std_deg  = float(s['std_degree']) + eps\n    a_clust  = float(s['avg_clustering']) + eps\n    trans    = float(s['transitivity']) + eps\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles']) + 1.0\n\n    # (i) Size vs. average degree – larger sparse graphs tend to have longer paths\n    size_term = (n ** 0.5) / (a_deg + 1.0)\n\n    # (ii) Sparsity penalty – low density inflates distances\n    sparsity_term = 1.0 / dens\n\n    # (iii) Local clustering slightly increases distances\n    clustering_term = 1.0 + a_clust\n\n    # (iv) Global transitivity further shortens paths\n    trans_term = 1.0 + trans\n\n    # (v) Triangle abundance creates shortcuts\n    triangle_term = 1.0 + (tri / (m + 1.0)) ** 0.4\n\n    # (vi) Degree heterogeneity (high std relative to mean) typically shortens paths\n    hetero_term = 1.0 + (std_deg / a_deg) ** 0.3\n\n    # (vii) Extremal degrees – hubs pull nodes close, isolated nodes push them apart\n    max_term = 1.0 + (max_deg / a_deg) ** 0.2\n    min_term = 1.0 + 1.0 / (min_deg + 1.0)\n\n    # (viii) Degree assortativity amplifies the overall effect\n    assort_term = 1.0 + abs(assort)\n\n    # (ix) Median degree (from the sorted degree list) captures typical\n    #      connectivity and adds another heterogeneity dimension.\n    degrees = s['degrees']\n    mid_index = len(degrees) // 2\n    median_deg = float(degrees[mid_index]) if degrees else a_deg\n    median_term = 1.0 + (median_deg / a_deg) ** 0.3\n\n    # Combine all multiplicative terms to obtain a smooth estimate\n    estimate = (size_term *\n                sparsity_term *\n                clustering_term *\n                trans_term *\n                triangle_term *\n                hetero_term *\n                max_term *\n                min_term *\n                assort_term *\n                median_term)\n\n    return float(estimate)",
        "island_id": 3,
        "generation": 19,
        "train_score": 0.9443937575030013,
        "val_score": 0.5434966253021819,
        "simplicity_score": 0.15431304674817606,
        "novelty_bonus": 0.15231680792019786
      },
      {
        "id": "g25_i0_p4_132102837",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph\n    statistics.  The estimate is a smooth multiplicative combination of\n    several terms that capture the size of the network, its sparsity,\n    clustering, triangle abundance, degree heterogeneity, extremal\n    degrees, assortativity, and the median degree.  No graph traversal\n    or external imports are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed graph features.  Expected keys:\n            - 'n'                : number of nodes\n            - 'm'                : number of edges\n            - 'density'          : edge density (0‑1)\n            - 'avg_degree'       : average degree\n            - 'max_degree'       : maximum degree\n            - 'min_degree'       : minimum degree\n            - 'std_degree'       : standard deviation of degrees\n            - 'avg_clustering'   : average local clustering coefficient\n            - 'transitivity'     : global transitivity\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'    : total number of triangles\n            - 'degrees'          : sorted list of node degrees\n\n    Returns\n    -------\n    float\n        Continuous, non‑negative estimate of the average shortest‑path\n        length.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    # Basic statistics\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density']) + eps\n    avg_deg    = float(s['avg_degree']) + eps\n    max_deg    = float(s['max_degree']) + eps\n    min_deg    = float(s['min_degree']) + eps\n    std_deg    = float(s['std_degree']) + eps\n    avg_clust  = float(s['avg_clustering']) + eps\n    trans      = float(s['transitivity']) + eps\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles']) + 1.0\n\n    # Median degree\n    degrees = s['degrees']\n    if degrees:\n        mid = len(degrees) // 2\n        if len(degrees) % 2 == 0:\n            median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n        else:\n            median_deg = degrees[mid]\n    else:\n        median_deg = avg_deg\n\n    # Individual multiplicative factors\n    size_factor      = (n ** 0.5) / (avg_deg + 1.0)\n    density_factor   = 1.0 / density\n    clustering_factor= 1.0 + avg_clust\n    trans_factor     = 1.0 + trans\n    triangle_factor  = 1.0 + ((num_tri / (m + 1.0)) ** 0.4)\n    hetero_factor    = 1.0 + ((std_deg / avg_deg) ** 0.3)\n    max_factor       = 1.0 + ((max_deg / avg_deg) ** 0.2)\n    min_factor       = 1.0 + 1.0 / (min_deg + 1.0)\n    assort_factor    = 1.0 + abs(assort)\n    median_factor    = 1.0 + ((median_deg / avg_deg) ** 0.3)\n\n    # Combine all factors\n    estimate = (size_factor *\n                density_factor *\n                clustering_factor *\n                trans_factor *\n                triangle_factor *\n                hetero_factor *\n                max_factor *\n                min_factor *\n                assort_factor *\n                median_factor)\n\n    return float(estimate)",
        "island_id": 0,
        "generation": 25,
        "train_score": 0.9443937575030013,
        "val_score": 0.5434803280012999,
        "simplicity_score": 0.153609794485866,
        "novelty_bonus": 0.1523513087827194
      },
      {
        "id": "g26_i0_p1_253383353",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph\n    statistics.  The estimate is a smooth multiplicative combination of\n    several terms that capture the size of the network, its sparsity,\n    clustering, triangle abundance, degree heterogeneity, extremal\n    degrees, assortativity, and the median degree.  No graph traversal\n    or external imports are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed graph features.  Expected keys:\n            - 'n'                : number of nodes\n            - 'm'                : number of edges\n            - 'density'          : edge density (0‑1)\n            - 'avg_degree'       : average degree\n            - 'max_degree'       : maximum degree\n            - 'min_degree'       : minimum degree\n            - 'std_degree'       : standard deviation of degrees\n            - 'avg_clustering'   : average local clustering coefficient\n            - 'transitivity'     : global transitivity\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'    : total number of triangles\n            - 'degrees'          : sorted list of node degrees\n\n    Returns\n    -------\n    float\n        Continuous, non‑negative estimate of the average shortest‑path\n        length.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    # Basic statistics\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density']) + eps\n    avg_deg    = float(s['avg_degree']) + eps\n    max_deg    = float(s['max_degree']) + eps\n    min_deg    = float(s['min_degree']) + eps\n    std_deg    = float(s['std_degree']) + eps\n    avg_clust  = float(s['avg_clustering']) + eps\n    trans      = float(s['transitivity']) + eps\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles']) + 1.0\n\n    # Median degree from the sorted degree list\n    degrees = s['degrees']\n    if degrees:\n        l = len(degrees)\n        mid = l // 2\n        if l % 2 == 0:\n            median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n        else:\n            median_deg = degrees[mid]\n    else:\n        median_deg = avg_deg\n\n    # Individual multiplicative factors\n    size_factor      = (n ** 0.5) / (avg_deg + 1.0)\n    density_factor   = 1.0 / density\n    clustering_factor= 1.0 + avg_clust\n    trans_factor     = 1.0 + trans\n    triangle_factor  = 1.0 + ((num_tri / (m + 1.0)) ** 0.4)\n    hetero_factor    = 1.0 + ((std_deg / avg_deg) ** 0.3)\n    max_factor       = 1.0 + ((max_deg / avg_deg) ** 0.2)\n    min_factor       = 1.0 + 1.0 / (min_deg + 1.0)\n    assort_factor    = 1.0 + abs(assort)\n    median_factor    = 1.0 + ((median_deg / avg_deg) ** 0.3)\n\n    # Combine all factors\n    estimate = (size_factor *\n                density_factor *\n                clustering_factor *\n                trans_factor *\n                triangle_factor *\n                hetero_factor *\n                max_factor *\n                min_factor *\n                assort_factor *\n                median_factor)\n\n    return float(estimate)",
        "island_id": 0,
        "generation": 26,
        "train_score": 0.9443937575030013,
        "val_score": 0.5434727688173149,
        "simplicity_score": 0.15357199856594123,
        "novelty_bonus": 0.1523513087827194
      },
      {
        "id": "g26_i0_p2_721856569",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph\n    statistics.  The estimate is a smooth multiplicative combination of\n    several terms that capture the size of the network, its sparsity,\n    clustering, triangle abundance, degree heterogeneity, extremal\n    degrees, assortativity, and the median degree.  No graph traversal\n    or external imports are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed graph features.  Expected keys:\n            - 'n'                : number of nodes\n            - 'm'                : number of edges\n            - 'density'          : edge density (0‑1)\n            - 'avg_degree'       : average degree\n            - 'max_degree'       : maximum degree\n            - 'min_degree'       : minimum degree\n            - 'std_degree'       : standard deviation of degrees\n            - 'avg_clustering'   : average local clustering coefficient\n            - 'transitivity'     : global transitivity\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'    : total number of triangles\n            - 'degrees'          : sorted list of node degrees\n\n    Returns\n    -------\n    float\n        Continuous, non‑negative estimate of the average shortest‑path\n        length.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density']) + eps\n    avg_deg    = float(s['avg_degree']) + eps\n    max_deg    = float(s['max_degree']) + eps\n    min_deg    = float(s['min_degree']) + eps\n    std_deg    = float(s['std_degree']) + eps\n    avg_clust  = float(s['avg_clustering']) + eps\n    trans      = float(s['transitivity']) + eps\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles']) + 1.0\n\n    # median degree from the sorted degree list\n    degrees = s['degrees']\n    if degrees:\n        l = len(degrees)\n        mid = l // 2\n        if l % 2 == 0:\n            median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n        else:\n            median_deg = degrees[mid]\n    else:\n        median_deg = avg_deg\n\n    # Individual multiplicative factors\n    size_factor      = (n ** 0.5) / (avg_deg + 1.0)\n    density_factor   = 1.0 / density\n    clustering_factor= 1.0 + avg_clust\n    trans_factor     = 1.0 + trans\n    triangle_factor  = 1.0 + ((num_tri / (m + 1.0)) ** 0.4)\n    hetero_factor    = 1.0 + ((std_deg / avg_deg) ** 0.3)\n    max_factor       = 1.0 + ((max_deg / avg_deg) ** 0.2)\n    min_factor       = 1.0 + 1.0 / (min_deg + 1.0)\n    assort_factor    = 1.0 + abs(assort)\n    median_factor    = 1.0 + ((median_deg / avg_deg) ** 0.3)\n\n    # Combine all factors\n    estimate = (size_factor *\n                density_factor *\n                clustering_factor *\n                trans_factor *\n                triangle_factor *\n                hetero_factor *\n                max_factor *\n                min_factor *\n                assort_factor *\n                median_factor)\n\n    return float(estimate)",
        "island_id": 0,
        "generation": 26,
        "train_score": 0.9443937575030013,
        "val_score": 0.5434727688173149,
        "simplicity_score": 0.15357199856594123,
        "novelty_bonus": 0.1523513087827194
      },
      {
        "id": "g27_i0_p1_117103565",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of global graph\n    statistics.  The estimate is a smooth multiplicative combination of\n    several terms that capture the size of the network, its sparsity,\n    clustering, triangle abundance, degree heterogeneity, extremal degrees,\n    assortativity, and the median degree.  No graph traversal or external\n    imports are used.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed graph features.  Expected keys:\n            - 'n'                : number of nodes\n            - 'm'                : number of edges\n            - 'density'          : edge density (0‑1)\n            - 'avg_degree'       : average degree\n            - 'max_degree'       : maximum degree\n            - 'min_degree'       : minimum degree\n            - 'std_degree'       : standard deviation of degrees\n            - 'avg_clustering'   : average local clustering coefficient\n            - 'transitivity'     : global transitivity\n            - 'degree_assortativity' : degree assortativity coefficient\n            - 'num_triangles'    : total number of triangles\n            - 'degrees'          : sorted list of node degrees\n\n    Returns\n    -------\n    float\n        Continuous, non‑negative estimate of the average shortest‑path\n        length.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    # Basic statistics\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density']) + eps\n    avg_deg    = float(s['avg_degree']) + eps\n    max_deg    = float(s['max_degree']) + eps\n    min_deg    = float(s['min_degree']) + eps\n    std_deg    = float(s['std_degree']) + eps\n    avg_clust  = float(s['avg_clustering']) + eps\n    trans      = float(s['transitivity']) + eps\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles']) + 1.0\n\n    # Median degree from the sorted degree list\n    degrees = s['degrees']\n    if degrees:\n        l = len(degrees)\n        mid = l // 2\n        if l % 2 == 0:\n            median_deg = (degrees[mid - 1] + degrees[mid]) / 2.0\n        else:\n            median_deg = degrees[mid]\n    else:\n        median_deg = avg_deg\n\n    # Individual multiplicative factors\n    size_factor      = (n ** 0.5) / (avg_deg + 1.0)\n    density_factor   = 1.0 / density\n    clustering_factor= 1.0 + avg_clust\n    trans_factor     = 1.0 + trans\n    triangle_factor  = 1.0 + ((num_tri / (m + 1.0)) ** 0.4)\n    hetero_factor    = 1.0 + ((std_deg / avg_deg) ** 0.3)\n    max_factor       = 1.0 + ((max_deg / avg_deg) ** 0.2)\n    min_factor       = 1.0 + 1.0 / (min_deg + 1.0)\n    assort_factor    = 1.0 + abs(assort)\n    median_factor    = 1.0 + ((median_deg / avg_deg) ** 0.3)\n\n    # Combine all factors\n    estimate = (size_factor *\n                density_factor *\n                clustering_factor *\n                trans_factor *\n                triangle_factor *\n                hetero_factor *\n                max_factor *\n                min_factor *\n                assort_factor *\n                median_factor)\n\n    return float(estimate)",
        "island_id": 0,
        "generation": 27,
        "train_score": 0.9443937575030013,
        "val_score": 0.5434727688173149,
        "simplicity_score": 0.15357199856594123,
        "novelty_bonus": 0.1523513087827194
      }
    ],
    "1": [
      {
        "id": "g10_i1_p3_786886457",
        "code": "def new_invariant(s):\n    eps = 1e-12\n\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base factor: size and average degree\n    base = pow(n, 0.5) / (avg_deg + 1)\n\n    # Size‑edge interaction\n    size_edge = n / (m + 1)\n\n    # Triangle influence\n    tri = 1 + triangles / (m + 1)\n\n    # Clustering and transitivity\n    clu = 1 + clustering\n    trans_f = 1 + trans\n\n    # Sparsity\n    dens = 1 / (density + eps)\n\n    # Assortativity strength\n    assort_f = 1 + abs(assort)\n\n    # Degree spread\n    std_f = 1 + std_deg / (avg_deg + eps)\n\n    # Extremal degrees\n    max_f = 1 + max_deg / (avg_deg + 1)\n    min_f = 1 + min_deg / (avg_deg + eps)\n\n    # Degree‑sequence shape (harmonic mean)\n    nonzero = [d for d in degrees if d > 0]\n    if nonzero:\n        harmonic = len(nonzero) / sum(1.0 / d for d in nonzero)\n    else:\n        harmonic = 1.0\n    deg_shape = harmonic / (avg_deg + eps)\n\n    # Relative degree ratio\n    rel_avg_max = 1 + avg_deg / (max_deg + 1)\n\n    # Combine all contributions multiplicatively\n    invariant = (\n        base *\n        size_edge *\n        tri *\n        clu *\n        trans_f *\n        dens *\n        assort_f *\n        std_f *\n        max_f *\n        min_f *\n        deg_shape *\n        rel_avg_max\n    )\n\n    return float(invariant)",
        "island_id": 1,
        "generation": 10,
        "train_score": 0.9127010804321728,
        "val_score": 0.5375940988048828,
        "simplicity_score": 0.15261039225509246,
        "novelty_bonus": 0.19198829970749254
      },
      {
        "id": "g9_i1_p3_455776289",
        "code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clu = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Base factor: size and average degree\n    base = (n ** 0.5) / (avg_deg + 1)\n\n    # Size‑edge interaction\n    size_edge = n / (m + 1)\n\n    # Triangle influence\n    tri_factor = 1 + num_tri / (m + 1)\n\n    # Clustering and transitivity\n    clu_factor = 1 + avg_clu\n    trans_factor = 1 + trans\n\n    # Sparsity\n    dens_factor = 1 / (density + eps)\n\n    # Assortativity strength\n    assort_factor = 1 + abs(assort)\n\n    # Degree spread\n    std_factor = 1 + std_deg / (avg_deg + eps)\n\n    # Extremal degrees\n    max_factor = 1 + max_deg / (avg_deg + 1)\n    min_factor = 1 + min_deg / (avg_deg + eps)\n\n    # Degree‑sequence shape (harmonic mean)\n    nonzero_deg = [d for d in degrees if d > 0]\n    if nonzero_deg:\n        harmonic = len(nonzero_deg) / sum(1.0 / d for d in nonzero_deg)\n    else:\n        harmonic = 1.0\n    deg_shape_factor = harmonic / (avg_deg + eps)\n\n    # Relative degree ratios\n    rel_avg_max = 1 + avg_deg / (max_deg + 1)\n    rel_min_max = 1 + min_deg / (max_deg + 1)\n    rel_std_max = 1 + std_deg / (max_deg + 1)\n\n    # Combine all contributions multiplicatively\n    invariant = (\n        base *\n        size_edge *\n        tri_factor *\n        clu_factor *\n        trans_factor *\n        dens_factor *\n        assort_factor *\n        std_factor *\n        max_factor *\n        min_factor *\n        deg_shape_factor *\n        rel_avg_max *\n        rel_min_max *\n        rel_std_max\n    )\n    return float(invariant)",
        "island_id": 1,
        "generation": 9,
        "train_score": 0.9024249699879953,
        "val_score": 0.5365733928946387,
        "simplicity_score": 0.1518464803042319,
        "novelty_bonus": 0.20529063226580657
      },
      {
        "id": "g11_i1_p4_82729999",
        "code": "def new_invariant(s):\n    eps = 1e-12\n\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base factor: size and average degree\n    base = (n ** 0.5) / (avg_deg + 1)\n\n    # Size‑edge interaction\n    size_edge = n / (m + 1)\n\n    # Triangle influence\n    tri = 1 + triangles / (m + 1)\n\n    # Clustering and transitivity\n    clu = 1 + clustering\n    trans_f = 1 + trans\n\n    # Sparsity\n    dens = 1 / (density + eps)\n\n    # Assortativity strength\n    assort_f = 1 + abs(assort)\n\n    # Degree spread\n    std_f = 1 + std_deg / (avg_deg + eps)\n\n    # Extremal degrees\n    max_f = 1 + max_deg / (avg_deg + 1)\n    min_f = 1 + min_deg / (avg_deg + eps)\n\n    # Degree‑sequence shape (harmonic mean)\n    nonzero = [d for d in degrees if d > 0]\n    if nonzero:\n        harmonic = len(nonzero) / sum(1.0 / d for d in nonzero)\n    else:\n        harmonic = 1.0\n    deg_shape = harmonic / (avg_deg + eps)\n\n    # Relative degree ratios\n    rel_avg_max = 1 + avg_deg / (max_deg + 1)\n    rel_min_max = 1 + min_deg / (max_deg + 1)\n    rel_std_max = 1 + std_deg / (max_deg + 1)\n\n    # Combine all contributions multiplicatively\n    invariant = (\n        base *\n        size_edge *\n        tri *\n        clu *\n        trans_f *\n        dens *\n        assort_f *\n        std_f *\n        max_f *\n        min_f *\n        deg_shape *\n        rel_avg_max *\n        rel_min_max *\n        rel_std_max\n    )\n\n    return float(invariant)",
        "island_id": 1,
        "generation": 11,
        "train_score": 0.9024249699879953,
        "val_score": 0.5365733928946387,
        "simplicity_score": 0.1518464803042319,
        "novelty_bonus": 0.20529063226580657
      },
      {
        "id": "g13_i1_p4_634831088",
        "code": "def new_invariant(s):\n    eps = 1e-12\n\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_clu    = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base factor: size and average degree\n    base = (n ** 0.5) / (avg_deg + 1)\n\n    # Size‑edge interaction\n    size_edge = n / (m + 1)\n\n    # Triangle influence\n    tri = 1 + num_tri / (m + 1)\n\n    # Clustering and transitivity\n    clu = 1 + avg_clu\n    trans_f = 1 + trans\n\n    # Sparsity\n    dens = 1 / (density + eps)\n\n    # Assortativity strength\n    assort_f = 1 + abs(assort)\n\n    # Degree spread\n    std_f = 1 + std_deg / (avg_deg + eps)\n\n    # Extremal degrees\n    max_f = 1 + max_deg / (avg_deg + 1)\n    min_f = 1 + min_deg / (avg_deg + eps)\n\n    # Degree‑sequence shape (harmonic mean)\n    nonzero = [d for d in degrees if d > 0]\n    if nonzero:\n        harmonic = len(nonzero) / sum(1.0 / d for d in nonzero)\n    else:\n        harmonic = 1.0\n    deg_shape = harmonic / (avg_deg + eps)\n\n    # Relative degree ratios\n    rel_avg_max = 1 + avg_deg / (max_deg + 1)\n    rel_min_max = 1 + min_deg / (max_deg + 1)\n    rel_std_max = 1 + std_deg / (max_deg + 1)\n\n    # Combine all contributions multiplicatively\n    invariant = (\n        base *\n        size_edge *\n        tri *\n        clu *\n        trans_f *\n        dens *\n        assort_f *\n        std_f *\n        max_f *\n        min_f *\n        deg_shape *\n        rel_avg_max *\n        rel_min_max *\n        rel_std_max\n    )\n\n    return float(invariant)",
        "island_id": 1,
        "generation": 13,
        "train_score": 0.9024249699879953,
        "val_score": 0.5365733928946387,
        "simplicity_score": 0.1518464803042319,
        "novelty_bonus": 0.20529063226580657
      },
      {
        "id": "g14_i1_p1_518858360",
        "code": "def new_invariant(s):\n    eps = 1e-12\n\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Base factor: size and average degree\n    base = (n ** 0.5) / (avg_deg + 1)\n\n    # Size‑edge interaction\n    size_edge = n / (m + 1)\n\n    # Triangle influence\n    tri = 1 + triangles / (m + 1)\n\n    # Clustering and transitivity\n    clu = 1 + clustering\n    trans_f = 1 + trans\n\n    # Sparsity\n    dens = 1 / (density + eps)\n\n    # Assortativity strength\n    assort_f = 1 + abs(assort)\n\n    # Degree spread\n    std_f = 1 + std_deg / (avg_deg + eps)\n\n    # Extremal degrees\n    max_f = 1 + max_deg / (avg_deg + 1)\n    min_f = 1 + min_deg / (avg_deg + eps)\n\n    # Degree‑sequence shape (harmonic mean)\n    nonzero = [d for d in degrees if d > 0]\n    if nonzero:\n        harmonic = len(nonzero) / sum(1.0 / d for d in nonzero)\n    else:\n        harmonic = 1.0\n    deg_shape = harmonic / (avg_deg + eps)\n\n    # Relative degree ratios\n    rel_avg_max = 1 + avg_deg / (max_deg + 1)\n    rel_min_max = 1 + min_deg / (max_deg + 1)\n    rel_std_max = 1 + std_deg / (max_deg + 1)\n\n    # Combine all contributions multiplicatively\n    invariant = (\n        base *\n        size_edge *\n        tri *\n        clu *\n        trans_f *\n        dens *\n        assort_f *\n        std_f *\n        max_f *\n        min_f *\n        deg_shape *\n        rel_avg_max *\n        rel_min_max *\n        rel_std_max\n    )\n\n    return float(invariant)",
        "island_id": 1,
        "generation": 14,
        "train_score": 0.9024249699879953,
        "val_score": 0.5365733928946387,
        "simplicity_score": 0.1518464803042319,
        "novelty_bonus": 0.20529063226580657
      }
    ],
    "2": [
      {
        "id": "g26_i2_p1_727748755",
        "code": "def new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph quantities\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_clust  = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # ----- Multiplicative components -----\n    base = pow(n, 0.5) / (avg_deg + 1)                    # size vs average degree\n    dens_factor = 1 / (density + eps)                    # sparsity\n    clu_factor  = pow(1 + avg_clust, 0.6)                # clustering\n    trans_factor = pow(1 + trans, 0.5)                   # transitivity\n    assort_factor = 1 + abs(assort)                      # assortativity\n    tri_factor = 1 + num_tri / (m + 1)                   # triangles\n    std_factor = 1 + std_deg / (avg_deg + eps)           # degree spread\n    size_edge_factor = pow(n / (m + 1), 0.5)             # size‑edge interaction\n\n    # Degree‑sequence shape via harmonic mean\n    nonzero = [d for d in degrees if d > 0]\n    if nonzero:\n        harmonic = len(nonzero) / sum(1.0 / d for d in nonzero)\n    else:\n        harmonic = 1.0\n    deg_shape_factor = harmonic / (avg_deg + eps)\n\n    # Relative average to maximum degree\n    rel_avg_max = 1 + avg_deg / (max_deg + 1)\n\n    # ----- Combine all factors -----\n    estimate = (base * dens_factor * clu_factor * trans_factor *\n                assort_factor * tri_factor * std_factor *\n                size_edge_factor * deg_shape_factor * rel_avg_max)\n\n    # Clamp to realistic bounds\n    if estimate < 1.0:\n        estimate = 1.0\n    elif estimate > n:\n        estimate = float(n)\n\n    return estimate",
        "island_id": 2,
        "generation": 26,
        "train_score": 0.9360384153661465,
        "val_score": 0.5524962124229404,
        "simplicity_score": 0.17772139524247826,
        "novelty_bonus": 0.1643442214042362
      },
      {
        "id": "g24_i2_p0_804391827",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length (ASPL) from pre‑computed\n    graph statistics.  The expression combines several structural\n    factors with modest exponents to keep the formula compact while\n    improving accuracy over the baseline product.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph quantities\n    n = s['n']\n    m = s['m']\n\n    density      = s.get('density', 0.0)\n    avg_deg      = s.get('avg_degree', 0.0)\n    std_deg      = s.get('std_degree', 0.0)\n    max_deg      = s.get('max_degree', 1)\n    min_deg      = s.get('min_degree', 0)\n    avg_clust    = s.get('avg_clustering', 0.0)\n    trans        = s.get('transitivity', 0.0)\n    assort       = s.get('degree_assortativity', 0.0)\n    num_tri      = s.get('num_triangles', 0)\n    degrees      = s.get('degrees', [])\n\n    # ---------- Component factors ----------\n    # Size versus average degree\n    base = (n ** 0.5) / (avg_deg + 1)\n\n    # Sparsity (denser graphs → shorter paths)\n    dens_factor = 1 / (density + eps)\n\n    # Clustering and transitivity, tempered by fractional exponents\n    clu_factor   = 1 + avg_clust\n    trans_factor = 1 + trans\n    clu_factor   = pow(clu_factor, 0.7)\n    trans_factor = pow(trans_factor, 0.6)\n\n    # Positive assortativity shortens paths\n    assort_factor = 1 + max(0.0, assort)\n\n    # Triangle abundance provides alternative short routes\n    tri_factor = 1 + num_tri / (m + 1)\n\n    # Degree dispersion may lengthen paths\n    std_factor = 1 + std_deg / (avg_deg + eps)\n\n    # Size‑edge interaction (edges per vertex)\n    size_edge_factor = (n / (m + 1)) ** 0.5\n\n    # Degree‑sequence shape via harmonic mean ratio\n    if degrees:\n        harmonic = len(degrees) / sum(1.0 / d if d > 0 else 0 for d in degrees)\n    else:\n        harmonic = 1.0\n    deg_shape = harmonic / (avg_deg + eps)\n    deg_shape = pow(deg_shape, 0.5)\n\n    # ---------- Combine ----------\n    estimate = (\n        base *\n        dens_factor *\n        clu_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        std_factor *\n        size_edge_factor *\n        deg_shape\n    )\n\n    # Clamp to realistic bounds\n    if estimate < 1.0:\n        estimate = 1.0\n    elif estimate > n:\n        estimate = float(n)\n\n    return estimate",
        "island_id": 2,
        "generation": 24,
        "train_score": 0.9452581032412964,
        "val_score": 0.5503922782177872,
        "simplicity_score": 0.17743687048891446,
        "novelty_bonus": 0.15035060592384686
      },
      {
        "id": "g26_i2_p2_763923389",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length (ASPL) from a set of\n    pre‑computed graph statistics.  The expression is kept compact by\n    multiplying a small number of factors, each with a modest\n    fractional exponent.  No external libraries are required – only\n    built‑in Python functions.\n    \"\"\"\n    eps = 1e-12  # to avoid division by zero\n\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_clu    = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Basic structural factor: size vs average degree\n    base = pow(n, 0.5) / (avg_deg + 1)\n\n    # Sparsity: denser graphs have shorter paths\n    dens_factor = 1 / (density + eps)\n\n    # Clustering and transitivity (fractional exponents keep the influence moderate)\n    clu_factor   = pow(1 + avg_clu, 0.6)\n    trans_factor = pow(1 + trans, 0.5)\n\n    # Assortativity: both positive and negative values can affect ASPL\n    assort_factor = 1 + abs(assort)\n\n    # Triangle abundance provides alternative short routes\n    tri_factor = 1 + num_tri / (m + 1)\n\n    # Degree dispersion may lengthen paths\n    std_factor = 1 + std_deg / (avg_deg + eps)\n\n    # Size‑edge interaction: more edges per vertex generally reduce ASPL\n    size_edge_factor = pow(n / (m + 1), 0.5)\n\n    # Degree‑sequence shape via harmonic mean (ignoring zero degrees)\n    nonzero_deg = [d for d in degrees if d > 0]\n    if nonzero_deg:\n        harmonic = len(nonzero_deg) / sum(1.0 / d for d in nonzero_deg)\n    else:\n        harmonic = 1.0\n    deg_shape_factor = harmonic / (avg_deg + eps)\n\n    # Combine all contributions multiplicatively\n    estimate = (\n        base *\n        dens_factor *\n        clu_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        std_factor *\n        size_edge_factor *\n        deg_shape_factor\n    )\n\n    # Clamp to realistic bounds: ASPL is at least 1 and at most n\n    if estimate < 1.0:\n        estimate = 1.0\n    elif estimate > n:\n        estimate = float(n)\n\n    return float(estimate)",
        "island_id": 2,
        "generation": 26,
        "train_score": 0.9330612244897959,
        "val_score": 0.5457458225893734,
        "simplicity_score": 0.154940803466983,
        "novelty_bonus": 0.1573505758384398
      },
      {
        "id": "g27_i2_p1_898366547",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length (ASPL) from pre‑computed\n    graph statistics.  The formula multiplies a handful of compact\n    factors, each using only built‑in Python operations, to keep the\n    expression simple while still capturing key structural influences.\n    \"\"\"\n    eps = 1e-12  # avoid division by zero\n\n    # Extract features\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    avg_clust  = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # ----- Component factors -----\n    # Size vs. average degree\n    base = pow(n, 0.5) / (avg_deg + 1)\n\n    # Sparsity (denser graphs → shorter paths)\n    dens_factor = 1 / (density + eps)\n\n    # Clustering and transitivity (moderate influence)\n    clu_factor   = pow(1 + avg_clust, 0.5)\n    trans_factor = pow(1 + trans, 0.4)\n\n    # Assortativity (both signs can affect ASPL)\n    assort_factor = 1 + abs(assort)\n\n    # Triangle abundance\n    tri_factor = 1 + num_tri / (m + 1)\n\n    # Degree dispersion\n    std_factor = 1 + std_deg / (avg_deg + eps)\n\n    # Size‑edge interaction\n    size_edge_factor = pow(n / (m + 1), 0.5)\n\n    # Degree‑sequence shape via harmonic mean (ignore zeros)\n    nonzero = [d for d in degrees if d > 0]\n    if nonzero:\n        harmonic = len(nonzero) / sum(1.0 / d for d in nonzero)\n    else:\n        harmonic = 1.0\n    shape_factor = harmonic / (avg_deg + eps)\n    shape_factor = pow(shape_factor, 0.3)\n\n    # ----- Combine all contributions -----\n    estimate = (\n        base *\n        dens_factor *\n        clu_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        std_factor *\n        size_edge_factor *\n        shape_factor\n    )\n\n    # Clamp to realistic bounds: ASPL is at least 1 and at most n\n    if estimate < 1.0:\n        estimate = 1.0\n    elif estimate > n:\n        estimate = float(n)\n\n    return estimate",
        "island_id": 2,
        "generation": 27,
        "train_score": 0.924609843937575,
        "val_score": 0.5445489189581296,
        "simplicity_score": 0.17790327282754598,
        "novelty_bonus": 0.1569080626183521
      },
      {
        "id": "g25_i2_p1_723416511",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length (ASPL) from a set of\n    pre‑computed graph statistics.  The formula keeps the expression\n    compact by using a small number of multiplicative factors with\n    modest fractional exponents.  All arithmetic is performed with\n    built‑in Python functions only.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    avg_clu    = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # ---- Basic structural factor ----\n    base = (n ** 0.5) / (avg_deg + 1)\n\n    # ---- Sparsity (denser graphs → shorter paths) ----\n    dens_factor = 1 / (density + eps)\n\n    # ---- Clustering and transitivity ----\n    clu_factor   = (1 + avg_clu) ** 0.6\n    trans_factor = (1 + trans) ** 0.5\n\n    # ---- Assortativity ----\n    assort_factor = 1 + abs(assort)\n\n    # ---- Triangle abundance ----\n    tri_factor = 1 + num_tri / (m + 1)\n\n    # ---- Degree dispersion ----\n    std_factor = 1 + std_deg / (avg_deg + eps)\n\n    # ---- Size‑edge interaction ----\n    size_edge_factor = (n / (m + 1)) ** 0.5\n\n    # ---- Degree‑sequence shape (harmonic mean) ----\n    nonzero_deg = [d for d in degrees if d > 0]\n    if nonzero_deg:\n        harmonic = len(nonzero_deg) / sum(1.0 / d for d in nonzero_deg)\n    else:\n        harmonic = 1.0\n    deg_shape_factor = harmonic / (avg_deg + eps)\n\n    # ---- Relative degree ratios ----\n    rel_avg_max = 1 + avg_deg / (max_deg + 1)\n    rel_min_max = 1 + min_deg / (max_deg + 1)\n    rel_std_max = 1 + std_deg / (max_deg + 1)\n\n    # ---- Combine all contributions multiplicatively ----\n    estimate = (\n        base *\n        dens_factor *\n        clu_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        std_factor *\n        size_edge_factor *\n        deg_shape_factor *\n        rel_avg_max *\n        rel_min_max *\n        rel_std_max\n    )\n\n    # ---- Clamp to realistic bounds ----\n    if estimate < 1.0:\n        estimate = 1.0\n    elif estimate > n:\n        estimate = float(n)\n\n    return estimate",
        "island_id": 2,
        "generation": 25,
        "train_score": 0.8672749099639855,
        "val_score": 0.5397143054636072,
        "simplicity_score": 0.1769639687440645,
        "novelty_bonus": 0.16784501790350081
      }
    ],
    "3": [
      {
        "id": "g23_i3_p0_604177519",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate average shortest‑path length from pre‑computed graph statistics.\n    The formula is a smooth multiplicative combination of transformed\n    features that reflect size, sparsity, clustering, triangle shortcuts,\n    degree heterogeneity, extremal degrees, assortativity, transitivity,\n    and median degree.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    dens = s['density']\n    a_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    a_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    tri = s['num_triangles']\n    deg_list = s['degrees']\n\n    # 1. Size vs connectivity: larger sparse graphs → longer paths\n    size_term = pow(n, 0.5) / (a_deg + 1.0)\n\n    # 2. Sparsity penalty\n    sparsity_term = 1.0 / (dens + 1e-12)\n\n    # 3. Local clustering tends to increase path length\n    clustering_term = 1.0 + a_clust\n\n    # 4. Triangles provide shortcuts\n    triangle_term = 1.0 + pow((tri + 1.0) / (m + 1.0), 0.4)\n\n    # 5. Degree heterogeneity usually shortens paths\n    hetero_term = 1.0 + pow(std_deg / max(a_deg, 1.0), 0.3)\n\n    # 6. Extremal degrees\n    max_term = 1.0 + pow(max_deg / max(a_deg, 1.0), 0.2)\n    min_term = 1.0 + 1.0 / (min_deg + 1.0)\n\n    # 7. Degree assortativity amplifies the effect\n    assort_term = 1.0 + abs(assort)\n\n    # 8. Global transitivity shortens distances\n    trans_term = 1.0 + trans\n\n    # 9. Median degree captures typical connectivity\n    if deg_list:\n        median_deg = float(deg_list[len(deg_list) // 2])\n    else:\n        median_deg = float(a_deg)\n    median_term = 1.0 + pow(median_deg / max(a_deg, 1.0), 0.3)\n\n    # Combine all multiplicative terms to produce the final estimate\n    estimate = (\n        size_term *\n        sparsity_term *\n        clustering_term *\n        triangle_term *\n        hetero_term *\n        max_term *\n        min_term *\n        assort_term *\n        trans_term *\n        median_term\n    )\n\n    return float(estimate)",
        "island_id": 3,
        "generation": 23,
        "train_score": 0.9443937575030013,
        "val_score": 0.5437000762854024,
        "simplicity_score": 0.15533030166427855,
        "novelty_bonus": 0.15231680792019786
      },
      {
        "id": "g24_i3_p4_734893162",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    graph statistics.  The estimate is a smooth multiplicative combination\n    of transformed features that reflect graph size, sparsity, clustering,\n    triangle shortcuts, degree heterogeneity, extremal degrees,\n    degree assortativity, global transitivity, and the median degree.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics with keys:\n            n (int)                – number of nodes\n            m (int)                – number of edges\n            density (float)        – edge density (0‑1)\n            avg_degree (float)     – mean degree\n            max_degree (int)       – maximum degree\n            min_degree (int)       – minimum degree\n            std_degree (float)     – standard deviation of degrees\n            avg_clustering (float) – average clustering coefficient\n            transitivity (float)   – global transitivity\n            degree_assortativity (float)\n            num_triangles (int)    – number of triangles\n            degrees (list[int])    – sorted list of node degrees\n\n    Returns\n    -------\n    float\n        Continuous, non‑negative estimate of the average shortest‑path\n        length.  No external libraries or graph traversal is used.\n    \"\"\"\n    # Basic statistics cast to float to avoid integer division problems\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    deg_list   = s['degrees']\n\n    # Helper to avoid division by zero\n    eps = 1e-12\n\n    # 1. Size vs. average degree – larger sparse graphs tend to have longer paths\n    size_term = (n ** 0.5) / (avg_deg + 1.0)\n\n    # 2. Sparsity penalty – low density inflates distances\n    density_term = 1.0 / (density + eps)\n\n    # 3. Local clustering slightly increases distances\n    clustering_term = 1.0 + avg_clust\n\n    # 4. Triangle abundance creates shortcuts\n    triangle_term = 1.0 + ((num_tri + 1.0) / (m + 1.0)) ** 0.4\n\n    # 5. Degree heterogeneity (high std relative to mean) typically shortens paths\n    hetero_term = 1.0 + (std_deg / max(avg_deg, 1.0)) ** 0.3\n\n    # 6. Extremal degrees – hubs pull nodes close, isolated nodes push them apart\n    max_term = 1.0 + (max_deg / max(avg_deg, 1.0)) ** 0.2\n    min_term = 1.0 + 1.0 / (min_deg + 1.0)\n\n    # 7. Degree assortativity amplifies the overall effect\n    assort_term = 1.0 + abs(assort)\n\n    # 8. Global transitivity further shortens paths\n    trans_term = 1.0 + trans\n\n    # 9. Median degree (from the sorted degree list) captures typical connectivity\n    if deg_list:\n        median_deg = float(deg_list[len(deg_list) // 2])\n    else:\n        median_deg = avg_deg\n    median_term = 1.0 + (median_deg / max(avg_deg, 1.0)) ** 0.3\n\n    # Combine all multiplicative terms to obtain a smooth estimate\n    estimate = (size_term *\n                density_term *\n                clustering_term *\n                triangle_term *\n                hetero_term *\n                max_term *\n                min_term *\n                assort_term *\n                trans_term *\n                median_term)\n\n    return float(estimate)",
        "island_id": 3,
        "generation": 24,
        "train_score": 0.9443937575030013,
        "val_score": 0.543557799710093,
        "simplicity_score": 0.15461891878773135,
        "novelty_bonus": 0.15231680792019786
      },
      {
        "id": "g26_i3_p0_517706191",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph using only\n    pre‑computed statistics.\n\n    The estimate is a smooth, multiplicative combination of several\n    structural features that are known to influence the length of\n    shortest paths: the size versus average degree, sparsity,\n    local clustering, triangle shortcuts, degree heterogeneity,\n    presence of hubs and isolated nodes, degree assortativity,\n    global transitivity, and the median degree.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics with the following\n        keys:\n            n (int)                – number of nodes\n            m (int)                – number of edges\n            density (float)        – edge density (0‑1)\n            avg_degree (float)     – mean degree\n            max_degree (int)       – maximum degree\n            min_degree (int)       – minimum degree\n            std_degree (float)     – standard deviation of degrees\n            avg_clustering (float) – average clustering coefficient\n            transitivity (float)   – global transitivity\n            degree_assortativity (float)\n            num_triangles (int)    – number of triangles\n            degrees (list[int])    – sorted list of node degrees\n\n    Returns\n    -------\n    float\n        Continuous, non‑negative estimate of the average shortest‑path\n        length.  No graph traversal is performed.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    deg_list   = s.get('degrees', [])\n\n    # 1. Size vs. average degree\n    size_term = (n ** 0.5) / (avg_deg + 1.0)\n\n    # 2. Sparsity penalty\n    density_term = 1.0 / (density + eps)\n\n    # 3. Local clustering\n    clustering_term = 1.0 + avg_clust\n\n    # 4. Triangle shortcuts\n    triangle_term = 1.0 + ((num_tri + 1.0) / (m + 1.0)) ** 0.4\n\n    # 5. Degree heterogeneity\n    hetero_term = 1.0 + (std_deg / max(avg_deg, 1.0)) ** 0.3\n\n    # 6. Extremal degrees\n    max_term = 1.0 + (max_deg / max(avg_deg, 1.0)) ** 0.2\n    min_term = 1.0 + 1.0 / (min_deg + 1.0)\n\n    # 7. Degree assortativity\n    assort_term = 1.0 + abs(assort)\n\n    # 8. Global transitivity\n    trans_term = 1.0 + trans\n\n    # 9. Median degree\n    if deg_list:\n        median_deg = float(deg_list[len(deg_list) // 2])\n    else:\n        median_deg = avg_deg\n    median_term = 1.0 + (median_deg / max(avg_deg, 1.0)) ** 0.3\n\n    # Combine all terms multiplicatively\n    estimate = (size_term *\n                density_term *\n                clustering_term *\n                triangle_term *\n                hetero_term *\n                max_term *\n                min_term *\n                assort_term *\n                trans_term *\n                median_term)\n\n    return float(estimate)",
        "island_id": 3,
        "generation": 26,
        "train_score": 0.9443937575030013,
        "val_score": 0.5435444312238219,
        "simplicity_score": 0.15455207635637627,
        "novelty_bonus": 0.15231680792019786
      },
      {
        "id": "g27_i3_p2_795222948",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    graph statistics.  The estimate is a smooth multiplicative\n    combination of several structural features that are known to influence\n    path lengths: size vs. average degree, sparsity, local clustering,\n    triangle abundance, degree heterogeneity, the influence of hubs and\n    isolated vertices, degree assortativity, global transitivity, and the\n    median degree.\n\n    Parameters\n    ----------\n    s : dict\n        A dictionary containing the following pre‑computed statistics:\n            - n (int)                  : number of nodes\n            - m (int)                  : number of edges\n            - density (float)          : edge density (0‑1)\n            - avg_degree (float)       : mean degree\n            - max_degree (int)         : maximum degree\n            - min_degree (int)         : minimum degree\n            - std_degree (float)       : standard deviation of degrees\n            - avg_clustering (float)   : average clustering coefficient\n            - transitivity (float)     : global transitivity\n            - degree_assortativity (float)\n            - num_triangles (int)      : number of triangles\n            - degrees (list[int])      : sorted list of node degrees\n\n    Returns\n    -------\n    float\n        A non‑negative continuous estimate of the average shortest‑path\n        length.  No graph traversal or external libraries are used.\n    \"\"\"\n    # Safeguard against zero division\n    eps = 1e-12\n\n    n   = float(s['n'])\n    m   = float(s['m'])\n    dens = float(s['density'])\n    a_deg = float(s['avg_degree'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    std_deg = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n    deg_list = s.get('degrees', [])\n\n    # 1. Size vs. average degree – larger sparse graphs tend to have longer paths\n    size_term = (n ** 0.5) / (a_deg + 1.0)\n\n    # 2. Sparsity penalty – low density inflates distances\n    sparsity_term = 1.0 / (dens + eps)\n\n    # 3. Local clustering slightly increases distances\n    clustering_term = 1.0 + avg_clust\n\n    # 4. Triangle abundance creates shortcuts\n    triangle_term = 1.0 + ((num_tri + 1.0) / (m + 1.0)) ** 0.4\n\n    # 5. Degree heterogeneity (high std relative to mean) typically shortens paths\n    hetero_term = 1.0 + (std_deg / max(a_deg, 1.0)) ** 0.3\n\n    # 6. Extremal degrees – hubs pull nodes close, isolated nodes push them apart\n    max_term = 1.0 + (max_deg / max(a_deg, 1.0)) ** 0.2\n    min_term = 1.0 + 1.0 / (min_deg + 1.0)\n\n    # 7. Degree assortativity amplifies the overall effect\n    assort_term = 1.0 + abs(assort)\n\n    # 8. Global transitivity further shortens paths\n    trans_term = 1.0 + trans\n\n    # 9. Median degree captures typical connectivity\n    if deg_list:\n        median_deg = float(deg_list[len(deg_list) // 2])\n    else:\n        median_deg = a_deg\n    median_term = 1.0 + (median_deg / max(a_deg, 1.0)) ** 0.3\n\n    # Combine all terms multiplicatively to obtain a smooth estimate\n    estimate = (\n        size_term *\n        sparsity_term *\n        clustering_term *\n        triangle_term *\n        hetero_term *\n        max_term *\n        min_term *\n        assort_term *\n        trans_term *\n        median_term\n    )\n\n    return float(estimate)",
        "island_id": 3,
        "generation": 27,
        "train_score": 0.9443937575030013,
        "val_score": 0.5435444312238219,
        "simplicity_score": 0.15455207635637627,
        "novelty_bonus": 0.15231680792019786
      },
      {
        "id": "g27_i3_p4_532196820",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from a bag of\n    pre‑computed structural statistics.  The estimator is a smooth\n    multiplicative combination of terms that encode the interplay\n    between size, sparsity, local clustering, triangle shortcuts,\n    degree heterogeneity, extreme degrees, degree assortativity,\n    global transitivity, and the median degree.\n\n    Parameters\n    ----------\n    s : dict\n        A dictionary containing the following keys:\n            n                     (int)      – number of nodes\n            m                     (int)      – number of edges\n            density               (float)    – edge density (0‑1)\n            avg_degree            (float)    – mean degree\n            max_degree            (int)      – maximum degree\n            min_degree            (int)      – minimum degree\n            std_degree            (float)    – std‑dev of degrees\n            avg_clustering        (float)    – average local clustering\n            transitivity          (float)    – global transitivity\n            degree_assortativity  (float)    – assortativity coefficient\n            num_triangles         (int)      – number of triangles\n            degrees               (list[int])– sorted degree list\n\n    Returns\n    -------\n    float\n        A non‑negative continuous estimate of the average shortest‑path\n        length.  No traversal or external library is required.\n    \"\"\"\n\n    # Basic cast to float (to avoid accidental integer division)\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    deg_list   = s.get('degrees', [])\n\n    # tiny constant to avoid divide‑by‑zero\n    eps = 1e-12\n\n    # 1. Size versus average degree – larger, sparser graphs tend to have\n    #    longer shortest paths.\n    size_term = (n ** 0.5) / (avg_deg + 1.0)\n\n    # 2. Sparsity penalty – low density inflates distances.\n    density_term = 1.0 / (density + eps)\n\n    # 3. Local clustering slightly increases the average path length.\n    clustering_term = 1.0 + avg_clust\n\n    # 4. Triangles provide short‑cut cycles that shrink distances.\n    triangle_term = 1.0 + ((num_tri + 1.0) / (m + 1.0)) ** 0.4\n\n    # 5. Degree heterogeneity (large std relative to mean) usually shortens\n    #    paths by creating hubs.\n    hetero_term = 1.0 + (std_deg / max(avg_deg, 1.0)) ** 0.3\n\n    # 6. Extremal degrees – hubs pull nodes close; isolated nodes push them apart.\n    max_term = 1.0 + (max_deg / max(avg_deg, 1.0)) ** 0.2\n    min_term = 1.0 + 1.0 / (min_deg + 1.0)\n\n    # 7. Degree assortativity amplifies the combined effect.\n    assort_term = 1.0 + abs(assort)\n\n    # 8. Global transitivity (overall clustering) tends to reduce distances.\n    trans_term = 1.0 + trans\n\n    # 9. Median degree captures typical connectivity.\n    if deg_list:\n        median_deg = float(deg_list[len(deg_list) // 2])\n    else:\n        median_deg = avg_deg\n    median_term = 1.0 + (median_deg / max(avg_deg, 1.0)) ** 0.3\n\n    # Product of all multiplicative terms gives a smooth, non‑negative\n    # estimate of the average shortest‑path length.\n    estimate = (size_term *\n                density_term *\n                clustering_term *\n                triangle_term *\n                hetero_term *\n                max_term *\n                min_term *\n                assort_term *\n                trans_term *\n                median_term)\n\n    return float(estimate)",
        "island_id": 3,
        "generation": 27,
        "train_score": 0.9443937575030013,
        "val_score": 0.5435444312238219,
        "simplicity_score": 0.15455207635637627,
        "novelty_bonus": 0.15231680792019786
      }
    ]
  },
  "map_elites_archive": {
    "num_bins": 5,
    "cells": {
      "0,1": {
        "candidate": {
          "id": "g9_i1_p3_455776289",
          "code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clu = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Base factor: size and average degree\n    base = (n ** 0.5) / (avg_deg + 1)\n\n    # Size‑edge interaction\n    size_edge = n / (m + 1)\n\n    # Triangle influence\n    tri_factor = 1 + num_tri / (m + 1)\n\n    # Clustering and transitivity\n    clu_factor = 1 + avg_clu\n    trans_factor = 1 + trans\n\n    # Sparsity\n    dens_factor = 1 / (density + eps)\n\n    # Assortativity strength\n    assort_factor = 1 + abs(assort)\n\n    # Degree spread\n    std_factor = 1 + std_deg / (avg_deg + eps)\n\n    # Extremal degrees\n    max_factor = 1 + max_deg / (avg_deg + 1)\n    min_factor = 1 + min_deg / (avg_deg + eps)\n\n    # Degree‑sequence shape (harmonic mean)\n    nonzero_deg = [d for d in degrees if d > 0]\n    if nonzero_deg:\n        harmonic = len(nonzero_deg) / sum(1.0 / d for d in nonzero_deg)\n    else:\n        harmonic = 1.0\n    deg_shape_factor = harmonic / (avg_deg + eps)\n\n    # Relative degree ratios\n    rel_avg_max = 1 + avg_deg / (max_deg + 1)\n    rel_min_max = 1 + min_deg / (max_deg + 1)\n    rel_std_max = 1 + std_deg / (max_deg + 1)\n\n    # Combine all contributions multiplicatively\n    invariant = (\n        base *\n        size_edge *\n        tri_factor *\n        clu_factor *\n        trans_factor *\n        dens_factor *\n        assort_factor *\n        std_factor *\n        max_factor *\n        min_factor *\n        deg_shape_factor *\n        rel_avg_max *\n        rel_min_max *\n        rel_std_max\n    )\n    return float(invariant)",
          "island_id": 1,
          "generation": 9,
          "train_score": 0.9024249699879953,
          "val_score": 0.5365733928946387,
          "simplicity_score": 0.1518464803042319,
          "novelty_bonus": 0.20529063226580657
        },
        "fitness_signal": 0.8892338143081007
      },
      "0,2": {
        "candidate": {
          "id": "g22_i3_p3_739042961",
          "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a handful of aggregated\n    graph statistics.  The estimate is a smooth, multiplicative combination\n    of non‑linear transformations that reflect the interplay between\n    size, sparsity, degree heterogeneity, clustering, triangle abundance,\n    assortativity, and the typical degree level.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following pre‑computed keys:\n        - n                  : number of nodes\n        - m                  : number of edges\n        - density            : edge density (0‑1)\n        - avg_degree         : mean degree\n        - max_degree         : maximum degree\n        - min_degree         : minimum degree\n        - std_degree         : standard deviation of degrees\n        - avg_clustering     : average local clustering coefficient\n        - transitivity       : global transitivity (clustering)\n        - degree_assortativity : degree assortativity coefficient\n        - num_triangles      : total number of triangles\n        - degrees            : sorted list of node degrees\n\n    Returns\n    -------\n    float\n        Continuous, non‑negative estimate of the average shortest‑path\n        length.\n    \"\"\"\n    eps = 1e-12  # tiny constant to avoid division by zero\n\n    # ---- basic statistics --------------------------------------------------\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density']) + eps\n    avg_deg    = float(s['avg_degree']) + eps\n    max_deg    = float(s['max_degree']) + eps\n    min_deg    = float(s['min_degree']) + eps\n    std_deg    = float(s['std_degree']) + eps\n    avg_clust  = float(s['avg_clustering']) + eps\n    trans      = float(s['transitivity']) + eps\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles']) + 1.0   # avoid zero\n    degrees    = s.get('degrees', [])\n    median_deg = float(degrees[len(degrees)//2]) if degrees else avg_deg\n\n    # ---- transformed feature terms ------------------------------------------\n    # 1. Size vs. connectivity (root of size × root of inverse density)\n    size_factor = pow(n + 1.0, 0.5) * pow(1.0 / density, 0.5)\n\n    # 2. Degree heterogeneity dampens the path length (use e≈2.71828)\n    e_const = 2.718281828459045\n    hetero_factor = pow(e_const, -std_deg / (avg_deg + 1.0))\n\n    # 3. Local clustering and transitivity slightly shorten paths\n    clust_factor = pow(1.0 + avg_clust, -0.5)\n    trans_factor = pow(1.0 + trans, -0.3)\n\n    # 4. Triangles create shortcuts; the effect grows sub‑linearly\n    tri_factor = pow(tri / (m + 1.0), 0.4)\n\n    # 5. Extreme degrees: hubs pull nodes together, isolated nodes push them apart\n    max_factor = pow(max_deg / (avg_deg + 1.0), 0.2)\n    min_factor = 1.0 / (min_deg + 1.0)\n\n    # 6. Assortativity amplifies the combined effect\n    assort_factor = pow(e_const, abs(assort))\n\n    # 7. Median degree captures the typical connectivity level\n    median_factor = pow(median_deg / (avg_deg + 1.0), 0.2)\n\n    # ---- final estimate (smooth multiplicative combination) -----------------\n    estimate = (\n        size_factor *\n        hetero_factor *\n        clust_factor *\n        trans_factor *\n        tri_factor *\n        max_factor *\n        min_factor *\n        assort_factor *\n        median_factor\n    )\n\n    return float(estimate)",
          "island_id": 3,
          "generation": 22,
          "train_score": 0.5393037214885954,
          "val_score": 0.466888529202242,
          "simplicity_score": 0.15404215595975587,
          "novelty_bonus": 0.4117138888325351
        },
        "fitness_signal": 0.6251318627210605
      },
      "0,0": {
        "candidate": {
          "id": "g24_i2_p0_804391827",
          "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length (ASPL) from pre‑computed\n    graph statistics.  The expression combines several structural\n    factors with modest exponents to keep the formula compact while\n    improving accuracy over the baseline product.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph quantities\n    n = s['n']\n    m = s['m']\n\n    density      = s.get('density', 0.0)\n    avg_deg      = s.get('avg_degree', 0.0)\n    std_deg      = s.get('std_degree', 0.0)\n    max_deg      = s.get('max_degree', 1)\n    min_deg      = s.get('min_degree', 0)\n    avg_clust    = s.get('avg_clustering', 0.0)\n    trans        = s.get('transitivity', 0.0)\n    assort       = s.get('degree_assortativity', 0.0)\n    num_tri      = s.get('num_triangles', 0)\n    degrees      = s.get('degrees', [])\n\n    # ---------- Component factors ----------\n    # Size versus average degree\n    base = (n ** 0.5) / (avg_deg + 1)\n\n    # Sparsity (denser graphs → shorter paths)\n    dens_factor = 1 / (density + eps)\n\n    # Clustering and transitivity, tempered by fractional exponents\n    clu_factor   = 1 + avg_clust\n    trans_factor = 1 + trans\n    clu_factor   = pow(clu_factor, 0.7)\n    trans_factor = pow(trans_factor, 0.6)\n\n    # Positive assortativity shortens paths\n    assort_factor = 1 + max(0.0, assort)\n\n    # Triangle abundance provides alternative short routes\n    tri_factor = 1 + num_tri / (m + 1)\n\n    # Degree dispersion may lengthen paths\n    std_factor = 1 + std_deg / (avg_deg + eps)\n\n    # Size‑edge interaction (edges per vertex)\n    size_edge_factor = (n / (m + 1)) ** 0.5\n\n    # Degree‑sequence shape via harmonic mean ratio\n    if degrees:\n        harmonic = len(degrees) / sum(1.0 / d if d > 0 else 0 for d in degrees)\n    else:\n        harmonic = 1.0\n    deg_shape = harmonic / (avg_deg + eps)\n    deg_shape = pow(deg_shape, 0.5)\n\n    # ---------- Combine ----------\n    estimate = (\n        base *\n        dens_factor *\n        clu_factor *\n        trans_factor *\n        assort_factor *\n        tri_factor *\n        std_factor *\n        size_edge_factor *\n        deg_shape\n    )\n\n    # Clamp to realistic bounds\n    if estimate < 1.0:\n        estimate = 1.0\n    elif estimate > n:\n        estimate = float(n)\n\n    return estimate",
          "island_id": 2,
          "generation": 24,
          "train_score": 0.9452581032412964,
          "val_score": 0.5503922782177872,
          "simplicity_score": 0.17743687048891446,
          "novelty_bonus": 0.15035060592384686
        },
        "fitness_signal": 0.9395994446857007
      },
      "0,3": {
        "candidate": {
          "id": "g1_i3_p0_94177347",
          "code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from pre‑computed graph features.\n    The formula combines several smoothly varying factors that capture the\n    influence of size, density, clustering, assortativity, degree dispersion,\n    and higher‑order motifs.  All components are multiplied together so that\n    the invariant is sensitive to a wide range of structural properties while\n    remaining purely a function of the supplied feature dictionary.\n    \"\"\"\n\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    min_degree = s['min_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity  = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n\n    # Size scaling – larger graphs grow roughly with √n\n    size_factor = pow(n, 0.5)\n\n    # Connectivity – very sparse graphs get a large multiplier\n    density_factor = 1.0 / (density + 1e-9)\n\n    # Clustering and transitivity – more triangles and global clustering\n    # tend to create shorter detours, so we amplify the effect.\n    cluster_factor = 1.0 + avg_clustering\n    trans_factor   = 1.0 + transitivity\n\n    # Motif influence – count of triangles relative to edges\n    tri_factor = 1.0 + num_triangles / (m + 1.0)\n\n    # Assortativity – strong assortative mixing can lengthen paths.\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # Degree dispersion – more variability usually shortens paths.\n    std_factor = 1.0 + std_degree / (avg_degree + 1e-6)\n    max_factor = 1.0 + max_degree / (avg_degree + 1e-6)\n    min_factor = 1.0 + min_degree / (avg_degree + 1e-6)\n\n    # Final multiplicative combination\n    invariant = (size_factor *\n                 density_factor *\n                 cluster_factor *\n                 trans_factor *\n                 tri_factor *\n                 assort_factor *\n                 std_factor *\n                 max_factor *\n                 min_factor)\n\n    return float(invariant)",
          "island_id": 3,
          "generation": 1,
          "train_score": 0.6394717887154863,
          "val_score": 0.4150607179440796,
          "simplicity_score": 0.15598641871337862,
          "novelty_bonus": 0.6050839162268637
        },
        "fitness_signal": 0.40467651866668963
      },
      "1,1": {
        "candidate": {
          "id": "g23_i2_p1_433618652",
          "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length (ASPL) from pre‑computed graph\n    statistics.  The formula combines several influential factors while\n    remaining compact and bounded between 1 and the number of nodes.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    density        = s.get('density', 0.0)\n    avg_deg        = s.get('avg_degree', 0.0)\n    std_deg        = s.get('std_degree', 0.0)\n    max_deg        = s.get('max_degree', 1)\n    min_deg        = s.get('min_degree', 0)\n    avg_clust      = s.get('avg_clustering', 0.0)\n    transitivity   = s.get('transitivity', 0.0)\n    assortativity  = s.get('degree_assortativity', 0.0)\n    num_triangles  = s.get('num_triangles', 0)\n    degrees        = s.get('degrees', [])\n\n    # Base factor: size vs. average degree\n    base = pow(n, 0.5) / (avg_deg + 1)\n\n    # Sparsity factor (denser graphs → shorter paths)\n    dens = 1 / (density + eps)\n\n    # Clustering and transitivity\n    clu = 1 + avg_clust\n    trans = 1 + transitivity\n\n    # Assortativity (positive assortativity tends to shorten paths)\n    assort = 1 + max(0.0, assortativity)\n\n    # Triangle influence\n    tri = 1 + num_triangles / (m + 1)\n\n    # Degree dispersion\n    std = 1 + std_deg / (avg_deg + eps)\n\n    # Size‑edge interaction\n    size_edge = pow(n / (m + 1), 0.5)\n\n    # Degree‑sequence shape (harmonic mean relative to average degree)\n    nonzero = [d for d in degrees if d > 0]\n    if nonzero:\n        harmonic = len(nonzero) / sum(1.0 / d for d in nonzero)\n    else:\n        harmonic = 1.0\n    shape = harmonic / (avg_deg + eps)\n\n    # Extremal degree ratio (max / min)\n    ratio = 1 + max_deg / (min_deg + eps)\n\n    # Combine all contributions multiplicatively\n    inv = (base * dens * clu * trans * assort * tri *\n           std * size_edge * shape * ratio)\n\n    # Clamp to realistic bounds\n    if inv < 1.0:\n        inv = 1.0\n    elif inv > n:\n        inv = float(n)\n\n    return inv",
          "island_id": 2,
          "generation": 23,
          "train_score": 0.42950441847448745,
          "val_score": 0.411898093419955,
          "simplicity_score": 0.24577833077392158,
          "novelty_bonus": 0.3985890315349221
        },
        "fitness_signal": 0.4863314356093881
      }
    }
  }
}