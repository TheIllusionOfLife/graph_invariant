{
  "experiment_id": "seed_44",
  "generation": 20,
  "rng_seed": 44,
  "rng_state": {
    "bit_generator": "PCG64",
    "state": {
      "state": 233803892855348144265753380473833450835,
      "inc": 762441968459946881146668352658223677
    },
    "has_uint32": 0,
    "uinteger": 3489973623
  },
  "best_val_score": 0.534056960060647,
  "no_improve_count": 2,
  "island_stagnation": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_prompt_mode": {
    "0": "free",
    "1": "free",
    "2": "free",
    "3": "free"
  },
  "island_constrained_generations": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_recent_failures": {
    "0": [
      "below_novelty_threshold: novelty_bonus=0.052551",
      "below_train_threshold: train_signal=0.161585",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ],
    "1": [
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_train_threshold: train_signal=0.055942",
      "below_novelty_threshold: novelty_bonus=0.084318"
    ],
    "2": [
      "below_train_threshold: train_signal=0.118944",
      "below_novelty_threshold: novelty_bonus=0.033737",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ],
    "3": [
      "below_novelty_threshold: novelty_bonus=0.025874",
      "below_novelty_threshold: novelty_bonus=0.098162",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ]
  },
  "islands": {
    "0": [
      {
        "id": "g8_i3_p3_315365990",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    global graph statistics.  The formula is a non‑trivial combination of\n    size, density, clustering, degree heterogeneity, assortativity,\n    triangle density, and a harmonic‑mean degree factor – but it never\n    returns a single feature nor performs any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the following keys (missing keys default to a neutral\n        value):\n        - 'n'                 : number of nodes\n        - 'avg_degree'        : average degree\n        - 'std_degree'        : standard deviation of the degree sequence\n        - 'avg_clustering'    : average local clustering coefficient\n        - 'transitivity'      : global transitivity\n        - 'degree_assortativity' : degree assortativity coefficient\n        - 'num_triangles'     : number of triangles\n        - 'degrees'           : list of degrees (unsorted is also fine)\n\n    Returns\n    -------\n    float\n        A dimensionless estimate that correlates with the true\n        average shortest‑path length.  The value is positive for any\n        feasible input.\n    \"\"\"\n    # Basic scaling: distances grow roughly like sqrt(n)\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n    val = n ** 0.5\n\n    # Local cohesion: reward high clustering and transitivity\n    val *= (1.0 + s.get('avg_clustering', 0.0))\n    val *= (1.0 + s.get('transitivity', 0.0))\n\n    # Normalise by overall density (avg_degree)\n    avg_deg = s.get('avg_degree', 0.0)\n    denom = avg_deg + 1.0        # +1 avoids division by zero\n    val /= denom\n\n    # Degree heterogeneity (coefficient of variation)\n    std_deg = s.get('std_degree', 0.0)\n    val *= 1.0 + std_deg / max(avg_deg, 1e-6)\n\n    # Assortativity adjustment (positive assortativity can stretch paths)\n    assort = s.get('degree_assortativity', 0.0)\n    val /= 1.0 + abs(assort)\n\n    # Triangle density factor\n    tri = s.get('num_triangles', 0)\n    if n > 2:\n        max_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_dens = tri / max_tri\n    else:\n        tri_dens = 0.0\n    val *= 1.0 + tri_dens\n\n    # Harmonic‑mean degree factor: encourages many low‑degree nodes\n    degrees = s.get('degrees', [])\n    if degrees:\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0:\n            h_mean = len(degrees) / inv_sum\n            val *= h_mean / max(avg_deg, 1.0)\n\n    return float(val)",
        "island_id": 3,
        "generation": 8,
        "train_score": 0.7600960384153662,
        "val_score": 0.5314567841791523,
        "simplicity_score": 0.17087250571055487,
        "novelty_bonus": 0.23553705835967698
      },
      {
        "id": "g15_i0_p0_567658385",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    global graph statistics.  The formula is a compact, non‑trivial\n    combination of size, density, clustering, degree heterogeneity,\n    assortativity, triangle density, leaf ratio, degree extremes,\n    and the harmonic mean of the degree distribution.  No graph\n    traversal or single‑feature return is used.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the following keys (missing keys default to a\n        neutral value):\n        - 'n'                 : number of nodes\n        - 'm'                 : number of edges\n        - 'density'           : edge density (2m/(n(n-1)))\n        - 'avg_degree'        : average degree\n        - 'max_degree'        : maximum degree\n        - 'min_degree'        : minimum degree\n        - 'std_degree'        : standard deviation of the degree sequence\n        - 'avg_clustering'    : average local clustering coefficient\n        - 'transitivity'      : global transitivity\n        - 'degree_assortativity' : degree assortativity coefficient\n        - 'num_triangles'     : number of triangles\n        - 'degrees'           : list of degrees (unsorted is also fine)\n\n    Returns\n    -------\n    float\n        A positive, dimensionless estimate that correlates with the\n        true average shortest‑path length.\n    \"\"\"\n    # Basic sanity checks\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    # Extract features with safe defaults\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n    max_deg    = s.get('max_degree', 0)\n    min_deg    = s.get('min_degree', 0)\n\n    eps = 1e-6  # small constant to avoid division by zero\n\n    # 1. Size factor – distances grow roughly like sqrt(n)\n    size_factor = n ** 0.5\n\n    # 2. Density factor – denser graphs have shorter paths\n    density_factor = 1.0 / (density + eps)\n\n    # 3. Sparsity factor – normalises by average degree\n    sparsity_factor = (m + 1.0) / (n * avg_deg + 1.0)\n\n    # 4. Cohesion factor – clustering, transitivity, triangle density\n    tri_dens = 0.0\n    if n > 2:\n        max_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_dens = num_tri / max_tri\n    cohesion_factor = (1.0 + avg_clust) * (1.0 + trans) * (1.0 + 2.0 * tri_dens)\n\n    # 5. Heterogeneity factor – coefficient of variation\n    hetero_factor = 1.0 + std_deg / (avg_deg + eps)\n\n    # 6. Assortativity factor – positive assortativity tends to stretch paths\n    assort_factor = 1.0 + 1.5 * abs(assort)\n\n    # 7. Leaf ratio – many leaves increase path lengths\n    leaf_ratio = 0.0\n    if degrees:\n        leaf_count = sum(1 for d in degrees if d == 1)\n        leaf_ratio = leaf_count / n\n    leaf_factor = 1.0 + 0.3 * leaf_ratio\n\n    # 8. Max‑degree (hub) factor – a very high hub shortens paths\n    max_deg_factor = 1.0 - 0.07 * (max_deg / (avg_deg + eps))\n    if max_deg_factor < 0.9:\n        max_deg_factor = 0.9\n\n    # 9. Min‑degree factor – a higher minimum degree reduces distances\n    min_deg_factor = 1.0 + 0.12 * (min_deg / (avg_deg + eps))\n\n    # 10. Harmonic‑mean degree factor – many low‑degree nodes increase paths\n    h_mean_factor = 1.0\n    if degrees:\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0:\n            h_mean = len(degrees) / inv_sum\n            h_mean_factor = h_mean / (avg_deg + eps)\n\n    # 11. Combine all factors multiplicatively\n    val = (size_factor * density_factor * sparsity_factor *\n           cohesion_factor * hetero_factor * assort_factor *\n           leaf_factor * max_deg_factor * min_deg_factor *\n           h_mean_factor)\n\n    # Ensure a sensible lower bound\n    if val < 1.0:\n        val = 1.0\n\n    return float(val)",
        "island_id": 0,
        "generation": 15,
        "train_score": 0.7237935174069627,
        "val_score": 0.4840019593012528,
        "simplicity_score": 0.1660981089059753,
        "novelty_bonus": 0.2523090342645887
      },
      {
        "id": "g17_i3_p2_898326347",
        "code": "def new_invariant(s):\n    \"\"\"\n    Compute a closed‑form estimate of the average shortest‑path length\n    from a handful of pre‑computed global graph statistics.\n    The expression mixes logarithms, exponentials, polynomial\n    exponents, and ratios of complementary metrics so that it is\n    highly nonlinear and does not collapse to a single feature.\n\n    Parameters\n    ----------\n    s : dict\n        A dictionary that may contain the keys listed below. Missing\n        keys are treated as neutral values (0, 1 or empty list as\n        appropriate).\n\n        - n                       : int          number of nodes\n        - density                 : float        edge density (0‑1)\n        - avg_degree              : float\n        - max_degree              : int\n        - min_degree              : int\n        - std_degree              : float\n        - avg_clustering          : float\n        - transitivity            : float\n        - degree_assortativity    : float\n        - num_triangles           : int\n        - degrees                 : list[int]    degree sequence\n\n    Returns\n    -------\n    float\n        A dimensionless estimate that tracks the real average shortest‑path\n        length, but is derived purely algebraically from the supplied\n        statistics.\n    \"\"\"\n    # Helper: guard against missing keys\n    n                = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    density          = s.get('density', 0.0)\n    avg_degree       = s.get('avg_degree', 0.0)\n    max_degree       = s.get('max_degree', 0)\n    min_degree       = s.get('min_degree', 0)\n    std_degree       = s.get('std_degree', 0.0)\n    avg_clust        = s.get('avg_clustering', 0.0)\n    transitivity     = s.get('transitivity', 0.0)\n    assort           = s.get('degree_assortativity', 0.0)\n    num_tri          = s.get('num_triangles', 0)\n    degrees          = s.get('degrees', [])\n\n    # --- 1. Size scaling (√n) --------------------------------------------------\n    val = n ** 0.5\n\n    # --- 2. Cohesion boost ----------------------------------------------------\n    # Higher local and global clustering reduces path length\n    val *= (1.0 + avg_clust) ** 2.0\n    val *= (1.0 + transitivity) ** 1.5\n\n    # --- 3. Density / degree penalty -----------------------------------------\n    # Sparse graphs inflate distances; dense graphs compress them\n    val /= max(density, 1e-4)                  # avoid division by zero\n\n    # Logistic decrease with average degree\n    val *= (1.0 + avg_degree) ** (-1.0)\n    # Further attenuation for graphs with extremely low average degree\n    val *= (1.0 + avg_degree) ** (-0.5)\n\n    # --- 4. Heterogeneity amplification --------------------------------------\n    # Coefficient of variation raised to a power\n    cv = std_degree / max(avg_degree, 1e-4)\n    val *= (1.0 + cv) ** 1.2\n\n    # Influence of extremes in degree distribution\n    min_ratio = min_degree / max(max_degree, 1) if max_degree else 0.0\n    val *= (1.0 + min_ratio) ** 0.8\n\n    # --- 5. Assortativity modulation -----------------------------------------\n    val /= (1.0 + abs(assort) ** 2.0)          # penalise extreme assortativity\n\n    # --- 6. Triangle density factor -----------------------------------------\n    tri_max = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    tri_density = num_tri / max(tri_max, 1e-4)\n    val *= (1.0 + tri_density) ** 0.9\n\n    # --- 7. Harmonic mean degree influence ------------------------------------\n    if degrees:\n        # robust harmonic mean (skip zeros)\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0.0:\n            h_mean = len(degrees) / inv_sum\n            # low harmonic mean (many low‑degree nodes) increases distances\n            val *= (h_mean / max(avg_degree, 1.0)) ** 0.7\n\n    return float(val)",
        "island_id": 3,
        "generation": 17,
        "train_score": 0.9059783913565426,
        "val_score": 0.534056960060647,
        "simplicity_score": 0.16785415156178546,
        "novelty_bonus": 0.15318172152652532
      },
      {
        "id": "g17_i0_p1_937404241",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    global graph statistics.  The formula is a compact, non‑trivial\n    combination of size, density, clustering, degree heterogeneity,\n    assortativity, triangle density, leaf ratio, degree extremes,\n    and the harmonic mean of the degree distribution.  No graph\n    traversal or single‑feature return is used.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the following keys (missing keys default to a\n        neutral value):\n        - 'n'                 : number of nodes\n        - 'm'                 : number of edges\n        - 'density'           : edge density (2m/(n(n-1)))\n        - 'avg_degree'        : average degree\n        - 'max_degree'        : maximum degree\n        - 'min_degree'        : minimum degree\n        - 'std_degree'        : standard deviation of the degree sequence\n        - 'avg_clustering'    : average local clustering coefficient\n        - 'transitivity'      : global transitivity\n        - 'degree_assortativity' : degree assortativity coefficient\n        - 'num_triangles'     : number of triangles\n        - 'degrees'           : list of degrees (sorted or unsorted)\n\n    Returns\n    -------\n    float\n        A positive, dimensionless estimate that correlates with the\n        true average shortest‑path length.\n    \"\"\"\n    # Basic sanity check\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    # Extract features with safe defaults\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n    max_deg    = s.get('max_degree', 0)\n    min_deg    = s.get('min_degree', 0)\n\n    eps = 1e-6  # small constant to avoid division by zero\n\n    # 1. Size and density scaling\n    size_factor = n ** 0.45\n    density_factor = 1.0 / (density + eps)\n    sparsity_factor = (m + 1.0) / (n * avg_deg + 1.0)\n\n    # 2. Cohesion (clustering, transitivity, triangles)\n    tri_dens = 0.0\n    if n > 2:\n        max_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_dens = num_tri / max_tri\n    cohesion_factor = (1.0 + avg_clust) * (1.0 + trans) * (1.0 + tri_dens)\n\n    # 3. Heterogeneity and assortativity\n    hetero_factor = 1.0 + std_deg / (avg_deg + eps)\n    assort_factor = 1.0 + abs(assort)\n\n    # 4. Degree extremes and leaf ratio\n    leaf_ratio = 0.0\n    if degrees:\n        leaf_count = sum(1 for d in degrees if d == 1)\n        leaf_ratio = leaf_count / n\n    leaf_factor = 1.0 + leaf_ratio * 0.25\n\n    max_deg_factor = 1.0 - (max_deg / (avg_deg + 1.0)) * 0.07\n    if max_deg_factor < 0.9:\n        max_deg_factor = 0.9\n\n    min_deg_factor = 1.0 + (min_deg / (avg_deg + eps)) * 0.08\n\n    # 5. Harmonic‑mean degree factor\n    h_mean_factor = 1.0\n    if degrees:\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0:\n            h_mean = len(degrees) / inv_sum\n            h_mean_factor = h_mean / (avg_deg + eps)\n\n    # 6. Combine all factors multiplicatively\n    val = (size_factor * density_factor * sparsity_factor *\n           cohesion_factor * hetero_factor * assort_factor *\n           leaf_factor * max_deg_factor * min_deg_factor *\n           h_mean_factor)\n\n    # Ensure a sensible lower bound\n    if val < 1.0:\n        val = 1.0\n\n    return float(val)",
        "island_id": 0,
        "generation": 17,
        "train_score": 0.7421368547418967,
        "val_score": 0.4757659945005204,
        "simplicity_score": 0.16620515092735175,
        "novelty_bonus": 0.2110541136559816
      },
      {
        "id": "g17_i0_p2_398126195",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    global graph statistics.  The formula is a compact, non‑trivial\n    combination of size, density, clustering, degree heterogeneity,\n    assortativity, triangle density, leaf ratio, degree extremes,\n    and the harmonic mean of the degree distribution.  No graph\n    traversal or single‑feature return is used.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the following keys (missing keys default to a\n        neutral value):\n        - 'n'                 : number of nodes\n        - 'm'                 : number of edges\n        - 'density'           : edge density (2m/(n(n-1)))\n        - 'avg_degree'        : average degree\n        - 'max_degree'        : maximum degree\n        - 'min_degree'        : minimum degree\n        - 'std_degree'        : standard deviation of the degree sequence\n        - 'avg_clustering'    : average local clustering coefficient\n        - 'transitivity'      : global transitivity\n        - 'degree_assortativity' : degree assortativity coefficient\n        - 'num_triangles'     : number of triangles\n        - 'degrees'           : list of degrees (unsorted is also fine)\n\n    Returns\n    -------\n    float\n        A positive, dimensionless estimate that correlates with the\n        true average shortest‑path length.\n    \"\"\"\n    # Basic sanity check\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    # Extract features with safe defaults\n    m          = s.get('m', 0)\n    density    = s.get('density', 0.0)\n    avg_deg    = s.get('avg_degree', 0.0)\n    std_deg    = s.get('std_degree', 0.0)\n    avg_clust  = s.get('avg_clustering', 0.0)\n    trans      = s.get('transitivity', 0.0)\n    assort     = s.get('degree_assortativity', 0.0)\n    num_tri    = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n    max_deg    = s.get('max_degree', 0)\n    min_deg    = s.get('min_degree', 0)\n\n    eps = 1e-6  # small constant to avoid division by zero\n\n    # 1. Size and density scaling\n    size_factor = n ** 0.45\n    density_factor = 1.0 / (density + eps)\n    sparsity_factor = (m + 1.0) / (n * avg_deg + 1.0)\n\n    # 2. Cohesion (clustering, transitivity, triangles)\n    tri_dens = 0.0\n    if n > 2:\n        max_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_dens = num_tri / max_tri\n    cohesion_factor = (1.0 + avg_clust) * (1.0 + trans) * (1.0 + tri_dens)\n\n    # 3. Heterogeneity and assortativity\n    hetero_factor = 1.0 + std_deg / (avg_deg + eps)\n    assort_factor = 1.0 + abs(assort)\n\n    # 4. Degree extremes and leaf ratio\n    leaf_ratio = 0.0\n    if degrees:\n        leaf_count = sum(1 for d in degrees if d == 1)\n        leaf_ratio = leaf_count / n\n    leaf_factor = 1.0 + leaf_ratio * 0.25\n\n    max_deg_factor = 1.0 - (max_deg / (avg_deg + 1.0)) * 0.07\n    if max_deg_factor < 0.9:\n        max_deg_factor = 0.9\n\n    min_deg_factor = 1.0 + (min_deg / (avg_deg + eps)) * 0.08\n\n    # 5. Harmonic‑mean degree factor\n    h_mean_factor = 1.0\n    if degrees:\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0:\n            h_mean = len(degrees) / inv_sum\n            h_mean_factor = h_mean / (avg_deg + eps)\n\n    # 6. Combine all factors multiplicatively\n    val = (size_factor * density_factor * sparsity_factor *\n           cohesion_factor * hetero_factor * assort_factor *\n           leaf_factor * max_deg_factor * min_deg_factor *\n           h_mean_factor)\n\n    # Ensure a sensible lower bound\n    if val < 1.0:\n        val = 1.0\n\n    return float(val)",
        "island_id": 0,
        "generation": 17,
        "train_score": 0.7421368547418967,
        "val_score": 0.4757659945005204,
        "simplicity_score": 0.16620515092735175,
        "novelty_bonus": 0.2110541136559816
      }
    ],
    "1": [
      {
        "id": "g19_i1_p1_685568117",
        "code": "def new_invariant(s):\n    \"\"\"\n    Compute a graph invariant that captures several structural aspects\n    relevant to the average shortest‑path length.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys:\n        - n (int)                : number of nodes\n        - m (int)                : number of edges\n        - density (float)        : graph density\n        - avg_degree (float)     : average degree\n        - max_degree (int)       : maximum degree\n        - std_degree (float)     : standard deviation of degrees\n        - avg_clustering (float) : average clustering coefficient\n        - transitivity (float)   : global transitivity\n        - degree_assortativity (float) : degree assortativity coefficient\n\n    Returns\n    -------\n    float\n        The computed invariant value.\n    \"\"\"\n    # Basic quantities\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree'] if s['max_degree'] else 1\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n\n    # Size vs. connectivity\n    size_connect = n / (m + 1)\n\n    # Degree heterogeneity ratio\n    deg_ratio = avg_deg / max_deg\n\n    # sqrt‑like scaling (approximates log‑like growth)\n    scale = n ** 0.5\n\n    # Clustering adjustment (larger clustering reduces path length)\n    cluster_adj = 1 + avg_clust\n\n    # Additional heterogeneity factor\n    hetero = 1 + std_deg / max(avg_deg, 1)\n\n    # Transitivity boost\n    trans_factor = 1 + trans\n\n    # Assortativity correction\n    assort_factor = 1 + abs(assort)\n\n    # Density moderation (denser graphs tend to have shorter paths)\n    density_mod = 1 / (1 + density)\n\n    # Combine all components multiplicatively and adjust for clustering\n    return (\n        size_connect\n        * deg_ratio\n        * scale\n        * hetero\n        * trans_factor\n        * assort_factor\n        * density_mod\n    ) / cluster_adj",
        "island_id": 1,
        "generation": 19,
        "train_score": 0.9170228091236493,
        "val_score": 0.5185397046101271,
        "simplicity_score": 0.12522158612721232,
        "novelty_bonus": 0.2017910447761193
      },
      {
        "id": "g11_i1_p0_80843620",
        "code": "def new_invariant(s):\n    \"\"\"\n    Graph invariant combining size‑connectivity, degree heterogeneity,\n    log‑like scaling (via sqrt), clustering adjustment, heterogeneity,\n    transitivity, assortativity, and density moderation.\n    All operations use only built‑in Python functions.\n    \"\"\"\n    # Size vs. connectivity\n    size_connectivity = s['n'] / (s['m'] + 1)\n\n    # Degree heterogeneity\n    degree_ratio = s['avg_degree'] / max(s['max_degree'], 1)\n\n    # Log‑like scaling (sqrt(n) approximates log(n) for large n)\n    sqrt_n = pow(s['n'], 0.5)\n\n    # Clustering adjustment\n    clustering_adjust = 1 + s['avg_clustering']\n\n    # Additional heterogeneity factor\n    heterogeneity_factor = 1 + s['std_degree'] / max(s['avg_degree'], 1)\n\n    # Transitivity factor\n    transitivity_factor = 1 + s['transitivity']\n\n    # Degree assortativity adjustment (use absolute value to keep positive)\n    assortativity_factor = 1 + abs(s['degree_assortativity'])\n\n    # Density moderation\n    density_factor = 1 / (1 + s['density'])\n\n    # Combine all components multiplicatively\n    return (\n        size_connectivity\n        * degree_ratio\n        * sqrt_n\n        / clustering_adjust\n        * heterogeneity_factor\n        * transitivity_factor\n        * assortativity_factor\n        * density_factor\n    )",
        "island_id": 1,
        "generation": 11,
        "train_score": 0.9170228091236493,
        "val_score": 0.5179691115536831,
        "simplicity_score": 0.12236862084499239,
        "novelty_bonus": 0.2017910447761193
      },
      {
        "id": "g10_i1_p2_546994111",
        "code": "def new_invariant(s):\n    # Size vs. connectivity\n    size_connectivity = s['n'] / (s['m'] + 1)\n\n    # Degree heterogeneity\n    degree_ratio = s['avg_degree'] / max(s['max_degree'], 1)\n\n    # Log‑like scaling (sqrt(n))\n    scale_factor = s['n'] ** 0.5\n\n    # Clustering adjustment\n    clustering_adjust = 1 + s['avg_clustering']\n\n    # Degree dispersion factor\n    heterogeneity_factor = 1 + s['std_degree'] / max(s['avg_degree'], 1)\n\n    # Transitivity boost\n    transitivity_factor = 1 + s['transitivity']\n\n    # Assortativity correction\n    assortativity_factor = 1 + abs(s['degree_assortativity'])\n\n    # Density moderation\n    density_factor = 1 / (1 + s['density'])\n\n    # Combine all components multiplicatively\n    return (\n        size_connectivity\n        * degree_ratio\n        * scale_factor\n        / clustering_adjust\n        * heterogeneity_factor\n        * transitivity_factor\n        * assortativity_factor\n        * density_factor\n    )",
        "island_id": 1,
        "generation": 10,
        "train_score": 0.9170228091236493,
        "val_score": 0.5179110377541946,
        "simplicity_score": 0.12207825184754989,
        "novelty_bonus": 0.2017910447761193
      },
      {
        "id": "g8_i3_p3_315365990",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    global graph statistics.  The formula is a non‑trivial combination of\n    size, density, clustering, degree heterogeneity, assortativity,\n    triangle density, and a harmonic‑mean degree factor – but it never\n    returns a single feature nor performs any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the following keys (missing keys default to a neutral\n        value):\n        - 'n'                 : number of nodes\n        - 'avg_degree'        : average degree\n        - 'std_degree'        : standard deviation of the degree sequence\n        - 'avg_clustering'    : average local clustering coefficient\n        - 'transitivity'      : global transitivity\n        - 'degree_assortativity' : degree assortativity coefficient\n        - 'num_triangles'     : number of triangles\n        - 'degrees'           : list of degrees (unsorted is also fine)\n\n    Returns\n    -------\n    float\n        A dimensionless estimate that correlates with the true\n        average shortest‑path length.  The value is positive for any\n        feasible input.\n    \"\"\"\n    # Basic scaling: distances grow roughly like sqrt(n)\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n    val = n ** 0.5\n\n    # Local cohesion: reward high clustering and transitivity\n    val *= (1.0 + s.get('avg_clustering', 0.0))\n    val *= (1.0 + s.get('transitivity', 0.0))\n\n    # Normalise by overall density (avg_degree)\n    avg_deg = s.get('avg_degree', 0.0)\n    denom = avg_deg + 1.0        # +1 avoids division by zero\n    val /= denom\n\n    # Degree heterogeneity (coefficient of variation)\n    std_deg = s.get('std_degree', 0.0)\n    val *= 1.0 + std_deg / max(avg_deg, 1e-6)\n\n    # Assortativity adjustment (positive assortativity can stretch paths)\n    assort = s.get('degree_assortativity', 0.0)\n    val /= 1.0 + abs(assort)\n\n    # Triangle density factor\n    tri = s.get('num_triangles', 0)\n    if n > 2:\n        max_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_dens = tri / max_tri\n    else:\n        tri_dens = 0.0\n    val *= 1.0 + tri_dens\n\n    # Harmonic‑mean degree factor: encourages many low‑degree nodes\n    degrees = s.get('degrees', [])\n    if degrees:\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0:\n            h_mean = len(degrees) / inv_sum\n            val *= h_mean / max(avg_deg, 1.0)\n\n    return float(val)",
        "island_id": 3,
        "generation": 8,
        "train_score": 0.7600960384153662,
        "val_score": 0.5314567841791523,
        "simplicity_score": 0.17087250571055487,
        "novelty_bonus": 0.23553705835967698
      },
      {
        "id": "g13_i1_p1_124542230",
        "code": "def new_invariant(s):\n    \"\"\"\n    Graph invariant combining several structural features:\n    - Size vs. connectivity (n / (m + 1))\n    - Degree heterogeneity (avg_degree / max_degree)\n    - Scale factor (sqrt(n))\n    - Clustering adjustment (1 + avg_clustering)\n    - Degree dispersion (1 + std_degree / avg_degree)\n    - Transitivity boost (1 + transitivity)\n    - Assortativity correction (1 + |degree_assortativity|)\n    - Density moderation (1 / (1 + density))\n\n    The final value is the product of all factors, divided by the clustering adjustment.\n    \"\"\"\n    size_connectivity = s['n'] / (s['m'] + 1)\n    degree_ratio = s['avg_degree'] / max(s['max_degree'], 1)\n    scale_factor = s['n'] ** 0.5\n    clustering_adjust = 1 + s['avg_clustering']\n    heterogeneity_factor = 1 + s['std_degree'] / max(s['avg_degree'], 1)\n    transitivity_factor = 1 + s['transitivity']\n    assortativity_factor = 1 + abs(s['degree_assortativity'])\n    density_factor = 1 / (1 + s['density'])\n\n    return (\n        size_connectivity\n        * degree_ratio\n        * scale_factor\n        * heterogeneity_factor\n        * transitivity_factor\n        * assortativity_factor\n        * density_factor\n    ) / clustering_adjust",
        "island_id": 1,
        "generation": 13,
        "train_score": 0.9170228091236493,
        "val_score": 0.5178840937373761,
        "simplicity_score": 0.12194353176345743,
        "novelty_bonus": 0.2017910447761193
      }
    ],
    "2": [
      {
        "id": "g2_i1_p1_954936163",
        "code": "def new_invariant(s):\n    \"\"\"\n    Graph invariant combining size‑connectivity, degree heterogeneity,\n    log‑like scaling, clustering adjustment, and additional heterogeneity\n    and transitivity factors.  All operations are performed on the\n    pre‑computed feature dictionary `s`.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - avg_degree (float)\n        - max_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n\n    Returns\n    -------\n    float\n        The computed invariant value.\n    \"\"\"\n    # Size vs. connectivity\n    size_connectivity = s['n'] / (s['m'] + 1)\n\n    # Degree heterogeneity\n    degree_ratio = s['avg_degree'] / max(s['max_degree'], 1)\n\n    # Log‑like scaling (sqrt(n) approximates log(n) for large n)\n    log_like = s['n'] ** 0.5\n\n    # Clustering adjustment\n    clustering_adjust = 1 + s['avg_clustering']\n\n    # Additional heterogeneity factor\n    heterogeneity_factor = 1 + s['std_degree'] / max(s['avg_degree'], 1)\n\n    # Transitivity factor\n    transitivity_factor = 1 + s['transitivity']\n\n    # Degree assortativity adjustment (use absolute value to keep positive)\n    assortativity_factor = 1 + abs(s['degree_assortativity'])\n\n    # Combine all components\n    return (\n        size_connectivity\n        * degree_ratio\n        * log_like\n        / clustering_adjust\n        * heterogeneity_factor\n        * transitivity_factor\n        * assortativity_factor\n    )",
        "island_id": 1,
        "generation": 2,
        "train_score": 0.8995438175270108,
        "val_score": 0.5023257975710079,
        "simplicity_score": 0.12491707005709463,
        "novelty_bonus": 0.19229880747018668
      },
      {
        "id": "g18_i2_p1_102387527",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The estimate starts from a log‑ratio of the\n    (n+1) and (avg_degree+1) values (approximated with bit_length) and\n    is then scaled by several multiplicative adjustments that capture\n    density, clustering, transitivity, assortativity, heterogeneity,\n    triangle abundance, hub prominence, minimum degree, and median‑degree skew.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys:\n        - n (int)\n        - m (int)\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int])   # sorted\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg = s['avg_degree']\n\n    # Base estimate: ratio of approximate log₂(n+1) to log₂(avg_degree+1)\n    n_log = (n + 1).bit_length()\n    k_log = (int(avg_deg) + 1).bit_length()\n    base = float(n_log) / max(float(k_log), 1.0)\n\n    # 1. Density – denser graphs tend to have shorter paths\n    base *= 1 - 0.05 * s['density']\n\n    # 2. Average clustering – high clustering reduces path length\n    base *= 1 - 0.07 * s['avg_clustering']\n\n    # 3. Transitivity – slightly shortens paths in moderately transitive graphs\n    base *= 1 + 0.04 * s['transitivity']\n\n    # 4. Degree assortativity – positive assortativity can lengthen paths\n    base *= 1 + 0.06 * s['degree_assortativity']\n\n    # 5. Degree heterogeneity (std / max_degree)\n    base *= 1 + 0.03 * (s['std_degree'] / max(s['max_degree'], 1))\n\n    # 6. Triangle abundance – many triangles usually shrink path lengths\n    base *= 1 - min(0.2, 1e-6 * s['num_triangles'])\n\n    # 7. Hub prominence – large max_degree relative to n slightly increases length\n    base *= 1 + 0.02 * (s['max_degree'] / max(n, 1))\n\n    # 8. Minimum degree – very low min_degree increases length\n    base *= 1 + 0.05 * (1 - s['min_degree'] / max(s['avg_degree'], 1))\n\n    # 9. Median‑degree skew – captures skewness in the degree distribution\n    median_deg = s['degrees'][len(s['degrees']) // 2]\n    base *= 1 + 0.02 * ((median_deg - s['avg_degree']) / max(s['avg_degree'], 1))\n\n    return base",
        "island_id": 2,
        "generation": 18,
        "train_score": 0.757406962785114,
        "val_score": 0.4701241168863435,
        "simplicity_score": 0.22128271627508103,
        "novelty_bonus": 0.21179588470373922
      },
      {
        "id": "g19_i2_p1_536661656",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The core estimate is a log‑based ratio\n    (bit‑length of n+1 divided by bit‑length of avg_degree+1) with\n    several multiplicative adjustments that capture density, clustering,\n    transitivity, degree assortativity, heterogeneity, triangle abundance,\n    hub prominence, minimum degree, and median‑degree skew.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg = s['avg_degree']\n\n    # Rough log₂ approximations using bit_length (floor(log₂(x)))\n    n_log = (n + 1).bit_length() - 1          # ≈ floor(log₂(n+1))\n    k_log = (int(avg_deg) + 1).bit_length() - 1  # ≈ floor(log₂(avg_deg+1))\n\n    # Base estimate: log₂(n+1) / log₂(avg_degree+1)\n    base = (n_log + 1) / max(k_log + 1, 1)\n\n    # 1. Density – denser graphs tend to have shorter paths\n    base *= 1 - 0.10 * s['density']\n\n    # 2. Average clustering – high clustering reduces path length\n    base *= 1 - 0.08 * s['avg_clustering']\n\n    # 3. Transitivity – slightly shortens paths in moderately transitive graphs\n    base *= 1 + 0.03 * s['transitivity']\n\n    # 4. Degree assortativity – positive assortativity can lengthen paths\n    base *= 1 + 0.07 * s['degree_assortativity']\n\n    # 5. Degree heterogeneity (std / max_degree)\n    base *= 1 + 0.04 * (s['std_degree'] / max(s['max_degree'], 1))\n\n    # 6. Triangle abundance – many triangles usually shrink path lengths\n    base *= 1 - min(0.25, 1e-7 * s['num_triangles'])\n\n    # 7. Hub prominence – large max_degree relative to n slightly increases length\n    base *= 1 + 0.02 * (s['max_degree'] / max(n, 1))\n\n    # 8. Minimum degree – very low min_degree increases length\n    base *= 1 + 0.05 * (1 - s['min_degree'] / max(avg_deg, 1))\n\n    # 9. Median‑degree skew – captures skewness in the degree distribution\n    median_deg = s['degrees'][len(s['degrees']) // 2]\n    base *= 1 + 0.02 * ((median_deg - avg_deg) / max(avg_deg, 1))\n\n    return base",
        "island_id": 2,
        "generation": 19,
        "train_score": 0.7562545018007203,
        "val_score": 0.46905287273005947,
        "simplicity_score": 0.22137394722358028,
        "novelty_bonus": 0.198849017336304
      },
      {
        "id": "g19_i1_p1_685568117",
        "code": "def new_invariant(s):\n    \"\"\"\n    Compute a graph invariant that captures several structural aspects\n    relevant to the average shortest‑path length.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys:\n        - n (int)                : number of nodes\n        - m (int)                : number of edges\n        - density (float)        : graph density\n        - avg_degree (float)     : average degree\n        - max_degree (int)       : maximum degree\n        - std_degree (float)     : standard deviation of degrees\n        - avg_clustering (float) : average clustering coefficient\n        - transitivity (float)   : global transitivity\n        - degree_assortativity (float) : degree assortativity coefficient\n\n    Returns\n    -------\n    float\n        The computed invariant value.\n    \"\"\"\n    # Basic quantities\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree'] if s['max_degree'] else 1\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n\n    # Size vs. connectivity\n    size_connect = n / (m + 1)\n\n    # Degree heterogeneity ratio\n    deg_ratio = avg_deg / max_deg\n\n    # sqrt‑like scaling (approximates log‑like growth)\n    scale = n ** 0.5\n\n    # Clustering adjustment (larger clustering reduces path length)\n    cluster_adj = 1 + avg_clust\n\n    # Additional heterogeneity factor\n    hetero = 1 + std_deg / max(avg_deg, 1)\n\n    # Transitivity boost\n    trans_factor = 1 + trans\n\n    # Assortativity correction\n    assort_factor = 1 + abs(assort)\n\n    # Density moderation (denser graphs tend to have shorter paths)\n    density_mod = 1 / (1 + density)\n\n    # Combine all components multiplicatively and adjust for clustering\n    return (\n        size_connect\n        * deg_ratio\n        * scale\n        * hetero\n        * trans_factor\n        * assort_factor\n        * density_mod\n    ) / cluster_adj",
        "island_id": 1,
        "generation": 19,
        "train_score": 0.9170228091236493,
        "val_score": 0.5185397046101271,
        "simplicity_score": 0.12522158612721232,
        "novelty_bonus": 0.2017910447761193
      },
      {
        "id": "g19_i2_p3_597684511",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The estimate is built from a simple log‑ratio\n    (approximated with bit_length) and a series of multiplicative\n    adjustments that capture density, clustering, transitivity,\n    degree assortativity, heterogeneity, triangle abundance,\n    hub prominence, minimum degree, and median‑degree skew.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features. Expected keys:\n        - n (int)\n        - m (int)\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted list of degrees\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg = s['avg_degree']\n\n    # Rough log₂ approximations using bit_length (floor(log₂(x)))\n    n_log = (n + 1).bit_length() - 1          # ≈ floor(log₂(n+1))\n    k_log = (int(avg_deg) + 1).bit_length() - 1  # ≈ floor(log₂(avg_deg+1))\n\n    # Base estimate: (log₂(n+1)+1) / (log₂(avg_deg+1)+1)\n    base = (n_log + 1) / max(k_log + 1, 1)\n\n    # 1. Density – denser graphs tend to have shorter paths\n    base *= 1 - 0.07 * s['density']\n\n    # 2. Average clustering – high clustering reduces path length\n    base *= 1 - 0.10 * s['avg_clustering']\n\n    # 3. Transitivity – higher transitivity shortens paths\n    base *= 1 + 0.04 * s['transitivity']\n\n    # 4. Degree assortativity – positive assortativity can lengthen paths\n    base *= 1 + 0.08 * s['degree_assortativity']\n\n    # 5. Degree heterogeneity (std / max_degree)\n    base *= 1 + 0.05 * (s['std_degree'] / max(s['max_degree'], 1))\n\n    # 6. Triangle abundance – many triangles usually shrink path lengths\n    base *= 1 - min(0.3, 1e-7 * s['num_triangles'])\n\n    # 7. Hub prominence – large max_degree relative to n slightly increases length\n    base *= 1 + 0.02 * (s['max_degree'] / max(n, 1))\n\n    # 8. Minimum degree – very low min_degree increases length\n    base *= 1 + 0.04 * (1 - s['min_degree'] / max(avg_deg, 1))\n\n    # 9. Median‑degree skew – captures skewness in the degree distribution\n    degrees = s['degrees']\n    median_deg = degrees[len(degrees) // 2]\n    base *= 1 + 0.02 * ((median_deg - avg_deg) / max(avg_deg, 1))\n\n    return base",
        "island_id": 2,
        "generation": 19,
        "train_score": 0.7524129651860745,
        "val_score": 0.4680087364933718,
        "simplicity_score": 0.22131298568177266,
        "novelty_bonus": 0.20563445987327456
      }
    ],
    "3": [
      {
        "id": "g17_i3_p2_898326347",
        "code": "def new_invariant(s):\n    \"\"\"\n    Compute a closed‑form estimate of the average shortest‑path length\n    from a handful of pre‑computed global graph statistics.\n    The expression mixes logarithms, exponentials, polynomial\n    exponents, and ratios of complementary metrics so that it is\n    highly nonlinear and does not collapse to a single feature.\n\n    Parameters\n    ----------\n    s : dict\n        A dictionary that may contain the keys listed below. Missing\n        keys are treated as neutral values (0, 1 or empty list as\n        appropriate).\n\n        - n                       : int          number of nodes\n        - density                 : float        edge density (0‑1)\n        - avg_degree              : float\n        - max_degree              : int\n        - min_degree              : int\n        - std_degree              : float\n        - avg_clustering          : float\n        - transitivity            : float\n        - degree_assortativity    : float\n        - num_triangles           : int\n        - degrees                 : list[int]    degree sequence\n\n    Returns\n    -------\n    float\n        A dimensionless estimate that tracks the real average shortest‑path\n        length, but is derived purely algebraically from the supplied\n        statistics.\n    \"\"\"\n    # Helper: guard against missing keys\n    n                = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    density          = s.get('density', 0.0)\n    avg_degree       = s.get('avg_degree', 0.0)\n    max_degree       = s.get('max_degree', 0)\n    min_degree       = s.get('min_degree', 0)\n    std_degree       = s.get('std_degree', 0.0)\n    avg_clust        = s.get('avg_clustering', 0.0)\n    transitivity     = s.get('transitivity', 0.0)\n    assort           = s.get('degree_assortativity', 0.0)\n    num_tri          = s.get('num_triangles', 0)\n    degrees          = s.get('degrees', [])\n\n    # --- 1. Size scaling (√n) --------------------------------------------------\n    val = n ** 0.5\n\n    # --- 2. Cohesion boost ----------------------------------------------------\n    # Higher local and global clustering reduces path length\n    val *= (1.0 + avg_clust) ** 2.0\n    val *= (1.0 + transitivity) ** 1.5\n\n    # --- 3. Density / degree penalty -----------------------------------------\n    # Sparse graphs inflate distances; dense graphs compress them\n    val /= max(density, 1e-4)                  # avoid division by zero\n\n    # Logistic decrease with average degree\n    val *= (1.0 + avg_degree) ** (-1.0)\n    # Further attenuation for graphs with extremely low average degree\n    val *= (1.0 + avg_degree) ** (-0.5)\n\n    # --- 4. Heterogeneity amplification --------------------------------------\n    # Coefficient of variation raised to a power\n    cv = std_degree / max(avg_degree, 1e-4)\n    val *= (1.0 + cv) ** 1.2\n\n    # Influence of extremes in degree distribution\n    min_ratio = min_degree / max(max_degree, 1) if max_degree else 0.0\n    val *= (1.0 + min_ratio) ** 0.8\n\n    # --- 5. Assortativity modulation -----------------------------------------\n    val /= (1.0 + abs(assort) ** 2.0)          # penalise extreme assortativity\n\n    # --- 6. Triangle density factor -----------------------------------------\n    tri_max = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    tri_density = num_tri / max(tri_max, 1e-4)\n    val *= (1.0 + tri_density) ** 0.9\n\n    # --- 7. Harmonic mean degree influence ------------------------------------\n    if degrees:\n        # robust harmonic mean (skip zeros)\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0.0:\n            h_mean = len(degrees) / inv_sum\n            # low harmonic mean (many low‑degree nodes) increases distances\n            val *= (h_mean / max(avg_degree, 1.0)) ** 0.7\n\n    return float(val)",
        "island_id": 3,
        "generation": 17,
        "train_score": 0.9059783913565426,
        "val_score": 0.534056960060647,
        "simplicity_score": 0.16785415156178546,
        "novelty_bonus": 0.15318172152652532
      },
      {
        "id": "g19_i3_p2_183232034",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a dictionary of pre‑computed\n    graph statistics.  The expression mixes size, density, clustering,\n    degree heterogeneity, assortativity, triangle density and a harmonic‑mean\n    degree factor into a single analytic formula.\n\n    Parameters\n    ----------\n    s : dict\n        Available keys (missing keys are treated as neutral values):\n            n                     : int     number of nodes\n            m                     : int     number of edges\n            density               : float   edge density (0‑1)\n            avg_degree            : float   average degree\n            max_degree            : int\n            min_degree            : int\n            std_degree            : float   standard deviation of degrees\n            avg_clustering        : float   average local clustering\n            transitivity          : float   global transitivity\n            degree_assortativity  : float\n            num_triangles         : int     number of triangles\n            degrees               : list[int] sorted degree sequence\n\n    Returns\n    -------\n    float\n        A dimensionless estimate that correlates with the true average\n        shortest‑path length.\n    \"\"\"\n    # --- Basic checks and defaults ---------------------------------------------\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    m               = s.get('m', 0)\n    density         = s.get('density', 0.0)\n    avg_degree      = s.get('avg_degree', 0.0)\n    std_degree      = s.get('std_degree', 0.0)\n    avg_clustering  = s.get('avg_clustering', 0.0)\n    transitivity    = s.get('transitivity', 0.0)\n    assortativity   = s.get('degree_assortativity', 0.0)\n    num_triangles   = s.get('num_triangles', 0)\n    degrees         = s.get('degrees', [])\n\n    max_degree      = s.get('max_degree', 0)\n    min_degree      = s.get('min_degree', 0)\n\n    # --------------------------------------------------------------------------\n    # 1.  Harmonic mean of the degree sequence (robust against zeros)\n    if degrees:\n        inv_sum = sum(1.0/d for d in degrees if d > 0)\n        h_mean = 0.0\n        if inv_sum > 0.0:\n            h_mean = len(degrees) / inv_sum\n    else:\n        h_mean = 0.0\n\n    # 2.  Coefficient of variation of the degrees\n    cv = 0.0\n    if avg_degree > 0.0:\n        cv = std_degree / avg_degree\n\n    # 3.  Triangle density\n    if n > 2:\n        max_triangles = n * (n - 1) * (n - 2) / 6.0\n        tri_density   = num_triangles / max_triangles\n    else:\n        tri_density = 0.0\n\n    # 4.  Minimum‑to‑maximum degree ratio\n    min_max_ratio = 0.0\n    if max_degree > 0:\n        min_max_ratio = min_degree / max_degree\n\n    # --------------------------------------------------------------------------\n    # 5.  Construct the invariant ---------------------------------------------\n    val = n ** 0.5                                # √n – size scaling\n\n    # Reduce distances with clustering and transitivity\n    val *= (1.0 + avg_clustering) ** 2.0\n    val *= (1.0 + transitivity) ** 1.5\n\n    # Inflate distances for sparse graphs\n    val /= max(density, 1e-4)\n\n    # Penalize low average degree (sparse graphs)\n    val *= (1.0 + avg_degree) ** (-1.5)\n\n    # Amplify heterogeneity of the degree distribution\n    val *= (1.0 + cv) ** 1.2\n\n    # Small min‑max ratio reduces distances slightly\n    val *= (1.0 + min_max_ratio) ** 0.8\n\n    # Extreme assortativity lengthens paths\n    val /= (1.0 + abs(assortativity) ** 2.0)\n\n    # More triangles shrink distances\n    val *= (1.0 + tri_density) ** 0.9\n\n    # Low harmonic‑mean degree (many low‑degree nodes) increases distances\n    if h_mean > 0.0:\n        val *= (h_mean / max(avg_degree, 1.0)) ** 0.7\n\n    return float(val)",
        "island_id": 3,
        "generation": 19,
        "train_score": 0.9059783913565426,
        "val_score": 0.5339893753635594,
        "simplicity_score": 0.16751622807634728,
        "novelty_bonus": 0.15318172152652532
      },
      {
        "id": "g16_i3_p2_491296809",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features\n    without any graph traversal or external libraries.  The expression\n    blends size, density, degree heterogeneity, clustering, assortativity,\n    triangle density, and a harmonic‑mean degree factor into a single\n    analytical formula.\n    \"\"\"\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    # Basic size scaling – distances grow roughly like √n\n    val = pow(n, 0.5)\n\n    # Cohesion contributions – higher clustering/transitivity shrink distances\n    val *= (1.0 + s.get('avg_clustering', 0.0))\n    val *= (1.0 + s.get('transitivity', 0.0))\n\n    # Normalize by average degree (density proxy); +1 avoids division by zero\n    avg_deg = s.get('avg_degree', 0.0)\n    val /= (avg_deg + 1.0)\n\n    # Degree heterogeneity amplifies the estimate\n    std_deg = s.get('std_degree', 0.0)\n    val *= (1.0 + std_deg / max(avg_deg, 1e-6))\n\n    # Assortativity penalty – high assortativity can lengthen paths\n    assort = s.get('degree_assortativity', 0.0)\n    val /= (1.0 + abs(assort))\n\n    # Triangle density – more triangles usually shorten distances\n    tri = s.get('num_triangles', 0)\n    max_tri = n * (n - 1) * (n - 2) / 6.0 if n > 2 else 1.0\n    tri_dens = tri / max_tri\n    val *= (1.0 + tri_dens)\n\n    # Harmonic‑mean degree factor – low‑degree hubs influence distances\n    degrees = s.get('degrees', [])\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            if d > 0:\n                inv_sum += 1.0 / d\n        if inv_sum > 0.0:\n            h_mean = len(degrees) / inv_sum\n            val *= h_mean / max(avg_deg, 1.0)\n\n    return float(val)",
        "island_id": 3,
        "generation": 16,
        "train_score": 0.7600960384153662,
        "val_score": 0.5314901051692063,
        "simplicity_score": 0.17103911066082456,
        "novelty_bonus": 0.23553705835967698
      },
      {
        "id": "g17_i3_p3_332498068",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a dictionary of pre‑computed\n    graph statistics.  The estimate is a fully analytical combination of size,\n    density, clustering, degree distribution, assortativity, triangle density,\n    and a harmonic‑mean degree factor – no graph traversal or external libraries\n    are used.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys (missing keys are treated as neutral values):\n            - 'n'                 : int, number of nodes\n            - 'm'                 : int, number of edges\n            - 'density'           : float\n            - 'avg_degree'        : float\n            - 'max_degree'        : int\n            - 'min_degree'        : int\n            - 'std_degree'        : float\n            - 'avg_clustering'    : float\n            - 'transitivity'      : float\n            - 'degree_assortativity' : float\n            - 'num_triangles'     : int\n            - 'degrees'           : list[int], sorted degree sequence\n\n    Returns\n    -------\n    float\n        A dimensionless estimate that correlates with the true\n        average shortest‑path length.\n    \"\"\"\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n\n    # Basic size scaling – distances grow roughly like √n\n    val = n ** 0.5\n\n    # Cohesion factors – higher clustering/transitivity imply tighter groups\n    val *= (1.0 + s.get('avg_clustering', 0.0))\n    val *= (1.0 + s.get('transitivity', 0.0))\n\n    # Normalise by overall density proxy (average degree)\n    avg_deg = s.get('avg_degree', 0.0)\n    val /= (avg_deg + 1.0)          # +1 avoids division by zero\n\n    # Degree heterogeneity (coefficient of variation)\n    std_deg = s.get('std_degree', 0.0)\n    val *= 1.0 + std_deg / max(avg_deg, 1e-6)\n\n    # Assortativity adjustment – high assortativity can stretch paths\n    assort = s.get('degree_assortativity', 0.0)\n    val /= 1.0 + abs(assort)\n\n    # Triangle density factor – more triangles tend to shorten paths\n    tri = s.get('num_triangles', 0)\n    if n > 2:\n        max_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_dens = tri / max_tri\n    else:\n        tri_dens = 0.0\n    val *= 1.0 + tri_dens\n\n    # Harmonic‑mean degree factor – low‑degree nodes influence distances\n    degrees = s.get('degrees', [])\n    if degrees:\n        inv_sum = 0.0\n        for d in degrees:\n            if d > 0:\n                inv_sum += 1.0 / d\n        if inv_sum > 0.0:\n            h_mean = len(degrees) / inv_sum\n            val *= h_mean / max(avg_deg, 1.0)\n\n    return float(val)",
        "island_id": 3,
        "generation": 17,
        "train_score": 0.7600960384153662,
        "val_score": 0.531476676930495,
        "simplicity_score": 0.1709719694672685,
        "novelty_bonus": 0.23553705835967698
      },
      {
        "id": "g8_i3_p3_315365990",
        "code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed\n    global graph statistics.  The formula is a non‑trivial combination of\n    size, density, clustering, degree heterogeneity, assortativity,\n    triangle density, and a harmonic‑mean degree factor – but it never\n    returns a single feature nor performs any graph traversal.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the following keys (missing keys default to a neutral\n        value):\n        - 'n'                 : number of nodes\n        - 'avg_degree'        : average degree\n        - 'std_degree'        : standard deviation of the degree sequence\n        - 'avg_clustering'    : average local clustering coefficient\n        - 'transitivity'      : global transitivity\n        - 'degree_assortativity' : degree assortativity coefficient\n        - 'num_triangles'     : number of triangles\n        - 'degrees'           : list of degrees (unsorted is also fine)\n\n    Returns\n    -------\n    float\n        A dimensionless estimate that correlates with the true\n        average shortest‑path length.  The value is positive for any\n        feasible input.\n    \"\"\"\n    # Basic scaling: distances grow roughly like sqrt(n)\n    n = s.get('n', 0)\n    if n <= 0:\n        return 0.0\n    val = n ** 0.5\n\n    # Local cohesion: reward high clustering and transitivity\n    val *= (1.0 + s.get('avg_clustering', 0.0))\n    val *= (1.0 + s.get('transitivity', 0.0))\n\n    # Normalise by overall density (avg_degree)\n    avg_deg = s.get('avg_degree', 0.0)\n    denom = avg_deg + 1.0        # +1 avoids division by zero\n    val /= denom\n\n    # Degree heterogeneity (coefficient of variation)\n    std_deg = s.get('std_degree', 0.0)\n    val *= 1.0 + std_deg / max(avg_deg, 1e-6)\n\n    # Assortativity adjustment (positive assortativity can stretch paths)\n    assort = s.get('degree_assortativity', 0.0)\n    val /= 1.0 + abs(assort)\n\n    # Triangle density factor\n    tri = s.get('num_triangles', 0)\n    if n > 2:\n        max_tri = n * (n - 1) * (n - 2) / 6.0\n        tri_dens = tri / max_tri\n    else:\n        tri_dens = 0.0\n    val *= 1.0 + tri_dens\n\n    # Harmonic‑mean degree factor: encourages many low‑degree nodes\n    degrees = s.get('degrees', [])\n    if degrees:\n        inv_sum = sum(1.0 / d for d in degrees if d > 0)\n        if inv_sum > 0:\n            h_mean = len(degrees) / inv_sum\n            val *= h_mean / max(avg_deg, 1.0)\n\n    return float(val)",
        "island_id": 3,
        "generation": 8,
        "train_score": 0.7600960384153662,
        "val_score": 0.5314567841791523,
        "simplicity_score": 0.17087250571055487,
        "novelty_bonus": 0.23553705835967698
      }
    ]
  }
}