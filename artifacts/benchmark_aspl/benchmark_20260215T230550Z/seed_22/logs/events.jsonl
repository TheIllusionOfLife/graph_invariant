{"timestamp": "2026-02-16T05:50:46.118520+00:00", "event_type": "phase1_started", "payload": {"experiment_id": "seed_22", "resume": null, "model_name": "gpt-oss:20b", "dataset_fingerprint": "731af5d4e436a9e6deff361187e67071eb151f53a87e82eccebe8728ca6e8932"}}
{"timestamp": "2026-02-16T05:51:34.647268+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T05:51:34.648226+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T05:52:14.780284+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.038897", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T05:52:14.780692+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 0, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T05:54:26.508189+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.023595", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T05:54:26.508870+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.023595", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T05:54:46.567414+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.086010", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T05:54:46.567675+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T05:55:22.745998+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T05:55:22.746717+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T05:56:10.302261+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.048912", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T05:56:10.302968+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 0, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T05:57:05.781562+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T05:57:05.782954+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:14:00.305404+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.000000", "model_name": "gpt-oss:20b", "train_signal": 0.0}}
{"timestamp": "2026-02-16T06:14:00.305814+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:16:17.137323+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:16:17.138622+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:17:37.674313+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 0, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.039035", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:17:37.675013+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 0, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:17:55.258412+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:17:55.259118+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:18:17.520111+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.049794", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:18:17.520691+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 1, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:18:43.051583+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.002641", "model_name": "gpt-oss:20b", "train_signal": 0.0026410564225690276}}
{"timestamp": "2026-02-16T06:19:06.872231+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.082876", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:19:06.872772+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.082876", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:19:29.594875+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.084782", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:19:29.595251+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 1, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:19:50.229708+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:19:50.231286+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:20:10.016945+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.049794", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:20:10.017555+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 1, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:20:39.653831+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.043706", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:20:39.654378+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.043706", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:21:07.388157+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 1, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.096424", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:21:07.388682+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 1, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:21:29.121516+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:21:29.122617+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:22:18.713242+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.038818", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:22:18.713962+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 2, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:22:37.639964+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g0_i2_p1_771244614", "generation": 0, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.704969987995198, "fitness_mode": "correlation", "simplicity_score": 0.15837842979451028, "novelty_bonus": 0.1765154131543537, "total_score": 0.49053295747139736, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\nNone yet.\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.038818\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    return base * cluster_factor / std_factor\n```", "extracted_code": "def new_invariant(s):\n    # Basic estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    return base * cluster_factor / std_factor", "spearman": 0.8118052951323783, "pearson": 0.647920146844135, "rmse": 2.1058849404160918, "mae": 1.2864953475976975}}
{"timestamp": "2026-02-16T06:23:21.278767+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g0_i2_p2_366346915", "generation": 0, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7066026410564226, "fitness_mode": "correlation", "simplicity_score": 0.16907524701969207, "novelty_bonus": 0.20410652882616853, "total_score": 0.5358322776835298, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\nNone yet.\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.038818\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment", "spearman": 0.8815705392634816, "pearson": 0.8807640752526206, "rmse": 11.19993834985696, "mae": 9.503853455145881}}
{"timestamp": "2026-02-16T06:23:46.852822+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.081404", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:23:46.853272+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.081404", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:24:05.300427+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.086819", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:24:05.300799+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 2, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:24:42.740453+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:24:42.741681+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:25:16.822379+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 2, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:25:16.822996+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 2, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:25:46.980894+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:25:46.981786+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:26:34.530046+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.117784", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:26:34.530773+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 3, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:27:05.879824+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.296999", "model_name": "gpt-oss:20b", "train_signal": 0.2969987995198079}}
{"timestamp": "2026-02-16T06:27:34.438937+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:27:34.439472+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:28:02.576379+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 2, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:28:02.577263+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 3, "population_idx": 2, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:28:57.999162+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:28:57.999565+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:29:28.608175+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.058096", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:29:28.608368+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 3, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:30:18.477262+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.096829", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:30:18.477697+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 0, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.096829", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:30:48.505571+00:00", "event_type": "candidate_rejected", "payload": {"generation": 0, "island_id": 3, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.132519", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:30:48.505974+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 0, "island_id": 3, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:30:48.506751+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 1, "model_name": "gpt-oss:20b", "best_val_score": 0.5358322776835298, "no_improve_count": 0}}
{"timestamp": "2026-02-16T06:31:12.984997+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:31:12.985702+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:31:54.309710+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.022046", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:31:54.310226+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 0, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:33:05.517664+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.068790", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:33:05.518194+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.068790", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:33:59.713702+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:33:59.714830+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:34:34.915923+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.093955", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:34:34.916524+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.093955", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:35:26.591675+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.107543", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:35:26.592161+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 0, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:36:05.186902+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:36:05.187546+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:36:56.313903+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.005761", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:36:56.314469+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:37:34.161685+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i0_p4_659894213", "generation": 1, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.39918367346938777, "fitness_mode": "correlation", "simplicity_score": 0.14058240003633826, "novelty_bonus": 0.1954812942939631, "total_score": 0.2980666509400227, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\nNone yet.\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.107543\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.005761\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a combination of\n    pre‑computed graph statistics.  The formula is inspired by the\n    characteristic path length of random graphs (log(n)/log(avg_degree))\n    and is adjusted for sparsity, clustering, and degree assortativity.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n\n    # Baseline estimate for a random graph\n    baseline = np.log(n) / (np.log(avg_deg + 1) + 1e-6)\n\n    # Adjust for sparsity: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density)\n\n    # Adjust for clustering: higher clustering can slightly reduce path length\n    clustering_adj = 1 - clustering\n\n    # Adjust for degree assortativity: assortative mixing can increase path length\n    assort_adj = 1 + assort\n\n    return baseline * density_adj * clustering_adj * assort_adj\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a combination of\n    pre‑computed graph statistics.  The formula is inspired by the\n    characteristic path length of random graphs (log(n)/log(avg_degree))\n    and is adjusted for sparsity, clustering, and degree assortativity.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n\n    # Baseline estimate for a random graph\n    baseline = np.log(n) / (np.log(avg_deg + 1) + 1e-6)\n\n    # Adjust for sparsity: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density)\n\n    # Adjust for clustering: higher clustering can slightly reduce path length\n    clustering_adj = 1 - clustering\n\n    # Adjust for degree assortativity: assortative mixing can increase path length\n    assort_adj = 1 + assort\n\n    return baseline * density_adj * clustering_adj * assort_adj", "spearman": 0.4226115652891323, "pearson": 0.39880865368314483, "rmse": 1.0688813035208162, "mae": 0.7834911098782726}}
{"timestamp": "2026-02-16T06:37:47.944902+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:37:47.945309+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:39:27.192279+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i1_p0_199295379", "generation": 1, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3049699879951981, "fitness_mode": "correlation", "simplicity_score": 0.1306179331396189, "novelty_bonus": 0.324345608640216, "total_score": 0.24544331962124866, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\nNone yet.\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.049794\nbelow_novelty_threshold: novelty_bonus=0.043706\nbelow_novelty_threshold: novelty_bonus=0.096424\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A composite graph invariant that blends several structural features:\n    - logarithmic scaling of the node count (captures size effects)\n    - average degree (overall connectivity)\n    - average clustering (local cohesion)\n    - maximum degree (presence of hubs)\n    The formula is designed to be dimensionless and robust to extreme values.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    max_deg = s['max_degree']\n\n    # Avoid division by zero by adding small constants where needed\n    denom = m + avg_clust * n + max_deg + 1\n    return np.log1p(n) * avg_deg / denom\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    # Extract basic features\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity'] or 0\n\n    # Compute a normalized sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    return (avg_deg * (1 + avg_clust) * (1 + transitivity) + norm_sq) / denom", "extracted_code": "def new_invariant(s):\n    # Extract basic features\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity'] or 0\n\n    # Compute a normalized sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    return (avg_deg * (1 + avg_clust) * (1 + transitivity) + norm_sq) / denom", "spearman": 0.2440321008025201, "pearson": 0.10422424975771111, "rmse": 2.8668874289169164, "mae": 2.6960084191473737}}
{"timestamp": "2026-02-16T06:39:27.192958+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:40:13.918447+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.088079", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:40:13.918944+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.088079", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:40:43.789580+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.044898", "model_name": "gpt-oss:20b", "train_signal": 0.044897959183673466}}
{"timestamp": "2026-02-16T06:40:43.790356+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 1, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:41:16.031316+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.068708", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:41:16.031790+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.068708", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:41:37.401609+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.108582", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:41:37.401934+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:42:00.346500+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:42:00.347789+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:42:37.529800+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.043685", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:42:37.530268+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:43:05.650623+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.056458", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:43:05.651011+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.056458", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:43:22.729850+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 1, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.091906", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:43:22.730551+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 1, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:44:04.963378+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i2_p0_944153884", "generation": 1, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.6119087635054021, "fitness_mode": "correlation", "simplicity_score": 0.1357194346574119, "novelty_bonus": 0.16632859354268137, "total_score": 0.40894526256422603, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    # Basic estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    return base * cluster_factor / std_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.081404\nbelow_novelty_threshold: novelty_bonus=0.086819\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n    \n    The formula combines:\n    - A base estimate inversely proportional to the average degree.\n    - An upward adjustment for clustering (local detours increase path length).\n    - A downward adjustment for degree heterogeneity (hubs shorten paths).\n    - A further downward adjustment for the presence of triangles (shortcuts).\n    - An additional downward adjustment for degree assortativity (high‑degree\n      nodes tend to be connected, which reduces the overall path length).\n    \n    All denominators are shifted by +1 (or by the absolute value of the\n    assortativity coefficient) to avoid division by zero and keep the result\n    positive while preserving the relative influence of each term.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    triangles = s['num_triangles']\n    assort = s['degree_assortativity']\n\n    # Base estimate: larger n or smaller average degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Factor that increases the estimate when clustering is high\n    clust_factor = 1 + avg_clust\n\n    # Factor that decreases the estimate when degree variance is high\n    std_factor = 1 + std_deg\n\n    # Factor that decreases the estimate when many triangles exist\n    tri_factor = 1 + triangles / (n * (avg_deg + 1) + 1)\n\n    # Factor that decreases the estimate when assortativity is positive\n    # (use absolute value to keep the factor positive for negative values)\n    assort_factor = 1 + abs(assort)\n\n    # Combine all components\n    return base * clust_factor / (std_factor * tri_factor * assort_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n    \n    The formula combines:\n    - A base estimate inversely proportional to the average degree.\n    - An upward adjustment for clustering (local detours increase path length).\n    - A downward adjustment for degree heterogeneity (hubs shorten paths).\n    - A further downward adjustment for the presence of triangles (shortcuts).\n    - An additional downward adjustment for degree assortativity (high‑degree\n      nodes tend to be connected, which reduces the overall path length).\n    \n    All denominators are shifted by +1 (or by the absolute value of the\n    assortativity coefficient) to avoid division by zero and keep the result\n    positive while preserving the relative influence of each term.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    triangles = s['num_triangles']\n    assort = s['degree_assortativity']\n\n    # Base estimate: larger n or smaller average degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Factor that increases the estimate when clustering is high\n    clust_factor = 1 + avg_clust\n\n    # Factor that decreases the estimate when degree variance is high\n    std_factor = 1 + std_deg\n\n    # Factor that decreases the estimate when many triangles exist\n    tri_factor = 1 + triangles / (n * (avg_deg + 1) + 1)\n\n    # Factor that decreases the estimate when assortativity is positive\n    # (use absolute value to keep the factor positive for negative values)\n    assort_factor = 1 + abs(assort)\n\n    # Combine all components\n    return base * clust_factor / (std_factor * tri_factor * assort_factor)", "spearman": 0.6638055951398785, "pearson": 0.5049370496893864, "rmse": 1.7856004210500724, "mae": 1.2928700655558878}}
{"timestamp": "2026-02-16T06:44:27.871122+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i2_p1_264999982", "generation": 1, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8124369747899159, "fitness_mode": "correlation", "simplicity_score": 0.14657378588196107, "novelty_bonus": 0.19185789452501845, "total_score": 0.5269216267714287, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    # Basic estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    return base * cluster_factor / std_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.081404\nbelow_novelty_threshold: novelty_bonus=0.086819\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor", "spearman": 0.8800990024750619, "pearson": 0.7731471978136519, "rmse": 2.4952117095435975, "mae": 1.5743141810024883}}
{"timestamp": "2026-02-16T06:44:53.277025+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i2_p2_653191687", "generation": 1, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.5418007202881152, "fitness_mode": "correlation", "simplicity_score": 0.13552103783468633, "novelty_bonus": 0.27655989045790264, "total_score": 0.4921399763993505, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    # Basic estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    return base * cluster_factor / std_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.081404\nbelow_novelty_threshold: novelty_bonus=0.086819\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a lightweight\n    combination of basic graph statistics.\n\n    The formula is based on the intuition that:\n        • More nodes (n) and lower average degree (avg_degree) tend to\n          increase path lengths.\n        • High clustering (avg_clustering), many triangles, and high\n          density encourage local detours, slightly increasing path\n          lengths.\n        • Large degree variance (std_degree) shortens paths because\n          hubs create shortcuts, so we divide by it.\n\n    All divisions are protected against zero by using max(..., 1).\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    avg_deg    = s['avg_degree']\n    c          = s['avg_clustering']\n    tri        = s['num_triangles']\n    std_deg    = s['std_degree']\n    density    = s['density']\n\n    # Core estimate: more nodes and lower average degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Factors that tend to increase path length\n    cluster_factor   = 1 + c\n    density_factor   = 1 + density\n    tri_factor       = 1 + tri / max(m, 1)\n\n    # Factor that tends to shorten path length\n    std_factor       = 1 + std_deg\n\n    # Combine everything\n    return base * cluster_factor * density_factor * tri_factor / std_factor\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a lightweight\n    combination of basic graph statistics.\n\n    The formula is based on the intuition that:\n        • More nodes (n) and lower average degree (avg_degree) tend to\n          increase path lengths.\n        • High clustering (avg_clustering), many triangles, and high\n          density encourage local detours, slightly increasing path\n          lengths.\n        • Large degree variance (std_degree) shortens paths because\n          hubs create shortcuts, so we divide by it.\n\n    All divisions are protected against zero by using max(..., 1).\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    avg_deg    = s['avg_degree']\n    c          = s['avg_clustering']\n    tri        = s['num_triangles']\n    std_deg    = s['std_degree']\n    density    = s['density']\n\n    # Core estimate: more nodes and lower average degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Factors that tend to increase path length\n    cluster_factor   = 1 + c\n    density_factor   = 1 + density\n    tri_factor       = 1 + tri / max(m, 1)\n\n    # Factor that tends to shorten path length\n    std_factor       = 1 + std_deg\n\n    # Combine everything\n    return base * cluster_factor * density_factor * tri_factor / std_factor", "spearman": 0.7641356033900849, "pearson": 0.6393864835191673, "rmse": 4.616897017320004, "mae": 3.3992060070350436}}
{"timestamp": "2026-02-16T06:45:30.746553+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.102599", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:45:30.747074+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.102599", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:45:54.910584+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i2_p3_16540455", "generation": 1, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7681632653061223, "fitness_mode": "correlation", "simplicity_score": 0.18562128930995483, "novelty_bonus": 0.20808915378110748, "total_score": 0.5239033628052935, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    # Basic estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    return base * cluster_factor / std_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.081404\nbelow_novelty_threshold: novelty_bonus=0.086819\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.102599\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The core idea is the classic inverse‑degree estimate\n        n² / (2m)\n    which captures the intuition that a larger graph with few edges\n    tends to have longer paths.  The estimate is then gently nudged\n    by several structural factors that are known to influence path\n    lengths:\n\n        * Average clustering (c) – higher clustering usually forces\n          detours, so we increase the estimate.\n        * Triangle density – the fraction of all possible triangles\n          present in the graph; more triangles also tend to lengthen\n          paths locally.\n        * Degree heterogeneity – a large standard deviation in the\n          degree distribution (many hubs) shortens paths, so we\n          divide by a factor that grows with std_degree.\n        * Maximum degree – a very high maximum degree also tends to\n          shorten paths; we divide by a factor that grows with max_degree.\n        * Degree assortativity – disassortative mixing (high negative\n          assortativity) can lengthen paths; we increase the estimate\n          in proportion to (1 + assortativity).\n\n    All factors are bounded away from zero by adding 1, and\n    denominators that could be zero are protected with max(..., 1).\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are\n        'n', 'm', 'avg_clustering', 'num_triangles', 'std_degree',\n        'max_degree', 'degree_assortativity'.\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n\n    # Core inverse‑degree estimate\n    denom = max(m, 1)\n    base = (n ** 2) / (2 * denom)\n\n    # Normalise triangle count to the maximum possible number\n    max_triangles = n * (n - 1) * (n - 2) // 6\n    tri_norm = s['num_triangles'] / max(max_triangles, 1)\n\n    # Adjustment factors\n    cluster_adj   = 1 + s['avg_clustering']\n    tri_adj       = 1 + tri_norm\n    std_adj       = 1 + s['std_degree']\n    max_deg_adj   = 1 + s['max_degree']\n    assort_adj    = 1 + s['degree_assortativity']\n\n    # Combine everything\n    estimate = base * cluster_adj * tri_adj * assort_adj / (std_adj * max_deg_adj)\n    return estimate\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.\n\n    The base of the estimate is the classical inverse‑degree intuition\n    ``n / (avg_degree + 1)``: a larger graph or a smaller average degree\n    usually means longer paths.  The estimate is then gently nudged by\n    structural factors that are known to influence path lengths:\n\n        * density   – a sparse graph tends to have longer paths, so the\n          estimate is scaled up by 1/density (with a tiny epsilon to\n          avoid division by zero).\n        * avg_clustering – higher clustering forces local detours,\n          increasing the estimate.\n        * degree_assortativity – disassortative mixing (negative\n          assortativity) can lengthen paths, so the estimate is\n          multiplied by (1 + assortativity).\n        * std_degree – a highly heterogeneous degree distribution\n          (many hubs) shortens paths, so the estimate is divided by\n          (1 + std_degree).\n        * max_degree – a very high maximum degree also shortens paths,\n          so the estimate is divided by (1 + max_degree).\n\n    The formula remains compact and uses only simple arithmetic\n    operations on the supplied feature dictionary.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n\n    # Base inverse‑degree estimate\n    base = n / (avg_deg + 1)\n\n    # Scale by density (avoid division by zero)\n    eps = 1e-12\n    density_factor = 1 / (density + eps)\n\n    # Adjustments\n    cluster_factor = 1 + clustering\n    assort_factor  = 1 + assort\n    std_factor     = 1 + std_deg\n    max_deg_factor = 1 + max_deg\n\n    # Combine everything\n    estimate = base * density_factor * cluster_factor * assort_factor\n    estimate /= (std_factor * max_deg_factor)\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.\n\n    The base of the estimate is the classical inverse‑degree intuition\n    ``n / (avg_degree + 1)``: a larger graph or a smaller average degree\n    usually means longer paths.  The estimate is then gently nudged by\n    structural factors that are known to influence path lengths:\n\n        * density   – a sparse graph tends to have longer paths, so the\n          estimate is scaled up by 1/density (with a tiny epsilon to\n          avoid division by zero).\n        * avg_clustering – higher clustering forces local detours,\n          increasing the estimate.\n        * degree_assortativity – disassortative mixing (negative\n          assortativity) can lengthen paths, so the estimate is\n          multiplied by (1 + assortativity).\n        * std_degree – a highly heterogeneous degree distribution\n          (many hubs) shortens paths, so the estimate is divided by\n          (1 + std_degree).\n        * max_degree – a very high maximum degree also shortens paths,\n          so the estimate is divided by (1 + max_degree).\n\n    The formula remains compact and uses only simple arithmetic\n    operations on the supplied feature dictionary.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n\n    # Base inverse‑degree estimate\n    base = n / (avg_deg + 1)\n\n    # Scale by density (avoid division by zero)\n    eps = 1e-12\n    density_factor = 1 / (density + eps)\n\n    # Adjustments\n    cluster_factor = 1 + clustering\n    assort_factor  = 1 + assort\n    std_factor     = 1 + std_deg\n    max_deg_factor = 1 + max_deg\n\n    # Combine everything\n    estimate = base * density_factor * cluster_factor * assort_factor\n    estimate /= (std_factor * max_deg_factor)\n\n    return estimate", "spearman": 0.8487047176179405, "pearson": 0.6234177120441927, "rmse": 6.62014242040268, "mae": 2.9075097370816616}}
{"timestamp": "2026-02-16T06:45:54.911484+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 2, "population_idx": 3, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:46:24.167651+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i2_p4_459337044", "generation": 1, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7110204081632653, "fitness_mode": "correlation", "simplicity_score": 0.1660460124857252, "novelty_bonus": 0.25037853323188886, "total_score": 0.5358026994651367, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    # Basic estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    return base * cluster_factor / std_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.086819\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.102599\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero", "spearman": 0.85495987399685, "pearson": 0.7609261076655014, "rmse": 2.056947493566886, "mae": 1.2496393997142556}}
{"timestamp": "2026-02-16T06:46:54.927153+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:46:54.928014+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:47:25.970744+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.060384", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:47:25.971425+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 3, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:48:21.661288+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.029558", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:48:21.661837+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.029558", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:49:06.610856+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i3_p1_147026516", "generation": 1, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.47351740696278505, "fitness_mode": "correlation", "simplicity_score": 0.2485443085389514, "novelty_bonus": 0.38285163081094076, "total_score": 0.4544788488135191, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\nNone yet.\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.132519\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.060384\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.029558\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    An innovative estimate of the average shortest‑path length derived solely from\n    pre‑computed graph descriptors.  It blends size, density, degree dispersion,\n    clustering, assortativity and the presence of triangles, avoiding any\n    traversal or single‑feature reliance.\n    \"\"\"\n    # Guard against division by zero\n    avg_deg = max(s['avg_degree'], 1)\n\n    # Basic size/density influence\n    size_term = (s['n'] + 1) / (s['m'] + 1)\n\n    # Effect of degree dispersion (more variance → longer paths)\n    variance_term = 1 + s['std_degree'] / avg_deg\n\n    # Influence of clustering and global transitivity (higher values → shorter paths)\n    cluster_term = 1 + s['avg_clustering'] * s['transitivity']\n    if cluster_term <= 0:\n        cluster_term = 0.0001  # safety guard\n\n    # Effect of degree assortativity (both positive and negative values can stretch paths)\n    assort_term = 1 + abs(s['degree_assortativity'])\n\n    # Low density leads to larger distances\n    density = s['density']\n    if density <= 0:\n        density = 0.0001\n    density_term = 1 + density ** (-0.5)\n\n    # More triangles usually provide shortcuts\n    triangle_term = 1 + (s['num_triangles'] ** 0.5)\n\n    # Combine all contributions multiplicatively/divisively\n    inv = size_term * variance_term * assort_term * density_term\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A creative heuristic estimate of the average shortest‑path length that\n    blends several topological cues from the feature dictionary while\n    avoiding direct reliance on any single metric.  The construction uses\n    multiplicative coupling of size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance and assortativity, but\n    in a form that is not directly expressible as a simple function of any\n    individual feature.\n    \"\"\"\n    # Extract needed quantities\n    n        = s['n']\n    m        = s['m']\n    density  = s['density']\n    max_deg  = s['max_degree']\n    min_deg  = s['min_degree']\n    std_deg  = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']            # sorted degree list\n\n    # ---- Size–density hybrid\n    size_term = (n ** 1.5) / (m + 1)\n\n    # ---- Density penalty (lower density → larger value)\n    dens_term = 1 / (density + 1e-6)\n\n    # ---- Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1\n    std_term  = 1 + (std_deg / (deg_range + 1))\n\n    # ---- Harmonic mean of degrees (captures skewness)\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)   # avoid division by zero\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # ---- Clustering–transitivity reduction\n    cluster_term = 1 / (clustering * trans + 1e-6)\n\n    # ---- Triangle shortcut effect\n    tri_term = 1 + (triangles ** 0.4)\n\n    # ---- Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # ---- Assemble the invariant\n    inv = size_term * dens_term * std_term * harmonic_term * assort_term\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A creative heuristic estimate of the average shortest‑path length that\n    blends several topological cues from the feature dictionary while\n    avoiding direct reliance on any single metric.  The construction uses\n    multiplicative coupling of size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance and assortativity, but\n    in a form that is not directly expressible as a simple function of any\n    individual feature.\n    \"\"\"\n    # Extract needed quantities\n    n        = s['n']\n    m        = s['m']\n    density  = s['density']\n    max_deg  = s['max_degree']\n    min_deg  = s['min_degree']\n    std_deg  = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']            # sorted degree list\n\n    # ---- Size–density hybrid\n    size_term = (n ** 1.5) / (m + 1)\n\n    # ---- Density penalty (lower density → larger value)\n    dens_term = 1 / (density + 1e-6)\n\n    # ---- Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1\n    std_term  = 1 + (std_deg / (deg_range + 1))\n\n    # ---- Harmonic mean of degrees (captures skewness)\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)   # avoid division by zero\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # ---- Clustering–transitivity reduction\n    cluster_term = 1 / (clustering * trans + 1e-6)\n\n    # ---- Triangle shortcut effect\n    tri_term = 1 + (triangles ** 0.4)\n\n    # ---- Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # ---- Assemble the invariant\n    inv = size_term * dens_term * std_term * harmonic_term * assort_term\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.5798289957248932, "pearson": 0.8075195229575677, "rmse": 2.673887109375997, "mae": 2.5641545469858857}}
{"timestamp": "2026-02-16T06:49:06.611378+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 3, "population_idx": 1, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:49:53.926564+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.102713", "model_name": "gpt-oss:20b", "train_signal": 0.10271308523409363}}
{"timestamp": "2026-02-16T06:50:27.116830+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:50:27.118086+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:50:57.149227+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g1_i3_p3_987675618", "generation": 1, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.3995678271308523, "fitness_mode": "correlation", "simplicity_score": 0.1309390372390484, "novelty_bonus": 0.23310918878521403, "total_score": 0.31344224712545, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\nNone yet.\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.060384\nbelow_novelty_threshold: novelty_bonus=0.029558\nbelow_train_threshold: train_signal=0.102713\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s: dict) -> float:\n    \"\"\"\n    Novel approximation of the average shortest path length that blends\n    several global properties of the graph:\n    * size (n)\n    * degree statistics (average, std. dev.)\n    * clustering coefficients\n    * degree assortativity\n    * density and triangle abundance\n\n    The formula purposely avoids using any single feature directly\n    and instead combines them multiplicatively and in non‑linear ways.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    density    = s['density']\n\n    # Ratio of actual to possible triangles\n    possible_tri = n * (n - 1) * (n - 2) / 6.0\n    tri_ratio = triangles / possible_tri if possible_tri > 0 else 0.0\n\n    # Build composite terms\n    # 1. Growth‑rate component (log‑scale)\n    term_log = np.log(n + 1.0) / np.log(avg_deg + 1.0)\n\n    # 2. Clustering & assortativity interaction\n    term_cluster_assort = (1.0 + clustering) * (1.0 - assort**2)\n\n    # 3. Degree dispersion factor\n    term_std = np.sqrt(1.0 + std_deg)\n\n    # 4. Triangle density damping\n    term_tri = (tri_ratio + 1.0) ** (-0.5)\n\n    # 5. Density smoothing\n    term_density = np.sqrt(density + 1e-4)\n\n    # Multiply all factors to obtain the invariant\n    return term_log * term_cluster_assort * term_std * term_tri * term_density\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Novel approximation of the average shortest path length that blends\n    several global properties of the graph:\n    * size (n)\n    * degree statistics (average, std. dev.)\n    * clustering coefficients\n    * degree assortativity\n    * density and triangle abundance\n\n    The formula purposely avoids using any single feature directly\n    and instead combines them multiplicatively and in non‑linear ways.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    density    = s['density']\n\n    # Ratio of actual to possible triangles\n    possible_tri = n * (n - 1) * (n - 2) / 6.0\n    tri_ratio = triangles / possible_tri if possible_tri > 0 else 0.0\n\n    # Build composite terms\n    # 1. Growth‑rate component (power‑scale)\n    term_log = (n + 1.0) ** (1.0 / (avg_deg + 1.0))\n\n    # 2. Clustering & assortativity interaction\n    term_cluster_assort = (1.0 + clustering) * (1.0 - assort * assort)\n\n    # 3. Degree dispersion factor\n    term_std = (1.0 + std_deg) ** 0.5\n\n    # 4. Triangle density damping\n    term_tri = (tri_ratio + 1.0) ** (-0.5)\n\n    # 5. Density smoothing\n    term_density = (density + 1e-4) ** 0.5\n\n    # Multiply all factors to obtain the invariant\n    return term_log * term_cluster_assort * term_std * term_tri * term_density", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Novel approximation of the average shortest path length that blends\n    several global properties of the graph:\n    * size (n)\n    * degree statistics (average, std. dev.)\n    * clustering coefficients\n    * degree assortativity\n    * density and triangle abundance\n\n    The formula purposely avoids using any single feature directly\n    and instead combines them multiplicatively and in non‑linear ways.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    density    = s['density']\n\n    # Ratio of actual to possible triangles\n    possible_tri = n * (n - 1) * (n - 2) / 6.0\n    tri_ratio = triangles / possible_tri if possible_tri > 0 else 0.0\n\n    # Build composite terms\n    # 1. Growth‑rate component (power‑scale)\n    term_log = (n + 1.0) ** (1.0 / (avg_deg + 1.0))\n\n    # 2. Clustering & assortativity interaction\n    term_cluster_assort = (1.0 + clustering) * (1.0 - assort * assort)\n\n    # 3. Degree dispersion factor\n    term_std = (1.0 + std_deg) ** 0.5\n\n    # 4. Triangle density damping\n    term_tri = (tri_ratio + 1.0) ** (-0.5)\n\n    # 5. Density smoothing\n    term_density = (density + 1e-4) ** 0.5\n\n    # Multiply all factors to obtain the invariant\n    return term_log * term_cluster_assort * term_std * term_tri * term_density", "spearman": -0.4346433660841522, "pearson": -0.3120655400127865, "rmse": 1.779875343688738, "mae": 1.3984791412585549}}
{"timestamp": "2026-02-16T06:50:57.149668+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 3, "population_idx": 3, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:51:36.926246+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:51:36.927470+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 1, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:52:16.793691+00:00", "event_type": "candidate_rejected", "payload": {"generation": 1, "island_id": 3, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.105100", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:52:16.794464+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 1, "island_id": 3, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:52:16.797011+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 2, "model_name": "gpt-oss:20b", "best_val_score": 0.5358322776835298, "no_improve_count": 1}}
{"timestamp": "2026-02-16T06:52:58.209068+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.078131", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:52:58.209703+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.078131", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:53:39.721731+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 0, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.000000", "model_name": "gpt-oss:20b", "train_signal": 0.0}}
{"timestamp": "2026-02-16T06:53:39.722494+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 0, "population_idx": 0, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:54:04.263871+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:54:04.264059+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:54:40.584792+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.258679", "model_name": "gpt-oss:20b", "train_signal": 0.2586794717887155}}
{"timestamp": "2026-02-16T06:54:40.585384+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:55:35.139016+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:55:35.140852+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:56:55.697845+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i0_p2_328450339", "generation": 2, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.3113832942819225, "fitness_mode": "correlation", "simplicity_score": 0.12158516341552067, "novelty_bonus": 0.36920002446660805, "total_score": 0.249348996008722, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a combination of\n    pre‑computed graph statistics.  The formula is inspired by the\n    characteristic path length of random graphs (log(n)/log(avg_degree))\n    and is adjusted for sparsity, clustering, and degree assortativity.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n\n    # Baseline estimate for a random graph\n    baseline = np.log(n) / (np.log(avg_deg + 1) + 1e-6)\n\n    # Adjust for sparsity: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density)\n\n    # Adjust for clustering: higher clustering can slightly reduce path length\n    clustering_adj = 1 - clustering\n\n    # Adjust for degree assortativity: assortative mixing can increase path length\n    assort_adj = 1 + assort\n\n    return baseline * density_adj * clustering_adj * assort_adj\nRecent failures:\nbelow_train_threshold: train_signal=0.000000\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.258679\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a combination of\n    pre‑computed graph statistics.  The formula is based on the\n    characteristic path length of random graphs (log(n)/log(avg_degree))\n    and is refined by simple multiplicative adjustments that capture\n    sparsity, clustering, degree heterogeneity, assortativity, hubs,\n    and triangle abundance.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate for a random graph\n    baseline = np.log(n) / (np.log(avg_deg + 1) + 1e-6)\n\n    # Adjust for sparsity: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density)\n\n    # Adjust for clustering and transitivity: high values tend to shorten paths\n    clustering_adj = 1 - 0.5 * (clustering + trans)\n\n    # Adjust for degree heterogeneity: high variance can reduce path length\n    hetero_adj = 1 - std_deg / (avg_deg + 1e-6)\n\n    # Adjust for degree assortativity: assortative mixing can increase path length\n    assort_adj = 1 + assort\n\n    # Adjust for presence of hubs: a very high max degree usually shortens paths\n    hub_adj = 1 - max_deg / (n - 1 + 1e-6)\n\n    # Adjust for triangle abundance: many triangles typically reduce path length\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + 1e-6)\n\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            hetero_adj *\n            assort_adj *\n            hub_adj *\n            triangle_adj)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-6\n\n    # Baseline estimate based on graph size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustments for various structural properties\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    trans_adj = 1 - trans\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    # Clamp adjustments to avoid negative factors\n    density_adj = max(0, density_adj)\n    clustering_adj = max(0, clustering_adj)\n    trans_adj = max(0, trans_adj)\n    assort_adj = max(0, assort_adj)\n    hetero_adj = max(0, hetero_adj)\n    hub_adj = max(0, hub_adj)\n    triangle_adj = max(0, triangle_adj)\n\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            trans_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj)", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-6\n\n    # Baseline estimate based on graph size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustments for various structural properties\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    trans_adj = 1 - trans\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    # Clamp adjustments to avoid negative factors\n    density_adj = max(0, density_adj)\n    clustering_adj = max(0, clustering_adj)\n    trans_adj = max(0, trans_adj)\n    assort_adj = max(0, assort_adj)\n    hetero_adj = max(0, hetero_adj)\n    hub_adj = max(0, hub_adj)\n    triangle_adj = max(0, triangle_adj)\n\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            trans_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj)", "spearman": 0.22854391197127094, "pearson": 0.14977957518350002, "rmse": 2.4431821475946376, "mae": 2.2205734101941657}}
{"timestamp": "2026-02-16T06:56:55.699169+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 0, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:57:50.585263+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.197311", "model_name": "gpt-oss:20b", "train_signal": 0.19731092436974787}}
{"timestamp": "2026-02-16T06:58:36.008436+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.228427", "model_name": "gpt-oss:20b", "train_signal": 0.22842737094837934}}
{"timestamp": "2026-02-16T06:59:05.323969+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T06:59:05.325010+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:00:24.895200+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.133367", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:00:24.895752+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 1, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:00:57.832817+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i1_p1_851568069", "generation": 2, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.31831932773109245, "fitness_mode": "correlation", "simplicity_score": 0.15683459302352104, "novelty_bonus": 0.37009675241881046, "total_score": 0.25265995093051236, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Extract basic features\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity'] or 0\n\n    # Compute a normalized sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    return (avg_deg * (1 + avg_clust) * (1 + transitivity) + norm_sq) / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.091906\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.133367\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    degrees = s['degrees']\n\n    # Normalized sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        avg_deg * (1 + avg_clust) * (1 + transitivity)  # weighted degree–clustering term\n        + norm_sq                                         # normalized degree variance\n        + (num_triangles + 1) ** 0.5                      # square‑root of triangle count\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    degrees = s['degrees']\n\n    # Normalized sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        avg_deg * (1 + avg_clust) * (1 + transitivity)  # weighted degree–clustering term\n        + norm_sq                                         # normalized degree variance\n        + (num_triangles + 1) ** 0.5                      # square‑root of triangle count\n    )\n\n    return numerator / denom", "spearman": 0.22052801320033003, "pearson": 0.12237501480131305, "rmse": 2.83619060805491, "mae": 2.664010140662185}}
{"timestamp": "2026-02-16T07:01:16.621265+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.288355", "model_name": "gpt-oss:20b", "train_signal": 0.2883553421368547}}
{"timestamp": "2026-02-16T07:02:25.495932+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.265114", "model_name": "gpt-oss:20b", "train_signal": 0.26511404561824725}}
{"timestamp": "2026-02-16T07:02:41.851787+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:02:41.852589+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:03:00.255137+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i1_p4_319991269", "generation": 2, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.38007202881152463, "fitness_mode": "correlation", "simplicity_score": 0.1591862111203445, "novelty_bonus": 0.24753318832970805, "total_score": 0.2861136991354917, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    # Extract basic features\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity'] or 0\n\n    # Compute a normalized sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    return (avg_deg * (1 + avg_clust) * (1 + transitivity) + norm_sq) / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.133367\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    A dimensionless, bounded graph invariant that blends several structural\n    descriptors: degree distribution, clustering, transitivity, assortativity,\n    density, and triangle count.  The formulation normalises the squared\n    degree sum and scales the numerator by the graph size (sqrt(n)) to\n    capture both local and global effects.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        np.sqrt(n)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom", "spearman": 0.3600330008250207, "pearson": 0.25063701301632496, "rmse": 2.6467647176614726, "mae": 2.4683933439377115}}
{"timestamp": "2026-02-16T07:03:00.255557+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 1, "population_idx": 4, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:03:25.853501+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i2_p0_836961323", "generation": 2, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.812533013205282, "fitness_mode": "correlation", "simplicity_score": 0.1643975235452531, "novelty_bonus": 0.17424209182885086, "total_score": 0.5237225965193125, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.086819\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.102599\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The formula consists of three multiplicative components:\n\n    1. **Base term** – grows with the square of the node count and shrinks\n       with the number of edges (and the graph size).  The denominator is\n       `2*m + n`, which is never zero.\n\n    2. **Structural adjustment** – accounts for clustering, degree\n       assortativity and sparsity.  Higher clustering, positive\n       assortativity, and sparser graphs all tend to increase path\n       lengths, so we multiply by `(1 + avg_clustering)`,\n       `(1 + |degree_assortativity|)` and `(2 - density)`.\n\n    3. **Heterogeneity factor** – a larger degree standard deviation\n       (presence of hubs) typically shortens paths.  We divide by\n       `1 + std_degree`.\n\n    All arithmetic is safe from division by zero and keeps the\n    expression compact while capturing the main structural influences.\n    \"\"\"\n    n, m, c, a, std, density = (\n        s['n'],\n        s['m'],\n        s['avg_clustering'],\n        s['degree_assortativity'],\n        s['std_degree'],\n        s['density'],\n    )\n\n    # Base term: n² / (2m + n)\n    denom = max(2 * m + n, 1)\n    base = (n ** 2) / denom\n\n    # Structural adjustment: clustering, assortativity, sparsity\n    adj = (1 + c) * (1 + abs(a)) * (2 - density)\n\n    # Heterogeneity factor: larger std shortens paths\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The formula consists of three multiplicative components:\n\n    1. **Base term** – grows with the square of the node count and shrinks\n       with the number of edges (and the graph size).  The denominator is\n       `2*m + n`, which is never zero.\n\n    2. **Structural adjustment** – accounts for clustering, degree\n       assortativity and sparsity.  Higher clustering, positive\n       assortativity, and sparser graphs all tend to increase path\n       lengths, so we multiply by `(1 + avg_clustering)`,\n       `(1 + |degree_assortativity|)` and `(2 - density)`.\n\n    3. **Heterogeneity factor** – a larger degree standard deviation\n       (presence of hubs) typically shortens paths.  We divide by\n       `1 + std_degree`.\n\n    All arithmetic is safe from division by zero and keeps the\n    expression compact while capturing the main structural influences.\n    \"\"\"\n    n, m, c, a, std, density = (\n        s['n'],\n        s['m'],\n        s['avg_clustering'],\n        s['degree_assortativity'],\n        s['std_degree'],\n        s['density'],\n    )\n\n    # Base term: n² / (2m + n)\n    denom = max(2 * m + n, 1)\n    base = (n ** 2) / denom\n\n    # Structural adjustment: clustering, assortativity, sparsity\n    adj = (1 + c) * (1 + abs(a)) * (2 - density)\n\n    # Heterogeneity factor: larger std shortens paths\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero", "spearman": 0.8771409285232132, "pearson": 0.7704713663544236, "rmse": 6.863235081627967, "mae": 4.9113408379514905}}
{"timestamp": "2026-02-16T07:04:22.869974+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i2_p1_52787610", "generation": 2, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8109963985594237, "fitness_mode": "correlation", "simplicity_score": 0.12842268955696468, "novelty_bonus": 0.1791667463399862, "total_score": 0.5197143188073137, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.086819\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.102599\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n    The estimate is a product of several simple factors that capture the\n    main structural influences on path length:\n        * Base term: n / (avg_degree + 1) – larger graphs or lower average\n          degree lead to longer paths.\n        * Clustering factor: (1 + avg_clustering) – higher clustering tends\n          to increase path length by creating local detours.\n        * Assortativity factor: (1 + |degree_assortativity|) – positive\n          assortativity lengthens paths, negative assortativity shortens\n          them; using the absolute value keeps the factor monotonic.\n        * Heterogeneity factor: 1 / (1 + std_degree) – larger degree variance\n          (presence of hubs) generally shortens paths.\n        * Density factor: (2 - density) – sparser graphs (lower density)\n          have larger path lengths; the factor ranges roughly between 1\n          and 2.\n        * Triangle factor: (1 + num_triangles / max_possible_triangles)\n          – a high proportion of triangles indicates a more tightly knit\n          network, which can slightly reduce average path length.\n    All arithmetic uses only built‑in operations and avoids division by\n    zero by clamping denominators to at least 1.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Adjustment factors\n    cluster_factor = 1 + avg_clust\n    assort_factor = 1 + abs(assort)\n    hetero_factor = 1 / (1 + std_deg)\n    density_factor = 2 - density\n\n    # Max possible number of triangles in a simple graph\n    max_tri = 1 if n < 3 else n * (n - 1) * (n - 2) / 6\n    tri_factor = 1 + num_tri / max(1, max_tri)\n\n    return base * cluster_factor * assort_factor * hetero_factor * density_factor * tri_factor\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n    The estimate is a product of several simple factors that capture the\n    main structural influences on path length:\n        * Base term: n / (avg_degree + 1) – larger graphs or lower average\n          degree lead to longer paths.\n        * Clustering factor: (1 + avg_clustering) – higher clustering tends\n          to increase path length by creating local detours.\n        * Assortativity factor: (1 + |degree_assortativity|) – positive\n          assortativity lengthens paths, negative assortativity shortens\n          them; using the absolute value keeps the factor monotonic.\n        * Heterogeneity factor: 1 / (1 + std_degree) – larger degree variance\n          (presence of hubs) generally shortens paths.\n        * Density factor: (2 - density) – sparser graphs (lower density)\n          have larger path lengths; the factor ranges roughly between 1\n          and 2.\n        * Triangle factor: (1 + num_triangles / max_possible_triangles)\n          – a high proportion of triangles indicates a more tightly knit\n          network, which can slightly reduce average path length.\n    All arithmetic uses only built‑in operations and avoids division by\n    zero by clamping denominators to at least 1.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Adjustment factors\n    cluster_factor = 1 + avg_clust\n    assort_factor = 1 + abs(assort)\n    hetero_factor = 1 / (1 + std_deg)\n    density_factor = 2 - density\n\n    # Max possible number of triangles in a simple graph\n    max_tri = 1 if n < 3 else n * (n - 1) * (n - 2) / 6\n    tri_factor = 1 + num_tri / max(1, max_tri)\n\n    return base * cluster_factor * assort_factor * hetero_factor * density_factor * tri_factor", "spearman": 0.8805595139878497, "pearson": 0.7718786234267224, "rmse": 6.882315842848697, "mae": 4.939943200880749}}
{"timestamp": "2026-02-16T07:04:49.961393+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:04:49.962160+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:05:09.849195+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.088205", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:05:09.850281+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 2, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:05:44.936488+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:05:44.936875+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:06:11.947237+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i2_p3_51438767", "generation": 2, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7379111644657863, "fitness_mode": "correlation", "simplicity_score": 0.18246835978386947, "novelty_bonus": 0.25418240396560854, "total_score": 0.5087530432627094, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.102599\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.088205\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a compact set of\n    pre‑computed graph statistics.\n\n    The estimate is built from a *base* term that scales with the ratio of\n    node count to average degree.  The base is then modulated by several\n    multiplicative factors that capture the influence of connectivity,\n    clustering, degree heterogeneity, assortativity, and the presence of\n    triangles.  All denominators are guarded with a small epsilon to keep\n    the expression safe from division by zero.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n            - n (int): number of nodes\n            - m (int): number of edges\n            - density (float): 2*m / (n*(n-1))\n            - avg_degree (float)\n            - max_degree (int)\n            - min_degree (int)\n            - std_degree (float)\n            - avg_clustering (float)\n            - transitivity (float)\n            - degree_assortativity (float)\n            - num_triangles (int)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    import math\n\n    eps = 1e-6  # small constant to avoid division by zero\n\n    # Base estimate: larger n or smaller average degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1.0)\n\n    # Connectivity factors – higher density/transitivity shorten paths\n    density_adj = 1.0 / (1.0 + max(s['density'], eps))\n    trans_adj    = 1.0 / (1.0 + max(s['transitivity'], eps))\n\n    # Clustering tends to increase local detours, so scale up\n    cluster_adj  = 1.0 + max(s['avg_clustering'], 0.0)\n\n    # Degree heterogeneity – a large std reduces path length (presence of hubs)\n    hetero_adj   = 1.0 / (1.0 + max(s['std_degree'], eps))\n\n    # Assortativity – positive assortativity tends to lengthen paths\n    assort_adj   = 1.0 + abs(s['degree_assortativity'])\n\n    # Max/min degree – higher degrees generally shorten paths\n    max_adj      = 1.0 / (1.0 + max(s['max_degree'], 1))\n    min_adj      = 1.0 / (1.0 + max(s['min_degree'], 1))\n\n    # Triangle count – more triangles create additional short local loops\n    tri_adj      = 1.0 + math.sqrt(max(s['num_triangles'], 0))\n\n    # Combine all adjustments multiplicatively\n    estimate = (base * density_adj * trans_adj * cluster_adj *\n                hetero_adj * assort_adj * max_adj * min_adj * tri_adj)\n\n    return estimate\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a compact set of\n    pre‑computed graph statistics.\n\n    The estimate is built from a *base* term that scales with the ratio of\n    node count to average degree.  The base is then modulated by several\n    multiplicative factors that capture the influence of connectivity,\n    clustering, degree heterogeneity, assortativity, and the presence of\n    triangles.  All denominators are guarded with a small epsilon to keep\n    the expression safe from division by zero.\n    \"\"\"\n    eps = 1e-6  # small constant to avoid division by zero\n\n    # Base estimate: larger n or smaller average degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1.0)\n\n    # Connectivity factors – higher density/transitivity shorten paths\n    density_adj = 1.0 / (1.0 + max(s['density'], eps))\n    trans_adj   = 1.0 / (1.0 + max(s['transitivity'], eps))\n\n    # Clustering tends to increase local detours, so scale up\n    cluster_adj = 1.0 + max(s['avg_clustering'], 0.0)\n\n    # Degree heterogeneity – a large std reduces path length (presence of hubs)\n    hetero_adj  = 1.0 / (1.0 + max(s['std_degree'], eps))\n\n    # Assortativity – positive assortativity tends to lengthen paths\n    assort_adj  = 1.0 + abs(s['degree_assortativity'])\n\n    # Max/min degree – higher degrees generally shorten paths\n    max_adj     = 1.0 / (1.0 + max(s['max_degree'], 1))\n    min_adj     = 1.0 / (1.0 + max(s['min_degree'], 1))\n\n    # Triangle count – more triangles create additional short local loops\n    tri_adj     = 1.0 + (max(s['num_triangles'], 0) ** 0.5)\n\n    # Combine all adjustments multiplicatively\n    estimate = (base * density_adj * trans_adj * cluster_adj *\n                hetero_adj * assort_adj * max_adj * min_adj * tri_adj)\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a compact set of\n    pre‑computed graph statistics.\n\n    The estimate is built from a *base* term that scales with the ratio of\n    node count to average degree.  The base is then modulated by several\n    multiplicative factors that capture the influence of connectivity,\n    clustering, degree heterogeneity, assortativity, and the presence of\n    triangles.  All denominators are guarded with a small epsilon to keep\n    the expression safe from division by zero.\n    \"\"\"\n    eps = 1e-6  # small constant to avoid division by zero\n\n    # Base estimate: larger n or smaller average degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1.0)\n\n    # Connectivity factors – higher density/transitivity shorten paths\n    density_adj = 1.0 / (1.0 + max(s['density'], eps))\n    trans_adj   = 1.0 / (1.0 + max(s['transitivity'], eps))\n\n    # Clustering tends to increase local detours, so scale up\n    cluster_adj = 1.0 + max(s['avg_clustering'], 0.0)\n\n    # Degree heterogeneity – a large std reduces path length (presence of hubs)\n    hetero_adj  = 1.0 / (1.0 + max(s['std_degree'], eps))\n\n    # Assortativity – positive assortativity tends to lengthen paths\n    assort_adj  = 1.0 + abs(s['degree_assortativity'])\n\n    # Max/min degree – higher degrees generally shorten paths\n    max_adj     = 1.0 / (1.0 + max(s['max_degree'], 1))\n    min_adj     = 1.0 / (1.0 + max(s['min_degree'], 1))\n\n    # Triangle count – more triangles create additional short local loops\n    tri_adj     = 1.0 + (max(s['num_triangles'], 0) ** 0.5)\n\n    # Combine all adjustments multiplicatively\n    estimate = (base * density_adj * trans_adj * cluster_adj *\n                hetero_adj * assort_adj * max_adj * min_adj * tri_adj)\n\n    return estimate", "spearman": 0.7920093002325059, "pearson": 0.773366504883278, "rmse": 2.1091343528515294, "mae": 2.015804944693412}}
{"timestamp": "2026-02-16T07:06:11.948045+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 2, "population_idx": 3, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:06:47.508559+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.127890", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:06:47.509154+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.127890", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:07:11.620336+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 2, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.098549", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:07:11.621241+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 2, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:07:42.059170+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.102697", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:07:42.059532+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.102697", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:08:05.442909+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 0, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:08:05.444479+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 3, "population_idx": 0, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:08:29.186578+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:08:29.187714+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:09:05.555243+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i3_p1_269856067", "generation": 2, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.31351740696278513, "fitness_mode": "correlation", "simplicity_score": 0.17966964989604145, "novelty_bonus": 0.15983085849693146, "total_score": 0.2543504492098298, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A creative heuristic estimate of the average shortest‑path length that\n    blends several topological cues from the feature dictionary while\n    avoiding direct reliance on any single metric.  The construction uses\n    multiplicative coupling of size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance and assortativity, but\n    in a form that is not directly expressible as a simple function of any\n    individual feature.\n    \"\"\"\n    # Extract needed quantities\n    n        = s['n']\n    m        = s['m']\n    density  = s['density']\n    max_deg  = s['max_degree']\n    min_deg  = s['min_degree']\n    std_deg  = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']            # sorted degree list\n\n    # ---- Size–density hybrid\n    size_term = (n ** 1.5) / (m + 1)\n\n    # ---- Density penalty (lower density → larger value)\n    dens_term = 1 / (density + 1e-6)\n\n    # ---- Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1\n    std_term  = 1 + (std_deg / (deg_range + 1))\n\n    # ---- Harmonic mean of degrees (captures skewness)\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)   # avoid division by zero\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # ---- Clustering–transitivity reduction\n    cluster_term = 1 / (clustering * trans + 1e-6)\n\n    # ---- Triangle shortcut effect\n    tri_term = 1 + (triangles ** 0.4)\n\n    # ---- Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # ---- Assemble the invariant\n    inv = size_term * dens_term * std_term * harmonic_term * assort_term\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Novel approximation of the average shortest path length that blends\n    several global properties of the graph:\n    * size (n)\n    * degree statistics (average, std. dev.)\n    * clustering coefficients\n    * degree assortativity\n    * density and triangle abundance\n\n    The formula purposely avoids using any single feature directly\n    and instead combines them multiplicatively and in non‑linear ways.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    density    = s['density']\n\n    # Ratio of actual to possible triangles\n    possible_tri = n * (n - 1) * (n - 2) / 6.0\n    tri_ratio = triangles / possible_tri if possible_tri > 0 else 0.0\n\n    # Build composite terms\n    # 1. Growth‑rate component (power‑scale)\n    term_log = (n + 1.0) ** (1.0 / (avg_deg + 1.0))\n\n    # 2. Clustering & assortativity interaction\n    term_cluster_assort = (1.0 + clustering) * (1.0 - assort * assort)\n\n    # 3. Degree dispersion factor\n    term_std = (1.0 + std_deg) ** 0.5\n\n    # 4. Triangle density damping\n    term_tri = (tri_ratio + 1.0) ** (-0.5)\n\n    # 5. Density smoothing\n    term_density = (density + 1e-4) ** 0.5\n\n    # Multiply all factors to obtain the invariant\n    return term_log * term_cluster_assort * term_std * term_tri * term_density\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.105100\nbelow_novelty_threshold: novelty_bonus=0.102697\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport math\n\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest‑path length using a composite\n    of several structural descriptors.  Each factor blends several features\n    in a nonlinear fashion, so the final value does not reduce to any single\n    pre‑computed metric.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics with the following keys:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float): edge density\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted list of degrees\n\n    Returns\n    -------\n    float\n        The proposed invariant value.\n    \"\"\"\n\n    # ---- 1. Size–degree interaction ---------------------------------------\n    size_degree_term = math.log(s['n'] + 1) * math.sqrt(s['max_degree'] + 1)\n\n    # ---- 2. Density penalty (sparser graphs yield larger value) ----------\n    density_term = 1.0 / (s['density'] + 1e-8)\n\n    # ---- 3. Degree dispersion factor ------------------------------------\n    deg_range = s['max_degree'] - s['min_degree'] + 1\n    degree_dispersion_term = 1.0 + s['std_degree'] / (deg_range + 1e-6)\n\n    # ---- 4. Clustering–transitivity reduction ----------------------------\n    clustering_term = 1.0 / (s['avg_clustering'] * s['transitivity'] + 1e-8)\n\n    # ---- 5. Triangle abundance boost -----------------------------------\n    triangle_term = 1.0 + (s['num_triangles'] ** 0.35)\n\n    # ---- 6. Assortativity adjustment ------------------------------------\n    assort_term = 1.0 + abs(s['degree_assortativity'])\n\n    # ---- 7. Assemble the invariant --------------------------------------\n    invariant = (size_degree_term *\n                 density_term *\n                 degree_dispersion_term *\n                 clustering_term *\n                 triangle_term *\n                 assort_term)\n\n    return invariant\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest‑path length that blends\n    multiple graph‑level statistics without relying on any single\n    pre‑computed metric.  All arithmetic is performed with built‑in\n    operators only – no external imports are needed.\n    \"\"\"\n\n    # Small constants to avoid division by zero\n    eps_dens = 1e-8\n    eps_min  = 1e-6\n\n    # 1. Size vs. average degree (captures growth rate)\n    term_size = (s['n'] + 1) ** (1.0 / (s['avg_degree'] + 1.0))\n\n    # 2. Degree spread (ratio of extremes)\n    term_spread = (s['max_degree'] + 1) / (s['min_degree'] + 1 + eps_min)\n\n    # 3. Density smoothing (sparser graphs → larger value)\n    term_density = (s['density'] + eps_dens) ** 0.5\n\n    # 4. Clustering penalty (high clustering reduces distance)\n    term_cluster = (1.0 + s['avg_clustering']) ** -0.5\n\n    # 5. Triangle boost (more triangles → shorter paths)\n    term_tri = (s['num_triangles'] + 1) ** 0.3\n\n    # 6. Assortativity moderation (both ends increase the estimate)\n    term_assort = 1.0 + abs(s['degree_assortativity'])\n\n    # 7. Degree dispersion factor (standard deviation influence)\n    term_disp = 1.0 + s['std_degree']\n\n    # Combine all components multiplicatively\n    invariant = (\n        term_size *\n        term_spread *\n        term_density *\n        term_cluster *\n        term_tri *\n        term_assort *\n        term_disp\n    )\n\n    return invariant", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest‑path length that blends\n    multiple graph‑level statistics without relying on any single\n    pre‑computed metric.  All arithmetic is performed with built‑in\n    operators only – no external imports are needed.\n    \"\"\"\n\n    # Small constants to avoid division by zero\n    eps_dens = 1e-8\n    eps_min  = 1e-6\n\n    # 1. Size vs. average degree (captures growth rate)\n    term_size = (s['n'] + 1) ** (1.0 / (s['avg_degree'] + 1.0))\n\n    # 2. Degree spread (ratio of extremes)\n    term_spread = (s['max_degree'] + 1) / (s['min_degree'] + 1 + eps_min)\n\n    # 3. Density smoothing (sparser graphs → larger value)\n    term_density = (s['density'] + eps_dens) ** 0.5\n\n    # 4. Clustering penalty (high clustering reduces distance)\n    term_cluster = (1.0 + s['avg_clustering']) ** -0.5\n\n    # 5. Triangle boost (more triangles → shorter paths)\n    term_tri = (s['num_triangles'] + 1) ** 0.3\n\n    # 6. Assortativity moderation (both ends increase the estimate)\n    term_assort = 1.0 + abs(s['degree_assortativity'])\n\n    # 7. Degree dispersion factor (standard deviation influence)\n    term_disp = 1.0 + s['std_degree']\n\n    # Combine all components multiplicatively\n    invariant = (\n        term_size *\n        term_spread *\n        term_density *\n        term_cluster *\n        term_tri *\n        term_assort *\n        term_disp\n    )\n\n    return invariant", "spearman": -0.3409345233630841, "pearson": -0.13177814916703912, "rmse": 71.62576386782587, "mae": 46.31591436719532}}
{"timestamp": "2026-02-16T07:09:05.556256+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 3, "population_idx": 1, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:09:33.878045+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:09:33.878999+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:09:58.345259+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i3_p2_555345155", "generation": 2, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.39851140456182466, "fitness_mode": "correlation", "simplicity_score": 0.24967732526043718, "novelty_bonus": 0.31980627627947655, "total_score": 0.34335803495310585, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A creative heuristic estimate of the average shortest‑path length that\n    blends several topological cues from the feature dictionary while\n    avoiding direct reliance on any single metric.  The construction uses\n    multiplicative coupling of size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance and assortativity, but\n    in a form that is not directly expressible as a simple function of any\n    individual feature.\n    \"\"\"\n    # Extract needed quantities\n    n        = s['n']\n    m        = s['m']\n    density  = s['density']\n    max_deg  = s['max_degree']\n    min_deg  = s['min_degree']\n    std_deg  = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']            # sorted degree list\n\n    # ---- Size–density hybrid\n    size_term = (n ** 1.5) / (m + 1)\n\n    # ---- Density penalty (lower density → larger value)\n    dens_term = 1 / (density + 1e-6)\n\n    # ---- Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1\n    std_term  = 1 + (std_deg / (deg_range + 1))\n\n    # ---- Harmonic mean of degrees (captures skewness)\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)   # avoid division by zero\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # ---- Clustering–transitivity reduction\n    cluster_term = 1 / (clustering * trans + 1e-6)\n\n    # ---- Triangle shortcut effect\n    tri_term = 1 + (triangles ** 0.4)\n\n    # ---- Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # ---- Assemble the invariant\n    inv = size_term * dens_term * std_term * harmonic_term * assort_term\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Novel approximation of the average shortest path length that blends\n    several global properties of the graph:\n    * size (n)\n    * degree statistics (average, std. dev.)\n    * clustering coefficients\n    * degree assortativity\n    * density and triangle abundance\n\n    The formula purposely avoids using any single feature directly\n    and instead combines them multiplicatively and in non‑linear ways.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    density    = s['density']\n\n    # Ratio of actual to possible triangles\n    possible_tri = n * (n - 1) * (n - 2) / 6.0\n    tri_ratio = triangles / possible_tri if possible_tri > 0 else 0.0\n\n    # Build composite terms\n    # 1. Growth‑rate component (power‑scale)\n    term_log = (n + 1.0) ** (1.0 / (avg_deg + 1.0))\n\n    # 2. Clustering & assortativity interaction\n    term_cluster_assort = (1.0 + clustering) * (1.0 - assort * assort)\n\n    # 3. Degree dispersion factor\n    term_std = (1.0 + std_deg) ** 0.5\n\n    # 4. Triangle density damping\n    term_tri = (tri_ratio + 1.0) ** (-0.5)\n\n    # 5. Density smoothing\n    term_density = (density + 1e-4) ** 0.5\n\n    # Multiply all factors to obtain the invariant\n    return term_log * term_cluster_assort * term_std * term_tri * term_density\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.105100\nbelow_novelty_threshold: novelty_bonus=0.102697\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    A handcrafted estimate of the average shortest‑path length that blends\n    several global graph statistics without relying on a single metric.\n    The construction uses logarithms, power‑laws and harmonic mean terms\n    to capture size, degree dispersion, density, clustering, assortativity\n    and triangle abundance in a single expression.\n    \"\"\"\n    import math\n\n    # Basic quantities\n    n       = s['n']\n    density = s['density']\n\n    # Degree statistics\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Topological coefficients\n    avg_clust = s['avg_clustering']\n    assort    = s['degree_assortativity']\n    triangles = s['num_triangles']\n\n    # ---- Size–dispersion term\n    size_term = math.log(n + 1) * (1 + std_deg)\n\n    # ---- Density penalty (lower density → larger value)\n    density_term = (1 + density) ** -0.5\n\n    # ---- Clustering correction\n    clustering_term = 1 / (avg_clust + 1e-8)\n\n    # ---- Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # ---- Triangle shortcut influence\n    triangle_term = (triangles + 1) ** 0.3\n\n    # ---- Degree‑range adjustment\n    degree_disp_term = (max_deg - min_deg + 1) ** 0.4\n\n    # ---- Harmonic mean of degrees (captures skew)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # ---- Assemble the invariant\n    inv = (size_term * density_term * clustering_term *\n           assort_term * triangle_term * degree_disp_term *\n           harmonic_term)\n\n    return inv\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    \"\"\"\n    A handcrafted estimate of the average shortest‑path length that blends\n    several global graph statistics without relying on a single metric.\n    The construction uses power‑laws, harmonic mean terms, and\n    interactions of size, degree dispersion, density, clustering,\n    assortativity and triangle abundance in a single expression.\n    \"\"\"\n    n           = s['n']\n    density     = s['density']\n\n    max_deg     = s['max_degree']\n    min_deg     = s['min_degree']\n    std_deg     = s['std_degree']\n    degrees     = s['degrees']\n\n    avg_clust   = s['avg_clustering']\n    assort      = s['degree_assortativity']\n    triangles   = s['num_triangles']\n\n    # Size–dispersion term (replacing the log with a power to stay in pure Python)\n    size_term = (n + 1) ** 0.5 * (1 + std_deg)\n\n    # Density penalty (lower density → larger value)\n    density_term = (1 + density) ** -0.5\n\n    # Clustering correction\n    clustering_term = 1 / (avg_clust + 1e-8)\n\n    # Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # Triangle shortcut influence\n    triangle_term = (triangles + 1) ** 0.3\n\n    # Degree‑range adjustment\n    degree_disp_term = (max_deg - min_deg + 1) ** 0.4\n\n    # Harmonic mean of degrees (captures skew)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # Assemble the invariant\n    inv = (size_term * density_term * clustering_term *\n           assort_term * triangle_term * degree_disp_term *\n           harmonic_term)\n\n    return inv", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A handcrafted estimate of the average shortest‑path length that blends\n    several global graph statistics without relying on a single metric.\n    The construction uses power‑laws, harmonic mean terms, and\n    interactions of size, degree dispersion, density, clustering,\n    assortativity and triangle abundance in a single expression.\n    \"\"\"\n    n           = s['n']\n    density     = s['density']\n\n    max_deg     = s['max_degree']\n    min_deg     = s['min_degree']\n    std_deg     = s['std_degree']\n    degrees     = s['degrees']\n\n    avg_clust   = s['avg_clustering']\n    assort      = s['degree_assortativity']\n    triangles   = s['num_triangles']\n\n    # Size–dispersion term (replacing the log with a power to stay in pure Python)\n    size_term = (n + 1) ** 0.5 * (1 + std_deg)\n\n    # Density penalty (lower density → larger value)\n    density_term = (1 + density) ** -0.5\n\n    # Clustering correction\n    clustering_term = 1 / (avg_clust + 1e-8)\n\n    # Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # Triangle shortcut influence\n    triangle_term = (triangles + 1) ** 0.3\n\n    # Degree‑range adjustment\n    degree_disp_term = (max_deg - min_deg + 1) ** 0.4\n\n    # Harmonic mean of degrees (captures skew)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # Assemble the invariant\n    inv = (size_term * density_term * clustering_term *\n           assort_term * triangle_term * degree_disp_term *\n           harmonic_term)\n\n    return inv", "spearman": -0.39496137403435094, "pearson": 0.2939732614459913, "rmse": 167273962.8441268, "mae": 33204696.60001463}}
{"timestamp": "2026-02-16T07:09:58.345637+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 3, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:10:23.594407+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:10:23.594971+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 2, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:10:44.388995+00:00", "event_type": "candidate_rejected", "payload": {"generation": 2, "island_id": 3, "population_idx": 3, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.239184", "model_name": "gpt-oss:20b", "train_signal": 0.23918367346938774}}
{"timestamp": "2026-02-16T07:10:44.389773+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 2, "island_id": 3, "population_idx": 3, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:11:27.630562+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g2_i3_p4_607464526", "generation": 2, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.47351740696278505, "fitness_mode": "correlation", "simplicity_score": 0.2476328118184562, "novelty_bonus": 0.38285163081094076, "total_score": 0.45429654946942005, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A creative heuristic estimate of the average shortest‑path length that\n    blends several topological cues from the feature dictionary while\n    avoiding direct reliance on any single metric.  The construction uses\n    multiplicative coupling of size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance and assortativity, but\n    in a form that is not directly expressible as a simple function of any\n    individual feature.\n    \"\"\"\n    # Extract needed quantities\n    n        = s['n']\n    m        = s['m']\n    density  = s['density']\n    max_deg  = s['max_degree']\n    min_deg  = s['min_degree']\n    std_deg  = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']            # sorted degree list\n\n    # ---- Size–density hybrid\n    size_term = (n ** 1.5) / (m + 1)\n\n    # ---- Density penalty (lower density → larger value)\n    dens_term = 1 / (density + 1e-6)\n\n    # ---- Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1\n    std_term  = 1 + (std_deg / (deg_range + 1))\n\n    # ---- Harmonic mean of degrees (captures skewness)\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)   # avoid division by zero\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # ---- Clustering–transitivity reduction\n    cluster_term = 1 / (clustering * trans + 1e-6)\n\n    # ---- Triangle shortcut effect\n    tri_term = 1 + (triangles ** 0.4)\n\n    # ---- Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # ---- Assemble the invariant\n    inv = size_term * dens_term * std_term * harmonic_term * assort_term\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Novel approximation of the average shortest path length that blends\n    several global properties of the graph:\n    * size (n)\n    * degree statistics (average, std. dev.)\n    * clustering coefficients\n    * degree assortativity\n    * density and triangle abundance\n\n    The formula purposely avoids using any single feature directly\n    and instead combines them multiplicatively and in non‑linear ways.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    density    = s['density']\n\n    # Ratio of actual to possible triangles\n    possible_tri = n * (n - 1) * (n - 2) / 6.0\n    tri_ratio = triangles / possible_tri if possible_tri > 0 else 0.0\n\n    # Build composite terms\n    # 1. Growth‑rate component (power‑scale)\n    term_log = (n + 1.0) ** (1.0 / (avg_deg + 1.0))\n\n    # 2. Clustering & assortativity interaction\n    term_cluster_assort = (1.0 + clustering) * (1.0 - assort * assort)\n\n    # 3. Degree dispersion factor\n    term_std = (1.0 + std_deg) ** 0.5\n\n    # 4. Triangle density damping\n    term_tri = (tri_ratio + 1.0) ** (-0.5)\n\n    # 5. Density smoothing\n    term_density = (density + 1e-4) ** 0.5\n\n    # Multiply all factors to obtain the invariant\n    return term_log * term_cluster_assort * term_std * term_tri * term_density\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.102697\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.239184\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A composite estimate of the average shortest‑path length based on\n    several global properties of the graph.  \n    The formula blends size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance, and assortativity\n    in a multiplicative fashion without relying on any single metric\n    directly.  All arithmetic is performed with built‑in Python\n    operations; no external libraries are imported.\n    \"\"\"\n    # Basic graph descriptors\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clustering = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']          # sorted degree list\n\n    # --- 1. Size–density hybrid term\n    #  n**1.5 grows with graph size, division by (m+1) penalises sparsity\n    size_term = n ** 1.5 / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-6)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1.0\n    std_term  = 1.0 + (std_deg / (deg_range + 1.0))\n\n    # --- 4. Harmonic mean of degrees\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    # Avoid division by zero\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1.0)\n\n    # --- 5. Clustering–transitivity reduction\n    cluster_term = 1.0 / (clustering * trans + 1e-6)\n\n    # --- 6. Triangle shortcut effect\n    tri_term = 1.0 + (triangles ** 0.4)\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * std_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A composite estimate of the average shortest‑path length based on\n    several global properties of the graph.  \n    The formula blends size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance, and assortativity\n    in a multiplicative fashion without relying on any single metric\n    directly.  All arithmetic is performed with built‑in Python\n    operations; no external libraries are imported.\n    \"\"\"\n    # Basic graph descriptors\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clustering = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']          # sorted degree list\n\n    # --- 1. Size–density hybrid term\n    #  n**1.5 grows with graph size, division by (m+1) penalises sparsity\n    size_term = n ** 1.5 / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-6)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1.0\n    std_term  = 1.0 + (std_deg / (deg_range + 1.0))\n\n    # --- 4. Harmonic mean of degrees\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    # Avoid division by zero\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1.0)\n\n    # --- 5. Clustering–transitivity reduction\n    cluster_term = 1.0 / (clustering * trans + 1e-6)\n\n    # --- 6. Triangle shortcut effect\n    tri_term = 1.0 + (triangles ** 0.4)\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * std_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.5798289957248932, "pearson": 0.8075195229575677, "rmse": 2.673887109375997, "mae": 2.5641545469858857}}
{"timestamp": "2026-02-16T07:11:27.633058+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 3, "model_name": "gpt-oss:20b", "best_val_score": 0.5358322776835298, "no_improve_count": 2}}
{"timestamp": "2026-02-16T07:12:35.011524+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i0_p0_517977295", "generation": 3, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.3113832942819225, "fitness_mode": "correlation", "simplicity_score": 0.12098537223269717, "novelty_bonus": 0.36920002446660805, "total_score": 0.24922903777215732, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a combination of\n    pre‑computed graph statistics.  The formula is inspired by the\n    characteristic path length of random graphs (log(n)/log(avg_degree))\n    and is adjusted for sparsity, clustering, and degree assortativity.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n\n    # Baseline estimate for a random graph\n    baseline = np.log(n) / (np.log(avg_deg + 1) + 1e-6)\n\n    # Adjust for sparsity: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density)\n\n    # Adjust for clustering: higher clustering can slightly reduce path length\n    clustering_adj = 1 - clustering\n\n    # Adjust for degree assortativity: assortative mixing can increase path length\n    assort_adj = 1 + assort\n\n    return baseline * density_adj * clustering_adj * assort_adj\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-6\n\n    # Baseline estimate based on graph size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustments for various structural properties\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    trans_adj = 1 - trans\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    # Clamp adjustments to avoid negative factors\n    density_adj = max(0, density_adj)\n    clustering_adj = max(0, clustering_adj)\n    trans_adj = max(0, trans_adj)\n    assort_adj = max(0, assort_adj)\n    hetero_adj = max(0, hetero_adj)\n    hub_adj = max(0, hub_adj)\n    triangle_adj = max(0, triangle_adj)\n\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            trans_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj)\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.197311\nbelow_train_threshold: train_signal=0.228427\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-6\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    trans_adj = 1 - trans\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    density_adj = density_adj if density_adj > 0 else 0\n    clustering_adj = clustering_adj if clustering_adj > 0 else 0\n    trans_adj = trans_adj if trans_adj > 0 else 0\n    assort_adj = assort_adj if assort_adj > 0 else 0\n    hetero_adj = hetero_adj if hetero_adj > 0 else 0\n    hub_adj = hub_adj if hub_adj > 0 else 0\n    triangle_adj = triangle_adj if triangle_adj > 0 else 0\n\n    return baseline * density_adj * clustering_adj * trans_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-6\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    trans_adj = 1 - trans\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    density_adj = density_adj if density_adj > 0 else 0\n    clustering_adj = clustering_adj if clustering_adj > 0 else 0\n    trans_adj = trans_adj if trans_adj > 0 else 0\n    assort_adj = assort_adj if assort_adj > 0 else 0\n    hetero_adj = hetero_adj if hetero_adj > 0 else 0\n    hub_adj = hub_adj if hub_adj > 0 else 0\n    triangle_adj = triangle_adj if triangle_adj > 0 else 0\n\n    return baseline * density_adj * clustering_adj * trans_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.22854391197127094, "pearson": 0.14977957518350002, "rmse": 2.4431821475946376, "mae": 2.2205734101941657}}
{"timestamp": "2026-02-16T07:17:32.474385+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.033894", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:17:32.475569+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.033894", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:18:01.119851+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:18:01.120607+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:18:25.208596+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:18:25.209555+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:19:12.462953+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i0_p2_50141294", "generation": 3, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.41628243275357435, "fitness_mode": "correlation", "simplicity_score": 0.12411672846261049, "novelty_bonus": 0.2864413706515475, "total_score": 0.2944649276307954, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a combination of\n    pre‑computed graph statistics.  The formula is inspired by the\n    characteristic path length of random graphs (log(n)/log(avg_degree))\n    and is adjusted for sparsity, clustering, and degree assortativity.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n\n    # Baseline estimate for a random graph\n    baseline = np.log(n) / (np.log(avg_deg + 1) + 1e-6)\n\n    # Adjust for sparsity: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density)\n\n    # Adjust for clustering: higher clustering can slightly reduce path length\n    clustering_adj = 1 - clustering\n\n    # Adjust for degree assortativity: assortative mixing can increase path length\n    assort_adj = 1 + assort\n\n    return baseline * density_adj * clustering_adj * assort_adj\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-6\n\n    # Baseline estimate based on graph size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustments for various structural properties\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    trans_adj = 1 - trans\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    # Clamp adjustments to avoid negative factors\n    density_adj = max(0, density_adj)\n    clustering_adj = max(0, clustering_adj)\n    trans_adj = max(0, trans_adj)\n    assort_adj = max(0, assort_adj)\n    hetero_adj = max(0, hetero_adj)\n    hub_adj = max(0, hub_adj)\n    triangle_adj = max(0, triangle_adj)\n\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            trans_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj)\nRecent failures:\nbelow_train_threshold: train_signal=0.228427\nbelow_novelty_threshold: novelty_bonus=0.033894\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from pre‑computed graph statistics.\n    The baseline is based on the characteristic path length of random graphs\n    (log(n)/log(avg_degree+1)).  Several structural adjustments are applied:\n    - Density (sparser graphs → longer paths)\n    - Clustering (higher clustering → shorter paths)\n    - Assortativity (assortative mixing → longer paths)\n    - Degree heterogeneity (more heterogeneous → shorter paths)\n    - Hub prominence (larger max degree → shorter paths)\n    - Triangle density (more triangles → shorter paths)\n\n    All adjustment factors are clamped to the [0, ∞) range to avoid negative\n    contributions.  The final estimate is the product of the baseline and\n    all adjustment factors.\n    \"\"\"\n    eps = 1e-12  # small constant to avoid division by zero\n\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    density    = s['density']\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    std_deg    = s['std_degree']\n    max_deg    = s['max_degree']\n    num_tri    = s['num_triangles']\n\n    # Baseline estimate (random graph characteristic path length)\n    baseline = np.log(n + 1) / (np.log(avg_deg + 1) + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density)                     # sparser → longer\n    clustering_adj = 1 - clustering                       # more clustering → shorter\n    assort_adj    = 1 + assort                            # assortative → longer\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # more heterogeneous → shorter\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # larger hub → shorter\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter\n\n    # Clamp to avoid negative factors\n    density_adj   = max(0.0, density_adj)\n    clustering_adj = max(0.0, clustering_adj)\n    assort_adj    = max(0.0, assort_adj)\n    hetero_adj    = max(0.0, hetero_adj)\n    hub_adj       = max(0.0, hub_adj)\n    triangle_adj  = max(0.0, triangle_adj)\n\n    # Combine all components\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    density_adj = max(0.0, density_adj)\n    clustering_adj = max(0.0, clustering_adj)\n    assort_adj = max(0.0, assort_adj)\n    hetero_adj = max(0.0, hetero_adj)\n    hub_adj = max(0.0, hub_adj)\n    triangle_adj = max(0.0, triangle_adj)\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    density_adj = max(0.0, density_adj)\n    clustering_adj = max(0.0, clustering_adj)\n    assort_adj = max(0.0, assort_adj)\n    hetero_adj = max(0.0, hetero_adj)\n    hub_adj = max(0.0, hub_adj)\n    triangle_adj = max(0.0, triangle_adj)\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.3674183414856181, "pearson": 0.3157256552928762, "rmse": 2.272654697253303, "mae": 2.059867686716989}}
{"timestamp": "2026-02-16T07:19:12.463791+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 0, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:19:52.314527+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:19:52.315774+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:20:15.016787+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:20:15.017558+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:20:48.749129+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i0_p4_344182665", "generation": 3, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.3113832942819225, "fitness_mode": "correlation", "simplicity_score": 0.12058885996962432, "novelty_bonus": 0.36920002446660805, "total_score": 0.24914973531954276, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a combination of\n    pre‑computed graph statistics.  The formula is inspired by the\n    characteristic path length of random graphs (log(n)/log(avg_degree))\n    and is adjusted for sparsity, clustering, and degree assortativity.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n\n    # Baseline estimate for a random graph\n    baseline = np.log(n) / (np.log(avg_deg + 1) + 1e-6)\n\n    # Adjust for sparsity: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density)\n\n    # Adjust for clustering: higher clustering can slightly reduce path length\n    clustering_adj = 1 - clustering\n\n    # Adjust for degree assortativity: assortative mixing can increase path length\n    assort_adj = 1 + assort\n\n    return baseline * density_adj * clustering_adj * assort_adj\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-6\n\n    # Baseline estimate based on graph size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustments for various structural properties\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    trans_adj = 1 - trans\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    # Clamp adjustments to avoid negative factors\n    density_adj = max(0, density_adj)\n    clustering_adj = max(0, clustering_adj)\n    trans_adj = max(0, trans_adj)\n    assort_adj = max(0, assort_adj)\n    hetero_adj = max(0, hetero_adj)\n    hub_adj = max(0, hub_adj)\n    triangle_adj = max(0, triangle_adj)\n\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            trans_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.033894\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    eps = 1e-6\n\n    # Baseline estimate based on size and average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - avg_clust\n    trans_adj = 1 - trans\n    assort_adj = 1 + assort\n    hetero_adj = 1 - (std_deg / (avg_deg + eps))\n    hub_adj = 1 - (max_deg / (n - 1 + eps))\n    triangle_adj = 1 - (num_tri / ((n * (n - 1) / 2) + eps))\n\n    # Clamp adjustments to avoid negative values\n    density_adj = density_adj if density_adj > 0 else 0\n    clustering_adj = clustering_adj if clustering_adj > 0 else 0\n    trans_adj = trans_adj if trans_adj > 0 else 0\n    assort_adj = assort_adj if assort_adj > 0 else 0\n    hetero_adj = hetero_adj if hetero_adj > 0 else 0\n    hub_adj = hub_adj if hub_adj > 0 else 0\n    triangle_adj = triangle_adj if triangle_adj > 0 else 0\n\n    return baseline * density_adj * clustering_adj * trans_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    eps = 1e-6\n\n    # Baseline estimate based on size and average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - avg_clust\n    trans_adj = 1 - trans\n    assort_adj = 1 + assort\n    hetero_adj = 1 - (std_deg / (avg_deg + eps))\n    hub_adj = 1 - (max_deg / (n - 1 + eps))\n    triangle_adj = 1 - (num_tri / ((n * (n - 1) / 2) + eps))\n\n    # Clamp adjustments to avoid negative values\n    density_adj = density_adj if density_adj > 0 else 0\n    clustering_adj = clustering_adj if clustering_adj > 0 else 0\n    trans_adj = trans_adj if trans_adj > 0 else 0\n    assort_adj = assort_adj if assort_adj > 0 else 0\n    hetero_adj = hetero_adj if hetero_adj > 0 else 0\n    hub_adj = hub_adj if hub_adj > 0 else 0\n    triangle_adj = triangle_adj if triangle_adj > 0 else 0\n\n    return baseline * density_adj * clustering_adj * trans_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.22854391197127094, "pearson": 0.14977957518350002, "rmse": 2.4431821475946376, "mae": 2.2205734101941657}}
{"timestamp": "2026-02-16T07:21:17.765814+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i1_p0_477327952", "generation": 3, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.31831932773109245, "fitness_mode": "correlation", "simplicity_score": 0.15683459302352104, "novelty_bonus": 0.37009675241881046, "total_score": 0.25265995093051236, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    degrees = s['degrees']\n\n    # Normalized sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        avg_deg * (1 + avg_clust) * (1 + transitivity)  # weighted degree–clustering term\n        + norm_sq                                         # normalized degree variance\n        + (num_triangles + 1) ** 0.5                      # square‑root of triangle count\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    # Extract basic features\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity'] or 0\n\n    # Compute a normalized sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    return (avg_deg * (1 + avg_clust) * (1 + transitivity) + norm_sq) / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        avg_deg * (1 + avg_clust) * (1 + transitivity)  # weighted degree–clustering term\n        + norm_sq                                         # normalised degree variance\n        + (num_triangles + 1) ** 0.5                      # square‑root of triangle count\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        avg_deg * (1 + avg_clust) * (1 + transitivity)  # weighted degree–clustering term\n        + norm_sq                                         # normalised degree variance\n        + (num_triangles + 1) ** 0.5                      # square‑root of triangle count\n    )\n\n    return numerator / denom", "spearman": 0.22052801320033003, "pearson": 0.12237501480131305, "rmse": 2.83619060805491, "mae": 2.664010140662185}}
{"timestamp": "2026-02-16T07:22:21.694422+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i1_p1_910450602", "generation": 3, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3677791116446578, "fitness_mode": "correlation", "simplicity_score": 0.15579513717588922, "novelty_bonus": 0.26912772819320474, "total_score": 0.28232860667465887, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    degrees = s['degrees']\n\n    # Normalized sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        avg_deg * (1 + avg_clust) * (1 + transitivity)  # weighted degree–clustering term\n        + norm_sq                                         # normalized degree variance\n        + (num_triangles + 1) ** 0.5                      # square‑root of triangle count\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    # Extract basic features\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity'] or 0\n\n    # Compute a normalized sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    return (avg_deg * (1 + avg_clust) * (1 + transitivity) + norm_sq) / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    std_degree = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + transitivity)\n        + norm_sq\n        + (num_triangles + 1) ** 0.5\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity) + std_degree\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    std_degree = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + transitivity)\n        + norm_sq\n        + (num_triangles + 1) ** 0.5\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity) + std_degree\n\n    return numerator / denom", "spearman": 0.34086252156303914, "pearson": 0.2420949949566655, "rmse": 2.617102420825988, "mae": 2.436794407538649}}
{"timestamp": "2026-02-16T07:22:44.219075+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i1_p2_329563809", "generation": 3, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3840096038415366, "fitness_mode": "correlation", "simplicity_score": 0.15561303871599397, "novelty_bonus": 0.24071686983447582, "total_score": 0.28068935248563637, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    degrees = s['degrees']\n\n    # Normalized sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        avg_deg * (1 + avg_clust) * (1 + transitivity)  # weighted degree–clustering term\n        + norm_sq                                         # normalized degree variance\n        + (num_triangles + 1) ** 0.5                      # square‑root of triangle count\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    # Extract basic features\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity'] or 0\n\n    # Compute a normalized sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    return (avg_deg * (1 + avg_clust) * (1 + transitivity) + norm_sq) / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combine several informative terms\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)  # degree‑clustering‑transitivity product\n        + norm_sq                                            # normalised degree variance\n        + (num_tri + 1) ** 0.5                                # square‑root of triangle count\n        + std_deg                                             # standard deviation of degrees\n    )\n\n    # Denominator: keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combine several informative terms\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)  # degree‑clustering‑transitivity product\n        + norm_sq                                            # normalised degree variance\n        + (num_tri + 1) ** 0.5                                # square‑root of triangle count\n        + std_deg                                             # standard deviation of degrees\n    )\n\n    # Denominator: keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.35470336758418963, "pearson": 0.2436807838829459, "rmse": 2.6073706550303557, "mae": 2.4266761160274593}}
{"timestamp": "2026-02-16T07:23:21.647794+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i1_p3_326933074", "generation": 3, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3677791116446578, "fitness_mode": "correlation", "simplicity_score": 0.15484699696103787, "novelty_bonus": 0.26912772819320474, "total_score": 0.2821389786316886, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    degrees = s['degrees']\n\n    # Normalized sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        avg_deg * (1 + avg_clust) * (1 + transitivity)  # weighted degree–clustering term\n        + norm_sq                                         # normalized degree variance\n        + (num_triangles + 1) ** 0.5                      # square‑root of triangle count\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    # Extract basic features\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity'] or 0\n\n    # Compute a normalized sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    return (avg_deg * (1 + avg_clust) * (1 + transitivity) + norm_sq) / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s.get('avg_degree', 0)\n    avg_clust = s.get('avg_clustering', 0)\n    transitivity = s.get('transitivity', 0)\n    max_deg = s.get('max_degree', 0)\n    density = s.get('density', 0)\n    num_triangles = s.get('num_triangles', 0)\n    degree_assortativity = s.get('degree_assortativity', 0)\n    std_degree = s.get('std_degree', 0)\n    degrees = s.get('degrees', [])\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2)) if n > 0 else 0\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + transitivity)  # weighted degree–clustering term\n        + norm_sq                                                     # normalised degree variance\n        + (num_triangles + 1) ** 0.5                                   # square‑root of triangle count\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity) + std_degree\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s.get('avg_degree', 0)\n    avg_clust = s.get('avg_clustering', 0)\n    transitivity = s.get('transitivity', 0)\n    max_deg = s.get('max_degree', 0)\n    density = s.get('density', 0)\n    num_triangles = s.get('num_triangles', 0)\n    degree_assortativity = s.get('degree_assortativity', 0)\n    std_degree = s.get('std_degree', 0)\n    degrees = s.get('degrees', [])\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2)) if n > 0 else 0\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + transitivity)  # weighted degree–clustering term\n        + norm_sq                                                     # normalised degree variance\n        + (num_triangles + 1) ** 0.5                                   # square‑root of triangle count\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity) + std_degree\n\n    return numerator / denom", "spearman": 0.34086252156303914, "pearson": 0.2420949949566655, "rmse": 2.617102420825988, "mae": 2.436794407538649}}
{"timestamp": "2026-02-16T07:23:41.924356+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i1_p4_216485681", "generation": 3, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3677791116446578, "fitness_mode": "correlation", "simplicity_score": 0.15579513717588922, "novelty_bonus": 0.26912772819320474, "total_score": 0.28232860667465887, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    degrees = s['degrees']\n\n    # Normalized sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        avg_deg * (1 + avg_clust) * (1 + transitivity)  # weighted degree–clustering term\n        + norm_sq                                         # normalized degree variance\n        + (num_triangles + 1) ** 0.5                      # square‑root of triangle count\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    # Extract basic features\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity'] or 0\n\n    # Compute a normalized sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity)\n\n    # Combine features into a single dimensionless quantity\n    return (avg_deg * (1 + avg_clust) * (1 + transitivity) + norm_sq) / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, and triangle information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    denom = 1 + m + density + num_tri + abs(deg_assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, and triangle information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    denom = 1 + m + density + num_tri + abs(deg_assort) + std_deg\n\n    return numerator / denom", "spearman": 0.34086252156303914, "pearson": 0.2420949949566655, "rmse": 2.617102420825988, "mae": 2.436794407538649}}
{"timestamp": "2026-02-16T07:24:22.997071+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:24:22.998070+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:24:58.199981+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.061529", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:24:58.200318+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 2, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:25:29.545595+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.044566", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:25:29.546081+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.044566", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:25:52.914549+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:25:52.915269+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:26:18.498206+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i2_p2_468659001", "generation": 3, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8082112845138055, "fitness_mode": "correlation", "simplicity_score": 0.1516496875009765, "novelty_bonus": 0.16597308238851172, "total_score": 0.5182603156780854, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.061529\nbelow_novelty_threshold: novelty_bonus=0.044566\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Rough estimate of the average shortest path length from basic graph statistics.\n\n    The formula is built in three parts:\n\n    1. **Base term** – larger graphs (higher n) and sparser graphs (lower average degree)\n       tend to have longer paths, so we start with n / (avg_degree + 1).\n\n    2. **Structural adjustments** – clustering and degree assortativity both tend to\n       increase path lengths, whereas a high degree dispersion (hubs) tends to\n       shorten them.  We therefore multiply by (1 + avg_clustering) and\n       (1 + |degree_assortativity|), and divide by (1 + std_degree).\n\n    3. **Density correction** – denser graphs have shorter paths, so we divide\n       by (1 + density).  This keeps the expression bounded and avoids\n       division by zero.\n\n    All operations are simple arithmetic, no imports, and the expression\n    remains fully deterministic for any dictionary `s` that contains the\n    required features.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    std_deg = s['std_degree']\n    assort = s['degree_assortativity']\n    density = s['density']\n\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Adjustments for clustering, assortativity, and degree heterogeneity\n    adjust = (1 + avg_clust) * (1 + abs(assort)) / (1 + std_deg)\n\n    # Density correction (denser → shorter paths)\n    density_factor = 1 / (1 + density)\n\n    return base * adjust * density_factor\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Rough estimate of the average shortest path length from basic graph statistics.\n\n    The formula is built in three parts:\n\n    1. **Base term** – larger graphs (higher n) and sparser graphs (lower average degree)\n       tend to have longer paths, so we start with n / (avg_degree + 1).\n\n    2. **Structural adjustments** – clustering and degree assortativity both tend to\n       increase path lengths, whereas a high degree dispersion (hubs) tends to\n       shorten them.  We therefore multiply by (1 + avg_clustering) and\n       (1 + |degree_assortativity|), and divide by (1 + std_degree).\n\n    3. **Density correction** – denser graphs have shorter paths, so we divide\n       by (1 + density).  This keeps the expression bounded and avoids\n       division by zero.\n\n    All operations are simple arithmetic, no imports, and the expression\n    remains fully deterministic for any dictionary `s` that contains the\n    required features.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    std_deg = s['std_degree']\n    assort = s['degree_assortativity']\n    density = s['density']\n\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Adjustments for clustering, assortativity, and degree heterogeneity\n    adjust = (1 + avg_clust) * (1 + abs(assort)) / (1 + std_deg)\n\n    # Density correction (denser → shorter paths)\n    density_factor = 1 / (1 + density)\n\n    return base * adjust * density_factor", "spearman": 0.8762769069226731, "pearson": 0.7682383912849832, "rmse": 2.258873088627178, "mae": 1.4009786137719413}}
{"timestamp": "2026-02-16T07:26:49.431947+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i2_p3_797016732", "generation": 3, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.812533013205282, "fitness_mode": "correlation", "simplicity_score": 0.13562991635142835, "novelty_bonus": 0.17424209182885086, "total_score": 0.5179690750805476, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.061529\nbelow_novelty_threshold: novelty_bonus=0.044566\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from simple graph statistics.\n    The estimate combines several structural features that influence path\n    lengths in a monotonic way:\n\n    * **Size vs. connectivity** – larger graphs or lower average degree\n      increase path lengths.  We use n / (avg_degree + 1) as a base term.\n    * **Clustering** – higher clustering tends to create local detours,\n      so we multiply by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually lengthens paths,\n      while negative assortativity shortens them.  We use 1 + |assortativity|\n      to keep the factor monotonic.\n    * **Degree heterogeneity** – a large standard deviation of degrees\n      (hubs) typically shortens paths.  We divide by (1 + std_degree).\n    * **Density** – in very dense graphs paths are shorter; we damp the\n      estimate by a factor that decreases with density but never goes\n      below 0.5.\n\n    All arithmetic is done with built‑in operators and functions only.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree'] + 1          # avoid division by zero\n    base = n / avg_deg\n\n    cluster_factor = 1 + s['avg_clustering']\n    assort_factor  = 1 + abs(s['degree_assortativity'])\n    hetero_factor  = 1 / (1 + s['std_degree'])\n\n    density = s['density']                  # 0 <= density <= 1\n    density_factor = max(0.5, 1 - 0.5 * density)\n\n    return base * cluster_factor * assort_factor * hetero_factor * density_factor\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from simple graph statistics.\n    The estimate combines several structural features that influence path\n    lengths in a monotonic way:\n\n    * **Size vs. connectivity** – larger graphs or lower average degree\n      increase path lengths.  We use n / (avg_degree + 1) as a base term.\n    * **Clustering** – higher clustering tends to create local detours,\n      so we multiply by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually lengthens paths,\n      while negative assortativity shortens them.  We use 1 + |assortativity|\n      to keep the factor monotonic.\n    * **Degree heterogeneity** – a large standard deviation of degrees\n      (hubs) typically shortens paths.  We divide by (1 + std_degree).\n    * **Density** – in very dense graphs paths are shorter; we damp the\n      estimate by a factor that decreases with density but never goes\n      below 0.5.\n\n    All arithmetic is done with built‑in operators and functions only.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree'] + 1          # avoid division by zero\n    base = n / avg_deg\n\n    cluster_factor = 1 + s['avg_clustering']\n    assort_factor  = 1 + abs(s['degree_assortativity'])\n    hetero_factor  = 1 / (1 + s['std_degree'])\n\n    density = s['density']                  # 0 <= density <= 1\n    density_factor = max(0.5, 1 - 0.5 * density)\n\n    return base * cluster_factor * assort_factor * hetero_factor * density_factor", "spearman": 0.8771409285232132, "pearson": 0.7704713663544236, "rmse": 2.364698906071306, "mae": 1.4770536646415473}}
{"timestamp": "2026-02-16T07:27:18.638276+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.053470", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:27:18.638746+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.053470", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:27:43.260286+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 2, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.094567", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:27:43.260626+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 2, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:28:21.153504+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.100656", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:28:21.154271+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.100656", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:28:59.470178+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i3_p0_354288808", "generation": 3, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.3430012004801921, "fitness_mode": "correlation", "simplicity_score": 0.24690961456866728, "novelty_bonus": 0.1742428418523828, "total_score": 0.31548737128434373, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A creative heuristic estimate of the average shortest‑path length that\n    blends several topological cues from the feature dictionary while\n    avoiding direct reliance on any single metric.  The construction uses\n    multiplicative coupling of size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance and assortativity, but\n    in a form that is not directly expressible as a simple function of any\n    individual feature.\n    \"\"\"\n    # Extract needed quantities\n    n        = s['n']\n    m        = s['m']\n    density  = s['density']\n    max_deg  = s['max_degree']\n    min_deg  = s['min_degree']\n    std_deg  = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']            # sorted degree list\n\n    # ---- Size–density hybrid\n    size_term = (n ** 1.5) / (m + 1)\n\n    # ---- Density penalty (lower density → larger value)\n    dens_term = 1 / (density + 1e-6)\n\n    # ---- Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1\n    std_term  = 1 + (std_deg / (deg_range + 1))\n\n    # ---- Harmonic mean of degrees (captures skewness)\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)   # avoid division by zero\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # ---- Clustering–transitivity reduction\n    cluster_term = 1 / (clustering * trans + 1e-6)\n\n    # ---- Triangle shortcut effect\n    tri_term = 1 + (triangles ** 0.4)\n\n    # ---- Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # ---- Assemble the invariant\n    inv = size_term * dens_term * std_term * harmonic_term * assort_term\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    A composite estimate of the average shortest‑path length based on\n    several global properties of the graph.  \n    The formula blends size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance, and assortativity\n    in a multiplicative fashion without relying on any single metric\n    directly.  All arithmetic is performed with built‑in Python\n    operations; no external libraries are imported.\n    \"\"\"\n    # Basic graph descriptors\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clustering = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']          # sorted degree list\n\n    # --- 1. Size–density hybrid term\n    #  n**1.5 grows with graph size, division by (m+1) penalises sparsity\n    size_term = n ** 1.5 / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-6)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1.0\n    std_term  = 1.0 + (std_deg / (deg_range + 1.0))\n\n    # --- 4. Harmonic mean of degrees\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    # Avoid division by zero\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1.0)\n\n    # --- 5. Clustering–transitivity reduction\n    cluster_term = 1.0 / (clustering * trans + 1e-6)\n\n    # --- 6. Triangle shortcut effect\n    tri_term = 1.0 + (triangles ** 0.4)\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * std_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    A handcrafted estimate of the average shortest‑path length that blends\n    several global graph statistics without relying on a single metric.\n    The construction uses power‑laws, harmonic mean terms, and\n    interactions of size, degree dispersion, density, clustering,\n    assortativity and triangle abundance in a single expression.\n    \"\"\"\n    n           = s['n']\n    density     = s['density']\n\n    max_deg     = s['max_degree']\n    min_deg     = s['min_degree']\n    std_deg     = s['std_degree']\n    degrees     = s['degrees']\n\n    avg_clust   = s['avg_clustering']\n    assort      = s['degree_assortativity']\n    triangles   = s['num_triangles']\n\n    # Size–dispersion term (replacing the log with a power to stay in pure Python)\n    size_term = (n + 1) ** 0.5 * (1 + std_deg)\n\n    # Density penalty (lower density → larger value)\n    density_term = (1 + density) ** -0.5\n\n    # Clustering correction\n    clustering_term = 1 / (avg_clust + 1e-8)\n\n    # Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # Triangle shortcut influence\n    triangle_term = (triangles + 1) ** 0.3\n\n    # Degree‑range adjustment\n    degree_disp_term = (max_deg - min_deg + 1) ** 0.4\n\n    # Harmonic mean of degrees (captures skew)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # Assemble the invariant\n    inv = (size_term * density_term * clustering_term *\n           assort_term * triangle_term * degree_disp_term *\n           harmonic_term)\n\n    return inv\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.102697\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.239184\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.100656\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    A handcrafted estimate of the average shortest‑path length that combines\n    several global graph statistics without relying on a single metric\n    directly.  All operations use built‑in Python functions and simple\n    arithmetic; no external libraries or graph traversal routines are\n    required.\n\n    The invariant multiplies a number of multiplicative terms that depend\n    on size, density, degree dispersion, harmonic mean of the degrees,\n    clustering & transitivity, triangle abundance, and degree assortativity.\n    The combination is intentionally non‑linear and uses exponents and\n    reciprocal forms to emphasize different structural aspects.\n    \"\"\"\n    # Basic values\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints (sorted)\n\n    # 1. Size – sparsity factor\n    size_factor = (n ** 0.5) / (m + 1.0)\n\n    # 2. Density penalty (lower density -> larger value)\n    density_factor = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion factor\n    deg_range = max_deg - min_deg + 1.0\n    degree_disp_factor = (deg_range + 1.0) / (std_deg + 1e-6)\n\n    # 4. Harmonic mean of degrees\n    harm_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harm_sum += 1.0 / float(d)\n    harmonic = n / (harm_sum + 1e-12)  # avoid division by zero\n    harmonic_factor = harmonic / (max_deg + 1.0)\n\n    # 5. Clustering–transitivity correction\n    cluster_factor = 1.0 / ((clust * trans) + 1e-6)\n\n    # 6. Triangle shortcut term\n    triangle_factor = (triangles + 1.0) ** 0.4\n\n    # 7. Assortativity boost\n    assort_factor = 1.0 + abs(assort)\n\n    # Combine all terms\n    inv = (size_factor * density_factor *\n           degree_disp_factor * harmonic_factor *\n           cluster_factor * triangle_factor * assort_factor)\n\n    return inv\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built entirely from\n    pre‑computed global graph statistics.  \n    The formula mixes several structural descriptors in a\n    non‑linear, multiplicative way so that no single metric dominates.\n    No graph traversal or external libraries are required.\n    \"\"\"\n    # Basic graph descriptors (converted to float for arithmetic)\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints (sorted)\n\n    # ------------------------------------------------------------------\n    # 1. Size / sparsity coupling (boosts large sparse graphs)\n    # ------------------------------------------------------------------\n    size_factor = pow(n + 1, 0.45) / pow(m + 1, 0.25)\n\n    # ------------------------------------------------------------------\n    # 2. Density penalty – lower density yields larger factor\n    # ------------------------------------------------------------------\n    density_factor = 1.0 / (density + 1e-6)\n\n    # ------------------------------------------------------------------\n    # 3. Degree‑dispersion term – captures spread of the degree spectrum\n    # ------------------------------------------------------------------\n    deg_range     = max_deg - min_deg + 1.0\n    degree_disp   = (deg_range + 1.0) / (std_deg + 1e-6)\n    degree_factor = pow(degree_disp, 0.30)\n\n    # ------------------------------------------------------------------\n    # 4. Harmonic mean of degrees – highlights presence of high‑degree hubs\n    # ------------------------------------------------------------------\n    harm_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harm_sum += 1.0 / float(d)\n    harmonic_mean = n / (harm_sum + 1e-12)\n    harmonic_factor = pow(harmonic_mean / (max_deg + 1.0), 0.55)\n\n    # ------------------------------------------------------------------\n    # 5. Clustering–transitivity coupling – discourages very high clustering\n    # ------------------------------------------------------------------\n    cluster_term = 1.0 / (pow(clust + trans + 1e-6, 0.65) + 1e-6)\n\n    # ------------------------------------------------------------------\n    # 6. Triangle shortcut effect – more triangles, shorter paths\n    # ------------------------------------------------------------------\n    triangle_factor = pow(triangles + 1.0, 0.28)\n\n    # ------------------------------------------------------------------\n    # 7. Assortativity boost – highly assortative networks tend to\n    #    have slightly longer average paths\n    # ------------------------------------------------------------------\n    assort_factor = 1.0 + abs(assort)\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant\n    # ------------------------------------------------------------------\n    inv = (size_factor * density_factor *\n           degree_factor * harmonic_factor *\n           cluster_term * triangle_factor * assort_factor)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built entirely from\n    pre‑computed global graph statistics.  \n    The formula mixes several structural descriptors in a\n    non‑linear, multiplicative way so that no single metric dominates.\n    No graph traversal or external libraries are required.\n    \"\"\"\n    # Basic graph descriptors (converted to float for arithmetic)\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints (sorted)\n\n    # ------------------------------------------------------------------\n    # 1. Size / sparsity coupling (boosts large sparse graphs)\n    # ------------------------------------------------------------------\n    size_factor = pow(n + 1, 0.45) / pow(m + 1, 0.25)\n\n    # ------------------------------------------------------------------\n    # 2. Density penalty – lower density yields larger factor\n    # ------------------------------------------------------------------\n    density_factor = 1.0 / (density + 1e-6)\n\n    # ------------------------------------------------------------------\n    # 3. Degree‑dispersion term – captures spread of the degree spectrum\n    # ------------------------------------------------------------------\n    deg_range     = max_deg - min_deg + 1.0\n    degree_disp   = (deg_range + 1.0) / (std_deg + 1e-6)\n    degree_factor = pow(degree_disp, 0.30)\n\n    # ------------------------------------------------------------------\n    # 4. Harmonic mean of degrees – highlights presence of high‑degree hubs\n    # ------------------------------------------------------------------\n    harm_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harm_sum += 1.0 / float(d)\n    harmonic_mean = n / (harm_sum + 1e-12)\n    harmonic_factor = pow(harmonic_mean / (max_deg + 1.0), 0.55)\n\n    # ------------------------------------------------------------------\n    # 5. Clustering–transitivity coupling – discourages very high clustering\n    # ------------------------------------------------------------------\n    cluster_term = 1.0 / (pow(clust + trans + 1e-6, 0.65) + 1e-6)\n\n    # ------------------------------------------------------------------\n    # 6. Triangle shortcut effect – more triangles, shorter paths\n    # ------------------------------------------------------------------\n    triangle_factor = pow(triangles + 1.0, 0.28)\n\n    # ------------------------------------------------------------------\n    # 7. Assortativity boost – highly assortative networks tend to\n    #    have slightly longer average paths\n    # ------------------------------------------------------------------\n    assort_factor = 1.0 + abs(assort)\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant\n    # ------------------------------------------------------------------\n    inv = (size_factor * density_factor *\n           degree_factor * harmonic_factor *\n           cluster_term * triangle_factor * assort_factor)\n\n    return inv", "spearman": 0.42766519162979083, "pearson": 0.30867099545031085, "rmse": 74307.39005491711, "mae": 13980.206941630639}}
{"timestamp": "2026-02-16T07:28:59.470727+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 3, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:29:34.246441+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i3_p1_420898889", "generation": 3, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.4368307322929172, "fitness_mode": "correlation", "simplicity_score": 0.2485443085389514, "novelty_bonus": 0.32597891747441965, "total_score": 0.41315992838490206, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A creative heuristic estimate of the average shortest‑path length that\n    blends several topological cues from the feature dictionary while\n    avoiding direct reliance on any single metric.  The construction uses\n    multiplicative coupling of size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance and assortativity, but\n    in a form that is not directly expressible as a simple function of any\n    individual feature.\n    \"\"\"\n    # Extract needed quantities\n    n        = s['n']\n    m        = s['m']\n    density  = s['density']\n    max_deg  = s['max_degree']\n    min_deg  = s['min_degree']\n    std_deg  = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']            # sorted degree list\n\n    # ---- Size–density hybrid\n    size_term = (n ** 1.5) / (m + 1)\n\n    # ---- Density penalty (lower density → larger value)\n    dens_term = 1 / (density + 1e-6)\n\n    # ---- Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1\n    std_term  = 1 + (std_deg / (deg_range + 1))\n\n    # ---- Harmonic mean of degrees (captures skewness)\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)   # avoid division by zero\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # ---- Clustering–transitivity reduction\n    cluster_term = 1 / (clustering * trans + 1e-6)\n\n    # ---- Triangle shortcut effect\n    tri_term = 1 + (triangles ** 0.4)\n\n    # ---- Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # ---- Assemble the invariant\n    inv = size_term * dens_term * std_term * harmonic_term * assort_term\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    A composite estimate of the average shortest‑path length based on\n    several global properties of the graph.  \n    The formula blends size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance, and assortativity\n    in a multiplicative fashion without relying on any single metric\n    directly.  All arithmetic is performed with built‑in Python\n    operations; no external libraries are imported.\n    \"\"\"\n    # Basic graph descriptors\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clustering = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']          # sorted degree list\n\n    # --- 1. Size–density hybrid term\n    #  n**1.5 grows with graph size, division by (m+1) penalises sparsity\n    size_term = n ** 1.5 / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-6)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1.0\n    std_term  = 1.0 + (std_deg / (deg_range + 1.0))\n\n    # --- 4. Harmonic mean of degrees\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    # Avoid division by zero\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1.0)\n\n    # --- 5. Clustering–transitivity reduction\n    cluster_term = 1.0 / (clustering * trans + 1e-6)\n\n    # --- 6. Triangle shortcut effect\n    tri_term = 1.0 + (triangles ** 0.4)\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * std_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    A handcrafted estimate of the average shortest‑path length that blends\n    several global graph statistics without relying on a single metric.\n    The construction uses power‑laws, harmonic mean terms, and\n    interactions of size, degree dispersion, density, clustering,\n    assortativity and triangle abundance in a single expression.\n    \"\"\"\n    n           = s['n']\n    density     = s['density']\n\n    max_deg     = s['max_degree']\n    min_deg     = s['min_degree']\n    std_deg     = s['std_degree']\n    degrees     = s['degrees']\n\n    avg_clust   = s['avg_clustering']\n    assort      = s['degree_assortativity']\n    triangles   = s['num_triangles']\n\n    # Size–dispersion term (replacing the log with a power to stay in pure Python)\n    size_term = (n + 1) ** 0.5 * (1 + std_deg)\n\n    # Density penalty (lower density → larger value)\n    density_term = (1 + density) ** -0.5\n\n    # Clustering correction\n    clustering_term = 1 / (avg_clust + 1e-8)\n\n    # Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # Triangle shortcut influence\n    triangle_term = (triangles + 1) ** 0.3\n\n    # Degree‑range adjustment\n    degree_disp_term = (max_deg - min_deg + 1) ** 0.4\n\n    # Harmonic mean of degrees (captures skew)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # Assemble the invariant\n    inv = (size_term * density_term * clustering_term *\n           assort_term * triangle_term * degree_disp_term *\n           harmonic_term)\n\n    return inv\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.239184\nbelow_novelty_threshold: novelty_bonus=0.100656\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    An inventive, composite estimate of the average shortest‑path length\n    built solely from the global descriptors supplied in ``s``.\n    The formula mixes size, density, degree dispersion, harmonic degree,\n    clustering, triangles, and assortativity in a multiplicative structure.\n    No external libraries or shortest‑path computation are used.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # --- Size–density hybrid term\n    size_term = (n ** 1.2) / (m + 1)\n\n    # --- Density penalty (sparser → larger value)\n    dens_term = 1.0 / (density + 1e-6)\n\n    # --- Degree‑dispersion influence\n    degree_disp = max_deg - min_deg + 1\n    std_term = 1.0 + (std_deg / (degree_disp + 1))\n\n    # --- Harmonic mean of degrees\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # --- Clustering–transitivity reduction\n    cluster_term = 1.0 / (avg_clust * trans + 1e-6)\n\n    # --- Triangle shortcut influence\n    tri_term = 1.0 + (triangles ** 0.3)\n\n    # --- Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- Assemble the invariant\n    inv = size_term * dens_term * std_term * harmonic_term * assort_term\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    An inventive, composite estimate of the average shortest‑path length\n    built solely from the global descriptors supplied in ``s``.\n    The formula mixes size, density, degree dispersion, harmonic degree,\n    clustering, triangles, and assortativity in a multiplicative structure.\n    No external libraries or shortest‑path computation are used.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    degrees = s['degrees']\n\n    # --- Size–density hybrid term\n    size_term = (n ** 1.2) / (m + 1)\n\n    # --- Density penalty (sparser → larger value)\n    dens_term = 1.0 / (density + 1e-6)\n\n    # --- Degree‑dispersion influence\n    degree_disp = max_deg - min_deg + 1\n    std_term = 1.0 + (std_deg / (degree_disp + 1))\n\n    # --- Harmonic mean of degrees\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # --- Clustering–transitivity reduction\n    cluster_term = 1.0 / (avg_clust * trans + 1e-6)\n\n    # --- Triangle shortcut influence\n    tri_term = 1.0 + (triangles ** 0.3)\n\n    # --- Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- Assemble the invariant\n    inv = size_term * dens_term * std_term * harmonic_term * assort_term\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.5313147828695718, "pearson": 0.7954752941562746, "rmse": 2.8020449024428826, "mae": 2.6603355687924077}}
{"timestamp": "2026-02-16T07:29:54.579446+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:29:54.580394+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 3, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:30:16.157767+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 3, "population_idx": 2, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.001969", "model_name": "gpt-oss:20b", "train_signal": 0.0019687875150060023}}
{"timestamp": "2026-02-16T07:30:16.158686+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 3, "island_id": 3, "population_idx": 2, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:30:47.504314+00:00", "event_type": "candidate_rejected", "payload": {"generation": 3, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.296134", "model_name": "gpt-oss:20b", "train_signal": 0.2961344537815126}}
{"timestamp": "2026-02-16T07:31:18.346072+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g3_i3_p4_640731440", "generation": 3, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6675150060024009, "fitness_mode": "correlation", "simplicity_score": 0.24795247661365372, "novelty_bonus": 0.38647566189154714, "total_score": 0.5050074307461163, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    A creative heuristic estimate of the average shortest‑path length that\n    blends several topological cues from the feature dictionary while\n    avoiding direct reliance on any single metric.  The construction uses\n    multiplicative coupling of size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance and assortativity, but\n    in a form that is not directly expressible as a simple function of any\n    individual feature.\n    \"\"\"\n    # Extract needed quantities\n    n        = s['n']\n    m        = s['m']\n    density  = s['density']\n    max_deg  = s['max_degree']\n    min_deg  = s['min_degree']\n    std_deg  = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']            # sorted degree list\n\n    # ---- Size–density hybrid\n    size_term = (n ** 1.5) / (m + 1)\n\n    # ---- Density penalty (lower density → larger value)\n    dens_term = 1 / (density + 1e-6)\n\n    # ---- Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1\n    std_term  = 1 + (std_deg / (deg_range + 1))\n\n    # ---- Harmonic mean of degrees (captures skewness)\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)   # avoid division by zero\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # ---- Clustering–transitivity reduction\n    cluster_term = 1 / (clustering * trans + 1e-6)\n\n    # ---- Triangle shortcut effect\n    tri_term = 1 + (triangles ** 0.4)\n\n    # ---- Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # ---- Assemble the invariant\n    inv = size_term * dens_term * std_term * harmonic_term * assort_term\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    A composite estimate of the average shortest‑path length based on\n    several global properties of the graph.  \n    The formula blends size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance, and assortativity\n    in a multiplicative fashion without relying on any single metric\n    directly.  All arithmetic is performed with built‑in Python\n    operations; no external libraries are imported.\n    \"\"\"\n    # Basic graph descriptors\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clustering = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']          # sorted degree list\n\n    # --- 1. Size–density hybrid term\n    #  n**1.5 grows with graph size, division by (m+1) penalises sparsity\n    size_term = n ** 1.5 / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-6)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1.0\n    std_term  = 1.0 + (std_deg / (deg_range + 1.0))\n\n    # --- 4. Harmonic mean of degrees\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    # Avoid division by zero\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1.0)\n\n    # --- 5. Clustering–transitivity reduction\n    cluster_term = 1.0 / (clustering * trans + 1e-6)\n\n    # --- 6. Triangle shortcut effect\n    tri_term = 1.0 + (triangles ** 0.4)\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * std_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    A handcrafted estimate of the average shortest‑path length that blends\n    several global graph statistics without relying on a single metric.\n    The construction uses power‑laws, harmonic mean terms, and\n    interactions of size, degree dispersion, density, clustering,\n    assortativity and triangle abundance in a single expression.\n    \"\"\"\n    n           = s['n']\n    density     = s['density']\n\n    max_deg     = s['max_degree']\n    min_deg     = s['min_degree']\n    std_deg     = s['std_degree']\n    degrees     = s['degrees']\n\n    avg_clust   = s['avg_clustering']\n    assort      = s['degree_assortativity']\n    triangles   = s['num_triangles']\n\n    # Size–dispersion term (replacing the log with a power to stay in pure Python)\n    size_term = (n + 1) ** 0.5 * (1 + std_deg)\n\n    # Density penalty (lower density → larger value)\n    density_term = (1 + density) ** -0.5\n\n    # Clustering correction\n    clustering_term = 1 / (avg_clust + 1e-8)\n\n    # Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # Triangle shortcut influence\n    triangle_term = (triangles + 1) ** 0.3\n\n    # Degree‑range adjustment\n    degree_disp_term = (max_deg - min_deg + 1) ** 0.4\n\n    # Harmonic mean of degrees (captures skew)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # Assemble the invariant\n    inv = (size_term * density_term * clustering_term *\n           assort_term * triangle_term * degree_disp_term *\n           harmonic_term)\n\n    return inv\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.001969\nbelow_train_threshold: train_signal=0.296134\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv", "spearman": 0.6789484737118427, "pearson": 0.7725645896717948, "rmse": 5.66149177376175, "mae": 4.016017428976754}}
{"timestamp": "2026-02-16T07:31:18.348394+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 4, "model_name": "gpt-oss:20b", "best_val_score": 0.5358322776835298, "no_improve_count": 3}}
{"timestamp": "2026-02-16T07:31:55.275256+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:31:55.277088+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:32:58.267607+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i0_p0_103183108", "generation": 4, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.35855942376950783, "fitness_mode": "correlation", "simplicity_score": 0.12352402374819375, "novelty_bonus": 0.25613341117065924, "total_score": 0.3311308177505778, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a combination of\n    pre‑computed graph statistics.  The formula is inspired by the\n    characteristic path length of random graphs (log(n)/log(avg_degree))\n    and is adjusted for sparsity, clustering, and degree assortativity.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n\n    # Baseline estimate for a random graph\n    baseline = np.log(n) / (np.log(avg_deg + 1) + 1e-6)\n\n    # Adjust for sparsity: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density)\n\n    # Adjust for clustering: higher clustering can slightly reduce path length\n    clustering_adj = 1 - clustering\n\n    # Adjust for degree assortativity: assortative mixing can increase path length\n    assort_adj = 1 + assort\n\n    return baseline * density_adj * clustering_adj * assort_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    density_adj = max(0.0, density_adj)\n    clustering_adj = max(0.0, clustering_adj)\n    assort_adj = max(0.0, assort_adj)\n    hetero_adj = max(0.0, hetero_adj)\n    hub_adj = max(0.0, hub_adj)\n    triangle_adj = max(0.0, triangle_adj)\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-6\n\n    # Baseline estimate based on graph size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustments for various structural properties\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    trans_adj = 1 - trans\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    # Clamp adjustments to avoid negative factors\n    density_adj = max(0, density_adj)\n    clustering_adj = max(0, clustering_adj)\n    trans_adj = max(0, trans_adj)\n    assort_adj = max(0, assort_adj)\n    hetero_adj = max(0, hetero_adj)\n    hub_adj = max(0, hub_adj)\n    triangle_adj = max(0, triangle_adj)\n\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            trans_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.033894\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: code must define exactly one function named `new_invariant`\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = n / (avg_deg + 1)\n\n    # Adjustment factors for structural properties\n    density_adj = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                    # higher clustering → shorter paths\n    assort_adj = 1 + assort                              # assortative mixing → longer paths\n    hetero_adj = 1 - std_deg / (avg_deg + 1)             # degree heterogeneity → shorter paths\n    hub_adj = 1 - max_deg / (n - 1 + 1e-12)              # presence of hubs → shorter paths\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + 1e-12)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    def clamp(x, low=0.1, high=10):\n        return low if x < low else high if x > high else x\n\n    density_adj = clamp(density_adj)\n    clustering_adj = clamp(clustering_adj)\n    assort_adj = clamp(assort_adj)\n    hetero_adj = clamp(hetero_adj)\n    hub_adj = clamp(hub_adj)\n    triangle_adj = clamp(triangle_adj)\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-12\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = n / (avg_deg + 1)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + 1)           # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-12\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = n / (avg_deg + 1)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + 1)           # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.45917197929948256, "pearson": 0.36426452877758775, "rmse": 4.763016451096367, "mae": 3.3271017041369246}}
{"timestamp": "2026-02-16T07:32:58.268294+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 0, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:33:32.431672+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i0_p1_587715346", "generation": 4, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.3113832942819225, "fitness_mode": "correlation", "simplicity_score": 0.12152558990640369, "novelty_bonus": 0.36920002446660805, "total_score": 0.24933708130689863, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a combination of\n    pre‑computed graph statistics.  The formula is inspired by the\n    characteristic path length of random graphs (log(n)/log(avg_degree))\n    and is adjusted for sparsity, clustering, and degree assortativity.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n\n    # Baseline estimate for a random graph\n    baseline = np.log(n) / (np.log(avg_deg + 1) + 1e-6)\n\n    # Adjust for sparsity: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density)\n\n    # Adjust for clustering: higher clustering can slightly reduce path length\n    clustering_adj = 1 - clustering\n\n    # Adjust for degree assortativity: assortative mixing can increase path length\n    assort_adj = 1 + assort\n\n    return baseline * density_adj * clustering_adj * assort_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    density_adj = max(0.0, density_adj)\n    clustering_adj = max(0.0, clustering_adj)\n    assort_adj = max(0.0, assort_adj)\n    hetero_adj = max(0.0, hetero_adj)\n    hub_adj = max(0.0, hub_adj)\n    triangle_adj = max(0.0, triangle_adj)\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-6\n\n    # Baseline estimate based on graph size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustments for various structural properties\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    trans_adj = 1 - trans\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    # Clamp adjustments to avoid negative factors\n    density_adj = max(0, density_adj)\n    clustering_adj = max(0, clustering_adj)\n    trans_adj = max(0, trans_adj)\n    assort_adj = max(0, assort_adj)\n    hetero_adj = max(0, hetero_adj)\n    hub_adj = max(0, hub_adj)\n    triangle_adj = max(0, triangle_adj)\n\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            trans_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.033894\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula is a product of a baseline term and several adjustment factors\n    that capture sparsity, clustering, assortativity, degree heterogeneity,\n    hub prominence, and triangle density.  All operations use only built‑in\n    Python functions; no external imports are required.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: larger graphs and lower average degree give longer paths\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1.0 + (1.0 - density)          # sparser → longer paths\n    clustering_adj = 1.0 - clustering              # higher clustering → shorter paths\n    trans_adj     = 1.0 - trans                    # higher transitivity → shorter paths\n    assort_adj    = 1.0 + assort                    # assortative mixing → longer paths\n    hetero_adj    = 1.0 - std_deg / (avg_deg + eps) # more heterogeneous → shorter paths\n    hub_adj       = 1.0 - max_deg / (n - 1 + eps)   # prominent hubs → shorter paths\n    triangle_adj  = 1.0 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp each factor to a non‑negative value\n    density_adj   = max(0.0, density_adj)\n    clustering_adj = max(0.0, clustering_adj)\n    trans_adj     = max(0.0, trans_adj)\n    assort_adj    = max(0.0, assort_adj)\n    hetero_adj    = max(0.0, hetero_adj)\n    hub_adj       = max(0.0, hub_adj)\n    triangle_adj  = max(0.0, triangle_adj)\n\n    # Final estimate\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            trans_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula is a product of a baseline term and several adjustment factors\n    that capture sparsity, clustering, assortativity, degree heterogeneity,\n    hub prominence, and triangle density.  All operations use only built‑in\n    Python functions; no external imports are required.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: larger graphs and lower average degree give longer paths\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1.0 + (1.0 - density)          # sparser → longer paths\n    clustering_adj = 1.0 - clustering              # higher clustering → shorter paths\n    trans_adj     = 1.0 - trans                    # higher transitivity → shorter paths\n    assort_adj    = 1.0 + assort                    # assortative mixing → longer paths\n    hetero_adj    = 1.0 - std_deg / (avg_deg + eps) # more heterogeneous → shorter paths\n    hub_adj       = 1.0 - max_deg / (n - 1 + eps)   # prominent hubs → shorter paths\n    triangle_adj  = 1.0 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp each factor to a non‑negative value\n    density_adj   = max(0.0, density_adj)\n    clustering_adj = max(0.0, clustering_adj)\n    trans_adj     = max(0.0, trans_adj)\n    assort_adj    = max(0.0, assort_adj)\n    hetero_adj    = max(0.0, hetero_adj)\n    hub_adj       = max(0.0, hub_adj)\n    triangle_adj  = max(0.0, triangle_adj)\n\n    # Final estimate\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            trans_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj)", "spearman": 0.22854391197127094, "pearson": 0.14977958396248855, "rmse": 2.443182125811021, "mae": 2.2205733785512054}}
{"timestamp": "2026-02-16T07:34:05.092110+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i0_p2_369070618", "generation": 4, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.3113832942819225, "fitness_mode": "correlation", "simplicity_score": 0.12152558990640369, "novelty_bonus": 0.36920002446660805, "total_score": 0.24933708130689863, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a combination of\n    pre‑computed graph statistics.  The formula is inspired by the\n    characteristic path length of random graphs (log(n)/log(avg_degree))\n    and is adjusted for sparsity, clustering, and degree assortativity.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n\n    # Baseline estimate for a random graph\n    baseline = np.log(n) / (np.log(avg_deg + 1) + 1e-6)\n\n    # Adjust for sparsity: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density)\n\n    # Adjust for clustering: higher clustering can slightly reduce path length\n    clustering_adj = 1 - clustering\n\n    # Adjust for degree assortativity: assortative mixing can increase path length\n    assort_adj = 1 + assort\n\n    return baseline * density_adj * clustering_adj * assort_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    density_adj = max(0.0, density_adj)\n    clustering_adj = max(0.0, clustering_adj)\n    assort_adj = max(0.0, assort_adj)\n    hetero_adj = max(0.0, hetero_adj)\n    hub_adj = max(0.0, hub_adj)\n    triangle_adj = max(0.0, triangle_adj)\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-6\n\n    # Baseline estimate based on graph size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustments for various structural properties\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    trans_adj = 1 - trans\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    # Clamp adjustments to avoid negative factors\n    density_adj = max(0, density_adj)\n    clustering_adj = max(0, clustering_adj)\n    trans_adj = max(0, trans_adj)\n    assort_adj = max(0, assort_adj)\n    hetero_adj = max(0, hetero_adj)\n    hub_adj = max(0, hub_adj)\n    triangle_adj = max(0, triangle_adj)\n\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            trans_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.033894\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from pre‑computed graph statistics.\n    The formula is a multiplicative combination of a baseline estimate and\n    adjustment factors for density, clustering, transitivity, assortativity,\n    degree heterogeneity, hub dominance, and triangle density.\n    \"\"\"\n    eps = 1e-6\n\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    density    = s['density']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    std_deg    = s['std_degree']\n    max_deg    = s['max_degree']\n    num_tri    = s['num_triangles']\n\n    # Baseline estimate: grows with sqrt(n) and shrinks with avg degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density)          # sparser graphs → longer paths\n    clustering_adj= 1 - clustering             # higher clustering → slightly shorter paths\n    trans_adj     = 1 - trans                  # higher transitivity → shorter paths\n    assort_adj    = 1 + assort                  # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)   # more heterogeneous → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)     # dominant hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustments to avoid negative factors\n    density_adj   = max(0.0, density_adj)\n    clustering_adj= max(0.0, clustering_adj)\n    trans_adj     = max(0.0, trans_adj)\n    assort_adj    = max(0.0, assort_adj)\n    hetero_adj    = max(0.0, hetero_adj)\n    hub_adj       = max(0.0, hub_adj)\n    triangle_adj  = max(0.0, triangle_adj)\n\n    # Combine all components multiplicatively\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            trans_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from pre‑computed graph statistics.\n    The formula is a multiplicative combination of a baseline estimate and\n    adjustment factors for density, clustering, transitivity, assortativity,\n    degree heterogeneity, hub dominance, and triangle density.\n    \"\"\"\n    eps = 1e-6\n\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    density    = s['density']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    std_deg    = s['std_degree']\n    max_deg    = s['max_degree']\n    num_tri    = s['num_triangles']\n\n    # Baseline estimate: grows with sqrt(n) and shrinks with avg degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density)          # sparser graphs → longer paths\n    clustering_adj= 1 - clustering             # higher clustering → slightly shorter paths\n    trans_adj     = 1 - trans                  # higher transitivity → shorter paths\n    assort_adj    = 1 + assort                  # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)   # more heterogeneous → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)     # dominant hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustments to avoid negative factors\n    density_adj   = max(0.0, density_adj)\n    clustering_adj= max(0.0, clustering_adj)\n    trans_adj     = max(0.0, trans_adj)\n    assort_adj    = max(0.0, assort_adj)\n    hetero_adj    = max(0.0, hetero_adj)\n    hub_adj       = max(0.0, hub_adj)\n    triangle_adj  = max(0.0, triangle_adj)\n\n    # Combine all components multiplicatively\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            trans_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj)", "spearman": 0.22854391197127094, "pearson": 0.14977957518350002, "rmse": 2.4431821475946376, "mae": 2.2205734101941657}}
{"timestamp": "2026-02-16T07:36:42.493653+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:36:42.495367+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:37:00.192191+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:37:00.192841+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:37:32.336221+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i0_p4_593679861", "generation": 4, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.41628243275357435, "fitness_mode": "correlation", "simplicity_score": 0.12411672846261049, "novelty_bonus": 0.2864413706515475, "total_score": 0.2944649276307954, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a combination of\n    pre‑computed graph statistics.  The formula is inspired by the\n    characteristic path length of random graphs (log(n)/log(avg_degree))\n    and is adjusted for sparsity, clustering, and degree assortativity.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n\n    # Baseline estimate for a random graph\n    baseline = np.log(n) / (np.log(avg_deg + 1) + 1e-6)\n\n    # Adjust for sparsity: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density)\n\n    # Adjust for clustering: higher clustering can slightly reduce path length\n    clustering_adj = 1 - clustering\n\n    # Adjust for degree assortativity: assortative mixing can increase path length\n    assort_adj = 1 + assort\n\n    return baseline * density_adj * clustering_adj * assort_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    density_adj = max(0.0, density_adj)\n    clustering_adj = max(0.0, clustering_adj)\n    assort_adj = max(0.0, assort_adj)\n    hetero_adj = max(0.0, hetero_adj)\n    hub_adj = max(0.0, hub_adj)\n    triangle_adj = max(0.0, triangle_adj)\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-6\n\n    # Baseline estimate based on graph size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustments for various structural properties\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    trans_adj = 1 - trans\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    # Clamp adjustments to avoid negative factors\n    density_adj = max(0, density_adj)\n    clustering_adj = max(0, clustering_adj)\n    trans_adj = max(0, trans_adj)\n    assort_adj = max(0, assort_adj)\n    hetero_adj = max(0, hetero_adj)\n    hub_adj = max(0, hub_adj)\n    triangle_adj = max(0, triangle_adj)\n\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            trans_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj)\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.033894\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-12\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Structural adjustments\n    density_adj   = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    assort_adj    = 1 + assort\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)\n    hub_adj       = 1 - max_deg / (n - 1 + eps)\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    # Clamp to avoid negative factors\n    density_adj   = max(0.0, density_adj)\n    clustering_adj = max(0.0, clustering_adj)\n    assort_adj    = max(0.0, assort_adj)\n    hetero_adj    = max(0.0, hetero_adj)\n    hub_adj       = max(0.0, hub_adj)\n    triangle_adj  = max(0.0, triangle_adj)\n\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj)\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-12\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Structural adjustments\n    density_adj   = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    assort_adj    = 1 + assort\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)\n    hub_adj       = 1 - max_deg / (n - 1 + eps)\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    # Clamp to avoid negative factors\n    density_adj   = max(0.0, density_adj)\n    clustering_adj = max(0.0, clustering_adj)\n    assort_adj    = max(0.0, assort_adj)\n    hetero_adj    = max(0.0, hetero_adj)\n    hub_adj       = max(0.0, hub_adj)\n    triangle_adj  = max(0.0, triangle_adj)\n\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj)", "spearman": 0.3674183414856181, "pearson": 0.3157256552928762, "rmse": 2.272654697253303, "mae": 2.059867686716989}}
{"timestamp": "2026-02-16T07:37:54.717888+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p0_914844426", "generation": 4, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3677791116446578, "fitness_mode": "correlation", "simplicity_score": 0.15579513717588922, "novelty_bonus": 0.26912772819320474, "total_score": 0.28232860667465887, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    std_degree = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + transitivity)\n        + norm_sq\n        + (num_triangles + 1) ** 0.5\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity) + std_degree\n\n    return numerator / denom\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, and triangle information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    denom = 1 + m + density + num_tri + abs(deg_assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, and triangle information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    denom = 1 + m + density + num_tri + abs(deg_assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, and triangle information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    denom = 1 + m + density + num_tri + abs(deg_assort) + std_deg\n\n    return numerator / denom", "spearman": 0.34086252156303914, "pearson": 0.2420949949566655, "rmse": 2.617102420825988, "mae": 2.436794407538649}}
{"timestamp": "2026-02-16T07:38:21.862435+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p1_224901709", "generation": 4, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3734453781512605, "fitness_mode": "correlation", "simplicity_score": 0.15505154971632262, "novelty_bonus": 0.26412060301507523, "total_score": 0.2847031022630725, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    std_degree = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + transitivity)\n        + norm_sq\n        + (num_triangles + 1) ** 0.5\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity) + std_degree\n\n    return numerator / denom\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, and triangle information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    denom = 1 + m + density + num_tri + abs(deg_assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.34891322283057075, "pearson": 0.2670258388968786, "rmse": 2.620904785622736, "mae": 2.441546239297168}}
{"timestamp": "2026-02-16T07:38:48.322413+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p2_389597154", "generation": 4, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.36672268907563016, "fitness_mode": "correlation", "simplicity_score": 0.15517721393384742, "novelty_bonus": 0.2585074626865671, "total_score": 0.27580211195349863, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    std_degree = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + transitivity)\n        + norm_sq\n        + (num_triangles + 1) ** 0.5\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity) + std_degree\n\n    return numerator / denom\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, and triangle information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    denom = 1 + m + density + num_tri + abs(deg_assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n    min_deg = s.get('min_degree', 0)\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and minimum degree\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + min_deg\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    denom = 1 + m + density + num_tri + abs(deg_assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n    min_deg = s.get('min_degree', 0)\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and minimum degree\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + min_deg\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    denom = 1 + m + density + num_tri + abs(deg_assort) + std_deg\n\n    return numerator / denom", "spearman": 0.33442886072151806, "pearson": 0.23132136199612222, "rmse": 2.608264795772975, "mae": 2.426903753021496}}
{"timestamp": "2026-02-16T07:39:43.293733+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p3_400045390", "generation": 4, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.37690276110444176, "fitness_mode": "correlation", "simplicity_score": 0.15492810024111026, "novelty_bonus": 0.24566414160354, "total_score": 0.2810157708019909, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    std_degree = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + transitivity)\n        + norm_sq\n        + (num_triangles + 1) ** 0.5\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity) + std_degree\n\n    return numerator / denom\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, and triangle information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    denom = 1 + m + density + num_tri + abs(deg_assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree spread\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    denom = 1 + m + density + num_tri + abs(deg_assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree spread\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    denom = 1 + m + density + num_tri + abs(deg_assort) + std_deg\n\n    return numerator / denom", "spearman": 0.3526618165454137, "pearson": 0.24032699702810484, "rmse": 2.6090588167953124, "mae": 2.4283507338385943}}
{"timestamp": "2026-02-16T07:40:04.578909+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i1_p4_187335858", "generation": 4, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3720048019207683, "fitness_mode": "correlation", "simplicity_score": 0.15445512034840891, "novelty_bonus": 0.26307807695192376, "total_score": 0.28075047055584396, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    std_degree = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + transitivity)\n        + norm_sq\n        + (num_triangles + 1) ** 0.5\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity) + std_degree\n\n    return numerator / denom\n\ndef new_invariant(s):\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, and triangle information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    denom = 1 + m + density + num_tri + abs(deg_assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A dimensionless graph invariant that blends size, degree, clustering,\n    triangle, and assortativity information while keeping the value bounded.\n    \"\"\"\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s.get('min_degree', 0)\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and minimum degree\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1) ** 0.5\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A dimensionless graph invariant that blends size, degree, clustering,\n    triangle, and assortativity information while keeping the value bounded.\n    \"\"\"\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s.get('min_degree', 0)\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and minimum degree\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1) ** 0.5\n    )\n\n    return numerator / denom", "spearman": 0.3418720468011701, "pearson": 0.24922926668368556, "rmse": 2.6153905058154483, "mae": 2.4351782817579157}}
{"timestamp": "2026-02-16T07:40:47.282164+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i2_p0_66736154", "generation": 4, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8137815126050421, "fitness_mode": "correlation", "simplicity_score": 0.15404534289896643, "novelty_bonus": 0.1726947932823275, "total_score": 0.5223167490455536, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.053470\nbelow_novelty_threshold: novelty_bonus=0.094567\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n    \n    The estimate is a product of several simple ratios that capture the\n    main structural influences on path length:\n    \n    1. **Base term** – scales with the size of the graph and the\n       inverse of the average degree.\n    2. **Clustering & assortativity factor** – higher clustering or\n       assortativity tends to lengthen paths.\n    3. **Triangle density factor** – a higher fraction of triangles\n       shortens paths by providing local shortcuts.\n    4. **Degree heterogeneity factor** – a larger degree standard\n       deviation (presence of hubs) typically shortens paths.\n    5. **Density factor** – a denser graph usually has shorter paths.\n    \n    All terms are kept simple, use only arithmetic operations, and\n    avoid division by zero by adding small constants where needed.\n    \"\"\"\n    # Basic quantities\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    density = s['density']\n\n    # --- 1. Base term: size over average degree ---\n    base = n / (avg_deg + 1)          # +1 to avoid division by zero\n\n    # --- 2. Clustering & assortativity adjustment ---\n    ca_factor = (1 + clustering) * (1 + abs(assort))\n\n    # --- 3. Triangle density ratio (0 to 1) ---\n    max_triangles = n * (n - 1) * (n - 2) / 6\n    tri_ratio = triangles / max(max_triangles, 1)   # safe denominator\n    tri_factor = 1 + tri_ratio                      # >1\n\n    # --- 4. Degree heterogeneity factor ---\n    hetero_factor = 1 / (1 + std_deg)               # >0, decreases with std\n\n    # --- 5. Density factor (denser → shorter paths) ---\n    density_factor = 1.5 - density                  # ranges roughly from 0.5 to 1.5\n\n    # Combine all factors\n    estimate = base * ca_factor * tri_factor * hetero_factor * density_factor\n\n    # Ensure the estimate stays positive\n    return max(estimate, 0.01)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n    \n    The estimate is a product of several simple ratios that capture the\n    main structural influences on path length:\n    \n    1. **Base term** – scales with the size of the graph and the\n       inverse of the average degree.\n    2. **Clustering & assortativity factor** – higher clustering or\n       assortativity tends to lengthen paths.\n    3. **Triangle density factor** – a higher fraction of triangles\n       shortens paths by providing local shortcuts.\n    4. **Degree heterogeneity factor** – a larger degree standard\n       deviation (presence of hubs) typically shortens paths.\n    5. **Density factor** – a denser graph usually has shorter paths.\n    \n    All terms are kept simple, use only arithmetic operations, and\n    avoid division by zero by adding small constants where needed.\n    \"\"\"\n    # Basic quantities\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    triangles = s['num_triangles']\n    density = s['density']\n\n    # --- 1. Base term: size over average degree ---\n    base = n / (avg_deg + 1)          # +1 to avoid division by zero\n\n    # --- 2. Clustering & assortativity adjustment ---\n    ca_factor = (1 + clustering) * (1 + abs(assort))\n\n    # --- 3. Triangle density ratio (0 to 1) ---\n    max_triangles = n * (n - 1) * (n - 2) / 6\n    tri_ratio = triangles / max(max_triangles, 1)   # safe denominator\n    tri_factor = 1 + tri_ratio                      # >1\n\n    # --- 4. Degree heterogeneity factor ---\n    hetero_factor = 1 / (1 + std_deg)               # >0, decreases with std\n\n    # --- 5. Density factor (denser → shorter paths) ---\n    density_factor = 1.5 - density                  # ranges roughly from 0.5 to 1.5\n\n    # Combine all factors\n    estimate = base * ca_factor * tri_factor * hetero_factor * density_factor\n\n    # Ensure the estimate stays positive\n    return max(estimate, 0.01)", "spearman": 0.8793984849621241, "pearson": 0.77087511484569, "rmse": 4.491810218966386, "mae": 3.031068513767949}}
{"timestamp": "2026-02-16T07:41:18.411415+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.084812", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:41:18.411942+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.084812", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:41:41.038294+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.062768", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:41:41.038857+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:42:02.425118+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:42:02.425952+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:42:21.904745+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i2_p2_246408297", "generation": 4, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7755582232893158, "fitness_mode": "correlation", "simplicity_score": 0.14015998668743174, "novelty_bonus": 0.21218578231291085, "total_score": 0.5251798193335422, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.094567\nbelow_novelty_threshold: novelty_bonus=0.084812\nbelow_novelty_threshold: novelty_bonus=0.062768\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport math\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a compact combination of\n    global graph statistics.  The formula is built around three core ideas:\n\n    1. **Size vs. connectivity** – The base estimate scales with the ratio\n       of node count to average degree.  A larger graph with a small\n       average degree tends to have longer paths.\n       `base = n / (avg_degree + 1)`\n\n    2. **Local clustering effects** – High clustering and transitivity create\n       many short cycles that can force detours, slightly increasing path\n       lengths.  We combine them linearly with a small weight on transitivity\n       (which is a global clustering measure):\n       `clust_factor = 1 + avg_clustering + 0.5 * transitivity`\n\n    3. **Degree heterogeneity & assortativity** – A wide degree spread (high\n       `std_degree`) introduces hubs that shorten paths, while positive\n       assortativity tends to lengthen them.  We model this by dividing by\n       `1 + std_degree` and multiplying by a square‑root factor of\n       `1 + |degree_assortativity|`:\n       `hetero_factor = 1 / (1 + std_degree)`\n       `assort_factor = (1 + abs(degree_assortativity)) ** 0.5`\n\n    The final estimate is the product of these three components.  All\n    intermediate quantities are bounded away from zero, so the expression\n    remains well‑defined even on very sparse or very dense graphs.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    c = s['avg_clustering']\n    trans = s['transitivity']\n    a = s['degree_assortativity']\n\n    # 1. Base term (size vs connectivity)\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering / transitivity factor\n    clust_factor = 1 + c + 0.5 * trans\n\n    # 3. Heterogeneity and assortativity adjustments\n    hetero_factor = 1 / (1 + std_deg)\n    assort_factor = (1 + abs(a)) ** 0.5\n\n    return base * clust_factor * hetero_factor * assort_factor\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a compact combination of\n    global graph statistics.  The formula is built around three core ideas:\n\n    1. **Size vs. connectivity** – The base estimate scales with the ratio\n       of node count to average degree.  A larger graph with a small\n       average degree tends to have longer paths.\n       `base = n / (avg_degree + 1)`\n\n    2. **Local clustering effects** – High clustering and transitivity create\n       many short cycles that can force detours, slightly increasing path\n       lengths.  We combine them linearly with a small weight on transitivity\n       (which is a global clustering measure):\n       `clust_factor = 1 + avg_clustering + 0.5 * transitivity`\n\n    3. **Degree heterogeneity & assortativity** – A wide degree spread (high\n       `std_degree`) introduces hubs that shorten paths, while positive\n       assortativity tends to lengthen them.  We model this by dividing by\n       `1 + std_degree` and multiplying by a square‑root factor of\n       `1 + |degree_assortativity|`:\n       `hetero_factor = 1 / (1 + std_degree)`\n       `assort_factor = (1 + abs(degree_assortativity)) ** 0.5`\n\n    The final estimate is the product of these three components.  All\n    intermediate quantities are bounded away from zero, so the expression\n    remains well‑defined even on very sparse or very dense graphs.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    c = s['avg_clustering']\n    trans = s['transitivity']\n    a = s['degree_assortativity']\n\n    # 1. Base term (size vs connectivity)\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering / transitivity factor\n    clust_factor = 1 + c + 0.5 * trans\n\n    # 3. Heterogeneity and assortativity adjustments\n    hetero_factor = 1 / (1 + std_deg)\n    assort_factor = (1 + abs(a)) ** 0.5\n\n    return base * clust_factor * hetero_factor * assort_factor\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a compact combination of\n    global graph statistics.  The formula is built around three core ideas:\n\n    1. **Size vs. connectivity** – The base estimate scales with the ratio\n       of node count to average degree.  A larger graph with a small\n       average degree tends to have longer paths.\n       `base = n / (avg_degree + 1)`\n\n    2. **Local clustering effects** – High clustering and transitivity create\n       many short cycles that can force detours, slightly increasing path\n       lengths.  We combine them linearly with a small weight on transitivity\n       (which is a global clustering measure):\n       `clust_factor = 1 + avg_clustering + 0.5 * transitivity`\n\n    3. **Degree heterogeneity & assortativity** – A wide degree spread (high\n       `std_degree`) introduces hubs that shorten paths, while positive\n       assortativity tends to lengthen them.  We model this by dividing by\n       `1 + std_degree` and multiplying by a square‑root factor of\n       `1 + |degree_assortativity|`:\n       `hetero_factor = 1 / (1 + std_degree)`\n       `assort_factor = (1 + abs(degree_assortativity)) ** 0.5`\n\n    The final estimate is the product of these three components.  All\n    intermediate quantities are bounded away from zero, so the expression\n    remains well‑defined even on very sparse or very dense graphs.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    c = s['avg_clustering']\n    trans = s['transitivity']\n    a = s['degree_assortativity']\n\n    # 1. Base term (size vs connectivity)\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering / transitivity factor\n    clust_factor = 1 + c + 0.5 * trans\n\n    # 3. Heterogeneity and assortativity adjustments\n    hetero_factor = 1 / (1 + std_deg)\n    assort_factor = (1 + abs(a)) ** 0.5\n\n    return base * clust_factor * hetero_factor * assort_factor", "spearman": 0.8669841746043653, "pearson": 0.734135746204911, "rmse": 2.631042168168535, "mae": 1.624704989568592}}
{"timestamp": "2026-02-16T07:42:21.905413+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 2, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:42:48.111807+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i2_p3_512171558", "generation": 4, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7527010804321728, "fitness_mode": "correlation", "simplicity_score": 0.1353950262614392, "novelty_bonus": 0.20899593223129975, "total_score": 0.5149079131748842, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.084812\nbelow_novelty_threshold: novelty_bonus=0.062768\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  A small constant is added to the denominator\n       so the expression never blows up when the graph is very sparse.\n    2. **Clustering & density factor** – higher clustering and higher density\n       tend to shorten paths, so we multiply by (1 + avg_clustering) and\n       (1 + density).  The density term is already in [0,1], so it keeps the\n       factor bounded.\n    3. **Degree heterogeneity & assortativity adjustment** – a large\n       standard deviation of degrees (presence of hubs) typically shortens\n       paths, and positive degree assortativity tends to lengthen them.\n       We model this by dividing by (1 + std_degree) and multiplying by\n       (1 + degree_assortativity**2) to keep the adjustment monotonic.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    d = s['density']\n    std = s['std_degree']\n    a = s['degree_assortativity']\n\n    # Base estimate: n² divided by a slightly inflated edge count\n    denom = 2 * m + n + 1          # +1 guarantees non‑zero denominator\n    base = n ** 2 / denom\n\n    # Factors that increase the estimate\n    cluster_factor = 1 + c\n    density_factor = 1 + d\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    # Assortativity factor – squared to keep it non‑negative\n    assort_factor = 1 + a ** 2\n\n    return base * cluster_factor * density_factor * hetero * assort_factor\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  A small constant is added to the denominator\n       so the expression never blows up when the graph is very sparse.\n    2. **Clustering & density factor** – higher clustering and higher density\n       tend to shorten paths, so we multiply by (1 + avg_clustering) and\n       (1 + density).  The density term is already in [0,1], so it keeps the\n       factor bounded.\n    3. **Degree heterogeneity & assortativity adjustment** – a large\n       standard deviation of degrees (presence of hubs) typically shortens\n       paths, and positive degree assortativity tends to lengthen them.\n       We model this by dividing by (1 + std_degree) and multiplying by\n       (1 + degree_assortativity**2) to keep the adjustment monotonic.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    d = s['density']\n    std = s['std_degree']\n    a = s['degree_assortativity']\n\n    # Base estimate: n² divided by a slightly inflated edge count\n    denom = 2 * m + n + 1          # +1 guarantees non‑zero denominator\n    base = n ** 2 / denom\n\n    # Factors that increase the estimate\n    cluster_factor = 1 + c\n    density_factor = 1 + d\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    # Assortativity factor – squared to keep it non‑negative\n    assort_factor = 1 + a ** 2\n\n    return base * cluster_factor * density_factor * hetero * assort_factor", "spearman": 0.8502602565064128, "pearson": 0.7212612748349271, "rmse": 2.401004723667031, "mae": 1.4994241542295461}}
{"timestamp": "2026-02-16T07:43:24.222675+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.147637", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:43:24.223328+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 4, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.147637", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:43:53.497461+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 2, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:43:53.498153+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 4, "island_id": 2, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:44:24.941647+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i3_p0_439701657", "generation": 4, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6307322929171668, "fitness_mode": "correlation", "simplicity_score": 0.24795247661365372, "novelty_bonus": 0.3632595814895371, "total_score": 0.4707704248209682, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    A creative heuristic estimate of the average shortest‑path length that\n    blends several topological cues from the feature dictionary while\n    avoiding direct reliance on any single metric.  The construction uses\n    multiplicative coupling of size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance and assortativity, but\n    in a form that is not directly expressible as a simple function of any\n    individual feature.\n    \"\"\"\n    # Extract needed quantities\n    n        = s['n']\n    m        = s['m']\n    density  = s['density']\n    max_deg  = s['max_degree']\n    min_deg  = s['min_degree']\n    std_deg  = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']            # sorted degree list\n\n    # ---- Size–density hybrid\n    size_term = (n ** 1.5) / (m + 1)\n\n    # ---- Density penalty (lower density → larger value)\n    dens_term = 1 / (density + 1e-6)\n\n    # ---- Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1\n    std_term  = 1 + (std_deg / (deg_range + 1))\n\n    # ---- Harmonic mean of degrees (captures skewness)\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)   # avoid division by zero\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # ---- Clustering–transitivity reduction\n    cluster_term = 1 / (clustering * trans + 1e-6)\n\n    # ---- Triangle shortcut effect\n    tri_term = 1 + (triangles ** 0.4)\n\n    # ---- Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # ---- Assemble the invariant\n    inv = size_term * dens_term * std_term * harmonic_term * assort_term\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    A composite estimate of the average shortest‑path length based on\n    several global properties of the graph.  \n    The formula blends size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance, and assortativity\n    in a multiplicative fashion without relying on any single metric\n    directly.  All arithmetic is performed with built‑in Python\n    operations; no external libraries are imported.\n    \"\"\"\n    # Basic graph descriptors\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clustering = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']          # sorted degree list\n\n    # --- 1. Size–density hybrid term\n    #  n**1.5 grows with graph size, division by (m+1) penalises sparsity\n    size_term = n ** 1.5 / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-6)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1.0\n    std_term  = 1.0 + (std_deg / (deg_range + 1.0))\n\n    # --- 4. Harmonic mean of degrees\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    # Avoid division by zero\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1.0)\n\n    # --- 5. Clustering–transitivity reduction\n    cluster_term = 1.0 / (clustering * trans + 1e-6)\n\n    # --- 6. Triangle shortcut effect\n    tri_term = 1.0 + (triangles ** 0.4)\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * std_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.001969\nbelow_train_threshold: train_signal=0.296134\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.6244041101027527, "pearson": 0.7256175390017457, "rmse": 1.8287564419836346, "mae": 1.6983283926512458}}
{"timestamp": "2026-02-16T07:44:47.106338+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i3_p1_667555984", "generation": 4, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.47783913565426167, "fitness_mode": "correlation", "simplicity_score": 0.2475483017271958, "novelty_bonus": 0.3731649659613079, "total_score": 0.44678503328091024, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    A creative heuristic estimate of the average shortest‑path length that\n    blends several topological cues from the feature dictionary while\n    avoiding direct reliance on any single metric.  The construction uses\n    multiplicative coupling of size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance and assortativity, but\n    in a form that is not directly expressible as a simple function of any\n    individual feature.\n    \"\"\"\n    # Extract needed quantities\n    n        = s['n']\n    m        = s['m']\n    density  = s['density']\n    max_deg  = s['max_degree']\n    min_deg  = s['min_degree']\n    std_deg  = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']            # sorted degree list\n\n    # ---- Size–density hybrid\n    size_term = (n ** 1.5) / (m + 1)\n\n    # ---- Density penalty (lower density → larger value)\n    dens_term = 1 / (density + 1e-6)\n\n    # ---- Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1\n    std_term  = 1 + (std_deg / (deg_range + 1))\n\n    # ---- Harmonic mean of degrees (captures skewness)\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)   # avoid division by zero\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # ---- Clustering–transitivity reduction\n    cluster_term = 1 / (clustering * trans + 1e-6)\n\n    # ---- Triangle shortcut effect\n    tri_term = 1 + (triangles ** 0.4)\n\n    # ---- Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # ---- Assemble the invariant\n    inv = size_term * dens_term * std_term * harmonic_term * assort_term\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    A composite estimate of the average shortest‑path length based on\n    several global properties of the graph.  \n    The formula blends size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance, and assortativity\n    in a multiplicative fashion without relying on any single metric\n    directly.  All arithmetic is performed with built‑in Python\n    operations; no external libraries are imported.\n    \"\"\"\n    # Basic graph descriptors\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clustering = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']          # sorted degree list\n\n    # --- 1. Size–density hybrid term\n    #  n**1.5 grows with graph size, division by (m+1) penalises sparsity\n    size_term = n ** 1.5 / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-6)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1.0\n    std_term  = 1.0 + (std_deg / (deg_range + 1.0))\n\n    # --- 4. Harmonic mean of degrees\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    # Avoid division by zero\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1.0)\n\n    # --- 5. Clustering–transitivity reduction\n    cluster_term = 1.0 / (clustering * trans + 1e-6)\n\n    # --- 6. Triangle shortcut effect\n    tri_term = 1.0 + (triangles ** 0.4)\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * std_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.001969\nbelow_train_threshold: train_signal=0.296134\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mixture of\n    several global graph statistics.  Only built‑in Python operations are\n    used – no external libraries are imported and no single feature is\n    returned directly.\n    \"\"\"\n    # Basic graph descriptors as floats\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clustering = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']  # sorted list of ints\n\n    # --- 1. Size–density hybrid term\n    # Larger graphs grow with a power of n, while sparsity is penalised\n    size_term = (n ** 1.3) / (m + 1.0)\n\n    # --- 2. Density penalty (sparse graphs get a larger value)\n    dens_term = 1.0 / (density + 1e-8)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1.0\n    std_term  = 1.0 + (std_deg / (deg_range + 1.0))\n\n    # --- 4. Harmonic mean of degrees\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    # avoid division by zero\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic_mean / (max_deg + 1.0)\n\n    # --- 5. Clustering–transitivity reduction\n    cluster_term = 1.0 / (clustering * trans + 1e-8)\n\n    # --- 6. Triangle shortcut effect\n    tri_term = 1.0 + (triangles ** 0.4)\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * std_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mixture of\n    several global graph statistics.  Only built‑in Python operations are\n    used – no external libraries are imported and no single feature is\n    returned directly.\n    \"\"\"\n    # Basic graph descriptors as floats\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clustering = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']  # sorted list of ints\n\n    # --- 1. Size–density hybrid term\n    # Larger graphs grow with a power of n, while sparsity is penalised\n    size_term = (n ** 1.3) / (m + 1.0)\n\n    # --- 2. Density penalty (sparse graphs get a larger value)\n    dens_term = 1.0 / (density + 1e-8)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1.0\n    std_term  = 1.0 + (std_deg / (deg_range + 1.0))\n\n    # --- 4. Harmonic mean of degrees\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    # avoid division by zero\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic_mean / (max_deg + 1.0)\n\n    # --- 5. Clustering–transitivity reduction\n    cluster_term = 1.0 / (clustering * trans + 1e-8)\n\n    # --- 6. Triangle shortcut effect\n    tri_term = 1.0 + (triangles ** 0.4)\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * std_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.5706517662941574, "pearson": 0.7921117181881101, "rmse": 2.7993435432959872, "mae": 2.6590577008347704}}
{"timestamp": "2026-02-16T07:45:18.444634+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.298439", "model_name": "gpt-oss:20b", "train_signal": 0.2984393757503001}}
{"timestamp": "2026-02-16T07:46:02.666124+00:00", "event_type": "candidate_rejected", "payload": {"generation": 4, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.051429", "model_name": "gpt-oss:20b", "train_signal": 0.05142857142857142}}
{"timestamp": "2026-02-16T07:46:32.761184+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g4_i3_p4_986259276", "generation": 4, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5850180072028811, "fitness_mode": "correlation", "simplicity_score": 0.24795247661365372, "novelty_bonus": 0.3838940973524336, "total_score": 0.4594433416438888, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    A creative heuristic estimate of the average shortest‑path length that\n    blends several topological cues from the feature dictionary while\n    avoiding direct reliance on any single metric.  The construction uses\n    multiplicative coupling of size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance and assortativity, but\n    in a form that is not directly expressible as a simple function of any\n    individual feature.\n    \"\"\"\n    # Extract needed quantities\n    n        = s['n']\n    m        = s['m']\n    density  = s['density']\n    max_deg  = s['max_degree']\n    min_deg  = s['min_degree']\n    std_deg  = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    triangles  = s['num_triangles']\n    degrees    = s['degrees']            # sorted degree list\n\n    # ---- Size–density hybrid\n    size_term = (n ** 1.5) / (m + 1)\n\n    # ---- Density penalty (lower density → larger value)\n    dens_term = 1 / (density + 1e-6)\n\n    # ---- Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1\n    std_term  = 1 + (std_deg / (deg_range + 1))\n\n    # ---- Harmonic mean of degrees (captures skewness)\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic = n / (harmonic_sum + 1e-12)   # avoid division by zero\n    harmonic_term = harmonic / (max_deg + 1)\n\n    # ---- Clustering–transitivity reduction\n    cluster_term = 1 / (clustering * trans + 1e-6)\n\n    # ---- Triangle shortcut effect\n    tri_term = 1 + (triangles ** 0.4)\n\n    # ---- Assortativity boost\n    assort_term = 1 + abs(assort)\n\n    # ---- Assemble the invariant\n    inv = size_term * dens_term * std_term * harmonic_term * assort_term\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    A composite estimate of the average shortest‑path length based on\n    several global properties of the graph.  \n    The formula blends size, density, degree dispersion, harmonic\n    degree behaviour, clustering, triangle abundance, and assortativity\n    in a multiplicative fashion without relying on any single metric\n    directly.  All arithmetic is performed with built‑in Python\n    operations; no external libraries are imported.\n    \"\"\"\n    # Basic graph descriptors\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    clustering = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']          # sorted degree list\n\n    # --- 1. Size–density hybrid term\n    #  n**1.5 grows with graph size, division by (m+1) penalises sparsity\n    size_term = n ** 1.5 / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-6)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = max_deg - min_deg + 1.0\n    std_term  = 1.0 + (std_deg / (deg_range + 1.0))\n\n    # --- 4. Harmonic mean of degrees\n    #    harmonic = n / sum(1/d)  (ignore zero degrees)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    # Avoid division by zero\n    harmonic = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic / (max_deg + 1.0)\n\n    # --- 5. Clustering–transitivity reduction\n    cluster_term = 1.0 / (clustering * trans + 1e-6)\n\n    # --- 6. Triangle shortcut effect\n    tri_term = 1.0 + (triangles ** 0.4)\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * std_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.296134\nbelow_train_threshold: train_signal=0.298439\nbelow_train_threshold: train_signal=0.051429\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the graph's average shortest‑path length.\n\n    This expression mixes several topological signals—size, density,\n    degree dispersion, harmonic degree behaviour, clustering/transitivity,\n    triangle abundance, and degree assortativity—into a single multiplicative\n    formula.  It avoids any direct lookup of a pre‑computed distance metric\n    and uses only built‑in Python operations.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features with keys:\n        'n', 'm', 'density', 'avg_degree', 'max_degree', 'min_degree',\n        'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'num_triangles', 'degrees' (sorted list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # --- Extract the basic quantities -------------------------------------------------\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']                     # list of ints\n\n    # --- Size–density hybrid (penalises sparsity) ---------------------------------------\n    size_term = (n ** 0.6) / (m + 1.0)\n\n    # --- Density penalty (sparser graphs inflate the estimate) ------------------------\n    density_term = 1.0 / (density + 1e-6)\n\n    # --- Degree‑dispersion influence ---------------------------------------------------\n    deg_range = max_deg - min_deg + 1.0\n    dispersion_term = deg_range ** 0.4\n\n    # --- Harmonic mean of degrees (captures skewness of the distribution) --------------\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic_mean\n\n    # --- Clustering–transitivity reduction (high clustering → shorter paths) ----------\n    cluster_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # --- Triangle shortcut effect (more triangles tend to shrink paths) ----------------\n    triangle_term = (triangles + 1.0) ** 0.3\n\n    # --- Assortativity boost (mixing can create shortcuts) ----------------------------\n    assort_term = 1.0 + abs(assort)\n\n    # --- Combine everything ------------------------------------------------------------\n    inv = (size_term * density_term * dispersion_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the graph's average shortest‑path length.\n\n    This expression mixes several topological signals—size, density,\n    degree dispersion, harmonic degree behaviour, clustering/transitivity,\n    triangle abundance, and degree assortativity—into a single multiplicative\n    formula.  It avoids any direct lookup of a pre‑computed distance metric\n    and uses only built‑in Python operations.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features with keys:\n        'n', 'm', 'density', 'avg_degree', 'max_degree', 'min_degree',\n        'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'num_triangles', 'degrees' (sorted list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # --- Extract the basic quantities -------------------------------------------------\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']                     # list of ints\n\n    # --- Size–density hybrid (penalises sparsity) ---------------------------------------\n    size_term = (n ** 0.6) / (m + 1.0)\n\n    # --- Density penalty (sparser graphs inflate the estimate) ------------------------\n    density_term = 1.0 / (density + 1e-6)\n\n    # --- Degree‑dispersion influence ---------------------------------------------------\n    deg_range = max_deg - min_deg + 1.0\n    dispersion_term = deg_range ** 0.4\n\n    # --- Harmonic mean of degrees (captures skewness of the distribution) --------------\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic_mean\n\n    # --- Clustering–transitivity reduction (high clustering → shorter paths) ----------\n    cluster_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # --- Triangle shortcut effect (more triangles tend to shrink paths) ----------------\n    triangle_term = (triangles + 1.0) ** 0.3\n\n    # --- Assortativity boost (mixing can create shortcuts) ----------------------------\n    assort_term = 1.0 + abs(assort)\n\n    # --- Combine everything ------------------------------------------------------------\n    inv = (size_term * density_term * dispersion_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv", "spearman": 0.5893692342308559, "pearson": 0.7105457136676865, "rmse": 1.7631391309259714, "mae": 1.6190538187735732}}
{"timestamp": "2026-02-16T07:46:32.764319+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 5, "model_name": "gpt-oss:20b", "best_val_score": 0.5358322776835298, "no_improve_count": 4}}
{"timestamp": "2026-02-16T07:47:12.772285+00:00", "event_type": "candidate_rejected", "payload": {"generation": 5, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:47:12.773172+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 5, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:47:30.120894+00:00", "event_type": "candidate_rejected", "payload": {"generation": 5, "island_id": 0, "population_idx": 0, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:47:30.121606+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 5, "island_id": 0, "population_idx": 0, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:48:06.867465+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i0_p1_848319403", "generation": 5, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.44816326530612244, "fitness_mode": "correlation", "simplicity_score": 0.12333767116259307, "novelty_bonus": 0.2622397629033182, "total_score": 0.33766482123746744, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-12\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = n / (avg_deg + 1)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + 1)           # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a combination of\n    pre‑computed graph statistics.  The formula is inspired by the\n    characteristic path length of random graphs (log(n)/log(avg_degree))\n    and is adjusted for sparsity, clustering, and degree assortativity.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n\n    # Baseline estimate for a random graph\n    baseline = np.log(n) / (np.log(avg_deg + 1) + 1e-6)\n\n    # Adjust for sparsity: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density)\n\n    # Adjust for clustering: higher clustering can slightly reduce path length\n    clustering_adj = 1 - clustering\n\n    # Adjust for degree assortativity: assortative mixing can increase path length\n    assort_adj = 1 + assort\n\n    return baseline * density_adj * clustering_adj * assort_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    density_adj = max(0.0, density_adj)\n    clustering_adj = max(0.0, clustering_adj)\n    assort_adj = max(0.0, assort_adj)\n    hetero_adj = max(0.0, hetero_adj)\n    hub_adj = max(0.0, hub_adj)\n    triangle_adj = max(0.0, triangle_adj)\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.033894\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.4686507162679068, "pearson": 0.37156436832847817, "rmse": 2.242179205602687, "mae": 2.042449420766387}}
{"timestamp": "2026-02-16T07:48:47.315398+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i0_p2_325114020", "generation": 5, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.35855942376950783, "fitness_mode": "correlation", "simplicity_score": 0.12352402374819375, "novelty_bonus": 0.25613341117065924, "total_score": 0.3311308177505778, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-12\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = n / (avg_deg + 1)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + 1)           # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a combination of\n    pre‑computed graph statistics.  The formula is inspired by the\n    characteristic path length of random graphs (log(n)/log(avg_degree))\n    and is adjusted for sparsity, clustering, and degree assortativity.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n\n    # Baseline estimate for a random graph\n    baseline = np.log(n) / (np.log(avg_deg + 1) + 1e-6)\n\n    # Adjust for sparsity: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density)\n\n    # Adjust for clustering: higher clustering can slightly reduce path length\n    clustering_adj = 1 - clustering\n\n    # Adjust for degree assortativity: assortative mixing can increase path length\n    assort_adj = 1 + assort\n\n    return baseline * density_adj * clustering_adj * assort_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    density_adj = max(0.0, density_adj)\n    clustering_adj = max(0.0, clustering_adj)\n    assort_adj = max(0.0, assort_adj)\n    hetero_adj = max(0.0, hetero_adj)\n    hub_adj = max(0.0, hub_adj)\n    triangle_adj = max(0.0, triangle_adj)\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.033894\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-12\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = n / (avg_deg + 1)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + 1)           # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-12\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = n / (avg_deg + 1)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + 1)           # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.45917197929948256, "pearson": 0.36426452877758775, "rmse": 4.763016451096367, "mae": 3.3271017041369246}}
{"timestamp": "2026-02-16T07:49:33.292649+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i0_p3_524489063", "generation": 5, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.44816326530612244, "fitness_mode": "correlation", "simplicity_score": 0.12333767116259307, "novelty_bonus": 0.2622397629033182, "total_score": 0.33766482123746744, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-12\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = n / (avg_deg + 1)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + 1)           # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a combination of\n    pre‑computed graph statistics.  The formula is inspired by the\n    characteristic path length of random graphs (log(n)/log(avg_degree))\n    and is adjusted for sparsity, clustering, and degree assortativity.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n\n    # Baseline estimate for a random graph\n    baseline = np.log(n) / (np.log(avg_deg + 1) + 1e-6)\n\n    # Adjust for sparsity: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density)\n\n    # Adjust for clustering: higher clustering can slightly reduce path length\n    clustering_adj = 1 - clustering\n\n    # Adjust for degree assortativity: assortative mixing can increase path length\n    assort_adj = 1 + assort\n\n    return baseline * density_adj * clustering_adj * assort_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    density_adj = max(0.0, density_adj)\n    clustering_adj = max(0.0, clustering_adj)\n    assort_adj = max(0.0, assort_adj)\n    hetero_adj = max(0.0, hetero_adj)\n    hub_adj = max(0.0, hub_adj)\n    triangle_adj = max(0.0, triangle_adj)\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.033894\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: scales with sqrt(n) and inversely with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: scales with sqrt(n) and inversely with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.4686507162679068, "pearson": 0.37156436832847817, "rmse": 2.242179205602687, "mae": 2.042449420766387}}
{"timestamp": "2026-02-16T07:50:07.653177+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i0_p4_674615732", "generation": 5, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.35855942376950783, "fitness_mode": "correlation", "simplicity_score": 0.12275228871560445, "novelty_bonus": 0.25613341117065924, "total_score": 0.33097647074405995, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-12\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = n / (avg_deg + 1)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + 1)           # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a combination of\n    pre‑computed graph statistics.  The formula is inspired by the\n    characteristic path length of random graphs (log(n)/log(avg_degree))\n    and is adjusted for sparsity, clustering, and degree assortativity.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n\n    # Baseline estimate for a random graph\n    baseline = np.log(n) / (np.log(avg_deg + 1) + 1e-6)\n\n    # Adjust for sparsity: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density)\n\n    # Adjust for clustering: higher clustering can slightly reduce path length\n    clustering_adj = 1 - clustering\n\n    # Adjust for degree assortativity: assortative mixing can increase path length\n    assort_adj = 1 + assort\n\n    return baseline * density_adj * clustering_adj * assort_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    density_adj = max(0.0, density_adj)\n    clustering_adj = max(0.0, clustering_adj)\n    assort_adj = max(0.0, assort_adj)\n    hetero_adj = max(0.0, hetero_adj)\n    hub_adj = max(0.0, hub_adj)\n    triangle_adj = max(0.0, triangle_adj)\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.033894\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula is a baseline based on graph size and average degree, with\n    multiplicative adjustments for sparsity, clustering, assortativity,\n    degree heterogeneity, hub presence, and triangle density.\n    \"\"\"\n    eps = 1e-12\n\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    num_tri    = float(s['num_triangles'])\n\n    # Baseline: larger graphs with lower average degree tend to have longer paths\n    baseline = n / (avg_deg + 1.0)\n\n    # Adjustment factors\n    density_adj   = 1.0 + (1.0 - density)          # sparser → longer paths\n    clustering_adj = 1.0 - clustering              # higher clustering → shorter paths\n    assort_adj    = 1.0 + assort                    # assortative mixing → longer paths\n    hetero_adj    = 1.0 - std_deg / (avg_deg + 1.0) # degree heterogeneity → shorter paths\n    hub_adj       = 1.0 - max_deg / (n - 1.0 + eps) # presence of hubs → shorter paths\n    triangle_adj  = 1.0 - num_tri / (n * (n - 1.0) / 2.0 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula is a baseline based on graph size and average degree, with\n    multiplicative adjustments for sparsity, clustering, assortativity,\n    degree heterogeneity, hub presence, and triangle density.\n    \"\"\"\n    eps = 1e-12\n\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    num_tri    = float(s['num_triangles'])\n\n    # Baseline: larger graphs with lower average degree tend to have longer paths\n    baseline = n / (avg_deg + 1.0)\n\n    # Adjustment factors\n    density_adj   = 1.0 + (1.0 - density)          # sparser → longer paths\n    clustering_adj = 1.0 - clustering              # higher clustering → shorter paths\n    assort_adj    = 1.0 + assort                    # assortative mixing → longer paths\n    hetero_adj    = 1.0 - std_deg / (avg_deg + 1.0) # degree heterogeneity → shorter paths\n    hub_adj       = 1.0 - max_deg / (n - 1.0 + eps) # presence of hubs → shorter paths\n    triangle_adj  = 1.0 - num_tri / (n * (n - 1.0) / 2.0 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.45917197929948256, "pearson": 0.36426452877758775, "rmse": 4.763016451096367, "mae": 3.3271017041369246}}
{"timestamp": "2026-02-16T07:50:27.525531+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i1_p0_797434307", "generation": 5, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3734453781512605, "fitness_mode": "correlation", "simplicity_score": 0.1549690082869574, "novelty_bonus": 0.26412060301507523, "total_score": 0.2846865939771994, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    std_degree = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + transitivity)\n        + norm_sq\n        + (num_triangles + 1) ** 0.5\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity) + std_degree\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A dimensionless graph invariant that blends size, degree, clustering,\n    triangle counts, degree heterogeneity and assortativity.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    # and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A dimensionless graph invariant that blends size, degree, clustering,\n    triangle counts, degree heterogeneity and assortativity.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    # and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.34891322283057075, "pearson": 0.2670258388968786, "rmse": 2.620904785622736, "mae": 2.441546239297168}}
{"timestamp": "2026-02-16T07:50:47.763105+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i1_p1_313929537", "generation": 5, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3734453781512605, "fitness_mode": "correlation", "simplicity_score": 0.15505154971632262, "novelty_bonus": 0.26412060301507523, "total_score": 0.2847031022630725, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    std_degree = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + transitivity)\n        + norm_sq\n        + (num_triangles + 1) ** 0.5\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity) + std_degree\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.34891322283057075, "pearson": 0.2670258388968786, "rmse": 2.620904785622736, "mae": 2.441546239297168}}
{"timestamp": "2026-02-16T07:51:09.169817+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i1_p2_565152403", "generation": 5, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3734453781512605, "fitness_mode": "correlation", "simplicity_score": 0.1549690082869574, "novelty_bonus": 0.26412060301507523, "total_score": 0.2846865939771994, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    std_degree = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + transitivity)\n        + norm_sq\n        + (num_triangles + 1) ** 0.5\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity) + std_degree\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, and degree heterogeneity into a single value.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, and degree heterogeneity into a single value.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.34891322283057075, "pearson": 0.2670258388968786, "rmse": 2.620904785622736, "mae": 2.441546239297168}}
{"timestamp": "2026-02-16T07:51:38.694597+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i1_p3_877296382", "generation": 5, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15387124888181722, "novelty_bonus": 0.25199429985749633, "total_score": 0.28478850013262236, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    std_degree = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + transitivity)\n        + norm_sq\n        + (num_triangles + 1) ** 0.5\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity) + std_degree\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A dimensionless graph invariant that combines size, degree distribution,\n    clustering, triangle count, assortativity, and degree range information.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s.get('density', 0)\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range info\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    # and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A dimensionless graph invariant that combines size, degree distribution,\n    clustering, triangle count, assortativity, and degree range information.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s.get('density', 0)\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range info\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    # and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T07:52:02.858367+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i1_p4_590798902", "generation": 5, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3734453781512605, "fitness_mode": "correlation", "simplicity_score": 0.15505154971632262, "novelty_bonus": 0.26412060301507523, "total_score": 0.2847031022630725, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    transitivity = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_triangles = s['num_triangles']\n    degree_assortativity = s.get('degree_assortativity', 0)\n    std_degree = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + transitivity)\n        + norm_sq\n        + (num_triangles + 1) ** 0.5\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_triangles + abs(degree_assortativity) + std_degree\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.34891322283057075, "pearson": 0.2670258388968786, "rmse": 2.620904785622736, "mae": 2.441546239297168}}
{"timestamp": "2026-02-16T07:52:41.131815+00:00", "event_type": "candidate_rejected", "payload": {"generation": 5, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.118759", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:52:41.132237+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 5, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.118759", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:53:05.060701+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i2_p0_982543331", "generation": 5, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7858343337334933, "fitness_mode": "correlation", "simplicity_score": 0.13610258241385123, "novelty_bonus": 0.15613652376628495, "total_score": 0.49621402742650117, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.062768\nbelow_novelty_threshold: novelty_bonus=0.147637\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.118759\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from simple graph statistics.\n    The estimate uses:\n      - n² / (2*m + n)          : captures size vs connectivity\n      - (1 + avg_clustering)    : higher clustering tends to increase path length\n      - (1 + degree_assortativity) : positive assortativity lengthens paths\n      - 1/(1 + std_degree)      : heterogeneity (hubs) shortens paths\n      - 1/(1 + num_triangles/n) : more triangles reduce average path length\n    All operations avoid division by zero by using safe defaults.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n    tri = s['num_triangles']\n\n    denom = 2 * m + n\n    if denom == 0:\n        denom = 1\n\n    base = (n ** 2) / denom\n\n    cluster_adj = 1 + c\n    assort_adj = 1 + a\n    hetero_adj = 1 / (1 + std)\n    tri_adj = 1 / (1 + tri / max(n, 1))\n\n    return base * cluster_adj * assort_adj * hetero_adj * tri_adj\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is a product of several multiplicative factors that capture\n    the main structural influences on path length:\n\n    1. **Base term** – n² / (2*m + n)  (size versus connectivity).\n       The denominator is always at least 1 to avoid division by zero.\n\n    2. **Clustering factor** – (1 + avg_clustering).  Higher clustering\n       tends to create local detours, slightly increasing path lengths.\n\n    3. **Assortativity factor** – (1 + |degree_assortativity|).  Positive\n       assortativity increases the average path length, while negative\n       assortativity shortens it; using the absolute value keeps the factor\n       monotonic.\n\n    4. **Degree heterogeneity factor** – 1 / (1 + std_degree).  A larger\n       standard deviation of degrees (presence of hubs) typically shortens\n       paths, so the estimate is reduced.\n\n    5. **Triangle density factor** – 1 / (1 + tri_density) where\n       tri_density = num_triangles / (n choose 2).  A higher triangle\n       density indicates more tightly knit subgraphs, which tends to\n       reduce the overall average shortest path length.\n\n    All divisions use a safe denominator (at least 1) to keep the\n    expression well‑defined for very sparse graphs.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n    tri = s['num_triangles']\n\n    # Safe denominator for the base term\n    base_denom = max(2 * m + n, 1)\n    base = (n ** 2) / base_denom\n\n    # Clustering adjustment\n    cluster_adj = 1 + c\n\n    # Assortativity adjustment (use absolute value)\n    assort_adj = 1 + abs(a)\n\n    # Heterogeneity adjustment\n    hetero_adj = 1 / (1 + std)\n\n    # Triangle density adjustment\n    possible_triangles = n * (n - 1) / 2\n    tri_density = tri / max(possible_triangles, 1)\n    tri_adj = 1 / (1 + tri_density)\n\n    return base * cluster_adj * assort_adj * hetero_adj * tri_adj\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is a product of several multiplicative factors that capture\n    the main structural influences on path length:\n\n    1. **Base term** – n² / (2*m + n)  (size versus connectivity).\n       The denominator is always at least 1 to avoid division by zero.\n\n    2. **Clustering factor** – (1 + avg_clustering).  Higher clustering\n       tends to create local detours, slightly increasing path lengths.\n\n    3. **Assortativity factor** – (1 + |degree_assortativity|).  Positive\n       assortativity increases the average path length, while negative\n       assortativity shortens it; using the absolute value keeps the factor\n       monotonic.\n\n    4. **Degree heterogeneity factor** – 1 / (1 + std_degree).  A larger\n       standard deviation of degrees (presence of hubs) typically shortens\n       paths, so the estimate is reduced.\n\n    5. **Triangle density factor** – 1 / (1 + tri_density) where\n       tri_density = num_triangles / (n choose 2).  A higher triangle\n       density indicates more tightly knit subgraphs, which tends to\n       reduce the overall average shortest path length.\n\n    All divisions use a safe denominator (at least 1) to keep the\n    expression well‑defined for very sparse graphs.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n    tri = s['num_triangles']\n\n    # Safe denominator for the base term\n    base_denom = max(2 * m + n, 1)\n    base = (n ** 2) / base_denom\n\n    # Clustering adjustment\n    cluster_adj = 1 + c\n\n    # Assortativity adjustment (use absolute value)\n    assort_adj = 1 + abs(a)\n\n    # Heterogeneity adjustment\n    hetero_adj = 1 / (1 + std)\n\n    # Triangle density adjustment\n    possible_triangles = n * (n - 1) / 2\n    tri_density = tri / max(possible_triangles, 1)\n    tri_adj = 1 / (1 + tri_density)\n\n    return base * cluster_adj * assort_adj * hetero_adj * tri_adj", "spearman": 0.8443051076276908, "pearson": 0.7551372392001262, "rmse": 2.4004976596027023, "mae": 1.5422159049846003}}
{"timestamp": "2026-02-16T07:53:05.060996+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 5, "island_id": 2, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:53:28.572213+00:00", "event_type": "candidate_rejected", "payload": {"generation": 5, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.113313", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:53:28.572570+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 5, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.113313", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:53:53.473316+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i2_p1_412496576", "generation": 5, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.4978151260504201, "fitness_mode": "correlation", "simplicity_score": 0.12336355135147392, "novelty_bonus": 0.33987343404771064, "total_score": 0.4127458932634275, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.147637\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.118759\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.113313\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from simple graph statistics.\n    The estimate combines:\n      - A base term n/(m+1)  (more nodes or fewer edges → longer paths)\n      - A density adjustment: (1 + (1 - density))  (sparser graphs → longer paths)\n      - A clustering & assortativity multiplier: (1 + avg_clustering) * (1 + degree_assortativity)\n      - A heterogeneity divisor: 1/(1 + std_degree)  (larger degree spread → shorter paths)\n    All operations are safe from division by zero and use only built‑in arithmetic.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Base term: more nodes or fewer edges increase path lengths\n    base = n / (m + 1)\n\n    # Density factor: sparser graphs tend to have longer paths\n    density_factor = 1 + (1 - density)\n\n    # Clustering & assortativity multiplier\n    cluster_assort_factor = (1 + c) * (1 + a)\n\n    # Heterogeneity divisor: higher degree variance shortens paths\n    hetero_factor = 1 / (1 + std)\n\n    return base * density_factor * cluster_assort_factor * hetero_factor\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The estimate is a multiplicative combination of several structural\n    indicators.  All intermediate terms are clamped to avoid division by\n    zero and keep the expression well‑defined for all graphs.\n\n    Components\n    ----------\n    base          : n / (m + 1)                       # more nodes or fewer edges → longer paths\n    density_factor: 1 + (1 - density)                # sparser graphs → longer paths\n    triangle_factor: 1 + num_triangles / (n + 1)     # more triangles → slightly shorter paths\n    max_factor    : 1 / (1 + max_degree)              # hubs shorten paths\n    min_factor    : 1 + min_degree / (n + 1)          # very low degrees can lengthen paths\n    assort_factor : 1 + abs(degree_assortativity)    # positive assortativity tends to lengthen paths\n    clust_factor  : 1 + avg_clustering               # high clustering can create detours\n    hetero_factor : 1 / (1 + std_degree)             # high degree heterogeneity shortens paths\n\n    All multipliers are positive and the product gives a rough estimate of\n    the average shortest path length.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    assort     = s['degree_assortativity']\n    clustering = s['avg_clustering']\n\n    # Base term: node count over edge count\n    base = n / (m + 1)\n\n    # Sparser graphs tend to have longer paths\n    density_factor = 1 + (1 - density)\n\n    # More triangles tend to create shortcuts\n    triangle_factor = 1 + num_tri / (n + 1)\n\n    # Hubs (high max degree) shorten paths\n    max_factor = 1 / (1 + max_deg)\n\n    # Very low degree nodes can lengthen paths\n    min_factor = 1 + min_deg / (n + 1)\n\n    # Positive assortativity lengthens paths, negative shortens them\n    assort_factor = 1 + abs(assort)\n\n    # Clustering can create local detours\n    clust_factor = 1 + clustering\n\n    # Degree heterogeneity shortens paths\n    hetero_factor = 1 / (1 + std_deg)\n\n    return (base *\n            density_factor *\n            triangle_factor *\n            max_factor *\n            min_factor *\n            assort_factor *\n            clust_factor *\n            hetero_factor)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The estimate is a multiplicative combination of several structural\n    indicators.  All intermediate terms are clamped to avoid division by\n    zero and keep the expression well‑defined for all graphs.\n\n    Components\n    ----------\n    base          : n / (m + 1)                       # more nodes or fewer edges → longer paths\n    density_factor: 1 + (1 - density)                # sparser graphs → longer paths\n    triangle_factor: 1 + num_triangles / (n + 1)     # more triangles → slightly shorter paths\n    max_factor    : 1 / (1 + max_degree)              # hubs shorten paths\n    min_factor    : 1 + min_degree / (n + 1)          # very low degrees can lengthen paths\n    assort_factor : 1 + abs(degree_assortativity)    # positive assortativity tends to lengthen paths\n    clust_factor  : 1 + avg_clustering               # high clustering can create detours\n    hetero_factor : 1 / (1 + std_degree)             # high degree heterogeneity shortens paths\n\n    All multipliers are positive and the product gives a rough estimate of\n    the average shortest path length.\n    \"\"\"\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    assort     = s['degree_assortativity']\n    clustering = s['avg_clustering']\n\n    # Base term: node count over edge count\n    base = n / (m + 1)\n\n    # Sparser graphs tend to have longer paths\n    density_factor = 1 + (1 - density)\n\n    # More triangles tend to create shortcuts\n    triangle_factor = 1 + num_tri / (n + 1)\n\n    # Hubs (high max degree) shorten paths\n    max_factor = 1 / (1 + max_deg)\n\n    # Very low degree nodes can lengthen paths\n    min_factor = 1 + min_deg / (n + 1)\n\n    # Positive assortativity lengthens paths, negative shortens them\n    assort_factor = 1 + abs(assort)\n\n    # Clustering can create local detours\n    clust_factor = 1 + clustering\n\n    # Degree heterogeneity shortens paths\n    hetero_factor = 1 / (1 + std_deg)\n\n    return (base *\n            density_factor *\n            triangle_factor *\n            max_factor *\n            min_factor *\n            assort_factor *\n            clust_factor *\n            hetero_factor)", "spearman": 0.5722223055576391, "pearson": 0.5773075560605356, "rmse": 2.8194310565346616, "mae": 2.657915707268099}}
{"timestamp": "2026-02-16T07:53:53.474052+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 5, "island_id": 2, "population_idx": 1, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:54:19.291917+00:00", "event_type": "candidate_rejected", "payload": {"generation": 5, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.124672", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:54:19.292325+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 5, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.124672", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:54:53.671831+00:00", "event_type": "candidate_rejected", "payload": {"generation": 5, "island_id": 2, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.030406", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:54:53.672256+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 5, "island_id": 2, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:55:26.016948+00:00", "event_type": "candidate_rejected", "payload": {"generation": 5, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:55:26.017857+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 5, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:55:54.149857+00:00", "event_type": "candidate_rejected", "payload": {"generation": 5, "island_id": 2, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.113271", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:55:54.150175+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 5, "island_id": 2, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:56:41.251451+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i2_p4_109720158", "generation": 5, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7277310924369748, "fitness_mode": "correlation", "simplicity_score": 0.14348093828453246, "novelty_bonus": 0.16271880022741858, "total_score": 0.5232577213724733, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.030406\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.113271\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The estimate is built from a few multiplicative factors that capture\n    the main structural influences on path length:\n\n    1. **Base term** – scales with the ratio of node count to average degree.\n    2. **Density & clustering** – higher density and clustering tend to\n       increase the average path length, so we multiply by (1 + density)\n       and (1 + avg_clustering).\n    3. **Transitivity** – a global measure of clustering, added as another\n       multiplier.\n    4. **Assortativity** – positive assortativity usually lengthens paths,\n       while negative assortativity shortens them; we use the absolute value\n       to keep the factor monotonic.\n    5. **Degree heterogeneity** – a large standard deviation of degrees\n       (presence of hubs) typically shortens paths; we divide by (1 + std).\n    6. **Triangularity** – the number of triangles relative to n² is a\n       small correction factor that slightly increases the estimate.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    num_tri = s['num_triangles']\n\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Multiplicative adjustment for density, clustering, transitivity, assortativity\n    factor = (1 + density) * (1 + avg_clust) * (1 + trans) * (1 + abs(assort))\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std_deg)\n\n    # Small correction for the number of triangles\n    tri_adj = 1 + (num_tri / max(n ** 2, 1))\n\n    return base * factor * hetero * tri_adj\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The estimate is built from a few multiplicative factors that capture\n    the main structural influences on path length:\n\n    1. **Base term** – scales with the ratio of node count to average degree.\n    2. **Density & clustering** – higher density and clustering tend to\n       increase the average path length, so we multiply by (1 + density)\n       and (1 + avg_clustering).\n    3. **Transitivity** – a global measure of clustering, added as another\n       multiplier.\n    4. **Assortativity** – positive assortativity usually lengthens paths,\n       while negative assortativity shortens them; we use the absolute value\n       to keep the factor monotonic.\n    5. **Degree heterogeneity** – a large standard deviation of degrees\n       (presence of hubs) typically shortens paths; we divide by (1 + std).\n    6. **Triangularity** – the number of triangles relative to n² is a\n       small correction factor that slightly increases the estimate.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    num_tri = s['num_triangles']\n\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Multiplicative adjustment for density, clustering, transitivity, assortativity\n    factor = (1 + density) * (1 + avg_clust) * (1 + trans) * (1 + abs(assort))\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std_deg)\n\n    # Small correction for the number of triangles\n    tri_adj = 1 + (num_tri / max(n ** 2, 1))\n\n    return base * factor * hetero * tri_adj", "spearman": 0.8914917872946825, "pearson": 0.8265456584614095, "rmse": 4.5126379622838835, "mae": 3.2020959399302864}}
{"timestamp": "2026-02-16T07:57:18.684318+00:00", "event_type": "candidate_rejected", "payload": {"generation": 5, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:57:18.684898+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 5, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:57:44.854726+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i3_p0_251970817", "generation": 5, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6104681872749098, "fitness_mode": "correlation", "simplicity_score": 0.24860980274794608, "novelty_bonus": 0.37244431110777754, "total_score": 0.47042997825003174, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the graph's average shortest‑path length.\n\n    This expression mixes several topological signals—size, density,\n    degree dispersion, harmonic degree behaviour, clustering/transitivity,\n    triangle abundance, and degree assortativity—into a single multiplicative\n    formula.  It avoids any direct lookup of a pre‑computed distance metric\n    and uses only built‑in Python operations.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features with keys:\n        'n', 'm', 'density', 'avg_degree', 'max_degree', 'min_degree',\n        'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'num_triangles', 'degrees' (sorted list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # --- Extract the basic quantities -------------------------------------------------\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']                     # list of ints\n\n    # --- Size–density hybrid (penalises sparsity) ---------------------------------------\n    size_term = (n ** 0.6) / (m + 1.0)\n\n    # --- Density penalty (sparser graphs inflate the estimate) ------------------------\n    density_term = 1.0 / (density + 1e-6)\n\n    # --- Degree‑dispersion influence ---------------------------------------------------\n    deg_range = max_deg - min_deg + 1.0\n    dispersion_term = deg_range ** 0.4\n\n    # --- Harmonic mean of degrees (captures skewness of the distribution) --------------\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic_mean\n\n    # --- Clustering–transitivity reduction (high clustering → shorter paths) ----------\n    cluster_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # --- Triangle shortcut effect (more triangles tend to shrink paths) ----------------\n    triangle_term = (triangles + 1.0) ** 0.3\n\n    # --- Assortativity boost (mixing can create shortcuts) ----------------------------\n    assort_term = 1.0 + abs(assort)\n\n    # --- Combine everything ------------------------------------------------------------\n    inv = (size_term * density_term * dispersion_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.296134\nbelow_train_threshold: train_signal=0.298439\nbelow_train_threshold: train_signal=0.051429\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport math\n\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest‑path length built from a mix\n    of global graph statistics.  The expression deliberately blends\n    size, density, degree dispersion, harmonic degree behaviour,\n    clustering/transitivity, triangle abundance and degree assortativity,\n    avoiding any single feature or explicit path‑finding algorithm.\n    \"\"\"\n    # ---------- Basic quantities ----------\n    n            = float(s['n'])\n    m            = float(s['m'])\n    density      = float(s['density'])\n    max_deg      = float(s['max_degree'])\n    min_deg      = float(s['min_degree'])\n    avg_degree   = float(s['avg_degree'])\n    avg_clust    = float(s['avg_clustering'])\n    transitivity = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    triangles    = float(s['num_triangles'])\n    degrees      = s['degrees']                # list of integers\n\n    # ---------- Harmonic mean of degrees ----------\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / d\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid division by zero\n\n    # ---------- Size × density hybrid ----------\n    # Large n and small m → longer paths\n    size_density = (math.log(n + 1) * (m + 1)) / (density + 1e-9)\n\n    # ---------- Degree‑dispersion influence ----------\n    deg_range      = max_deg - min_deg + 1.0\n    dispersion_term = deg_range ** 0.3\n\n    # ---------- Clustering / transitivity reduction ----------\n    cluster_term = 1.0 / (avg_clust + transitivity + 1e-9)\n\n    # ---------- Triangle shortcut effect ----------\n    triangle_term = (triangles + 1.0) ** 0.25\n\n    # ---------- Assortativity boost ----------\n    assort_term = 1.0 + abs(assort)\n\n    # ---------- Assemble everything ----------\n    value = (size_density * dispersion_term *\n             harmonic_mean * assort_term)\n    value = value / (cluster_term * triangle_term)\n\n    return value\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest‑path length from global\n    graph statistics.  The expression mixes size, density, degree\n    dispersion, the harmonic mean of degrees, clustering/transitivity,\n    triangle abundance and assortativity.  No external libraries are\n    required and no single feature dominates the result.\n    \"\"\"\n    n           = float(s['n'])\n    m           = float(s['m'])\n    density     = float(s['density'])\n    max_deg     = float(s['max_degree'])\n    min_deg     = float(s['min_degree'])\n    avg_clust   = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    triangles   = float(s['num_triangles'])\n    degrees     = s['degrees']                 # list of integers\n\n    # ----- Size‑density hybrid term -----\n    size_term = (n ** 0.7) / (m + 1.0)\n\n    # ----- Density penalty (sparser graphs → larger estimate) -----\n    density_term = 1.0 / (density + 1e-6)\n\n    # ----- Degree‑dispersion influence -----\n    disp_term = (max_deg - min_deg + 1.0) ** 0.3\n\n    # ----- Harmonic mean of degrees (captures skewness) -----\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_term = n / (harmonic_sum + 1e-12)\n\n    # ----- Clustering/transitivity reduction (more clustering shortens paths) -----\n    cluster_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # ----- Triangle shortcut effect (more triangles shortens paths) -----\n    triangle_term = (triangles + 1.0) ** 0.3\n\n    # ----- Assortativity boost (mixing can create shortcuts) -----\n    assort_term = 1.0 + abs(assort)\n\n    # ----- Assemble invariant -----\n    inv = (size_term * density_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest‑path length from global\n    graph statistics.  The expression mixes size, density, degree\n    dispersion, the harmonic mean of degrees, clustering/transitivity,\n    triangle abundance and assortativity.  No external libraries are\n    required and no single feature dominates the result.\n    \"\"\"\n    n           = float(s['n'])\n    m           = float(s['m'])\n    density     = float(s['density'])\n    max_deg     = float(s['max_degree'])\n    min_deg     = float(s['min_degree'])\n    avg_clust   = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    triangles   = float(s['num_triangles'])\n    degrees     = s['degrees']                 # list of integers\n\n    # ----- Size‑density hybrid term -----\n    size_term = (n ** 0.7) / (m + 1.0)\n\n    # ----- Density penalty (sparser graphs → larger estimate) -----\n    density_term = 1.0 / (density + 1e-6)\n\n    # ----- Degree‑dispersion influence -----\n    disp_term = (max_deg - min_deg + 1.0) ** 0.3\n\n    # ----- Harmonic mean of degrees (captures skewness) -----\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_term = n / (harmonic_sum + 1e-12)\n\n    # ----- Clustering/transitivity reduction (more clustering shortens paths) -----\n    cluster_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # ----- Triangle shortcut effect (more triangles shortens paths) -----\n    triangle_term = (triangles + 1.0) ** 0.3\n\n    # ----- Assortativity boost (mixing can create shortcuts) -----\n    assort_term = 1.0 + abs(assort)\n\n    # ----- Assemble invariant -----\n    inv = (size_term * density_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv", "spearman": 0.6179494487362185, "pearson": 0.7401676981792735, "rmse": 1.5863789889424686, "mae": 1.4188452808719976}}
{"timestamp": "2026-02-16T07:57:44.855262+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 5, "island_id": 3, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T07:58:21.749133+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i3_p1_704590287", "generation": 5, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6306362545018007, "fitness_mode": "correlation", "simplicity_score": 0.24860980274794608, "novelty_bonus": 0.36456911422785565, "total_score": 0.4690154428866477, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the graph's average shortest‑path length.\n\n    This expression mixes several topological signals—size, density,\n    degree dispersion, harmonic degree behaviour, clustering/transitivity,\n    triangle abundance, and degree assortativity—into a single multiplicative\n    formula.  It avoids any direct lookup of a pre‑computed distance metric\n    and uses only built‑in Python operations.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features with keys:\n        'n', 'm', 'density', 'avg_degree', 'max_degree', 'min_degree',\n        'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'num_triangles', 'degrees' (sorted list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # --- Extract the basic quantities -------------------------------------------------\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']                     # list of ints\n\n    # --- Size–density hybrid (penalises sparsity) ---------------------------------------\n    size_term = (n ** 0.6) / (m + 1.0)\n\n    # --- Density penalty (sparser graphs inflate the estimate) ------------------------\n    density_term = 1.0 / (density + 1e-6)\n\n    # --- Degree‑dispersion influence ---------------------------------------------------\n    deg_range = max_deg - min_deg + 1.0\n    dispersion_term = deg_range ** 0.4\n\n    # --- Harmonic mean of degrees (captures skewness of the distribution) --------------\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic_mean\n\n    # --- Clustering–transitivity reduction (high clustering → shorter paths) ----------\n    cluster_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # --- Triangle shortcut effect (more triangles tend to shrink paths) ----------------\n    triangle_term = (triangles + 1.0) ** 0.3\n\n    # --- Assortativity boost (mixing can create shortcuts) ----------------------------\n    assort_term = 1.0 + abs(assort)\n\n    # --- Combine everything ------------------------------------------------------------\n    inv = (size_term * density_term * dispersion_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.298439\nbelow_train_threshold: train_signal=0.051429\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length from pre‑computed\n    global features.  The expression mixes several topological signals\n    (size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle count and assortativity) into a single\n    multiplicative formula.  It uses only built‑in Python operations\n    and does not rely on any explicit shortest‑path algorithm.\n    \"\"\"\n    # basic quantities\n    n   = float(s['n'])\n    m   = float(s['m'])\n    d   = float(s['density'])\n    max_d = float(s['max_degree'])\n    min_d = float(s['min_degree'])\n    ac   = float(s['avg_clustering'])\n    tr   = float(s['transitivity'])\n    ass  = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n    degs = s['degrees']\n\n    # harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for dv in degs:\n        if dv > 0:\n            h_sum += 1.0 / float(dv)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # individual components\n    size_term     = (n ** 0.7) / (m + 1.0)                # larger n → larger distance\n    density_term  = 1.0 / (d + 1e-6)                      # sparser → larger distance\n    disp_term     = (max_d - min_d + 1.0) ** 0.3           # degree dispersion effect\n    cluster_term  = 1.0 / (ac + tr + 1e-6)                 # high clustering shortens paths\n    tri_term      = (num_tri + 1.0) ** 0.35                # more triangles → shorter paths\n    assort_term   = 1.0 + abs(ass)                         # assortative mixing can create shortcuts\n\n    # final composite invariant\n    inv = (size_term * density_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length from pre‑computed\n    global features.  The expression mixes several topological signals\n    (size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle count and assortativity) into a single\n    multiplicative formula.  It uses only built‑in Python operations\n    and does not rely on any explicit shortest‑path algorithm.\n    \"\"\"\n    # basic quantities\n    n   = float(s['n'])\n    m   = float(s['m'])\n    d   = float(s['density'])\n    max_d = float(s['max_degree'])\n    min_d = float(s['min_degree'])\n    ac   = float(s['avg_clustering'])\n    tr   = float(s['transitivity'])\n    ass  = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n    degs = s['degrees']\n\n    # harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for dv in degs:\n        if dv > 0:\n            h_sum += 1.0 / float(dv)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # individual components\n    size_term     = (n ** 0.7) / (m + 1.0)                # larger n → larger distance\n    density_term  = 1.0 / (d + 1e-6)                      # sparser → larger distance\n    disp_term     = (max_d - min_d + 1.0) ** 0.3           # degree dispersion effect\n    cluster_term  = 1.0 / (ac + tr + 1e-6)                 # high clustering shortens paths\n    tri_term      = (num_tri + 1.0) ** 0.35                # more triangles → shorter paths\n    assort_term   = 1.0 + abs(ass)                         # assortative mixing can create shortcuts\n\n    # final composite invariant\n    inv = (size_term * density_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.6198454961374036, "pearson": 0.7299547186722752, "rmse": 1.807414703469885, "mae": 1.6766598979430642}}
{"timestamp": "2026-02-16T07:58:55.522247+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i3_p2_43273802", "generation": 5, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5936614645858344, "fitness_mode": "correlation", "simplicity_score": 0.24860980274794608, "novelty_bonus": 0.39074476861921537, "total_score": 0.47385456386467206, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the graph's average shortest‑path length.\n\n    This expression mixes several topological signals—size, density,\n    degree dispersion, harmonic degree behaviour, clustering/transitivity,\n    triangle abundance, and degree assortativity—into a single multiplicative\n    formula.  It avoids any direct lookup of a pre‑computed distance metric\n    and uses only built‑in Python operations.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features with keys:\n        'n', 'm', 'density', 'avg_degree', 'max_degree', 'min_degree',\n        'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'num_triangles', 'degrees' (sorted list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # --- Extract the basic quantities -------------------------------------------------\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']                     # list of ints\n\n    # --- Size–density hybrid (penalises sparsity) ---------------------------------------\n    size_term = (n ** 0.6) / (m + 1.0)\n\n    # --- Density penalty (sparser graphs inflate the estimate) ------------------------\n    density_term = 1.0 / (density + 1e-6)\n\n    # --- Degree‑dispersion influence ---------------------------------------------------\n    deg_range = max_deg - min_deg + 1.0\n    dispersion_term = deg_range ** 0.4\n\n    # --- Harmonic mean of degrees (captures skewness of the distribution) --------------\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic_mean\n\n    # --- Clustering–transitivity reduction (high clustering → shorter paths) ----------\n    cluster_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # --- Triangle shortcut effect (more triangles tend to shrink paths) ----------------\n    triangle_term = (triangles + 1.0) ** 0.3\n\n    # --- Assortativity boost (mixing can create shortcuts) ----------------------------\n    assort_term = 1.0 + abs(assort)\n\n    # --- Combine everything ------------------------------------------------------------\n    inv = (size_term * density_term * dispersion_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.298439\nbelow_train_threshold: train_signal=0.051429\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length.\n\n    This heuristic blends several global topological signals—\n    size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, and assortativity—\n    without using any external libraries or explicit shortest‑path\n    algorithms.  All operations are built‑in Python functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys listed in the prompt.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert main numeric features to float for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass   = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    degs  = s['degrees']          # list of int degrees\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase paths)\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get a larger value\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees (captures skewness of the distribution)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction: high clustering tends to shorten paths\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles tend to shrink paths\n    tri_term = (tri + 1.0) ** 0.3\n\n    # 7. Assortativity boost: mixing can create shortcuts\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length.\n\n    This heuristic blends several global topological signals—\n    size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, and assortativity—\n    without using any external libraries or explicit shortest‑path\n    algorithms.  All operations are built‑in Python functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys listed in the prompt.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert main numeric features to float for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass   = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    degs  = s['degrees']          # list of int degrees\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase paths)\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get a larger value\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees (captures skewness of the distribution)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction: high clustering tends to shorten paths\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles tend to shrink paths\n    tri_term = (tri + 1.0) ** 0.3\n\n    # 7. Assortativity boost: mixing can create shortcuts\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.6138183454586364, "pearson": 0.7433129289161846, "rmse": 1.3505234140000788, "mae": 0.9946018529878919}}
{"timestamp": "2026-02-16T07:59:23.101433+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i3_p3_858393427", "generation": 5, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6104681872749098, "fitness_mode": "correlation", "simplicity_score": 0.2484472613346054, "novelty_bonus": 0.37244431110777754, "total_score": 0.47039746996736354, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the graph's average shortest‑path length.\n\n    This expression mixes several topological signals—size, density,\n    degree dispersion, harmonic degree behaviour, clustering/transitivity,\n    triangle abundance, and degree assortativity—into a single multiplicative\n    formula.  It avoids any direct lookup of a pre‑computed distance metric\n    and uses only built‑in Python operations.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features with keys:\n        'n', 'm', 'density', 'avg_degree', 'max_degree', 'min_degree',\n        'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'num_triangles', 'degrees' (sorted list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # --- Extract the basic quantities -------------------------------------------------\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']                     # list of ints\n\n    # --- Size–density hybrid (penalises sparsity) ---------------------------------------\n    size_term = (n ** 0.6) / (m + 1.0)\n\n    # --- Density penalty (sparser graphs inflate the estimate) ------------------------\n    density_term = 1.0 / (density + 1e-6)\n\n    # --- Degree‑dispersion influence ---------------------------------------------------\n    deg_range = max_deg - min_deg + 1.0\n    dispersion_term = deg_range ** 0.4\n\n    # --- Harmonic mean of degrees (captures skewness of the distribution) --------------\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic_mean\n\n    # --- Clustering–transitivity reduction (high clustering → shorter paths) ----------\n    cluster_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # --- Triangle shortcut effect (more triangles tend to shrink paths) ----------------\n    triangle_term = (triangles + 1.0) ** 0.3\n\n    # --- Assortativity boost (mixing can create shortcuts) ----------------------------\n    assort_term = 1.0 + abs(assort)\n\n    # --- Combine everything ------------------------------------------------------------\n    inv = (size_term * density_term * dispersion_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.298439\nbelow_train_threshold: train_signal=0.051429\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the graph's average shortest‑path length\n    built from a multiplicative combination of global topological\n    descriptors.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed graph features with keys:\n        'n', 'm', 'density', 'avg_degree', 'max_degree', 'min_degree',\n        'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'num_triangles', 'degrees' (sorted list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    n           = float(s['n'])\n    m           = float(s['m'])\n    density     = float(s['density'])\n    max_deg     = float(s['max_degree'])\n    min_deg     = float(s['min_degree'])\n    avg_clust   = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    triangles   = float(s['num_triangles'])\n    degrees     = s['degrees']                    # list of integers\n\n    # Size–density hybrid: larger, sparser graphs contribute more\n    size_term = (n ** 0.7) / (m + 1.0)\n\n    # Density penalty: sparse graphs raise the estimate\n    density_term = 1.0 / (density + 1e-6)\n\n    # Degree dispersion: a wider spread tends to increase distances\n    disp_term = (max_deg - min_deg + 1.0) ** 0.3\n\n    # Harmonic mean of degrees: captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic_mean\n\n    # Clustering–transitivity reduction: high clustering shortens paths\n    cluster_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # Triangle shortcut effect: more triangles typically reduce distances\n    triangle_term = (triangles + 1.0) ** 0.3\n\n    # Assortativity boost: assortative mixing can create shortcuts\n    assort_term = 1.0 + abs(assort)\n\n    # Combine all components multiplicatively, then correct for\n    # clustering and triangles\n    inv = (size_term * density_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the graph's average shortest‑path length\n    built from a multiplicative combination of global topological\n    descriptors.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed graph features with keys:\n        'n', 'm', 'density', 'avg_degree', 'max_degree', 'min_degree',\n        'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'num_triangles', 'degrees' (sorted list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    n           = float(s['n'])\n    m           = float(s['m'])\n    density     = float(s['density'])\n    max_deg     = float(s['max_degree'])\n    min_deg     = float(s['min_degree'])\n    avg_clust   = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    triangles   = float(s['num_triangles'])\n    degrees     = s['degrees']                    # list of integers\n\n    # Size–density hybrid: larger, sparser graphs contribute more\n    size_term = (n ** 0.7) / (m + 1.0)\n\n    # Density penalty: sparse graphs raise the estimate\n    density_term = 1.0 / (density + 1e-6)\n\n    # Degree dispersion: a wider spread tends to increase distances\n    disp_term = (max_deg - min_deg + 1.0) ** 0.3\n\n    # Harmonic mean of degrees: captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic_mean\n\n    # Clustering–transitivity reduction: high clustering shortens paths\n    cluster_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # Triangle shortcut effect: more triangles typically reduce distances\n    triangle_term = (triangles + 1.0) ** 0.3\n\n    # Assortativity boost: assortative mixing can create shortcuts\n    assort_term = 1.0 + abs(assort)\n\n    # Combine all components multiplicatively, then correct for\n    # clustering and triangles\n    inv = (size_term * density_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv", "spearman": 0.6179494487362185, "pearson": 0.7401676981792735, "rmse": 1.5863789889424686, "mae": 1.4188452808719976}}
{"timestamp": "2026-02-16T07:59:52.883218+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g5_i3_p4_407237922", "generation": 5, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5946218487394958, "fitness_mode": "correlation", "simplicity_score": 0.2484472613346054, "novelty_bonus": 0.3857931448286206, "total_score": 0.4669596840227149, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the graph's average shortest‑path length.\n\n    This expression mixes several topological signals—size, density,\n    degree dispersion, harmonic degree behaviour, clustering/transitivity,\n    triangle abundance, and degree assortativity—into a single multiplicative\n    formula.  It avoids any direct lookup of a pre‑computed distance metric\n    and uses only built‑in Python operations.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features with keys:\n        'n', 'm', 'density', 'avg_degree', 'max_degree', 'min_degree',\n        'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'num_triangles', 'degrees' (sorted list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # --- Extract the basic quantities -------------------------------------------------\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    triangles  = float(s['num_triangles'])\n    degrees    = s['degrees']                     # list of ints\n\n    # --- Size–density hybrid (penalises sparsity) ---------------------------------------\n    size_term = (n ** 0.6) / (m + 1.0)\n\n    # --- Density penalty (sparser graphs inflate the estimate) ------------------------\n    density_term = 1.0 / (density + 1e-6)\n\n    # --- Degree‑dispersion influence ---------------------------------------------------\n    deg_range = max_deg - min_deg + 1.0\n    dispersion_term = deg_range ** 0.4\n\n    # --- Harmonic mean of degrees (captures skewness of the distribution) --------------\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n    harmonic_term = harmonic_mean\n\n    # --- Clustering–transitivity reduction (high clustering → shorter paths) ----------\n    cluster_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # --- Triangle shortcut effect (more triangles tend to shrink paths) ----------------\n    triangle_term = (triangles + 1.0) ** 0.3\n\n    # --- Assortativity boost (mixing can create shortcuts) ----------------------------\n    assort_term = 1.0 + abs(assort)\n\n    # --- Combine everything ------------------------------------------------------------\n    inv = (size_term * density_term * dispersion_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.298439\nbelow_train_threshold: train_signal=0.051429\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_triangles = float(s['num_triangles'])\n    degrees = s['degrees']\n\n    eps = 1e-6\n\n    size_term = (n ** 0.7) / (m + 1.0)\n    density_term = 1.0 / (density + eps)\n    disp_term = (max_deg - min_deg + 1.0) ** 0.4\n\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_term = n / (harmonic_sum + eps)\n\n    cluster_term = 1.0 / (avg_clust + trans + eps)\n    triangle_term = (num_triangles + 1.0) ** 0.3\n    assort_term = 1.0 + abs(assort)\n\n    inv = (size_term * density_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv", "extracted_code": "def new_invariant(s):\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_triangles = float(s['num_triangles'])\n    degrees = s['degrees']\n\n    eps = 1e-6\n\n    size_term = (n ** 0.7) / (m + 1.0)\n    density_term = 1.0 / (density + eps)\n    disp_term = (max_deg - min_deg + 1.0) ** 0.4\n\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_term = n / (harmonic_sum + eps)\n\n    cluster_term = 1.0 / (avg_clust + trans + eps)\n    triangle_term = (num_triangles + 1.0) ** 0.3\n    assort_term = 1.0 + abs(assort)\n\n    inv = (size_term * density_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv", "spearman": 0.6030645766144154, "pearson": 0.7298174750261003, "rmse": 1.3753420117504702, "mae": 1.1319934707785417}}
{"timestamp": "2026-02-16T07:59:52.886661+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 6, "model_name": "gpt-oss:20b", "best_val_score": 0.5358322776835298, "no_improve_count": 5}}
{"timestamp": "2026-02-16T08:00:21.506565+00:00", "event_type": "candidate_rejected", "payload": {"generation": 6, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:00:21.507489+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 6, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:01:24.127942+00:00", "event_type": "candidate_rejected", "payload": {"generation": 6, "island_id": 0, "population_idx": 0, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:01:24.129461+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 6, "island_id": 0, "population_idx": 0, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:01:57.485969+00:00", "event_type": "candidate_rejected", "payload": {"generation": 6, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:01:57.486946+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 6, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:02:52.303692+00:00", "event_type": "candidate_rejected", "payload": {"generation": 6, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:02:52.304685+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 6, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:04:29.075543+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i0_p2_725028159", "generation": 6, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.3766146458583433, "fitness_mode": "correlation", "simplicity_score": 0.1180887632114264, "novelty_bonus": 0.1850707060905643, "total_score": 0.2905887507141107, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: scales with sqrt(n) and inversely with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-12\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = n / (avg_deg + 1)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + 1)           # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.033894\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_degree = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: scales with sqrt(n) and inversely with average degree\n    baseline = pow(n, 0.5) / (avg_degree + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 / (density + eps)                     # sparser graphs → longer paths\n    clustering_adj = 1 / (clustering + eps)                 # higher clustering → shorter paths\n    trans_adj     = 1 / (transitivity + eps)                # higher transitivity → shorter paths\n    assort_adj    = 1 + assort                              # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_degree + eps)        # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)             # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)   # more triangles → shorter paths\n    min_deg_adj   = 1 / (min_deg + 1)                       # very low minimum degree → longer paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    trans_adj     = max(0.1, min(10, trans_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n    min_deg_adj   = max(0.1, min(10, min_deg_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * trans_adj * assort_adj * hetero_adj * hub_adj * triangle_adj * min_deg_adj", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_degree = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: scales with sqrt(n) and inversely with average degree\n    baseline = pow(n, 0.5) / (avg_degree + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 / (density + eps)                     # sparser graphs → longer paths\n    clustering_adj = 1 / (clustering + eps)                 # higher clustering → shorter paths\n    trans_adj     = 1 / (transitivity + eps)                # higher transitivity → shorter paths\n    assort_adj    = 1 + assort                              # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_degree + eps)        # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)             # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)   # more triangles → shorter paths\n    min_deg_adj   = 1 / (min_deg + 1)                       # very low minimum degree → longer paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    trans_adj     = max(0.1, min(10, trans_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n    min_deg_adj   = max(0.1, min(10, min_deg_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * trans_adj * assort_adj * hetero_adj * hub_adj * triangle_adj * min_deg_adj", "spearman": 0.4228995724893123, "pearson": 0.1523570885707641, "rmse": 100.7788473866061, "mae": 50.476339278864195}}
{"timestamp": "2026-02-16T08:05:04.907472+00:00", "event_type": "candidate_rejected", "payload": {"generation": 6, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:05:04.908329+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 6, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:05:25.878385+00:00", "event_type": "candidate_rejected", "payload": {"generation": 6, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:05:25.879276+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 6, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:06:18.845664+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i0_p4_816008749", "generation": 6, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.44816326530612244, "fitness_mode": "correlation", "simplicity_score": 0.12333767116259307, "novelty_bonus": 0.2622397629033182, "total_score": 0.33766482123746744, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: scales with sqrt(n) and inversely with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    eps = 1e-12\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = n / (avg_deg + 1)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + 1)           # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.033894\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser → longer paths\n    clustering_adj = 1 - clustering                      # more clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser → longer paths\n    clustering_adj = 1 - clustering                      # more clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.4686507162679068, "pearson": 0.37156436832847817, "rmse": 2.242179205602687, "mae": 2.042449420766387}}
{"timestamp": "2026-02-16T08:07:22.824667+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i1_p0_419565975", "generation": 6, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15349720539652392, "novelty_bonus": 0.25199429985749633, "total_score": 0.2847136914355637, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    A dimensionless graph invariant that combines size, degree distribution,\n    clustering, triangle count, assortativity, and degree range information.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s.get('density', 0)\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range info\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    # and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0)\n    avg_deg = s.get('avg_degree', 0)\n    avg_clust = s.get('avg_clustering', 0)\n    trans = s.get('transitivity', 0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    std_deg = s.get('std_degree', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    num_tri = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    numerator = (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans) + norm_sq + (num_tri + 1) ** 0.5 + (max_deg + 1) ** 0.5 + (min_deg + 1) ** 0.5\n\n    denom = 1 + m + density + num_tri + abs(deg_assort) + std_deg + (max_deg + 1) + (min_deg + 1)\n\n    return numerator / denom", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0)\n    avg_deg = s.get('avg_degree', 0)\n    avg_clust = s.get('avg_clustering', 0)\n    trans = s.get('transitivity', 0)\n    max_deg = s.get('max_degree', 0)\n    min_deg = s.get('min_degree', 0)\n    std_deg = s.get('std_degree', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    num_tri = s.get('num_triangles', 0)\n    degrees = s.get('degrees', [])\n\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    numerator = (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans) + norm_sq + (num_tri + 1) ** 0.5 + (max_deg + 1) ** 0.5 + (min_deg + 1) ** 0.5\n\n    denom = 1 + m + density + num_tri + abs(deg_assort) + std_deg + (max_deg + 1) + (min_deg + 1)\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T08:07:48.561753+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i1_p1_287467450", "generation": 6, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15394154834809554, "novelty_bonus": 0.25199429985749633, "total_score": 0.284802560025878, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    A dimensionless graph invariant that combines size, degree distribution,\n    clustering, triangle count, assortativity, and degree range information.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s.get('density', 0)\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range info\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    # and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0)\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0)\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T08:08:16.598768+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i1_p2_87107484", "generation": 6, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15394154834809554, "novelty_bonus": 0.25199429985749633, "total_score": 0.284802560025878, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    A dimensionless graph invariant that combines size, degree distribution,\n    clustering, triangle count, assortativity, and degree range information.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s.get('density', 0)\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range info\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    # and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s.get('density', 0)\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range info\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s.get('density', 0)\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range info\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T08:09:02.288422+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i1_p3_117456868", "generation": 6, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15394154834809554, "novelty_bonus": 0.25199429985749633, "total_score": 0.284802560025878, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    A dimensionless graph invariant that combines size, degree distribution,\n    clustering, triangle count, assortativity, and degree range information.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s.get('density', 0)\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range info\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    # and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s.get('density', 0)\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range info\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s.get('density', 0)\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range info\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T08:09:25.091162+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i1_p4_185789124", "generation": 6, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15401258590532532, "novelty_bonus": 0.25199429985749633, "total_score": 0.28481676753732393, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    A dimensionless graph invariant that combines size, degree distribution,\n    clustering, triangle count, assortativity, and degree range information.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s.get('density', 0)\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range info\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    # and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T08:10:06.960885+00:00", "event_type": "candidate_rejected", "payload": {"generation": 6, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.105996", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:10:06.961755+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 6, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.105996", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:10:29.639961+00:00", "event_type": "candidate_rejected", "payload": {"generation": 6, "island_id": 2, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.085600", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:10:29.640309+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 6, "island_id": 2, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:11:18.659384+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i2_p1_9835028", "generation": 6, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8082112845138055, "fitness_mode": "correlation", "simplicity_score": 0.13457704057347636, "novelty_bonus": 0.16597308238851172, "total_score": 0.5148457862925854, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.113271\nbelow_novelty_threshold: novelty_bonus=0.105996\nbelow_novelty_threshold: novelty_bonus=0.085600\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from a simple base term that captures the\n    relationship between the number of nodes and the average degree,\n    and then adjusted by several multiplicative factors that model the\n    effect of clustering, degree heterogeneity, degree assortativity,\n    and graph density.\n\n    The formula is intentionally kept compact and free of any\n    algorithmic graph traversal.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']          # 2m / n\n    c          = s['avg_clustering']      # average clustering coefficient\n    std        = s['std_degree']          # standard deviation of degrees\n    a          = s['degree_assortativity']# Pearson correlation of degrees\n    dens       = s['density']             # 2m / (n(n-1))\n\n    # Base term: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Clustering tends to increase local detours, so scale up\n    cluster_factor = 1 + c\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use the absolute value to\n    # keep the adjustment monotonic.\n    assort_factor = 1 + abs(a)\n\n    # Heterogeneity (large std) shortens paths, so divide by it\n    hetero_factor = 1 / (1 + std)\n\n    # Dense graphs have shorter paths; dampen the estimate accordingly\n    density_factor = 1 / (1 + dens)\n\n    return base * cluster_factor * assort_factor * hetero_factor * density_factor\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from a simple base term that captures the\n    relationship between the number of nodes and the average degree,\n    and then adjusted by several multiplicative factors that model the\n    effect of clustering, degree heterogeneity, degree assortativity,\n    and graph density.\n\n    The formula is intentionally kept compact and free of any\n    algorithmic graph traversal.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']          # 2m / n\n    c          = s['avg_clustering']      # average clustering coefficient\n    std        = s['std_degree']          # standard deviation of degrees\n    a          = s['degree_assortativity']# Pearson correlation of degrees\n    dens       = s['density']             # 2m / (n(n-1))\n\n    # Base term: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Clustering tends to increase local detours, so scale up\n    cluster_factor = 1 + c\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use the absolute value to\n    # keep the adjustment monotonic.\n    assort_factor = 1 + abs(a)\n\n    # Heterogeneity (large std) shortens paths, so divide by it\n    hetero_factor = 1 / (1 + std)\n\n    # Dense graphs have shorter paths; dampen the estimate accordingly\n    density_factor = 1 / (1 + dens)\n\n    return base * cluster_factor * assort_factor * hetero_factor * density_factor", "spearman": 0.8762769069226731, "pearson": 0.7682383912849833, "rmse": 2.258873088627178, "mae": 1.4009786137719413}}
{"timestamp": "2026-02-16T08:11:46.470823+00:00", "event_type": "candidate_rejected", "payload": {"generation": 6, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:11:46.471590+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 6, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:12:22.109602+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i2_p2_551264609", "generation": 6, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8101320528211284, "fitness_mode": "correlation", "simplicity_score": 0.22714966057713604, "novelty_bonus": 0.1558807657418717, "total_score": 0.5274870441600469, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.113271\nbelow_novelty_threshold: novelty_bonus=0.105996\nbelow_novelty_threshold: novelty_bonus=0.085600\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport math\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of global\n    graph statistics.  The core idea is a random‑graph baseline\n    (log(n) / log(avg_degree+1)) that is then corrected for the\n    following structural effects:\n\n    * **Clustering** – higher local clustering tends to force longer detours,\n      so we multiply by (1 + avg_clustering).\n\n    * **Assortativity** – positive assortativity (high‑degree nodes\n      connecting to high‑degree nodes) usually lengthens paths,\n      so we multiply by (1 + |degree_assortativity|).\n\n    * **Degree heterogeneity** – a large standard deviation of degrees\n      (presence of hubs) shortens paths; we divide by (1 + std_degree).\n\n    * **Density** – denser graphs have shorter paths; we multiply by\n      a factor proportional to (1 – density) but bounded below by a small\n      constant to avoid negative values.\n\n    * **Triangles** – a high number of triangles indicates a highly\n      interconnected network and therefore shorter paths; we divide by\n      (1 + triangle_ratio), where triangle_ratio is the fraction of\n      possible triangles.\n\n    All arithmetic is safe from division by zero and keeps the\n    expression compact.\n    \"\"\"\n    n   = s['n']\n    m   = s['m']\n    avg_deg  = s['avg_degree']\n    c        = s['avg_clustering']\n    a        = s['degree_assortativity']\n    std      = s['std_degree']\n    dens     = s['density']\n    tri      = s['num_triangles']\n\n    # Random‑graph baseline (log‑scale)\n    base = math.log(n + 1) / math.log(avg_deg + 2)\n\n    # Clustering adjustment\n    base *= (1 + c)\n\n    # Assortativity adjustment\n    base *= (1 + abs(a))\n\n    # Degree heterogeneity adjustment\n    base /= (1 + std)\n\n    # Density adjustment (ensure positivity)\n    density_factor = max(0.05, 1 - dens)\n    base *= density_factor\n\n    # Triangle adjustment\n    possible_triangles = n * (n - 1) * (n - 2) / 6\n    triangle_ratio = tri / max(possible_triangles, 1)\n    base /= (1 + triangle_ratio)\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only basic graph\n    statistics.  The estimate is built from a simple baseline that\n    increases with the node count and decreases with the average degree,\n    then adjusted for clustering, assortativity, degree heterogeneity,\n    density, and the prevalence of triangles.\n\n    All operations are safe from division by zero and keep the expression\n    compact and interpretable.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths; use absolute value\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor proportional\n    # to (1 - density), bounded below by 0.05 to avoid negativity.\n    density_factor = 1 - s['density']\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangles indicate local cohesion and shorter paths; divide by\n    # (1 + triangle_ratio), where triangle_ratio is the fraction of\n    # possible triangles in the graph.\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = s['num_triangles'] / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only basic graph\n    statistics.  The estimate is built from a simple baseline that\n    increases with the node count and decreases with the average degree,\n    then adjusted for clustering, assortativity, degree heterogeneity,\n    density, and the prevalence of triangles.\n\n    All operations are safe from division by zero and keep the expression\n    compact and interpretable.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths; use absolute value\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor proportional\n    # to (1 - density), bounded below by 0.05 to avoid negativity.\n    density_factor = 1 - s['density']\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangles indicate local cohesion and shorter paths; divide by\n    # (1 + triangle_ratio), where triangle_ratio is the fraction of\n    # possible triangles in the graph.\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = s['num_triangles'] / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base", "spearman": 0.8705857646441162, "pearson": 0.7658467918903547, "rmse": 2.2462826730872316, "mae": 1.4013261328242663}}
{"timestamp": "2026-02-16T08:12:22.110375+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 6, "island_id": 2, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:12:57.946215+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i2_p3_610193515", "generation": 6, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7852581032412964, "fitness_mode": "correlation", "simplicity_score": 0.13352904457425752, "novelty_bonus": 0.22304657616440393, "total_score": 0.5246450573960636, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.105996\nbelow_novelty_threshold: novelty_bonus=0.085600\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The estimate is a product of several simple adjustment factors that capture\n    the influence of connectivity, clustering, degree heterogeneity, assortativity,\n    density, and the presence of high‑degree nodes.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    c          = s['avg_clustering']\n    a          = s['degree_assortativity']\n    dens       = s['density']\n    max_deg    = s['max_degree']\n\n    # Base estimate: larger n or smaller average degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Adjustments\n    cluster_adj   = 1 + c                    # higher clustering → longer paths\n    assort_adj    = 1 + abs(a)               # assortativity magnitude → longer paths\n    hetero_adj    = 1 / (1 + std_deg)        # degree heterogeneity (hubs) shortens paths\n    density_adj   = 1 / (1 + dens)           # higher density shortens paths\n    max_adj       = 1 / (1 + max_deg ** 0.5) # presence of very high‑degree nodes shortens paths\n\n    return base * cluster_adj * assort_adj * hetero_adj * density_adj * max_adj\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The estimate is a product of several simple adjustment factors that capture\n    the influence of connectivity, clustering, degree heterogeneity, assortativity,\n    density, and the presence of high‑degree nodes.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    c          = s['avg_clustering']\n    a          = s['degree_assortativity']\n    dens       = s['density']\n    max_deg    = s['max_degree']\n\n    # Base estimate: larger n or smaller average degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Adjustments\n    cluster_adj   = 1 + c                    # higher clustering → longer paths\n    assort_adj    = 1 + abs(a)               # assortativity magnitude → longer paths\n    hetero_adj    = 1 / (1 + std_deg)        # degree heterogeneity (hubs) shortens paths\n    density_adj   = 1 / (1 + dens)           # higher density shortens paths\n    max_adj       = 1 / (1 + max_deg ** 0.5) # presence of very high‑degree nodes shortens paths\n\n    return base * cluster_adj * assort_adj * hetero_adj * density_adj * max_adj", "spearman": 0.8620505512637817, "pearson": 0.7479547115402341, "rmse": 1.9981823245704506, "mae": 1.8897384689506402}}
{"timestamp": "2026-02-16T08:13:35.964520+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i2_p4_658849295", "generation": 6, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.812533013205282, "fitness_mode": "correlation", "simplicity_score": 0.18050425912525395, "novelty_bonus": 0.17424209182885086, "total_score": 0.5269439436353127, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using simple graph statistics.\n    The estimate scales with the ratio of node count to average degree,\n    then adjusts for clustering, degree dispersion, and degree assortativity.\n    \"\"\"\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase local detours, so scale up the estimate\n    cluster_factor = 1 + s['avg_clustering']\n\n    # High degree variance (hubs) shortens paths, so divide by it\n    std_factor = 1 + s['std_degree']\n\n    # Degree assortativity: positive values tend to lengthen paths,\n    # negative values tend to shorten them.  Use absolute value to keep\n    # the adjustment monotonic.\n    assort_factor = 1 + abs(s['degree_assortativity'])\n\n    return base * cluster_factor / std_factor * assort_factor\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.105996\nbelow_novelty_threshold: novelty_bonus=0.085600\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from simple graph statistics.\n\n    The formula is built in three parts:\n\n    1. **Base term** – proportional to the ratio of node count to average degree.\n       A larger graph or a lower average degree tends to increase the path length.\n       We add 1 to the average degree to avoid division by zero.\n\n    2. **Structural scaling** – multiplies the base by factors that capture\n       key structural properties:\n       * 1 + avg_clustering : higher clustering usually creates more local\n         detours, increasing the average distance.\n       * 2 - density       : sparser graphs (small density) get a larger factor,\n         while very dense graphs (density close to 1) keep the factor near 1.\n       * 1 / (1 + std_degree) : a larger degree variance (hubs) typically\n         shortens paths, so we divide by this term.\n       * 1 + abs(degree_assortativity) : positive assortativity tends to\n         lengthen paths, while negative assortativity tends to shorten them.\n         Using the absolute value keeps the adjustment monotonic.\n\n    3. **Return** – the product of the base term and the scaling factor gives\n       a simple, fast estimate of the average shortest path length.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics.  Expected keys:\n        - 'n' : number of nodes\n        - 'avg_degree' : average degree\n        - 'avg_clustering' : average clustering coefficient\n        - 'density' : graph density\n        - 'std_degree' : standard deviation of degrees\n        - 'degree_assortativity' : degree assortativity coefficient\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    c = s['avg_clustering']\n    dens = s['density']\n    std = s['std_degree']\n    assort = s['degree_assortativity']\n\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Scaling factor capturing clustering, sparsity, heterogeneity, and assortativity\n    scale = (1 + c) * (2 - dens) / (1 + std) * (1 + abs(assort))\n\n    return base * scale\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from simple graph statistics.\n\n    The formula is built in three parts:\n\n    1. **Base term** – proportional to the ratio of node count to average degree.\n       A larger graph or a lower average degree tends to increase the path length.\n       We add 1 to the average degree to avoid division by zero.\n\n    2. **Structural scaling** – multiplies the base by factors that capture\n       key structural properties:\n       * 1 + avg_clustering : higher clustering usually creates more local\n         detours, increasing the average distance.\n       * 2 - density       : sparser graphs (small density) get a larger factor,\n         while very dense graphs (density close to 1) keep the factor near 1.\n       * 1 / (1 + std_degree) : a larger degree variance (hubs) typically\n         shortens paths, so we divide by this term.\n       * 1 + abs(degree_assortativity) : positive assortativity tends to\n         lengthen paths, while negative assortativity tends to shorten them.\n         Using the absolute value keeps the adjustment monotonic.\n\n    3. **Return** – the product of the base term and the scaling factor gives\n       a simple, fast estimate of the average shortest path length.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics.  Expected keys:\n        - 'n' : number of nodes\n        - 'avg_degree' : average degree\n        - 'avg_clustering' : average clustering coefficient\n        - 'density' : graph density\n        - 'std_degree' : standard deviation of degrees\n        - 'degree_assortativity' : degree assortativity coefficient\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    c = s['avg_clustering']\n    dens = s['density']\n    std = s['std_degree']\n    assort = s['degree_assortativity']\n\n    # Base estimate: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Scaling factor capturing clustering, sparsity, heterogeneity, and assortativity\n    scale = (1 + c) * (2 - dens) / (1 + std) * (1 + abs(assort))\n\n    return base * scale", "spearman": 0.8771409285232132, "pearson": 0.7704713663544236, "rmse": 6.863235081627966, "mae": 4.9113408379514905}}
{"timestamp": "2026-02-16T08:14:12.646481+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i3_p0_678634926", "generation": 6, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.37363745498199274, "fitness_mode": "correlation", "simplicity_score": 0.2481336841741844, "novelty_bonus": 0.5201858902647387, "total_score": 0.33337844631281854, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length.\n\n    This heuristic blends several global topological signals—\n    size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, and assortativity—\n    without using any external libraries or explicit shortest‑path\n    algorithms.  All operations are built‑in Python functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys listed in the prompt.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert main numeric features to float for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass   = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    degs  = s['degrees']          # list of int degrees\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase paths)\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get a larger value\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees (captures skewness of the distribution)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction: high clustering tends to shorten paths\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles tend to shrink paths\n    tri_term = (tri + 1.0) ** 0.3\n\n    # 7. Assortativity boost: mixing can create shortcuts\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.298439\nbelow_train_threshold: train_signal=0.051429\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest‑path length that mixes\n    several global graph statistics.  No external libraries are used\n    and the expression is constructed purely from built‑in Python\n    operators.  The formula is deliberately nonlinear to avoid\n    dependence on any single feature.\n    \"\"\"\n    # Extract the features (converted to float where necessary)\n    n           = float(s['n'])\n    m           = float(s['m'])\n    dens        = float(s['density'])\n    max_deg     = float(s['max_degree'])\n    min_deg     = float(s['min_degree'])\n    std_deg     = float(s['std_degree'])\n    avg_clust   = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    num_tri     = float(s['num_triangles'])\n    degrees     = s['degrees']               # list of ints\n\n    # ---------- 1. Size–density hybrid term\n    size_term = (n ** 0.65) / (m + 1.0)\n\n    # ---------- 2. Density penalty\n    dens_term = (1.0 + dens) ** -0.4\n\n    # ---------- 3. Degree‑dispersion influence\n    disp_term = ((max_deg - min_deg + 1.0) ** 0.35)\n\n    # ---------- 4. Harmonic mean of degrees (skewness capture)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # ---------- 5. Clustering/transitivity reduction\n    cluster_term = (avg_clust + trans + 1e-6) ** -0.5\n\n    # ---------- 6. Triangle shortcut influence\n    triangle_term = (num_tri + 1.0) ** 0.3\n\n    # ---------- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # ---------- 8. Assemble the invariant\n    inv = size_term * dens_term * disp_term * harmonic_mean * assort_term\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest‑path length that mixes\n    several global graph statistics.  No external libraries are used\n    and the expression is constructed purely from built‑in Python\n    operators.  The formula is deliberately nonlinear to avoid\n    dependence on any single feature.\n    \"\"\"\n    # Extract the features (converted to float where necessary)\n    n           = float(s['n'])\n    m           = float(s['m'])\n    dens        = float(s['density'])\n    max_deg     = float(s['max_degree'])\n    min_deg     = float(s['min_degree'])\n    std_deg     = float(s['std_degree'])\n    avg_clust   = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    num_tri     = float(s['num_triangles'])\n    degrees     = s['degrees']               # list of ints\n\n    # ---------- 1. Size–density hybrid term\n    size_term = (n ** 0.65) / (m + 1.0)\n\n    # ---------- 2. Density penalty\n    dens_term = (1.0 + dens) ** -0.4\n\n    # ---------- 3. Degree‑dispersion influence\n    disp_term = ((max_deg - min_deg + 1.0) ** 0.35)\n\n    # ---------- 4. Harmonic mean of degrees (skewness capture)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # ---------- 5. Clustering/transitivity reduction\n    cluster_term = (avg_clust + trans + 1e-6) ** -0.5\n\n    # ---------- 6. Triangle shortcut influence\n    triangle_term = (num_tri + 1.0) ** 0.3\n\n    # ---------- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # ---------- 8. Assemble the invariant\n    inv = size_term * dens_term * disp_term * harmonic_mean * assort_term\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv", "spearman": 0.25539188479712, "pearson": 0.19516508115718223, "rmse": 2.7281594666893336, "mae": 2.552487173260625}}
{"timestamp": "2026-02-16T08:15:10.725130+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i3_p1_26377889", "generation": 6, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5743577430972389, "fitness_mode": "correlation", "simplicity_score": 0.24746488621996363, "novelty_bonus": 0.39512487812195296, "total_score": 0.4569106626861288, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length.\n\n    This heuristic blends several global topological signals—\n    size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, and assortativity—\n    without using any external libraries or explicit shortest‑path\n    algorithms.  All operations are built‑in Python functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys listed in the prompt.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert main numeric features to float for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass   = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    degs  = s['degrees']          # list of int degrees\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase paths)\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get a larger value\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees (captures skewness of the distribution)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction: high clustering tends to shorten paths\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles tend to shrink paths\n    tri_term = (tri + 1.0) ** 0.3\n\n    # 7. Assortativity boost: mixing can create shortcuts\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.298439\nbelow_train_threshold: train_signal=0.051429\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    std_deg = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n    degrees = s['degrees']\n    avg_deg = sum(degrees) / len(degrees) if degrees else 0.0\n    size = (n ** 0.7) / (m + 1)\n    dens_pen = 1.0 / (density + 1e-9)\n    disp = (max_deg - min_deg + 1) ** 0.5\n    std_inf = pow(2.718281828459045, std_deg / (max_deg + 1e-9))\n    harmonic = n / (sum((1.0 / d) for d in degrees if d > 0) + 1e-12)\n    cluster_fac = 1.0 / (avg_clust + trans + 1e-9)\n    tri_fac = (num_tri + 1) ** 0.3\n    assort_adj = 1.0 + abs(assort)\n    inv = size * dens_pen * disp * std_inf * harmonic * assort_adj\n    inv = inv / (cluster_fac * tri_fac)\n    return inv", "extracted_code": "def new_invariant(s):\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    std_deg = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n    degrees = s['degrees']\n    avg_deg = sum(degrees) / len(degrees) if degrees else 0.0\n    size = (n ** 0.7) / (m + 1)\n    dens_pen = 1.0 / (density + 1e-9)\n    disp = (max_deg - min_deg + 1) ** 0.5\n    std_inf = pow(2.718281828459045, std_deg / (max_deg + 1e-9))\n    harmonic = n / (sum((1.0 / d) for d in degrees if d > 0) + 1e-12)\n    cluster_fac = 1.0 / (avg_clust + trans + 1e-9)\n    tri_fac = (num_tri + 1) ** 0.3\n    assort_adj = 1.0 + abs(assort)\n    inv = size * dens_pen * disp * std_inf * harmonic * assort_adj\n    inv = inv / (cluster_fac * tri_fac)\n    return inv", "spearman": 0.5777604440111004, "pearson": 0.7136963686606035, "rmse": 1.4160903748471423, "mae": 1.063486041280394}}
{"timestamp": "2026-02-16T08:15:51.572224+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i3_p2_420788012", "generation": 6, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.3671068427370948, "fitness_mode": "correlation", "simplicity_score": 0.2493025190090454, "novelty_bonus": 0.284213557710871, "total_score": 0.28850115552968075, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length.\n\n    This heuristic blends several global topological signals—\n    size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, and assortativity—\n    without using any external libraries or explicit shortest‑path\n    algorithms.  All operations are built‑in Python functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys listed in the prompt.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert main numeric features to float for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass   = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    degs  = s['degrees']          # list of int degrees\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase paths)\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get a larger value\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees (captures skewness of the distribution)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction: high clustering tends to shorten paths\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles tend to shrink paths\n    tri_term = (tri + 1.0) ** 0.3\n\n    # 7. Assortativity boost: mixing can create shortcuts\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.298439\nbelow_train_threshold: train_signal=0.051429\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from its\n    global structural statistics, without using any graph traversal\n    algorithm or external libraries.\n\n    The formula is a multiplicative blend of several features:\n\n    * Size–density hybrid term      – larger and sparser graphs\n    * Degree‑dispersion factor      – wide degree ranges lengthen paths\n    * Harmonic mean of degrees      – captures skewness of the degree\n      distribution\n    * Clustering‑transitivity factor – high clustering usually shortens paths\n    * Triangle shortcut factor      – many triangles create shortcuts\n    * Assortativity boost           – mixing can reduce distances\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  The dictionary must contain the\n        keys listed below:\n\n        n (int)                 – number of nodes\n        m (int)                 – number of edges\n        density (float)         – edge density\n        max_degree (int)        – maximum degree\n        min_degree (int)        – minimum degree\n        degrees (list[int])     – list of node degrees\n        avg_clustering (float)  – average clustering coefficient\n        transitivity (float)    – global transitivity\n        degree_assortativity (float)\n        num_triangles (int)     – number of triangles\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 1. Basic numeric values (converted to float for safety)\n    # ------------------------------------------------------------------\n    n = float(s['n'])\n    m = float(s['m'])\n    dens = float(s['density'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n    degrees = s['degrees']\n\n    # ------------------------------------------------------------------\n    # 2. Size–density hybrid term (larger graphs + sparser graphs → longer paths)\n    # ------------------------------------------------------------------\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # ------------------------------------------------------------------\n    # 3. Degree dispersion (a wider spread usually increases distances)\n    # ------------------------------------------------------------------\n    disp_term = ((max_deg - min_deg + 1.0) ** 0.3)\n\n    # ------------------------------------------------------------------\n    # 4. Harmonic mean of degrees (captures skewness of the degree distribution)\n    # ------------------------------------------------------------------\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # tiny epsilon to avoid div/0\n\n    # ------------------------------------------------------------------\n    # 5. Clustering/transitivity reduction – high clustering shortens paths\n    # ------------------------------------------------------------------\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # ------------------------------------------------------------------\n    # 6. Triangle shortcut influence – more triangles usually reduce distances\n    # ------------------------------------------------------------------\n    tri_term = (num_tri + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # 7. Assortativity boost – mixing can create additional short‑cuts\n    # ------------------------------------------------------------------\n    assort_term = 1.0 + abs(assort)\n\n    # ------------------------------------------------------------------\n    # 8. Assemble the invariant (multiplicative mixture of the components)\n    # ------------------------------------------------------------------\n    inv = (size_term * disp_term * harmonic_mean *\n           assort_term) / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph from its\n    global structural statistics, without using any graph traversal\n    algorithm or external libraries.\n\n    The formula is a multiplicative blend of several features:\n\n    * Size–density hybrid term      – larger and sparser graphs\n    * Degree‑dispersion factor      – wide degree ranges lengthen paths\n    * Harmonic mean of degrees      – captures skewness of the degree\n      distribution\n    * Clustering‑transitivity factor – high clustering usually shortens paths\n    * Triangle shortcut factor      – many triangles create shortcuts\n    * Assortativity boost           – mixing can reduce distances\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  The dictionary must contain the\n        keys listed below:\n\n        n (int)                 – number of nodes\n        m (int)                 – number of edges\n        density (float)         – edge density\n        max_degree (int)        – maximum degree\n        min_degree (int)        – minimum degree\n        degrees (list[int])     – list of node degrees\n        avg_clustering (float)  – average clustering coefficient\n        transitivity (float)    – global transitivity\n        degree_assortativity (float)\n        num_triangles (int)     – number of triangles\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # 1. Basic numeric values (converted to float for safety)\n    # ------------------------------------------------------------------\n    n = float(s['n'])\n    m = float(s['m'])\n    dens = float(s['density'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n    degrees = s['degrees']\n\n    # ------------------------------------------------------------------\n    # 2. Size–density hybrid term (larger graphs + sparser graphs → longer paths)\n    # ------------------------------------------------------------------\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # ------------------------------------------------------------------\n    # 3. Degree dispersion (a wider spread usually increases distances)\n    # ------------------------------------------------------------------\n    disp_term = ((max_deg - min_deg + 1.0) ** 0.3)\n\n    # ------------------------------------------------------------------\n    # 4. Harmonic mean of degrees (captures skewness of the degree distribution)\n    # ------------------------------------------------------------------\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # tiny epsilon to avoid div/0\n\n    # ------------------------------------------------------------------\n    # 5. Clustering/transitivity reduction – high clustering shortens paths\n    # ------------------------------------------------------------------\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # ------------------------------------------------------------------\n    # 6. Triangle shortcut influence – more triangles usually reduce distances\n    # ------------------------------------------------------------------\n    tri_term = (num_tri + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # 7. Assortativity boost – mixing can create additional short‑cuts\n    # ------------------------------------------------------------------\n    assort_term = 1.0 + abs(assort)\n\n    # ------------------------------------------------------------------\n    # 8. Assemble the invariant (multiplicative mixture of the components)\n    # ------------------------------------------------------------------\n    inv = (size_term * disp_term * harmonic_mean *\n           assort_term) / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.3067531688292207, "pearson": 0.3054786038192101, "rmse": 2.7507545222283327, "mae": 2.5830344194289943}}
{"timestamp": "2026-02-16T08:16:16.098338+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g6_i3_p3_942920041", "generation": 6, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6403361344537815, "fitness_mode": "correlation", "simplicity_score": 0.24860980274794608, "novelty_bonus": 0.36648166204155097, "total_score": 0.4700714692873077, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length.\n\n    This heuristic blends several global topological signals—\n    size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, and assortativity—\n    without using any external libraries or explicit shortest‑path\n    algorithms.  All operations are built‑in Python functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys listed in the prompt.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert main numeric features to float for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass   = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    degs  = s['degrees']          # list of int degrees\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase paths)\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get a larger value\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees (captures skewness of the distribution)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction: high clustering tends to shorten paths\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles tend to shrink paths\n    tri_term = (tri + 1.0) ** 0.3\n\n    # 7. Assortativity boost: mixing can create shortcuts\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.298439\nbelow_train_threshold: train_signal=0.051429\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length using only\n    pre‑computed global statistics.  The expression blends size,\n    density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle count and assortativity.\n    No external libraries are imported and no shortest‑path algorithm\n    is used.\n    \"\"\"\n    # Basic numeric features\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass    = float(s['degree_assortativity'])\n    tri    = float(s['num_triangles'])\n    clus   = float(s['avg_clustering'])\n    trans  = float(s['transitivity'])\n    degs   = s['degrees']          # list of ints\n\n    # 1. Size–density hybrid term\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get larger contribution\n    dens_term = 1.0 / (dens + 1e-9)\n\n    # 3. Degree‑dispersion influence\n    disp_term = ((max_d - min_d + 1.0) ** 0.35)\n\n    # 4. Harmonic mean of degrees (captures skewness)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # 7. Assortativity boost\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length using only\n    pre‑computed global statistics.  The expression blends size,\n    density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle count and assortativity.\n    No external libraries are imported and no shortest‑path algorithm\n    is used.\n    \"\"\"\n    # Basic numeric features\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass    = float(s['degree_assortativity'])\n    tri    = float(s['num_triangles'])\n    clus   = float(s['avg_clustering'])\n    trans  = float(s['transitivity'])\n    degs   = s['degrees']          # list of ints\n\n    # 1. Size–density hybrid term\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get larger contribution\n    dens_term = 1.0 / (dens + 1e-9)\n\n    # 3. Degree‑dispersion influence\n    disp_term = ((max_d - min_d + 1.0) ** 0.35)\n\n    # 4. Harmonic mean of degrees (captures skewness)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # 7. Assortativity boost\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.6208100202505064, "pearson": 0.7226986744340416, "rmse": 1.7240093431286232, "mae": 1.5793960254810588}}
{"timestamp": "2026-02-16T08:17:08.954891+00:00", "event_type": "candidate_rejected", "payload": {"generation": 6, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.104256", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:17:08.955801+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 6, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.104256", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:17:33.200665+00:00", "event_type": "candidate_rejected", "payload": {"generation": 6, "island_id": 3, "population_idx": 4, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.274910", "model_name": "gpt-oss:20b", "train_signal": 0.2749099639855942}}
{"timestamp": "2026-02-16T08:17:33.201345+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 6, "island_id": 3, "population_idx": 4, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:17:33.203421+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 7, "model_name": "gpt-oss:20b", "best_val_score": 0.5358322776835298, "no_improve_count": 6}}
{"timestamp": "2026-02-16T08:18:28.013186+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:18:28.014415+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 7, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:18:58.472712+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 0, "population_idx": 0, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:18:58.473447+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 7, "island_id": 0, "population_idx": 0, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:19:25.926136+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:19:25.927056+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 7, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:19:58.638999+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:19:58.639397+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 7, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:21:33.763586+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:21:33.764361+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 7, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:21:59.134567+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i0_p2_714620213", "generation": 7, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.469483793517407, "fitness_mode": "correlation", "simplicity_score": 0.11835677450326673, "novelty_bonus": 0.25808602048460516, "total_score": 0.333735727010184, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: scales with sqrt(n) and inversely with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser → longer paths\n    clustering_adj = 1 - clustering                      # more clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.033894\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: code must define exactly one function named `new_invariant`\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    min_deg = s['min_degree']\n    trans = s['transitivity']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)\n    hub_adj       = 1 - max_deg / (n - 1 + eps)\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)\n    min_adj       = 1 - (min_deg / (avg_deg + eps)) * 0.5\n    trans_adj     = 1 - trans * 0.5\n\n    def clamp(x):\n        if x < 0.05:\n            return 0.05\n        if x > 20:\n            return 20\n        return x\n\n    density_adj   = clamp(density_adj)\n    clustering_adj = clamp(clustering_adj)\n    assort_adj    = clamp(assort_adj)\n    hetero_adj    = clamp(hetero_adj)\n    hub_adj       = clamp(hub_adj)\n    triangle_adj  = clamp(triangle_adj)\n    min_adj       = clamp(min_adj)\n    trans_adj     = clamp(trans_adj)\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj * min_adj * trans_adj\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    min_deg = s['min_degree']\n    trans = s['transitivity']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)\n    hub_adj       = 1 - max_deg / (n - 1 + eps)\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)\n    min_adj       = 1 - (min_deg / (avg_deg + eps)) * 0.5\n    trans_adj     = 1 - trans * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.05, min(20, density_adj))\n    clustering_adj = max(0.05, min(20, clustering_adj))\n    assort_adj    = max(0.05, min(20, assort_adj))\n    hetero_adj    = max(0.05, min(20, hetero_adj))\n    hub_adj       = max(0.05, min(20, hub_adj))\n    triangle_adj  = max(0.05, min(20, triangle_adj))\n    min_adj       = max(0.05, min(20, min_adj))\n    trans_adj     = max(0.05, min(20, trans_adj))\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj * min_adj * trans_adj", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    min_deg = s['min_degree']\n    trans = s['transitivity']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)\n    hub_adj       = 1 - max_deg / (n - 1 + eps)\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)\n    min_adj       = 1 - (min_deg / (avg_deg + eps)) * 0.5\n    trans_adj     = 1 - trans * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.05, min(20, density_adj))\n    clustering_adj = max(0.05, min(20, clustering_adj))\n    assort_adj    = max(0.05, min(20, assort_adj))\n    hetero_adj    = max(0.05, min(20, hetero_adj))\n    hub_adj       = max(0.05, min(20, hub_adj))\n    triangle_adj  = max(0.05, min(20, triangle_adj))\n    min_adj       = max(0.05, min(20, min_adj))\n    trans_adj     = max(0.05, min(20, trans_adj))\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj * min_adj * trans_adj", "spearman": 0.4652771319282982, "pearson": 0.3599346255669505, "rmse": 2.477341548413317, "mae": 2.3029188230446214}}
{"timestamp": "2026-02-16T08:21:59.135232+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 7, "island_id": 0, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:22:48.074925+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:22:48.075993+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 7, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:23:06.317300+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:23:06.318002+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 7, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:26:18.675272+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i0_p4_206039232", "generation": 7, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.363265306122449, "fitness_mode": "correlation", "simplicity_score": 0.11695515564112408, "novelty_bonus": 0.3619764513529441, "total_score": 0.3022997244280554, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: scales with sqrt(n) and inversely with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser → longer paths\n    clustering_adj = 1 - clustering                      # more clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.033894\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    min_deg = s['min_degree']\n    trans = s['transitivity']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n    min_degree_adj = 1 + (1 - min_deg / (avg_deg + eps))\n    transitivity_adj = 1 - trans\n\n    density_adj = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj = max(0.1, min(10, assort_adj))\n    hetero_adj = max(0.1, min(10, hetero_adj))\n    hub_adj = max(0.1, min(10, hub_adj))\n    triangle_adj = max(0.1, min(10, triangle_adj))\n    min_degree_adj = max(0.1, min(10, min_degree_adj))\n    transitivity_adj = max(0.1, min(10, transitivity_adj))\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj * min_degree_adj * transitivity_adj", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    min_deg = s['min_degree']\n    trans = s['transitivity']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + (1 - density)\n    clustering_adj = 1 - clustering\n    assort_adj = 1 + assort\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n    min_degree_adj = 1 + (1 - min_deg / (avg_deg + eps))\n    transitivity_adj = 1 - trans\n\n    density_adj = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj = max(0.1, min(10, assort_adj))\n    hetero_adj = max(0.1, min(10, hetero_adj))\n    hub_adj = max(0.1, min(10, hub_adj))\n    triangle_adj = max(0.1, min(10, triangle_adj))\n    min_degree_adj = max(0.1, min(10, min_degree_adj))\n    transitivity_adj = max(0.1, min(10, transitivity_adj))\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj * min_degree_adj * transitivity_adj", "spearman": 0.3406315157878947, "pearson": 0.20812002778484567, "rmse": 2.1856863406382634, "mae": 1.8986618867500824}}
{"timestamp": "2026-02-16T08:26:50.541995+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i1_p0_722388541", "generation": 7, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15376715397334234, "novelty_bonus": 0.25199429985749633, "total_score": 0.2847676811509274, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0)\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0)\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * pow((max_deg + 1), 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        pow(n, 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + pow(num_tri + 1, 0.5)\n        + pow(max_deg + 1, 0.5)\n        + pow(min_deg + 1, 0.5)\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1 + m + density + num_tri + abs(deg_assort) + std_deg\n        + (max_deg + 1) + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0)\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * pow((max_deg + 1), 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        pow(n, 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + pow(num_tri + 1, 0.5)\n        + pow(max_deg + 1, 0.5)\n        + pow(min_deg + 1, 0.5)\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1 + m + density + num_tri + abs(deg_assort) + std_deg\n        + (max_deg + 1) + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T08:27:32.249617+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i1_p1_708303257", "generation": 7, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3672989195678271, "fitness_mode": "correlation", "simplicity_score": 0.1526596330787678, "novelty_bonus": 0.2334925603989817, "total_score": 0.27333151353091795, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0)\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0)\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s.get('std_degree', 0)\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    deg_assort = s.get('degree_assortativity', 0)\n    num_tri = s.get('num_triangles', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Degree range and normalised average degree\n    deg_range = max_deg - min_deg\n    avg_over_max = avg_deg / (max_deg + 1)\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n        + deg_range / (max_deg + 1)\n        + avg_over_max\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n        + deg_range\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0)\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s.get('std_degree', 0)\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    deg_assort = s.get('degree_assortativity', 0)\n    num_tri = s.get('num_triangles', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Degree range and normalised average degree\n    deg_range = max_deg - min_deg\n    avg_over_max = avg_deg / (max_deg + 1)\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n        + deg_range / (max_deg + 1)\n        + avg_over_max\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n        + deg_range\n    )\n\n    return numerator / denom", "spearman": 0.34550363759093977, "pearson": 0.28022854264450103, "rmse": 2.626200601160641, "mae": 2.4473763041238086}}
{"timestamp": "2026-02-16T08:27:57.637188+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i1_p2_988173913", "generation": 7, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15387124888181722, "novelty_bonus": 0.25199429985749633, "total_score": 0.28478850013262236, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0)\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0.0)\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0.0)\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0.0)\n    std_deg = s.get('std_degree', 0.0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T08:28:28.123022+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i1_p3_17297519", "generation": 7, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15423026863007167, "novelty_bonus": 0.25199429985749633, "total_score": 0.28486030408227325, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0)\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "extracted_code": "def new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T08:28:59.082633+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i1_p4_620824100", "generation": 7, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15387124888181722, "novelty_bonus": 0.25199429985749633, "total_score": 0.28478850013262236, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0)\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity and degree range into a single\n    bounded quantity.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0)\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    # and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity and degree range into a single\n    bounded quantity.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s.get('density', 0)\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s.get('num_triangles', 0)\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity\n    # and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T08:29:28.323170+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i2_p0_772116943", "generation": 7, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8373109243697479, "fitness_mode": "correlation", "simplicity_score": 0.22714966057713604, "novelty_bonus": 0.20040381990466183, "total_score": 0.5627212573413072, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only basic graph\n    statistics.  The estimate is built from a simple baseline that\n    increases with the node count and decreases with the average degree,\n    then adjusted for clustering, assortativity, degree heterogeneity,\n    density, and the prevalence of triangles.\n\n    All operations are safe from division by zero and keep the expression\n    compact and interpretable.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths; use absolute value\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor proportional\n    # to (1 - density), bounded below by 0.05 to avoid negativity.\n    density_factor = 1 - s['density']\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangles indicate local cohesion and shorter paths; divide by\n    # (1 + triangle_ratio), where triangle_ratio is the fraction of\n    # possible triangles in the graph.\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = s['num_triangles'] / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.105996\nbelow_novelty_threshold: novelty_bonus=0.085600\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base", "spearman": 0.9143403585089629, "pearson": 0.8271326217624315, "rmse": 3.359512705062122, "mae": 2.0994546103869034}}
{"timestamp": "2026-02-16T08:30:06.151854+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.024261", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:30:06.152384+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 7, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.024261", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:31:22.163629+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.110087", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:31:22.164508+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 7, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:31:55.974119+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i2_p2_492429754", "generation": 7, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.5559183673469387, "fitness_mode": "correlation", "simplicity_score": 0.2244631078218879, "novelty_bonus": 0.20131420140844625, "total_score": 0.4548796218054069, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only basic graph\n    statistics.  The estimate is built from a simple baseline that\n    increases with the node count and decreases with the average degree,\n    then adjusted for clustering, assortativity, degree heterogeneity,\n    density, and the prevalence of triangles.\n\n    All operations are safe from division by zero and keep the expression\n    compact and interpretable.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths; use absolute value\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor proportional\n    # to (1 - density), bounded below by 0.05 to avoid negativity.\n    density_factor = 1 - s['density']\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangles indicate local cohesion and shorter paths; divide by\n    # (1 + triangle_ratio), where triangle_ratio is the fraction of\n    # possible triangles in the graph.\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = s['num_triangles'] / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024261\nbelow_novelty_threshold: novelty_bonus=0.110087\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a small set of\n    pre‑computed graph statistics.\n\n    The formula is built around a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    corrected for the following effects:\n\n    * **Clustering** – higher clustering usually forces longer detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity tends to lengthen\n      paths; we use the absolute value to avoid negative factors.\n    * **Degree heterogeneity** – a large standard deviation of the\n      degree sequence (hubs) shortens paths; we divide by (1 + std_degree).\n    * **Degree distribution skew** – if the maximum degree is much\n      larger than the average, hubs dominate and shorten paths;\n      we multiply by avg_degree / max_degree.\n    * **Density** – denser graphs have shorter paths; we multiply by a\n      factor proportional to (1 - density), bounded below by 0.05.\n    * **Triangles** – a higher triangle ratio indicates local cohesion\n      and usually shorter paths; we divide by (1 + triangle_ratio).\n\n    All intermediate values are protected against division by zero,\n    and the expression remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clust = s['avg_clustering']\n    assort = abs(s['degree_assortativity'])\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # ---------- Baseline ----------\n    # Longer paths for larger graphs and smaller average degree.\n    base = n / (avg_deg + 1)\n\n    # ---------- Clustering & assortativity ----------\n    base *= (1 + clust) * (1 + assort)\n\n    # ---------- Degree heterogeneity ----------\n    base /= (1 + std_deg)\n\n    # ---------- Max degree / avg degree ----------\n    base *= avg_deg / max(max_deg, 1)\n\n    # ---------- Density factor ----------\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # ---------- Triangle ratio ----------\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a small set of\n    pre‑computed graph statistics.\n\n    The formula is built around a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    corrected for the following effects:\n\n    * **Clustering** – higher clustering usually forces longer detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity tends to lengthen\n      paths; we use the absolute value to avoid negative factors.\n    * **Degree heterogeneity** – a large standard deviation of the\n      degree sequence (hubs) shortens paths; we divide by (1 + std_degree).\n    * **Degree distribution skew** – if the maximum degree is much\n      larger than the average, hubs dominate and shorten paths;\n      we multiply by avg_degree / max_degree.\n    * **Density** – denser graphs have shorter paths; we multiply by a\n      factor proportional to (1 - density), bounded below by 0.05.\n    * **Triangles** – a higher triangle ratio indicates local cohesion\n      and usually shorter paths; we divide by (1 + triangle_ratio).\n\n    All intermediate values are protected against division by zero,\n    and the expression remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clust = s['avg_clustering']\n    assort = abs(s['degree_assortativity'])\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # ---------- Baseline ----------\n    # Longer paths for larger graphs and smaller average degree.\n    base = n / (avg_deg + 1)\n\n    # ---------- Clustering & assortativity ----------\n    base *= (1 + clust) * (1 + assort)\n\n    # ---------- Degree heterogeneity ----------\n    base /= (1 + std_deg)\n\n    # ---------- Max degree / avg degree ----------\n    base *= avg_deg / max(max_deg, 1)\n\n    # ---------- Density factor ----------\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # ---------- Triangle ratio ----------\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base", "spearman": 0.699185479636991, "pearson": 0.5539602657610206, "rmse": 1.6295033406086181, "mae": 1.4083241387423215}}
{"timestamp": "2026-02-16T08:32:35.600640+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i2_p3_224403455", "generation": 7, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8521008403361344, "fitness_mode": "correlation", "simplicity_score": 0.2239988892662493, "novelty_bonus": 0.17057522678088544, "total_score": 0.553525034704736, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only basic graph\n    statistics.  The estimate is built from a simple baseline that\n    increases with the node count and decreases with the average degree,\n    then adjusted for clustering, assortativity, degree heterogeneity,\n    density, and the prevalence of triangles.\n\n    All operations are safe from division by zero and keep the expression\n    compact and interpretable.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths; use absolute value\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor proportional\n    # to (1 - density), bounded below by 0.05 to avoid negativity.\n    density_factor = 1 - s['density']\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangles indicate local cohesion and shorter paths; divide by\n    # (1 + triangle_ratio), where triangle_ratio is the fraction of\n    # possible triangles in the graph.\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = s['num_triangles'] / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024261\nbelow_novelty_threshold: novelty_bonus=0.110087\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the size of the\n    graph and shrinks with the average degree.  It is then adjusted by\n    several structural factors that are known to influence path lengths:\n\n    * **Clustering** – higher clustering tends to create detours,\n      therefore the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of degrees\n      (presence of hubs) shortens paths, so the estimate is divided by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Density** – denser graphs have shorter paths.  We multiply by a\n      factor proportional to (1 – density), bounded below by 0.05 to\n      avoid negative values.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n\n    All arithmetic is safe from division by zero, and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Clustering and assortativity factors\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Heterogeneity and minimum‑degree adjustments\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the size of the\n    graph and shrinks with the average degree.  It is then adjusted by\n    several structural factors that are known to influence path lengths:\n\n    * **Clustering** – higher clustering tends to create detours,\n      therefore the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of degrees\n      (presence of hubs) shortens paths, so the estimate is divided by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Density** – denser graphs have shorter paths.  We multiply by a\n      factor proportional to (1 – density), bounded below by 0.05 to\n      avoid negative values.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n\n    All arithmetic is safe from division by zero, and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Clustering and assortativity factors\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Heterogeneity and minimum‑degree adjustments\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base", "spearman": 0.915105377634441, "pearson": 0.8648265992030016, "rmse": 4.8737777447114725, "mae": 3.1861418238665817}}
{"timestamp": "2026-02-16T08:33:10.095768+00:00", "event_type": "candidate_rejected", "payload": {"generation": 7, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:33:10.096820+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 7, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:33:39.571934+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i2_p4_358146337", "generation": 7, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.6149819927971187, "fitness_mode": "correlation", "simplicity_score": 0.2229950669851596, "novelty_bonus": 0.22093180671960433, "total_score": 0.47455589734646164, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n\n    The estimate is built from three components:\n\n    1. **Base term** – scales with the square of the node count and inversely\n       with the number of edges.  The denominator is a small positive\n       quantity that never becomes zero: 2*m + n.\n\n    2. **Clustering & assortativity factor** – higher clustering and\n       assortativity tend to increase path lengths, so we multiply by\n       (1 + avg_clustering) * (1 + degree_assortativity).\n\n    3. **Degree heterogeneity adjustment** – a large standard deviation of\n       degrees (presence of hubs) typically shortens paths.  We divide by\n       (1 + std_degree) to model this effect.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    simple while capturing the main structural influences on average path\n    length.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n    std = s['std_degree']\n\n    # Safe denominator – never zero\n    denom = max(2 * m + n, 1)\n\n    # Base estimate: scales with n² / (2m + n)\n    base = (n ** 2) / denom\n\n    # Adjustment for clustering and assortativity\n    adj = (1 + c) * (1 + a)\n\n    # Heterogeneity factor – larger std reduces the estimate\n    hetero = 1 / (1 + std)\n\n    return base * adj * hetero\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using only basic graph\n    statistics.  The estimate is built from a simple baseline that\n    increases with the node count and decreases with the average degree,\n    then adjusted for clustering, assortativity, degree heterogeneity,\n    density, and the prevalence of triangles.\n\n    All operations are safe from division by zero and keep the expression\n    compact and interpretable.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths; use absolute value\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor proportional\n    # to (1 - density), bounded below by 0.05 to avoid negativity.\n    density_factor = 1 - s['density']\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangles indicate local cohesion and shorter paths; divide by\n    # (1 + triangle_ratio), where triangle_ratio is the fraction of\n    # possible triangles in the graph.\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = s['num_triangles'] / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024261\nbelow_novelty_threshold: novelty_bonus=0.110087\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from pre‑computed graph\n    statistics.  The estimate is built from a compact set of multiplicative\n    factors that capture the main structural influences:\n\n    1. **Baseline** – inversely proportional to the average degree and\n       directly proportional to the node count.\n    2. **Clustering** – higher clustering tends to increase detours.\n    3. **Assortativity** – positive assortativity usually lengthens paths.\n    4. **Degree heterogeneity** – a larger standard deviation of degrees\n       (presence of hubs) shortens paths.\n    5. **Density** – denser graphs have shorter paths.\n    6. **Triangles** – a higher triangle ratio indicates local cohesion\n       and shortens paths.\n    7. **Transitivity** – higher transitivity also shortens paths.\n    8. **Degree range** – a very large maximum degree (hub) reduces path\n       length; we model this by dividing by a factor that grows with\n       max_degree relative to the average degree.\n    9. **Size scaling** – a mild logarithmic dependence on the number of\n       nodes is added to capture the growth of path lengths in very large\n       graphs.\n\n    All arithmetic is safe from division by zero and the expression\n    remains simple and interpretable.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_degree = s['avg_degree']\n    max_degree = s['max_degree']\n    std_degree = s['std_degree']\n    avg_clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    degree_assortativity = s['degree_assortativity']\n    num_triangles = s['num_triangles']\n\n    # ---------- 1. Baseline ----------\n    # Avoid division by zero by adding 1 to the denominator\n    base = n / (avg_degree + 1)\n\n    # ---------- 2. Clustering ----------\n    base *= (1 + avg_clustering)\n\n    # ---------- 3. Assortativity ----------\n    base *= (1 + abs(degree_assortativity))\n\n    # ---------- 4. Degree heterogeneity ----------\n    base /= (1 + std_degree)\n\n    # ---------- 5. Density ----------\n    density_factor = max(1 - density, 0.05)          # never below 0.05\n    base *= density_factor\n\n    # ---------- 6. Triangle ratio ----------\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # ---------- 7. Transitivity ----------\n    base /= (1 + transitivity)\n\n    # ---------- 8. Degree range (hub effect) ----------\n    # The factor grows with max_degree relative to avg_degree\n    hub_factor = 1 + max_degree / (avg_degree + 1)\n    base /= hub_factor\n\n    # ---------- 9. Size scaling ----------\n    # Add a mild logarithmic dependence on the number of nodes\n    # Use natural log; avoid math import by using the built‑in pow\n    import math\n    size_scale = math.log(n + 1)\n    base *= size_scale\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from pre‑computed graph\n    statistics.  The estimate is built from a compact set of multiplicative\n    factors that capture the main structural influences:\n\n    1. Baseline inversely proportional to the average degree and directly\n       proportional to the node count.\n    2. Clustering increases detours.\n    3. Positive assortativity tends to lengthen paths.\n    4. Degree heterogeneity (large std) shortens paths.\n    5. Density reduces path length.\n    6. Triangle ratio shortens paths.\n    7. Transitivity shortens paths.\n    8. Large maximum degree (hub) shortens paths.\n    9. A mild logarithmic dependence on the number of nodes.\n\n    All arithmetic is safe from division by zero and the expression\n    remains simple and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    avg_clustering = s['avg_clustering']\n    degree_assortativity = s['degree_assortativity']\n    std_degree = s['std_degree']\n    density = s['density']\n    transitivity = s['transitivity']\n    max_degree = s['max_degree']\n    num_triangles = s['num_triangles']\n\n    # 1. Baseline\n    base = n / (avg_degree + 1)\n\n    # 2. Clustering\n    base *= (1 + avg_clustering)\n\n    # 3. Assortativity\n    base *= (1 + abs(degree_assortativity))\n\n    # 4. Degree heterogeneity\n    base /= (1 + std_degree)\n\n    # 5. Density\n    density_factor = max(1 - density, 0.05)\n    base *= density_factor\n\n    # 6. Triangle ratio\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # 7. Transitivity\n    base /= (1 + transitivity)\n\n    # 8. Degree range (hub effect)\n    hub_factor = 1 + max_degree / (avg_degree + 1)\n    base /= hub_factor\n\n    # 9. Size scaling (use bit_length as a cheap log approximation)\n    size_scale = n.bit_length()  # ~log2(n)\n    base *= size_scale\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from pre‑computed graph\n    statistics.  The estimate is built from a compact set of multiplicative\n    factors that capture the main structural influences:\n\n    1. Baseline inversely proportional to the average degree and directly\n       proportional to the node count.\n    2. Clustering increases detours.\n    3. Positive assortativity tends to lengthen paths.\n    4. Degree heterogeneity (large std) shortens paths.\n    5. Density reduces path length.\n    6. Triangle ratio shortens paths.\n    7. Transitivity shortens paths.\n    8. Large maximum degree (hub) shortens paths.\n    9. A mild logarithmic dependence on the number of nodes.\n\n    All arithmetic is safe from division by zero and the expression\n    remains simple and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_degree = s['avg_degree']\n    avg_clustering = s['avg_clustering']\n    degree_assortativity = s['degree_assortativity']\n    std_degree = s['std_degree']\n    density = s['density']\n    transitivity = s['transitivity']\n    max_degree = s['max_degree']\n    num_triangles = s['num_triangles']\n\n    # 1. Baseline\n    base = n / (avg_degree + 1)\n\n    # 2. Clustering\n    base *= (1 + avg_clustering)\n\n    # 3. Assortativity\n    base *= (1 + abs(degree_assortativity))\n\n    # 4. Degree heterogeneity\n    base /= (1 + std_degree)\n\n    # 5. Density\n    density_factor = max(1 - density, 0.05)\n    base *= density_factor\n\n    # 6. Triangle ratio\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # 7. Transitivity\n    base /= (1 + transitivity)\n\n    # 8. Degree range (hub effect)\n    hub_factor = 1 + max_degree / (avg_degree + 1)\n    base /= hub_factor\n\n    # 9. Size scaling (use bit_length as a cheap log approximation)\n    size_scale = n.bit_length()  # ~log2(n)\n    base *= size_scale\n\n    return base", "spearman": 0.7273546838670969, "pearson": 0.5484320185523521, "rmse": 6.985970926635055, "mae": 4.3521325715006745}}
{"timestamp": "2026-02-16T08:33:39.572799+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 7, "island_id": 2, "population_idx": 4, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:34:13.700768+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i3_p0_685243149", "generation": 7, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5289315726290517, "fitness_mode": "correlation", "simplicity_score": 0.24851180164633907, "novelty_bonus": 0.16304959829535792, "total_score": 0.34753646279844974, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length.\n\n    This heuristic blends several global topological signals—\n    size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, and assortativity—\n    without using any external libraries or explicit shortest‑path\n    algorithms.  All operations are built‑in Python functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys listed in the prompt.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert main numeric features to float for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass   = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    degs  = s['degrees']          # list of int degrees\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase paths)\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get a larger value\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees (captures skewness of the distribution)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction: high clustering tends to shorten paths\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles tend to shrink paths\n    tri_term = (tri + 1.0) ** 0.3\n\n    # 7. Assortativity boost: mixing can create shortcuts\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.104256\nbelow_train_threshold: train_signal=0.274910\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a blend of\n    global graph statistics.  No external libraries are imported and the\n    function never returns a single feature directly.  All operations\n    use only built‑in Python operators and functions.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Keys that are\n        guaranteed to exist are:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        A heuristic estimate of the graph's average shortest‑path length.\n    \"\"\"\n    # ----- Convert numeric features to float for consistency -----\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass    = float(s['degree_assortativity'])\n    tri    = float(s['num_triangles'])\n    clus   = float(s['avg_clustering'])\n    trans  = float(s['transitivity'])\n    degs   = s['degrees']          # list of ints\n\n    # ----- Size / density hybrid -----\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # ----- Density penalty (sparser graphs give a larger value) -----\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # ----- Degree‑dispersion factor (wide range increases path length) -----\n    disp_term = ((max_d + 1.0) / (min_d + 1.0)) ** 0.2\n\n    # ----- Harmonic mean of degrees (captures skewness) -----\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic = n / (h_sum + 1e-12)\n\n    # ----- Clustering/transitivity reduction (high values shorten paths) -----\n    cluster_term = (clus + trans + 1e-6) ** 0.5\n\n    # ----- Triangle shortcut effect -----\n    tri_term = (tri + 1.0) ** 0.35\n\n    # ----- Assortativity boost -----\n    assort_term = 1.0 + abs(ass)\n\n    # ----- Assemble the invariant -----\n    inv = (size_term * dens_term * disp_term *\n           harmonic * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a blend of\n    global graph statistics.  No external libraries are imported and the\n    function never returns a single feature directly.  All operations\n    use only built‑in Python operators and functions.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Keys that are\n        guaranteed to exist are:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        A heuristic estimate of the graph's average shortest‑path length.\n    \"\"\"\n    # ----- Convert numeric features to float for consistency -----\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass    = float(s['degree_assortativity'])\n    tri    = float(s['num_triangles'])\n    clus   = float(s['avg_clustering'])\n    trans  = float(s['transitivity'])\n    degs   = s['degrees']          # list of ints\n\n    # ----- Size / density hybrid -----\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # ----- Density penalty (sparser graphs give a larger value) -----\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # ----- Degree‑dispersion factor (wide range increases path length) -----\n    disp_term = ((max_d + 1.0) / (min_d + 1.0)) ** 0.2\n\n    # ----- Harmonic mean of degrees (captures skewness) -----\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic = n / (h_sum + 1e-12)\n\n    # ----- Clustering/transitivity reduction (high values shorten paths) -----\n    cluster_term = (clus + trans + 1e-6) ** 0.5\n\n    # ----- Triangle shortcut effect -----\n    tri_term = (tri + 1.0) ** 0.35\n\n    # ----- Assortativity boost -----\n    assort_term = 1.0 + abs(ass)\n\n    # ----- Assemble the invariant -----\n    inv = (size_term * dens_term * disp_term *\n           harmonic * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.49783844596114907, "pearson": 0.30187997227009755, "rmse": 6011.424147784976, "mae": 1174.1375339181766}}
{"timestamp": "2026-02-16T08:34:46.638206+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i3_p1_879250435", "generation": 7, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6187274909963985, "fitness_mode": "correlation", "simplicity_score": 0.24795247661365372, "novelty_bonus": 0.4014745368634215, "total_score": 0.4869487792798297, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length.\n\n    This heuristic blends several global topological signals—\n    size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, and assortativity—\n    without using any external libraries or explicit shortest‑path\n    algorithms.  All operations are built‑in Python functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys listed in the prompt.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert main numeric features to float for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass   = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    degs  = s['degrees']          # list of int degrees\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase paths)\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get a larger value\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees (captures skewness of the distribution)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction: high clustering tends to shorten paths\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles tend to shrink paths\n    tri_term = (tri + 1.0) ** 0.3\n\n    # 7. Assortativity boost: mixing can create shortcuts\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.104256\nbelow_train_threshold: train_signal=0.274910\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built solely from global\n    graph statistics.  The function uses only built‑in Python operations\n    and does not call any external libraries or shortest‑path routines.\n    \"\"\"\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']            # list of integers\n\n    # --- size–density blend  (larger graphs, sparser edges → larger paths)\n    size_term   = (n ** 1.1) / (m + 1.0)\n\n    # --- density penalty (sparser graphs increase the value)\n    dens_term   = 1.0 / (dens + 1e-9)\n\n    # --- degree dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.35) * (std_d + 1e-9) ** 0.2\n\n    # --- harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- clustering / transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # --- triangle shortcut effect\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- assemble the composite invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built solely from global\n    graph statistics.  The function uses only built‑in Python operations\n    and does not call any external libraries or shortest‑path routines.\n    \"\"\"\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']            # list of integers\n\n    # --- size–density blend  (larger graphs, sparser edges → larger paths)\n    size_term   = (n ** 1.1) / (m + 1.0)\n\n    # --- density penalty (sparser graphs increase the value)\n    dens_term   = 1.0 / (dens + 1e-9)\n\n    # --- degree dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.35) * (std_d + 1e-9) ** 0.2\n\n    # --- harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- clustering / transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # --- triangle shortcut effect\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- assemble the composite invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.633831845796145, "pearson": 0.7330730708079574, "rmse": 4.369073609951461, "mae": 3.1190349544205254}}
{"timestamp": "2026-02-16T08:35:35.462041+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i3_p2_699352441", "generation": 7, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.4836974789915966, "fitness_mode": "correlation", "simplicity_score": 0.24746488621996363, "novelty_bonus": 0.2633048635813895, "total_score": 0.42081999470736936, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length.\n\n    This heuristic blends several global topological signals—\n    size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, and assortativity—\n    without using any external libraries or explicit shortest‑path\n    algorithms.  All operations are built‑in Python functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys listed in the prompt.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert main numeric features to float for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass   = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    degs  = s['degrees']          # list of int degrees\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase paths)\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get a larger value\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees (captures skewness of the distribution)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction: high clustering tends to shorten paths\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles tend to shrink paths\n    tri_term = (tri + 1.0) ** 0.3\n\n    # 7. Assortativity boost: mixing can create shortcuts\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.104256\nbelow_train_threshold: train_signal=0.274910\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length based on a blend of\n    global structural statistics.  No external libraries are used and the\n    expression does not rely on a single feature.  It mixes size, density,\n    degree dispersion, harmonic mean of degrees, clustering, triangle\n    abundance, assortativity, and the ratio of average to standard degree.\n    \"\"\"\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    avg_degree = float(s['avg_degree'])\n    max_degree = float(s['max_degree'])\n    min_degree = float(s['min_degree'])\n    std_degree = float(s['std_degree'])\n    avg_clustering = float(s['avg_clustering'])\n    transitivity = float(s['transitivity'])\n    degree_assortativity = float(s['degree_assortativity'])\n    num_triangles = float(s['num_triangles'])\n    degrees = s['degrees']  # list of ints\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase path length)\n    size_factor = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty (sparser graphs give a larger value)\n    density_factor = 1.0 / (density + 1e-9)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    degree_disp_factor = ((max_degree - min_degree + 1.0) ** 0.3)\n\n    # 4. Harmonic mean of degrees (captures skewness)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction (high clustering shortens paths)\n    clustering_factor = 1.0 / (avg_clustering + transitivity + 1e-9)\n\n    # 6. Triangle shortcut influence (more triangles shrink paths)\n    triangle_factor = (num_triangles + 1.0) ** 0.4\n\n    # 7. Assortativity boost (mixing can create shortcuts)\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # 8. Avg degree over std degree (captures regularity of the degree distribution)\n    degree_avg_factor = avg_degree / (std_degree + 1e-12)\n\n    # Assemble the invariant\n    inv = (size_factor * density_factor * degree_disp_factor *\n           harmonic_mean * assort_factor * degree_avg_factor)\n    inv = inv / (clustering_factor * triangle_factor)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length based on a blend of\n    global structural statistics.  No external libraries are used and the\n    expression does not rely on a single feature.  It mixes size, density,\n    degree dispersion, harmonic mean of degrees, clustering, triangle\n    abundance, assortativity, and the ratio of average to standard degree.\n    \"\"\"\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    avg_degree = float(s['avg_degree'])\n    max_degree = float(s['max_degree'])\n    min_degree = float(s['min_degree'])\n    std_degree = float(s['std_degree'])\n    avg_clustering = float(s['avg_clustering'])\n    transitivity = float(s['transitivity'])\n    degree_assortativity = float(s['degree_assortativity'])\n    num_triangles = float(s['num_triangles'])\n    degrees = s['degrees']  # list of ints\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase path length)\n    size_factor = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty (sparser graphs give a larger value)\n    density_factor = 1.0 / (density + 1e-9)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    degree_disp_factor = ((max_degree - min_degree + 1.0) ** 0.3)\n\n    # 4. Harmonic mean of degrees (captures skewness)\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction (high clustering shortens paths)\n    clustering_factor = 1.0 / (avg_clustering + transitivity + 1e-9)\n\n    # 6. Triangle shortcut influence (more triangles shrink paths)\n    triangle_factor = (num_triangles + 1.0) ** 0.4\n\n    # 7. Assortativity boost (mixing can create shortcuts)\n    assort_factor = 1.0 + abs(degree_assortativity)\n\n    # 8. Avg degree over std degree (captures regularity of the degree distribution)\n    degree_avg_factor = avg_degree / (std_degree + 1e-12)\n\n    # Assemble the invariant\n    inv = (size_factor * density_factor * degree_disp_factor *\n           harmonic_mean * assort_factor * degree_avg_factor)\n    inv = inv / (clustering_factor * triangle_factor)\n\n    return inv", "spearman": 0.5846711167779196, "pearson": 0.570554315267445, "rmse": 3.85633224190832, "mae": 2.292828193309704}}
{"timestamp": "2026-02-16T08:36:17.469120+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i3_p3_952716637", "generation": 7, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.4625690276110444, "fitness_mode": "correlation", "simplicity_score": 0.2475763488720511, "novelty_bonus": 0.4634500862521562, "total_score": 0.43608873411101867, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length.\n\n    This heuristic blends several global topological signals—\n    size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, and assortativity—\n    without using any external libraries or explicit shortest‑path\n    algorithms.  All operations are built‑in Python functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys listed in the prompt.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert main numeric features to float for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass   = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    degs  = s['degrees']          # list of int degrees\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase paths)\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get a larger value\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees (captures skewness of the distribution)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction: high clustering tends to shorten paths\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles tend to shrink paths\n    tri_term = (tri + 1.0) ** 0.3\n\n    # 7. Assortativity boost: mixing can create shortcuts\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.104256\nbelow_train_threshold: train_signal=0.274910\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length built from a\n    multiplicative blend of global statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed graph features.  Keys:\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity, num_triangles,\n        degrees (list of node degrees).\n\n    Returns\n    -------\n    float\n        An invariant that correlates with the average shortest‑path\n        length.  The expression uses only standard Python operations and\n        built‑in types – no external libraries or explicit shortest‑path\n        algorithms are involved.\n    \"\"\"\n    # Core numeric values – cast to float for safety\n    n           = float(s['n'])\n    m           = float(s['m'])\n    density     = float(s['density'])\n    avg_deg     = float(s['avg_degree'])\n    max_deg     = float(s['max_degree'])\n    min_deg     = float(s['min_degree'])\n    std_deg     = float(s['std_degree'])\n    avg_clust   = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    num_tri     = float(s['num_triangles'])\n    degrees     = s['degrees']           # list of ints\n\n    # ---------- 1. Size & density interplay ----------\n    # Larger graphs and sparser edges give longer paths\n    size_density = (n ** 0.8) / (m + 1.0)\n\n    # ---------- 2. Explicit density penalty ----------\n    density_pen = 1.0 / (density + 1e-6)\n\n    # ---------- 3. Degree dispersion ----------\n    # Wider range → more heterogeneity → larger average distance\n    dispersion = (max_deg - min_deg + 1.0) ** 0.3\n\n    # ---------- 4. Harmonic mean of degrees ----------\n    # Captures skewness without requiring external math functions\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # ---------- 5. Standard deviation factor ----------\n    # A higher spread in degrees can increase path length\n    std_factor = std_deg + 1.0\n\n    # ---------- 6. Clustering/transitivity moderation ----------\n    # Highly clustered graphs usually have shorter paths\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # ---------- 7. Triangle shortcut multiplier ----------\n    triangle_term = (num_tri + 1.0) ** 0.4\n\n    # ---------- 8. Assortativity boost ----------\n    # Assortative mixing often introduces shortcuts\n    assort_term = 1.0 + abs(assort)\n\n    # ---------- 9. Assemble the invariant ----------\n    # Multiply the positive contributions and divide by the\n    # short‑cut reducing terms.\n    inv = (size_density * density_pen * dispersion *\n           harmonic_mean * std_factor * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length built from a\n    multiplicative blend of global statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed graph features.  Keys:\n        n, m, density, avg_degree, max_degree, min_degree, std_degree,\n        avg_clustering, transitivity, degree_assortativity, num_triangles,\n        degrees (list of node degrees).\n\n    Returns\n    -------\n    float\n        An invariant that correlates with the average shortest‑path\n        length.  The expression uses only standard Python operations and\n        built‑in types – no external libraries or explicit shortest‑path\n        algorithms are involved.\n    \"\"\"\n    # Core numeric values – cast to float for safety\n    n           = float(s['n'])\n    m           = float(s['m'])\n    density     = float(s['density'])\n    avg_deg     = float(s['avg_degree'])\n    max_deg     = float(s['max_degree'])\n    min_deg     = float(s['min_degree'])\n    std_deg     = float(s['std_degree'])\n    avg_clust   = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    num_tri     = float(s['num_triangles'])\n    degrees     = s['degrees']           # list of ints\n\n    # ---------- 1. Size & density interplay ----------\n    # Larger graphs and sparser edges give longer paths\n    size_density = (n ** 0.8) / (m + 1.0)\n\n    # ---------- 2. Explicit density penalty ----------\n    density_pen = 1.0 / (density + 1e-6)\n\n    # ---------- 3. Degree dispersion ----------\n    # Wider range → more heterogeneity → larger average distance\n    dispersion = (max_deg - min_deg + 1.0) ** 0.3\n\n    # ---------- 4. Harmonic mean of degrees ----------\n    # Captures skewness without requiring external math functions\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # ---------- 5. Standard deviation factor ----------\n    # A higher spread in degrees can increase path length\n    std_factor = std_deg + 1.0\n\n    # ---------- 6. Clustering/transitivity moderation ----------\n    # Highly clustered graphs usually have shorter paths\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # ---------- 7. Triangle shortcut multiplier ----------\n    triangle_term = (num_tri + 1.0) ** 0.4\n\n    # ---------- 8. Assortativity boost ----------\n    # Assortative mixing often introduces shortcuts\n    assort_term = 1.0 + abs(assort)\n\n    # ---------- 9. Assemble the invariant ----------\n    # Multiply the positive contributions and divide by the\n    # short‑cut reducing terms.\n    inv = (size_density * density_pen * dispersion *\n           harmonic_mean * std_factor * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv", "spearman": 0.49507687692192315, "pearson": 0.5612362769486019, "rmse": 2.881319355049566, "mae": 1.8750027312406408}}
{"timestamp": "2026-02-16T08:36:55.682598+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g7_i3_p4_352038400", "generation": 7, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6134453781512604, "fitness_mode": "correlation", "simplicity_score": 0.24738254017056902, "novelty_bonus": 0.3820505512637815, "total_score": 0.44691324395251175, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length.\n\n    This heuristic blends several global topological signals—\n    size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, and assortativity—\n    without using any external libraries or explicit shortest‑path\n    algorithms.  All operations are built‑in Python functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys listed in the prompt.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert main numeric features to float for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass   = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    degs  = s['degrees']          # list of int degrees\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase paths)\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get a larger value\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees (captures skewness of the distribution)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction: high clustering tends to shorten paths\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles tend to shrink paths\n    tri_term = (tri + 1.0) ** 0.3\n\n    # 7. Assortativity boost: mixing can create shortcuts\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length based on a composite\n    of global graph statistics.  The formula is a multiplicative blend\n    of size, density, degree dispersion, harmonic mean of degrees,\n    clustering, triangle abundance and assortativity, without\n    relying on any single feature alone.\n    \"\"\"\n\n    # Basic quantities\n    n         = float(s['n'])\n    m         = float(s['m'])\n    density   = float(s['density'])\n    max_deg   = float(s['max_degree'])\n    min_deg   = float(s['min_degree'])\n    std_deg   = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    tri       = float(s['num_triangles'])\n    degrees   = s['degrees']            # list of ints\n\n    # --- 1. Size–density hybrid term\n    #   Larger graphs increase path length; sparser graphs (smaller m) increase it\n    size_term = (n ** 0.75) / (m + 1.0)\n\n    # --- 2. Density penalty (lower density → larger value)\n    dens_term = 1.0 / (density + 1e-9)\n\n    # --- 3. Degree‑dispersion influence\n    deg_range = (max_deg - min_deg + 1.0)\n    disp_term = deg_range ** 0.3\n\n    # --- 4. Harmonic mean of degrees\n    #   Harmonic mean captures skewness without needing external libs\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic = n / (harmonic_sum + 1e-12)  # avoid div‑by‑zero\n    harmonic_term = harmonic\n\n    # --- 5. Clustering‑transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # --- 6. Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.104256\nbelow_train_threshold: train_signal=0.274910\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using a mixture of\n    global graph statistics.  The formula blends several aspects\n    – graph size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, assortativity and\n    degree variance – without invoking any external libraries or\n    explicit shortest‑path algorithms.\n    \"\"\"\n    # Extract numerical features as floats for safety\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    avg_d      = float(s['avg_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    deg_list   = s['degrees']           # list of int degrees\n\n    # 1. Size–density term: larger and sparser graphs tend to have longer paths\n    size_term = (n ** 0.55) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs increase the value\n    dens_term = 1.0 / (density + 1e-9)\n\n    # 3. Degree‑dispersion influence (wide range inflates path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.3)\n\n    # 4. Harmonic mean of degrees (captures skewness without external libs)\n    harmonic_sum = 0.0\n    for d in deg_list:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Degree‑variance factor: higher variance tends to increase path length\n    var_factor = 1.0 + (std_d / (avg_d + 1e-12))\n\n    # 6. Clustering‑transitivity reduction: higher clustering shortens paths\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # 7. Triangle shortcut effect: more triangles shrink distances\n    tri_term = (num_tri + 1.0) ** 0.35\n\n    # 8. Assortativity boost: assortative mixing can create shortcuts\n    assort_term = 1.0 + abs(assort)\n\n    # Combine everything multiplicatively, balancing the influences\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * var_factor * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using a mixture of\n    global graph statistics.  The formula blends several aspects\n    – graph size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, assortativity and\n    degree variance – without invoking any external libraries or\n    explicit shortest‑path algorithms.\n    \"\"\"\n    # Extract numerical features as floats for safety\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    avg_d      = float(s['avg_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    deg_list   = s['degrees']           # list of int degrees\n\n    # 1. Size–density term: larger and sparser graphs tend to have longer paths\n    size_term = (n ** 0.55) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs increase the value\n    dens_term = 1.0 / (density + 1e-9)\n\n    # 3. Degree‑dispersion influence (wide range inflates path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.3)\n\n    # 4. Harmonic mean of degrees (captures skewness without external libs)\n    harmonic_sum = 0.0\n    for d in deg_list:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Degree‑variance factor: higher variance tends to increase path length\n    var_factor = 1.0 + (std_d / (avg_d + 1e-12))\n\n    # 6. Clustering‑transitivity reduction: higher clustering shortens paths\n    cluster_term = 1.0 / (avg_clust + trans + 1e-9)\n\n    # 7. Triangle shortcut effect: more triangles shrink distances\n    tri_term = (num_tri + 1.0) ** 0.35\n\n    # 8. Assortativity boost: assortative mixing can create shortcuts\n    assort_term = 1.0 + abs(assort)\n\n    # Combine everything multiplicatively, balancing the influences\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * var_factor * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.565643141078527, "pearson": 0.6547428673512767, "rmse": 2.0647551463621996, "mae": 1.9290157381254769}}
{"timestamp": "2026-02-16T08:36:55.685560+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 8, "model_name": "gpt-oss:20b", "best_val_score": 0.5627212573413072, "no_improve_count": 0}}
{"timestamp": "2026-02-16T08:39:36.486186+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i0_p0_933969318", "generation": 8, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.3766146458583433, "fitness_mode": "correlation", "simplicity_score": 0.1186189375370042, "novelty_bonus": 0.24959085151079252, "total_score": 0.22840603808551674, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: scales with sqrt(n) and inversely with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser → longer paths\n    clustering_adj = 1 - clustering                      # more clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.033894\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    trans = s['transitivity']\n    min_deg = s['min_degree']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser → longer paths\n    clustering_adj = 1 - clustering                      # more clustering → shorter paths\n    assort_adj    = 1 - assort                            # disassortative → shorter paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n    trans_adj     = 1 - trans                             # higher transitivity → shorter paths\n    min_adj       = 1 + (1 - min_deg / (avg_deg + eps))   # low min degree → longer paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n    trans_adj     = max(0.1, min(10, trans_adj))\n    min_adj       = max(0.1, min(10, min_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj * trans_adj * min_adj", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    trans = s['transitivity']\n    min_deg = s['min_degree']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser → longer paths\n    clustering_adj = 1 - clustering                      # more clustering → shorter paths\n    assort_adj    = 1 - assort                            # disassortative → shorter paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n    trans_adj     = 1 - trans                             # higher transitivity → shorter paths\n    min_adj       = 1 + (1 - min_deg / (avg_deg + eps))   # low min degree → longer paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n    trans_adj     = max(0.1, min(10, trans_adj))\n    min_adj       = max(0.1, min(10, min_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj * trans_adj * min_adj", "spearman": 0.2596099902497563, "pearson": 0.12580875237946093, "rmse": 2.175385778411153, "mae": 1.8343843905602097}}
{"timestamp": "2026-02-16T08:40:21.035746+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.131207", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:40:21.036269+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 8, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.131207", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:40:46.037364+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:40:46.038357+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 8, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:41:29.321799+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:41:29.323725+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 8, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:41:48.677107+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 0, "population_idx": 2, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:41:48.677920+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 8, "island_id": 0, "population_idx": 2, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:42:30.775245+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i0_p3_505152712", "generation": 8, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.363265306122449, "fitness_mode": "correlation", "simplicity_score": 0.11864129925683053, "novelty_bonus": 0.3619764513529441, "total_score": 0.3026369531511967, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: scales with sqrt(n) and inversely with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser → longer paths\n    clustering_adj = 1 - clustering                      # more clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.131207\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    trans = s['transitivity']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser → longer paths\n    clustering_adj = 1 - clustering                      # more clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n    min_adj       = 1 + (1 - min_deg / (avg_deg + eps))   # low minimum degree → longer paths\n    trans_adj     = 1 - trans                             # high transitivity → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n    min_adj       = max(0.1, min(10, min_adj))\n    trans_adj     = max(0.1, min(10, trans_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj * min_adj * trans_adj\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    trans = s['transitivity']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser → longer paths\n    clustering_adj = 1 - clustering                      # more clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n    min_adj       = 1 + (1 - min_deg / (avg_deg + eps))   # low minimum degree → longer paths\n    trans_adj     = 1 - trans                             # high transitivity → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n    min_adj       = max(0.1, min(10, min_adj))\n    trans_adj     = max(0.1, min(10, trans_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj * min_adj * trans_adj", "spearman": 0.3406315157878947, "pearson": 0.20812002778484567, "rmse": 2.1856863406382634, "mae": 1.8986618867500824}}
{"timestamp": "2026-02-16T08:44:00.317321+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:44:00.319040+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 8, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:44:19.235817+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 0, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:44:19.236460+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 8, "island_id": 0, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:45:53.812177+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i1_p0_491313832", "generation": 8, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15415693150818588, "novelty_bonus": 0.25199429985749633, "total_score": 0.2848456366578961, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T08:46:21.450794+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i1_p1_883295760", "generation": 8, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15415693150818588, "novelty_bonus": 0.25199429985749633, "total_score": 0.2848456366578961, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        The invariant value.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        The invariant value.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T08:47:20.737426+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i1_p2_852535647", "generation": 8, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15415693150818588, "novelty_bonus": 0.25199429985749633, "total_score": 0.2848456366578961, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T08:47:40.389082+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i1_p3_143003048", "generation": 8, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15401258590532532, "novelty_bonus": 0.25199429985749633, "total_score": 0.28481676753732393, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T08:48:07.051970+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i1_p4_958034766", "generation": 8, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15401258590532532, "novelty_bonus": 0.25199429985749633, "total_score": 0.28481676753732393, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s.get('degree_assortativity', 0)\n    std_deg = s.get('std_degree', 0)\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T08:48:58.128739+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i2_p0_590880149", "generation": 8, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7218727490996399, "fitness_mode": "correlation", "simplicity_score": 0.22236282455199058, "novelty_bonus": 0.19043785597933904, "total_score": 0.5222331874358432, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the size of the\n    graph and shrinks with the average degree.  It is then adjusted by\n    several structural factors that are known to influence path lengths:\n\n    * **Clustering** – higher clustering tends to create detours,\n      therefore the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of degrees\n      (presence of hubs) shortens paths, so the estimate is divided by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Density** – denser graphs have shorter paths.  We multiply by a\n      factor proportional to (1 – density), bounded below by 0.05 to\n      avoid negative values.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n\n    All arithmetic is safe from division by zero, and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Clustering and assortativity factors\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Heterogeneity and minimum‑degree adjustments\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.024261\nbelow_novelty_threshold: novelty_bonus=0.110087\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n\n    The estimate starts from a baseline that grows with the number of nodes\n    and shrinks with the average degree.  It is then progressively adjusted\n    by a handful of structural factors that are known to influence path\n    lengths.  All arithmetic is safe from division by zero and the\n    expression stays compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``.\n    \"\"\"\n    # Basic quantities with guards against zero\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 1\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with avg_degree\n    base = n / (avg_deg + 1)\n\n    # Effects of clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assort))\n\n    # Degree heterogeneity and presence of hubs\n    base /= (1 + std_deg)\n    # A very large max_degree relative to avg_degree shortens paths\n    base /= (1 + max_deg / avg_deg)\n\n    # Minimum degree (leaves) tends to lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # Density: denser graphs have shorter paths\n    base *= 1 / (1 + density)\n\n    # Triangle ratio: more triangles reduce average distances\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # Global transitivity (another clustering measure)\n    base *= (1 + s['transitivity'])\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n\n    The estimate starts from a baseline that grows with the number of nodes\n    and shrinks with the average degree.  It is then progressively adjusted\n    by a handful of structural factors that are known to influence path\n    lengths.  All arithmetic is safe from division by zero and the\n    expression stays compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``.\n    \"\"\"\n    # Basic quantities with guards against zero\n    n          = s['n']\n    avg_deg    = s['avg_degree'] if s['avg_degree'] > 0 else 1\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 1\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with avg_degree\n    base = n / (avg_deg + 1)\n\n    # Effects of clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assort))\n\n    # Degree heterogeneity and presence of hubs\n    base /= (1 + std_deg)\n    # A very large max_degree relative to avg_degree shortens paths\n    base /= (1 + max_deg / avg_deg)\n\n    # Minimum degree (leaves) tends to lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # Density: denser graphs have shorter paths\n    base *= 1 / (1 + density)\n\n    # Triangle ratio: more triangles reduce average distances\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # Global transitivity (another clustering measure)\n    base *= (1 + s['transitivity'])\n\n    return base", "spearman": 0.8412585314632867, "pearson": 0.8167729583728379, "rmse": 1.5126352931962745, "mae": 1.201304431672231}}
{"timestamp": "2026-02-16T08:49:30.639308+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:49:30.639665+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 8, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:50:09.745862+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.136526", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:50:09.746466+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 8, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:50:49.508300+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.136526", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:50:49.508843+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 8, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.136526", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:51:16.341366+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 2, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.133341", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:51:16.341669+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 8, "island_id": 2, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:52:22.912939+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.136526", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:52:22.913737+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 8, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.136526", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:52:48.099651+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 2, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:52:48.100368+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 8, "island_id": 2, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:53:35.425709+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.095242", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:53:35.426732+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 8, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.095242", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:54:17.078167+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 2, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:54:17.078985+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 8, "island_id": 2, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:54:47.701600+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i3_p0_606381433", "generation": 8, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6385114045618246, "fitness_mode": "correlation", "simplicity_score": 0.24795247661365372, "novelty_bonus": 0.3745968649216229, "total_score": 0.47446861727577955, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built solely from global\n    graph statistics.  The function uses only built‑in Python operations\n    and does not call any external libraries or shortest‑path routines.\n    \"\"\"\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']            # list of integers\n\n    # --- size–density blend  (larger graphs, sparser edges → larger paths)\n    size_term   = (n ** 1.1) / (m + 1.0)\n\n    # --- density penalty (sparser graphs increase the value)\n    dens_term   = 1.0 / (dens + 1e-9)\n\n    # --- degree dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.35) * (std_d + 1e-9) ** 0.2\n\n    # --- harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- clustering / transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # --- triangle shortcut effect\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- assemble the composite invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length.\n\n    This heuristic blends several global topological signals—\n    size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, and assortativity—\n    without using any external libraries or explicit shortest‑path\n    algorithms.  All operations are built‑in Python functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys listed in the prompt.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert main numeric features to float for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass   = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    degs  = s['degrees']          # list of int degrees\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase paths)\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get a larger value\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees (captures skewness of the distribution)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction: high clustering tends to shorten paths\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles tend to shrink paths\n    tri_term = (tri + 1.0) ** 0.3\n\n    # 7. Assortativity boost: mixing can create shortcuts\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.104256\nbelow_train_threshold: train_signal=0.274910\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using a blend of global\n    structural statistics.  The expression mixes the size of the graph,\n    its sparsity, degree spread, harmonic degree mean, clustering\n    properties, triangle abundance and assortativity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic numeric values\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']          # list of int degrees\n\n    # --- Size and sparsity terms\n    size_term   = (n ** 0.85) / (m + 1.0)\n    dens_pen    = 1.0 / (dens + 1e-8)\n\n    # --- Degree‑dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.25) * ((std_d + 1e-6) ** 0.15)\n\n    # --- Harmonic mean of degrees\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- Clustering/transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # --- Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.35\n\n    # --- Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- Assemble the invariant\n    inv = (size_term * dens_pen * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using a blend of global\n    structural statistics.  The expression mixes the size of the graph,\n    its sparsity, degree spread, harmonic degree mean, clustering\n    properties, triangle abundance and assortativity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic numeric values\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']          # list of int degrees\n\n    # --- Size and sparsity terms\n    size_term   = (n ** 0.85) / (m + 1.0)\n    dens_pen    = 1.0 / (dens + 1e-8)\n\n    # --- Degree‑dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.25) * ((std_d + 1e-6) ** 0.15)\n\n    # --- Harmonic mean of degrees\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- Clustering/transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # --- Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.35\n\n    # --- Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- Assemble the invariant\n    inv = (size_term * dens_pen * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.6249981249531239, "pearson": 0.7459461937390459, "rmse": 1.279872993513438, "mae": 1.011354460900101}}
{"timestamp": "2026-02-16T08:55:21.493791+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.163217", "model_name": "gpt-oss:20b", "train_signal": 0.1632172869147659}}
{"timestamp": "2026-02-16T08:55:51.844513+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i3_p2_825511795", "generation": 8, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.535750300120048, "fitness_mode": "correlation", "simplicity_score": 0.24722096000728, "novelty_bonus": 0.4308183409538626, "total_score": 0.45740266211181047, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built solely from global\n    graph statistics.  The function uses only built‑in Python operations\n    and does not call any external libraries or shortest‑path routines.\n    \"\"\"\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']            # list of integers\n\n    # --- size–density blend  (larger graphs, sparser edges → larger paths)\n    size_term   = (n ** 1.1) / (m + 1.0)\n\n    # --- density penalty (sparser graphs increase the value)\n    dens_term   = 1.0 / (dens + 1e-9)\n\n    # --- degree dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.35) * (std_d + 1e-9) ** 0.2\n\n    # --- harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- clustering / transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # --- triangle shortcut effect\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- assemble the composite invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length.\n\n    This heuristic blends several global topological signals—\n    size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, and assortativity—\n    without using any external libraries or explicit shortest‑path\n    algorithms.  All operations are built‑in Python functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys listed in the prompt.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert main numeric features to float for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass   = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    degs  = s['degrees']          # list of int degrees\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase paths)\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get a larger value\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees (captures skewness of the distribution)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction: high clustering tends to shorten paths\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles tend to shrink paths\n    tri_term = (tri + 1.0) ** 0.3\n\n    # 7. Assortativity boost: mixing can create shortcuts\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.104256\nbelow_train_threshold: train_signal=0.274910\nbelow_train_threshold: train_signal=0.163217\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest‑path length computed\n    solely from global graph statistics.\n    \n    The function mixes size, density, degree dispersion, harmonic mean\n    of degrees, clustering, triangle abundance and assortativity into a\n    composite expression.  No external libraries or explicit path\n    computations are used.  Epsilon values guard against division by\n    zero or log of non‑positive numbers.\n    \"\"\"\n    # Pull features, converting to float for numeric safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    avg_deg = float(s['avg_degree'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    std_d  = float(s['std_degree'])\n    clus   = float(s['avg_clustering'])\n    trans  = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    tri    = float(s['num_triangles'])\n    degs   = s['degrees']          # list of ints\n    \n    # ----- 1. Size / density hybrid term ----------\n    # larger graphs and sparser edges => longer average paths\n    size_term = (n ** 0.85) / (m + 1.0)\n    \n    # ----- 2. Density penalty ---------------------\n    dens_term = 1.0 / (dens + 1e-9)\n    \n    # ----- 3. Degree‑dispersion influence ----------\n    disp_term = ((max_d - min_d + 1.0) ** 0.4) * ((std_d + 1e-6) ** 0.2)\n    \n    # ----- 4. Harmonic mean of degrees -------------\n    hsum = 0.0\n    for d in degs:\n        if d > 0:\n            hsum += 1.0 / float(d)\n    harmonic_mean = n / (hsum + 1e-12)\n    \n    # ----- 5. Clustering/transitivity reduction ----\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n    \n    # ----- 6. Triangle shortcut effect -------------\n    tri_term = (tri + 1.0) ** 0.35\n    \n    # ----- 7. Assortativity boost ------------------\n    assort_term = 1.0 + abs(assort)\n    \n    # ----- 8. Optional use of avg degree ---------\n    # The average degree enters multiplicatively to give extra\n    # sensitivity to the overall edge density (excluding the\n    # explicit density term to keep the formula balanced).\n    avg_deg_term = (avg_deg + 1.0) ** 0.25\n    \n    # ----- 9. Assemble the invariant ----------------\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * avg_deg_term *\n           assort_term)\n    inv = inv / (cluster_term * tri_term)\n    \n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Heuristic estimate of the average shortest‑path length computed\n    solely from global graph statistics.\n    \n    The function mixes size, density, degree dispersion, harmonic mean\n    of degrees, clustering, triangle abundance and assortativity into a\n    composite expression.  No external libraries or explicit path\n    computations are used.  Epsilon values guard against division by\n    zero or log of non‑positive numbers.\n    \"\"\"\n    # Pull features, converting to float for numeric safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    avg_deg = float(s['avg_degree'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    std_d  = float(s['std_degree'])\n    clus   = float(s['avg_clustering'])\n    trans  = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    tri    = float(s['num_triangles'])\n    degs   = s['degrees']          # list of ints\n    \n    # ----- 1. Size / density hybrid term ----------\n    # larger graphs and sparser edges => longer average paths\n    size_term = (n ** 0.85) / (m + 1.0)\n    \n    # ----- 2. Density penalty ---------------------\n    dens_term = 1.0 / (dens + 1e-9)\n    \n    # ----- 3. Degree‑dispersion influence ----------\n    disp_term = ((max_d - min_d + 1.0) ** 0.4) * ((std_d + 1e-6) ** 0.2)\n    \n    # ----- 4. Harmonic mean of degrees -------------\n    hsum = 0.0\n    for d in degs:\n        if d > 0:\n            hsum += 1.0 / float(d)\n    harmonic_mean = n / (hsum + 1e-12)\n    \n    # ----- 5. Clustering/transitivity reduction ----\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n    \n    # ----- 6. Triangle shortcut effect -------------\n    tri_term = (tri + 1.0) ** 0.35\n    \n    # ----- 7. Assortativity boost ------------------\n    assort_term = 1.0 + abs(assort)\n    \n    # ----- 8. Optional use of avg degree ---------\n    # The average degree enters multiplicatively to give extra\n    # sensitivity to the overall edge density (excluding the\n    # explicit density term to keep the formula balanced).\n    avg_deg_term = (avg_deg + 1.0) ** 0.25\n    \n    # ----- 9. Assemble the invariant ----------------\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * avg_deg_term *\n           assort_term)\n    inv = inv / (cluster_term * tri_term)\n    \n    return inv", "spearman": 0.5574259356483914, "pearson": 0.6767690608713341, "rmse": 3.153210757218582, "mae": 2.2728599580479347}}
{"timestamp": "2026-02-16T08:56:30.637096+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i3_p3_593479727", "generation": 8, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.614501800720288, "fitness_mode": "correlation", "simplicity_score": 0.2481336841741844, "novelty_bonus": 0.37080327008175185, "total_score": 0.4615299844160264, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built solely from global\n    graph statistics.  The function uses only built‑in Python operations\n    and does not call any external libraries or shortest‑path routines.\n    \"\"\"\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']            # list of integers\n\n    # --- size–density blend  (larger graphs, sparser edges → larger paths)\n    size_term   = (n ** 1.1) / (m + 1.0)\n\n    # --- density penalty (sparser graphs increase the value)\n    dens_term   = 1.0 / (dens + 1e-9)\n\n    # --- degree dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.35) * (std_d + 1e-9) ** 0.2\n\n    # --- harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- clustering / transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # --- triangle shortcut effect\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- assemble the composite invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length.\n\n    This heuristic blends several global topological signals—\n    size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, and assortativity—\n    without using any external libraries or explicit shortest‑path\n    algorithms.  All operations are built‑in Python functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys listed in the prompt.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert main numeric features to float for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass   = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    degs  = s['degrees']          # list of int degrees\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase paths)\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get a larger value\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees (captures skewness of the distribution)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction: high clustering tends to shorten paths\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles tend to shrink paths\n    tri_term = (tri + 1.0) ** 0.3\n\n    # 7. Assortativity boost: mixing can create shortcuts\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.104256\nbelow_train_threshold: train_signal=0.274910\nbelow_train_threshold: train_signal=0.163217\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length from only global graph\n    statistics.  The function is deliberately combinatorial and avoids\n    returning any single feature directly.  No graph traversal algorithms\n    are used – only arithmetic operations on the supplied pre‑computed\n    feature dictionary.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with the following keys:\n            n                    (int)          number of nodes\n            m                    (int)          number of edges\n            density              (float)        edge density\n            avg_degree           (float)        average degree\n            max_degree           (int)          maximum degree\n            min_degree           (int)          minimum degree\n            std_degree           (float)        standard deviation of degree\n            avg_clustering       (float)        average local clustering\n            transitivity         (float)        global transitivity\n            degree_assortativity (float)        assortativity coefficient\n            num_triangles        (int)          number of triangles\n            degrees              (list[int])    sorted degree sequence\n\n    Returns\n    -------\n    float\n        Heuristic estimate of the graph's average shortest‑path length.\n    \"\"\"\n    # Core numeric values ----------------------------------------------------\n    n   = float(s['n'])\n    m   = float(s['m'])\n    dens= float(s['density'])\n    max_d = float(s['max_degree'])\n    min_d = float(s['min_degree'])\n    std_d = float(s['std_degree'])\n    clus   = float(s['avg_clustering'])\n    trans  = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    tri    = float(s['num_triangles'])\n    degs   = s['degrees']          # list of int degrees\n\n    # -----------------------------------------------------------------------\n    # 1. Size–density blend: larger graphs with fewer edges usually have\n    #    longer average paths.  Exponent 0.65 offers a sub‑linear growth.\n    size_term = (n ** 0.65) / (m + 1.0)\n\n    # 2. Density penalty: sparse networks tend to increase path length.\n    dens_term = 1.0 / (dens + 1e-9)\n\n    # 3. Degree‑dispersion influence: wide, highly skewed distributions\n    #    (captured by max‑min range plus std‑dev) tend to inflate distances.\n    disp_term = ((max_d - min_d + std_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees: reflects the presence of hubs.\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. Clustering / transitivity reduction: higher clustering often\n    #    introduces many short loops that reduce effective distances.\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # 6. Triangle shortcut effect: many triangles usually produce shortcuts.\n    tri_term = (tri + 1.0) ** 0.35\n\n    # 7. Assortativity boost: assortative mixing can create additional\n    #    short‑cut connections between high‑degree nodes.\n    assort_term = 1.0 + abs(assort)\n\n    # -----------------------------------------------------------------------\n    # 8. Assemble the composite invariant -----------------------------------\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length from only global graph\n    statistics.  The function is deliberately combinatorial and avoids\n    returning any single feature directly.  No graph traversal algorithms\n    are used – only arithmetic operations on the supplied pre‑computed\n    feature dictionary.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with the following keys:\n            n                    (int)          number of nodes\n            m                    (int)          number of edges\n            density              (float)        edge density\n            avg_degree           (float)        average degree\n            max_degree           (int)          maximum degree\n            min_degree           (int)          minimum degree\n            std_degree           (float)        standard deviation of degree\n            avg_clustering       (float)        average local clustering\n            transitivity         (float)        global transitivity\n            degree_assortativity (float)        assortativity coefficient\n            num_triangles        (int)          number of triangles\n            degrees              (list[int])    sorted degree sequence\n\n    Returns\n    -------\n    float\n        Heuristic estimate of the graph's average shortest‑path length.\n    \"\"\"\n    # Core numeric values ----------------------------------------------------\n    n   = float(s['n'])\n    m   = float(s['m'])\n    dens= float(s['density'])\n    max_d = float(s['max_degree'])\n    min_d = float(s['min_degree'])\n    std_d = float(s['std_degree'])\n    clus   = float(s['avg_clustering'])\n    trans  = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    tri    = float(s['num_triangles'])\n    degs   = s['degrees']          # list of int degrees\n\n    # -----------------------------------------------------------------------\n    # 1. Size–density blend: larger graphs with fewer edges usually have\n    #    longer average paths.  Exponent 0.65 offers a sub‑linear growth.\n    size_term = (n ** 0.65) / (m + 1.0)\n\n    # 2. Density penalty: sparse networks tend to increase path length.\n    dens_term = 1.0 / (dens + 1e-9)\n\n    # 3. Degree‑dispersion influence: wide, highly skewed distributions\n    #    (captured by max‑min range plus std‑dev) tend to inflate distances.\n    disp_term = ((max_d - min_d + std_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees: reflects the presence of hubs.\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. Clustering / transitivity reduction: higher clustering often\n    #    introduces many short loops that reduce effective distances.\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # 6. Triangle shortcut effect: many triangles usually produce shortcuts.\n    tri_term = (tri + 1.0) ** 0.35\n\n    # 7. Assortativity boost: assortative mixing can create additional\n    #    short‑cut connections between high‑degree nodes.\n    assort_term = 1.0 + abs(assort)\n\n    # -----------------------------------------------------------------------\n    # 8. Assemble the composite invariant -----------------------------------\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.6013245331133279, "pearson": 0.7096411000710514, "rmse": 1.719985392013017, "mae": 1.571037975885553}}
{"timestamp": "2026-02-16T08:56:56.681388+00:00", "event_type": "candidate_rejected", "payload": {"generation": 8, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:56:56.682091+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 8, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:57:24.397614+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g8_i3_p4_387588660", "generation": 8, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5594717887154862, "fitness_mode": "correlation", "simplicity_score": 0.17012642677563533, "novelty_bonus": 0.4369819245481136, "total_score": 0.45402558536262727, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built solely from global\n    graph statistics.  The function uses only built‑in Python operations\n    and does not call any external libraries or shortest‑path routines.\n    \"\"\"\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']            # list of integers\n\n    # --- size–density blend  (larger graphs, sparser edges → larger paths)\n    size_term   = (n ** 1.1) / (m + 1.0)\n\n    # --- density penalty (sparser graphs increase the value)\n    dens_term   = 1.0 / (dens + 1e-9)\n\n    # --- degree dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.35) * (std_d + 1e-9) ** 0.2\n\n    # --- harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- clustering / transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # --- triangle shortcut effect\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- assemble the composite invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the graph's average shortest‑path length.\n\n    This heuristic blends several global topological signals—\n    size, density, degree dispersion, harmonic mean of degrees,\n    clustering/transitivity, triangle abundance, and assortativity—\n    without using any external libraries or explicit shortest‑path\n    algorithms.  All operations are built‑in Python functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys listed in the prompt.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert main numeric features to float for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    ass   = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    degs  = s['degrees']          # list of int degrees\n\n    # 1. Size–density hybrid term (larger graphs and sparser graphs increase paths)\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs get a larger value\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence (wide degree range increases path length)\n    disp_term = ((max_d - min_d + 1.0) ** 0.4)\n\n    # 4. Harmonic mean of degrees (captures skewness of the distribution)\n    harmonic_sum = 0.0\n    for d in degs:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # 5. Clustering‑transitivity reduction: high clustering tends to shorten paths\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles tend to shrink paths\n    tri_term = (tri + 1.0) ** 0.3\n\n    # 7. Assortativity boost: mixing can create shortcuts\n    assort_term = 1.0 + abs(ass)\n\n    # 8. Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.104256\nbelow_train_threshold: train_signal=0.274910\nbelow_train_threshold: train_signal=0.163217\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of a graph's average shortest‑path length.\n    It mixes several global statistics (size, density, degree\n    dispersion, harmonic degree mean, clustering, triangles,\n    assortativity) without calling any shortest‑path routine.\n    \"\"\"\n    import math\n\n    # convert numeric values to float once\n    n        = float(s['n'])\n    m        = float(s['m'])\n    dens     = float(s['density'])\n    max_d    = float(s['max_degree'])\n    min_d    = float(s['min_degree'])\n    std_d    = float(s['std_degree'])\n    clus     = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    degs     = s['degrees']                # list of ints\n\n    # --------- 1. Size–density blending --------------------------\n    size_term = (n ** 0.90) / (m + 1.0)\n\n    # --------- 2. Log‑density bonus (sparse graphs -> larger) -----\n    dens_term = math.log1p(dens) + 1e-12      # avoid log(0)\n\n    # --------- 3. Degree‑dispersion influence --------------------\n    disp_range = max_d - min_d + 1.0\n    disp_term  = (disp_range ** 0.40) * ((std_d + 1e-12) ** 0.20)\n\n    # --------- 4. Harmonic mean of degrees -----------------------\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --------- 5. Clustering/transitivity attenuation ------------\n    cluster_term = 1.0 / (clus + trans + 1e-12)\n\n    # --------- 6. Triangle shortcut factor ----------------------\n    tri_term = (tri + 1.0) ** 0.30\n\n    # --------- 7. Assortativity boost ----------------------------\n    assort_term = 1.0 + abs(assort)\n\n    # --------- 8. Assemble all components -----------------------\n    # Use multiplicative structure to keep balance; scale by\n    # density and dispersion before dividing by cluster/tri terms.\n    val = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    val = val / (cluster_term * tri_term)\n\n    return float(val)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Heuristic estimate of a graph's average shortest‑path length\n    constructed solely from global structural statistics.  No\n    external libraries, imports, or shortest‑path algorithms are\n    used – only built‑in Python arithmetic.\n    \"\"\"\n    # Basic quantities\n    n   = float(s['n'])\n    m   = float(s['m'])\n    dens = float(s['density'])\n    max_d = float(s['max_degree'])\n    min_d = float(s['min_degree'])\n    std_d = float(s['std_degree'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    degs  = s['degrees']          # list of integers\n\n    # 1. Size–density blend: larger & sparser graphs → larger paths\n    size_term = (n ** 0.90) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs contribute more\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence\n    disp_range = max_d - min_d + 1.0\n    disp_term  = (disp_range ** 0.40) * ((std_d + 1e-6) ** 0.20)\n\n    # 4. Harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. Clustering/transitivity attenuation\n    cluster_term = 1.0 / (clus + trans + 1e-12)\n\n    # 6. Triangle shortcut factor\n    tri_term = (tri + 1.0) ** 0.30\n\n    # 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # 8. Assemble the composite invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term) / (cluster_term * tri_term)\n\n    return float(inv)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Heuristic estimate of a graph's average shortest‑path length\n    constructed solely from global structural statistics.  No\n    external libraries, imports, or shortest‑path algorithms are\n    used – only built‑in Python arithmetic.\n    \"\"\"\n    # Basic quantities\n    n   = float(s['n'])\n    m   = float(s['m'])\n    dens = float(s['density'])\n    max_d = float(s['max_degree'])\n    min_d = float(s['min_degree'])\n    std_d = float(s['std_degree'])\n    clus  = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    tri   = float(s['num_triangles'])\n    degs  = s['degrees']          # list of integers\n\n    # 1. Size–density blend: larger & sparser graphs → larger paths\n    size_term = (n ** 0.90) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs contribute more\n    dens_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion influence\n    disp_range = max_d - min_d + 1.0\n    disp_term  = (disp_range ** 0.40) * ((std_d + 1e-6) ** 0.20)\n\n    # 4. Harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. Clustering/transitivity attenuation\n    cluster_term = 1.0 / (clus + trans + 1e-12)\n\n    # 6. Triangle shortcut factor\n    tri_term = (tri + 1.0) ** 0.30\n\n    # 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # 8. Assemble the composite invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term) / (cluster_term * tri_term)\n\n    return float(inv)", "spearman": 0.5778114452861323, "pearson": 0.7062641277221283, "rmse": 2.9984211223357717, "mae": 2.0719290960701433}}
{"timestamp": "2026-02-16T08:57:24.398469+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 8, "island_id": 3, "population_idx": 4, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T08:57:24.400456+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 9, "model_name": "gpt-oss:20b", "best_val_score": 0.5627212573413072, "no_improve_count": 1}}
{"timestamp": "2026-02-16T08:58:28.598358+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i0_p0_893176402", "generation": 9, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.3275390156062425, "fitness_mode": "correlation", "simplicity_score": 0.11811104384655831, "novelty_bonus": 0.3639959363581925, "total_score": 0.29110644681319786, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: scales with sqrt(n) and inversely with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser → longer paths\n    clustering_adj = 1 - clustering                      # more clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.131207\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    min_deg = s['min_degree']\n    trans = s['transitivity']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering                  # more clustering → shorter paths\n    assort_adj    = 1 + assort                        # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)     # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)       # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n    trans_adj     = 1 - trans                         # higher transitivity → shorter paths\n    min_deg_adj   = 1 + min_deg / (avg_deg + eps)     # higher minimum degree → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n    trans_adj     = max(0.1, min(10, trans_adj))\n    min_deg_adj   = max(0.1, min(10, min_deg_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj * trans_adj * min_deg_adj", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    min_deg = s['min_degree']\n    trans = s['transitivity']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering                  # more clustering → shorter paths\n    assort_adj    = 1 + assort                        # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)     # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)       # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n    trans_adj     = 1 - trans                         # higher transitivity → shorter paths\n    min_deg_adj   = 1 + min_deg / (avg_deg + eps)     # higher minimum degree → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n    trans_adj     = max(0.1, min(10, trans_adj))\n    min_deg_adj   = max(0.1, min(10, min_deg_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj * trans_adj * min_deg_adj", "spearman": 0.3165709142728569, "pearson": 0.20152207237130537, "rmse": 2.379455376986118, "mae": 2.155887012286168}}
{"timestamp": "2026-02-16T09:01:24.533381+00:00", "event_type": "candidate_rejected", "payload": {"generation": 9, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:01:24.535328+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 9, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:01:45.531690+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i0_p1_469045582", "generation": 9, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.6852821128451381, "fitness_mode": "correlation", "simplicity_score": 0.12280850557015646, "novelty_bonus": 0.15809933534953824, "total_score": 0.4227865215943897, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: scales with sqrt(n) and inversely with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser → longer paths\n    clustering_adj = 1 - clustering                      # more clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.131207\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nWe need to produce final code. Let's design a new formula:\n\nBaseline: sqrt(n) / (avg_deg + eps). Good.\n\nAdjustments:\n\n- density_adj: 1 + (1 - density) * 0.5? Actually sparser graphs increase path length. We can use 1 + (1 - density) * 0.5 to moderate.\n\n- clustering_adj: 1 - clustering * 0.5 to moderate effect.\n\n- assort_adj: 1 + assort * 0.5.\n\n- hetero_adj: 1 - std_deg / (avg_deg + eps) * 0.5.\n\n- hub_adj: 1 - max_deg / (n - 1 + eps) * 0.5.\n\n- triangle_adj: 1 - num_tri / (n*(n-1)/2 + eps) * 0.5.\n\nWe can clamp each to 0.1-10.\n\nWe can also incorporate min_degree: maybe adjust baseline: baseline = baseline * (1 + min_degree / (avg_deg + eps) * 0.1). But maybe too small.\n\nWe can incorporate transitivity: maybe adjust triangle_adj: triangle_adj = 1 - transitivity * 0.5.\n\nBut we already have num_triangles. We can keep.\n\nWe can incorporate median degree: median_deg = degrees[len(degrees)//2] if degrees else 0. We can adjust baseline: baseline = pow(n, 0.5) / (median_deg + eps). But median may be lower than avg, causing baseline larger. But we can keep baseline as sqrt(n)/avg_deg.\n\nWe can incorporate min_degree: maybe adjust hetero_adj: hetero_adj = 1 - (std_deg + min_degree) / (avg_deg + eps) * 0.5. But min_degree is small relative.\n\nWe can incorporate max_degree: maybe adjust hub_adj: hub_adj = 1 - max_deg / (n - 1 + eps) * 0.5.\n\nWe can incorporate degree_assortativity: maybe adjust assort_adj: 1 + assort * 0.5.\n\nWe can incorporate transitivity: maybe adjust triangle_adj: 1 - transitivity * 0.5.\n\nBut we can keep triangle_adj as 1 - num_tri / (n*(n-1)/2 + eps) * 0.5.\n\nWe can also incorporate density: maybe adjust density_adj: 1 + (1 - density) * 0.5.\n\nWe can also incorporate avg_clustering: maybe adjust clustering_adj: 1 - clustering * 0.5.\n\nWe can also incorporate m: maybe adjust baseline: baseline = sqrt(n) / (avg_deg + eps) * (1 + m/(n*(n-1)/2 + eps)). But m/(n*(n-1)/2) is density. So no.\n\nWe can also incorporate min_degree: maybe adjust baseline: baseline = baseline * (1 + min_degree / (avg_deg + eps) * 0.1). But maybe not.\n\nWe can also incorporate max_degree: maybe adjust baseline: baseline = baseline * (1 - max_deg/(n-1+eps)*0.1). But maybe not.\n\nWe can keep baseline as is.\n\nThus final formula:\n\n```\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj = 1 + assort * 0.5\n    hetero_adj = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # clamp\n    density_adj = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj = max(0.1, min(10, assort_adj))\n    hetero_adj = max(0.1, min(10, hetero_adj))\n    hub_adj = max(0.1, min(10, hub_adj))\n    triangle_adj = max(0.1, min(10, triangle_adj))\n\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```\n\nWe can also incorporate min_degree: maybe adjust hetero_adj: hetero_adj = 1 - (std_deg + min_degree) / (avg_deg + eps) * 0.5. But min_degree may be small relative. We can ignore.\n\nWe can also incorporate transitivity: maybe adjust triangle_adj: triangle_adj = 1 - transitivity * 0.5. But we can keep.\n\nWe can also incorporate degrees list: maybe compute median_deg and adjust baseline: baseline = pow(n, 0.5) / (median_deg + eps). But we can keep.\n\nThus final code as above.\n\nWe need to ensure no import. We use pow, max, min. Good.\n\nWe need to ensure we use s['avg_clustering'] not s['avg_clustering']? It's correct.\n\nWe need to ensure we use s['degree_assortativity'].\n\nWe need to ensure we use s['num_triangles'].\n\nWe need to ensure we use s['max_degree'].\n\nWe need to ensure we use s['std_degree'].\n\nWe need to ensure we use s['density'].\n\nWe need to ensure we use s['avg_degree'].\n\nWe need to ensure we use s['n'].\n\nWe need to ensure we use s['m']? Not needed.\n\nWe need to ensure we use s['transitivity']? Not needed.\n\nWe need to ensure we use s['min_degree']? Not needed.\n\nWe need to ensure we use s['degrees']? Not needed.\n\nThus final code.\n\nWe should also consider that some features may be missing? But we assume they exist.\n\nWe need to return a float.\n\nWe need to ensure we don't use any forbidden tokens.\n\nWe need to not import anything.\n\nWe need to not use numpy.\n\nWe need to not use BFS/DFS.\n\nThus final code.\n\nLet's produce final answer.def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.7015900397509939, "pearson": 0.6209562393838068, "rmse": 1.885607422925485, "mae": 1.7218648966764767}}
{"timestamp": "2026-02-16T09:01:45.533749+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 9, "island_id": 0, "population_idx": 1, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:02:42.236119+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i0_p2_674787703", "generation": 9, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.544297719087635, "fitness_mode": "correlation", "simplicity_score": 0.1230677108014352, "novelty_bonus": 0.22169833554208662, "total_score": 0.3703332730786695, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: scales with sqrt(n) and inversely with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser → longer paths\n    clustering_adj = 1 - clustering                      # more clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.131207\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.5584204605115128, "pearson": 0.46609151447724606, "rmse": 2.0219886270648404, "mae": 1.813566092812708}}
{"timestamp": "2026-02-16T09:03:16.768601+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i0_p3_221561250", "generation": 9, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.458343337334934, "fitness_mode": "correlation", "simplicity_score": 0.12318631834180116, "novelty_bonus": 0.27485999871772415, "total_score": 0.3304650975295337, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: larger graphs with lower average degree tend to have longer paths\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: scales with sqrt(n) and inversely with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser graphs → longer paths\n    clustering_adj = 1 - clustering                      # higher clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative mixing → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # degree heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)                     # sparser → longer paths\n    clustering_adj = 1 - clustering                      # more clustering → shorter paths\n    assort_adj    = 1 + assort                            # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)         # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)           # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.131207\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1.0 / (density + eps)                     # sparser → longer paths\n    clustering_adj = 1.0 / (clustering + eps)                 # higher clustering → shorter paths\n    assort_adj    = 1.0 + assort                              # assortative mixing → longer paths\n    hetero_adj    = 1.0 - std_deg / (avg_deg + eps)           # degree heterogeneity → shorter paths\n    hub_adj       = 1.0 - max_deg / (n - 1 + eps)             # presence of hubs → shorter paths\n    triangle_adj  = 1.0 - num_tri / (n * (n - 1) / 2 + eps)   # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1.0 / (density + eps)                     # sparser → longer paths\n    clustering_adj = 1.0 / (clustering + eps)                 # higher clustering → shorter paths\n    assort_adj    = 1.0 + assort                              # assortative mixing → longer paths\n    hetero_adj    = 1.0 - std_deg / (avg_deg + eps)           # degree heterogeneity → shorter paths\n    hub_adj       = 1.0 - max_deg / (n - 1 + eps)             # presence of hubs → shorter paths\n    triangle_adj  = 1.0 - num_tri / (n * (n - 1) / 2 + eps)   # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.44673966849171237, "pearson": 0.23606571550085875, "rmse": 30.025006754305608, "mae": 20.006956660373994}}
{"timestamp": "2026-02-16T09:04:15.310600+00:00", "event_type": "candidate_rejected", "payload": {"generation": 9, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.146508", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:04:15.311592+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 9, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.146508", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:04:30.020851+00:00", "event_type": "candidate_rejected", "payload": {"generation": 9, "island_id": 0, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.101264", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:04:30.021411+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 9, "island_id": 0, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:04:57.054882+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i1_p0_10891681", "generation": 9, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15415693150818588, "novelty_bonus": 0.25199429985749633, "total_score": 0.2848456366578961, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T09:05:17.423077+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i1_p1_187598593", "generation": 9, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.1539769740017352, "novelty_bonus": 0.25199429985749633, "total_score": 0.28480964515660595, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree statistics,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * pow(max_deg + 1, 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        pow(n, 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + pow(num_tri + 1, 0.5)\n        + pow(max_deg + 1, 0.5)\n        + pow(min_deg + 1, 0.5)\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree statistics,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * pow(max_deg + 1, 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        pow(n, 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + pow(num_tri + 1, 0.5)\n        + pow(max_deg + 1, 0.5)\n        + pow(min_deg + 1, 0.5)\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T09:05:37.589362+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i1_p2_40103507", "generation": 9, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15415693150818588, "novelty_bonus": 0.25199429985749633, "total_score": 0.2848456366578961, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    All operations use only built‑in Python functions.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    All operations use only built‑in Python functions.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T09:06:03.694752+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i1_p3_308373036", "generation": 9, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3835294117647059, "fitness_mode": "correlation", "simplicity_score": 0.15401258590532532, "novelty_bonus": 0.24994674866871658, "total_score": 0.2849292703498943, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + (deg_assort if deg_assort is not None else 0)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + (deg_assort if deg_assort is not None else 0)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35828545713642845, "pearson": 0.2746771660963584, "rmse": 2.6179039751605977, "mae": 2.438666626231206}}
{"timestamp": "2026-02-16T09:06:38.475030+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i1_p4_236863332", "generation": 9, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.3827611044417767, "fitness_mode": "correlation", "simplicity_score": 0.15415693150818588, "novelty_bonus": 0.25199429985749633, "total_score": 0.2848456366578961, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_train_threshold: train_signal=0.288355\nbelow_train_threshold: train_signal=0.265114\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + abs(deg_assort)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom", "spearman": 0.35683192079802, "pearson": 0.2747139949068483, "rmse": 2.6182202855926717, "mae": 2.4389945001893376}}
{"timestamp": "2026-02-16T09:07:32.369862+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i2_p0_592053815", "generation": 9, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.84921968787515, "fitness_mode": "correlation", "simplicity_score": 0.2229950669851596, "novelty_bonus": 0.17576163950469004, "total_score": 0.553439408046009, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the size of the\n    graph and shrinks with the average degree.  It is then adjusted by\n    several structural factors that are known to influence path lengths:\n\n    * **Clustering** – higher clustering tends to create detours,\n      therefore the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of degrees\n      (presence of hubs) shortens paths, so the estimate is divided by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Density** – denser graphs have shorter paths.  We multiply by a\n      factor proportional to (1 – density), bounded below by 0.05 to\n      avoid negative values.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n\n    All arithmetic is safe from division by zero, and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Clustering and assortativity factors\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Heterogeneity and minimum‑degree adjustments\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.136526\nbelow_novelty_threshold: novelty_bonus=0.095242\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.  The formula is intentionally\n    compact and uses only built‑in arithmetic operators – no imports\n    are required.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Grab the most useful statistics\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    transitivity = s['transitivity']\n    num_triangles = s['num_triangles']\n\n    # ---------- Baseline ----------\n    # A simple scaling with graph size (sqrt(n)) and inverse average\n    # degree (n/(avg_deg+1)) gives a rough sense of path length.\n    base = (n ** 0.5) * (n / (avg_deg + 1))\n\n    # ---------- Structural adjustments ----------\n    # Higher clustering or positive assortativity tends to lengthen\n    # paths – we inflate the estimate accordingly.\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Heterogeneity (large std deviation) shortens paths; many leaves\n    # (small min_degree) lengthen them.\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n\n    # Denser graphs have shorter paths – a simple linear factor.\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangles provide local shortcuts – we reduce the estimate.\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # Global transitivity also shortens paths – a mild multiplier.\n    base *= (1 + transitivity)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.  The formula is intentionally\n    compact and uses only built‑in arithmetic operators – no imports\n    are required.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Grab the most useful statistics\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    transitivity = s['transitivity']\n    num_triangles = s['num_triangles']\n\n    # ---------- Baseline ----------\n    # A simple scaling with graph size (sqrt(n)) and inverse average\n    # degree (n/(avg_deg+1)) gives a rough sense of path length.\n    base = (n ** 0.5) * (n / (avg_deg + 1))\n\n    # ---------- Structural adjustments ----------\n    # Higher clustering or positive assortativity tends to lengthen\n    # paths – we inflate the estimate accordingly.\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Heterogeneity (large std deviation) shortens paths; many leaves\n    # (small min_degree) lengthen them.\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n\n    # Denser graphs have shorter paths – a simple linear factor.\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangles provide local shortcuts – we reduce the estimate.\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # Global transitivity also shortens paths – a mild multiplier.\n    base *= (1 + transitivity)\n\n    return base", "spearman": 0.9122238055951402, "pearson": 0.863824735165847, "rmse": 76.58662202120564, "mae": 54.24636431435927}}
{"timestamp": "2026-02-16T09:08:05.344450+00:00", "event_type": "candidate_rejected", "payload": {"generation": 9, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.136526", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:08:05.344846+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 9, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.136526", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:08:42.287898+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i2_p1_852636914", "generation": 9, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.3789195678271309, "fitness_mode": "correlation", "simplicity_score": 0.22162360630380393, "novelty_bonus": 0.23596302832448757, "total_score": 0.44886072343544897, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the size of the\n    graph and shrinks with the average degree.  It is then adjusted by\n    several structural factors that are known to influence path lengths:\n\n    * **Clustering** – higher clustering tends to create detours,\n      therefore the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of degrees\n      (presence of hubs) shortens paths, so the estimate is divided by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Density** – denser graphs have shorter paths.  We multiply by a\n      factor proportional to (1 – density), bounded below by 0.05 to\n      avoid negative values.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n\n    All arithmetic is safe from division by zero, and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Clustering and assortativity factors\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Heterogeneity and minimum‑degree adjustments\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.136526\nbelow_novelty_threshold: novelty_bonus=0.095242\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.136526\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n\n    The estimate is built from a baseline that grows with the number of nodes\n    and shrinks with the average degree.  Several structural factors that\n    influence path lengths are then applied multiplicatively or\n    divisively.  All operations are safe from division by zero and the\n    expression remains compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``.\n\n    Returns\n    -------\n    float\n        An invariant value approximating the average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = max(s['min_degree'], 1)          # avoid division by zero\n    clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: larger n or smaller average degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # Structural multipliers\n    base *= (1 + clustering)                    # clustering creates detours\n    base *= (1 + transitivity)                  # global clustering shortens paths\n    base *= (1 + abs(assortativity))            # positive assortativity lengthens paths\n\n    # Degree heterogeneity: hubs shorten paths\n    base /= (1 + std_deg)\n\n    # Minimum degree: leaves lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # Density factor: denser graphs have shorter paths\n    density_factor = 1 - density\n    if density_factor < 0.05:                  # prevent too small factor\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio: local cohesion shortens paths\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph\n    statistics.  The formula is a compact combination of several\n    structural features that are known to influence path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``.\n\n    Returns\n    -------\n    float\n        An invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Basic graph statistics\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 1\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # --- Core estimate ----------------------------------------------------\n    # Use the square‑root of the size (a crude proxy for graph diameter)\n    # and scale it with the average degree and density.\n    base = (n ** 0.5) * (avg_deg + 1) / (density + 0.05)\n\n    # --- Structural multipliers ------------------------------------------\n    # Clustering tends to create detours, so we lengthen the estimate.\n    base *= (1 + clustering)\n\n    # Global transitivity usually shortens paths; we counterbalance it\n    # by dividing, but keep the factor positive.\n    base /= (1 + transitivity)\n\n    # Positive assortativity typically increases path lengths.\n    base *= (1 + abs(assortativity))\n\n    # Degree heterogeneity (presence of hubs) shortens paths.\n    base /= (1 + std_deg)\n\n    # The ratio of max to min degree reflects how many leaves the graph\n    # has relative to hubs; a large ratio lengthens the estimate.\n    degree_ratio = max_deg / min_deg\n    base *= (1 + degree_ratio)\n\n    # Minimum degree: very small min_degree (many leaves) lengthens paths.\n    base *= (1 + 1 / min_deg)\n\n    # Density factor: denser graphs have shorter paths.\n    density_factor = 1 - density\n    if density_factor < 0.05:        # avoid an overly small factor\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio: more triangles mean tighter local cohesion,\n    # which tends to reduce average path length.\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph\n    statistics.  The formula is a compact combination of several\n    structural features that are known to influence path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``.\n\n    Returns\n    -------\n    float\n        An invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Basic graph statistics\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 1\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    clustering = s['avg_clustering']\n    transitivity = s['transitivity']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # --- Core estimate ----------------------------------------------------\n    # Use the square‑root of the size (a crude proxy for graph diameter)\n    # and scale it with the average degree and density.\n    base = (n ** 0.5) * (avg_deg + 1) / (density + 0.05)\n\n    # --- Structural multipliers ------------------------------------------\n    # Clustering tends to create detours, so we lengthen the estimate.\n    base *= (1 + clustering)\n\n    # Global transitivity usually shortens paths; we counterbalance it\n    # by dividing, but keep the factor positive.\n    base /= (1 + transitivity)\n\n    # Positive assortativity typically increases path lengths.\n    base *= (1 + abs(assortativity))\n\n    # Degree heterogeneity (presence of hubs) shortens paths.\n    base /= (1 + std_deg)\n\n    # The ratio of max to min degree reflects how many leaves the graph\n    # has relative to hubs; a large ratio lengthens the estimate.\n    degree_ratio = max_deg / min_deg\n    base *= (1 + degree_ratio)\n\n    # Minimum degree: very small min_degree (many leaves) lengthens paths.\n    base *= (1 + 1 / min_deg)\n\n    # Density factor: denser graphs have shorter paths.\n    density_factor = 1 - density\n    if density_factor < 0.05:        # avoid an overly small factor\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio: more triangles mean tighter local cohesion,\n    # which tends to reduce average path length.\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base", "spearman": 0.6674941873546838, "pearson": 0.5608163251383171, "rmse": 1826.698576238148, "mae": 1344.9857503955875}}
{"timestamp": "2026-02-16T09:08:42.288687+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 9, "island_id": 2, "population_idx": 1, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:09:18.860691+00:00", "event_type": "candidate_rejected", "payload": {"generation": 9, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.136526", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:09:18.861444+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 9, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.136526", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:09:47.835371+00:00", "event_type": "candidate_rejected", "payload": {"generation": 9, "island_id": 2, "population_idx": 2, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:09:47.836018+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 9, "island_id": 2, "population_idx": 2, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:10:26.271949+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i2_p3_659495282", "generation": 9, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8884033613445379, "fitness_mode": "correlation", "simplicity_score": 0.22205049545154468, "novelty_bonus": 0.15310237951290506, "total_score": 0.5595855440624584, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the size of the\n    graph and shrinks with the average degree.  It is then adjusted by\n    several structural factors that are known to influence path lengths:\n\n    * **Clustering** – higher clustering tends to create detours,\n      therefore the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of degrees\n      (presence of hubs) shortens paths, so the estimate is divided by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Density** – denser graphs have shorter paths.  We multiply by a\n      factor proportional to (1 – density), bounded below by 0.05 to\n      avoid negative values.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n\n    All arithmetic is safe from division by zero, and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Clustering and assortativity factors\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Heterogeneity and minimum‑degree adjustments\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.095242\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + max_degree/(n‑1)).\n    * **Density** – denser graphs have shorter paths.  We multiply by a\n      factor proportional to (1 – density), bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + max_degree/(n‑1)).\n    * **Density** – denser graphs have shorter paths.  We multiply by a\n      factor proportional to (1 – density), bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base", "spearman": 0.938489462236556, "pearson": 0.9160330136036973, "rmse": 5.685515483370974, "mae": 3.5693698485684333}}
{"timestamp": "2026-02-16T09:11:10.530531+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i2_p4_680067724", "generation": 9, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8884033613445379, "fitness_mode": "correlation", "simplicity_score": 0.2223273988983509, "novelty_bonus": 0.15163384317572048, "total_score": 0.5595896235821577, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the size of the\n    graph and shrinks with the average degree.  It is then adjusted by\n    several structural factors that are known to influence path lengths:\n\n    * **Clustering** – higher clustering tends to create detours,\n      therefore the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of degrees\n      (presence of hubs) shortens paths, so the estimate is divided by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Density** – denser graphs have shorter paths.  We multiply by a\n      factor proportional to (1 – density), bounded below by 0.05 to\n      avoid negative values.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n\n    All arithmetic is safe from division by zero, and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Clustering and assortativity factors\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Heterogeneity and minimum‑degree adjustments\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from basic graph statistics.\n    The formula is a simple combination of:\n        - The size of the graph (n)\n        - The number of edges (m)\n        - The average clustering coefficient (c)\n        - The degree assortativity (a)\n\n    It scales with n² / (2m) (the inverse of average degree) and is adjusted\n    by the clustering and assortativity factors.  A small offset (1) is added\n    to m, c and a to avoid division by zero and keep the expression positive.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    c = s['avg_clustering']\n    a = s['degree_assortativity']\n\n    # Use a safe denominator that never becomes zero\n    denom = max(m + 1, 1)\n\n    # Core estimate: n² / (2m)   (inverse of average degree)\n    base = (n ** 2) / (2 * denom)\n\n    # Adjust for clustering and assortativity\n    adjustment = (1 + c) * (1 + a)\n\n    return base * adjustment\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.095242\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the size of the\n    graph and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    minimum and maximum degree, density, triangle prevalence, and\n    transitivity.  All arithmetic is safe from division by zero and\n    keeps the expression compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``.\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # Positive assortativity tends to lengthen paths\n    base *= (1 + abs(assort))\n\n    # High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # Very small minimum degree can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # High maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n, 1))\n\n    # Denser graphs have shorter paths\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio indicates local cohesion\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + trans)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the size of the\n    graph and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    minimum and maximum degree, density, triangle prevalence, and\n    transitivity.  All arithmetic is safe from division by zero and\n    keeps the expression compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``.\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # Positive assortativity tends to lengthen paths\n    base *= (1 + abs(assort))\n\n    # High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # Very small minimum degree can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # High maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n, 1))\n\n    # Denser graphs have shorter paths\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio indicates local cohesion\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + trans)\n\n    return base", "spearman": 0.9392679816995426, "pearson": 0.9166380602831528, "rmse": 5.701597852520321, "mae": 3.584519236881687}}
{"timestamp": "2026-02-16T09:11:44.995094+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i3_p0_819363549", "generation": 9, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6507082833133253, "fitness_mode": "correlation", "simplicity_score": 0.24795247661365372, "novelty_bonus": 0.37788494712367804, "total_score": 0.4723027131281759, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built solely from global\n    graph statistics.  The function uses only built‑in Python operations\n    and does not call any external libraries or shortest‑path routines.\n    \"\"\"\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']            # list of integers\n\n    # --- size–density blend  (larger graphs, sparser edges → larger paths)\n    size_term   = (n ** 1.1) / (m + 1.0)\n\n    # --- density penalty (sparser graphs increase the value)\n    dens_term   = 1.0 / (dens + 1e-9)\n\n    # --- degree dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.35) * (std_d + 1e-9) ** 0.2\n\n    # --- harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- clustering / transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # --- triangle shortcut effect\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- assemble the composite invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using a blend of global\n    structural statistics.  The expression mixes the size of the graph,\n    its sparsity, degree spread, harmonic degree mean, clustering\n    properties, triangle abundance and assortativity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic numeric values\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']          # list of int degrees\n\n    # --- Size and sparsity terms\n    size_term   = (n ** 0.85) / (m + 1.0)\n    dens_pen    = 1.0 / (dens + 1e-8)\n\n    # --- Degree‑dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.25) * ((std_d + 1e-6) ** 0.15)\n\n    # --- Harmonic mean of degrees\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- Clustering/transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # --- Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.35\n\n    # --- Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- Assemble the invariant\n    inv = (size_term * dens_pen * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.274910\nbelow_train_threshold: train_signal=0.163217\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from global graph statistics.\n    The formula blends graph size, sparsity, degree dispersion, harmonic\n    degree mean, clustering, triangle abundance and assortativity.  Only\n    built‑in Python operations are used.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n    \n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Extract features\n    n           = float(s['n'])\n    m           = float(s['m'])\n    density     = float(s['density'])\n    max_d       = float(s['max_degree'])\n    min_d       = float(s['min_degree'])\n    std_d       = float(s['std_degree'])\n    avg_clust   = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    num_tri     = float(s['num_triangles'])\n    degrees     = s['degrees']          # list of integers\n\n    # 1. Size‑sparsity blend\n    size_term    = (n ** 0.9) / (m + 1.0)\n\n    # 2. Density penalty – sparser graphs give larger value\n    density_term = 1.0 / (density + 1e-8)\n\n    # 3. Degree‑dispersion influence\n    disp_term    = ((max_d - min_d + 1.0) ** 0.3) * ((std_d + 1e-8) ** 0.2)\n\n    # 4. Harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. Clustering/transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-8)\n\n    # 6. Triangle shortcut influence\n    tri_term = (num_tri + 1.0) ** 0.4\n\n    # 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # 8. Assemble invariant\n    inv = (size_term * density_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from global graph statistics.\n    The formula blends graph size, sparsity, degree dispersion, harmonic\n    degree mean, clustering, triangle abundance and assortativity.  Only\n    built‑in Python operations are used.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n    \n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Extract features\n    n           = float(s['n'])\n    m           = float(s['m'])\n    density     = float(s['density'])\n    max_d       = float(s['max_degree'])\n    min_d       = float(s['min_degree'])\n    std_d       = float(s['std_degree'])\n    avg_clust   = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    num_tri     = float(s['num_triangles'])\n    degrees     = s['degrees']          # list of integers\n\n    # 1. Size‑sparsity blend\n    size_term    = (n ** 0.9) / (m + 1.0)\n\n    # 2. Density penalty – sparser graphs give larger value\n    density_term = 1.0 / (density + 1e-8)\n\n    # 3. Degree‑dispersion influence\n    disp_term    = ((max_d - min_d + 1.0) ** 0.3) * ((std_d + 1e-8) ** 0.2)\n\n    # 4. Harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. Clustering/transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-8)\n\n    # 6. Triangle shortcut influence\n    tri_term = (num_tri + 1.0) ** 0.4\n\n    # 7. Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # 8. Assemble invariant\n    inv = (size_term * density_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.6186934673366835, "pearson": 0.7288618298409753, "rmse": 1.2764988401786357, "mae": 0.998190191987391}}
{"timestamp": "2026-02-16T09:12:17.248789+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i3_p1_606453998", "generation": 9, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6433133253301321, "fitness_mode": "correlation", "simplicity_score": 0.24766122955523237, "novelty_bonus": 0.3816875421885547, "total_score": 0.49303948359198857, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built solely from global\n    graph statistics.  The function uses only built‑in Python operations\n    and does not call any external libraries or shortest‑path routines.\n    \"\"\"\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']            # list of integers\n\n    # --- size–density blend  (larger graphs, sparser edges → larger paths)\n    size_term   = (n ** 1.1) / (m + 1.0)\n\n    # --- density penalty (sparser graphs increase the value)\n    dens_term   = 1.0 / (dens + 1e-9)\n\n    # --- degree dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.35) * (std_d + 1e-9) ** 0.2\n\n    # --- harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- clustering / transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # --- triangle shortcut effect\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- assemble the composite invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using a blend of global\n    structural statistics.  The expression mixes the size of the graph,\n    its sparsity, degree spread, harmonic degree mean, clustering\n    properties, triangle abundance and assortativity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic numeric values\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']          # list of int degrees\n\n    # --- Size and sparsity terms\n    size_term   = (n ** 0.85) / (m + 1.0)\n    dens_pen    = 1.0 / (dens + 1e-8)\n\n    # --- Degree‑dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.25) * ((std_d + 1e-6) ** 0.15)\n\n    # --- Harmonic mean of degrees\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- Clustering/transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # --- Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.35\n\n    # --- Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- Assemble the invariant\n    inv = (size_term * dens_pen * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.274910\nbelow_train_threshold: train_signal=0.163217\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using only global\n    structural statistics supplied in ``s``.  The calculation\n    employs only built‑in Python operators and functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (list of ints).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert values to float to ensure floating point arithmetic\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    avg_clus   = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degrees    = s['degrees']           # list of integers\n\n    # ---------- Size–sparsity component ----------\n    # Larger graphs with fewer edges produce larger path lengths\n    size_term  = (n ** 1.1) / (m + 1.0)\n\n    # ---------- Density penalty ----------\n    dens_term  = 1.0 / (density + 1e-6)\n\n    # ---------- Degree‑dispersion term ----------\n    deg_disp   = (max_d - min_d + 1.0) ** 0.25\n    deg_std    = (std_d + 1e-9) ** 0.15\n    disp_term  = deg_disp * deg_std\n\n    # ---------- Harmonic mean of degrees ----------\n    h_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # ---------- Clustering / transitivity penalty ----------\n    cluster_term = 1.0 / (avg_clus + trans + 1e-6)\n\n    # ---------- Triangle shortcut factor ----------\n    tri_term = (tri + 1.0) ** 0.4\n\n    # ---------- Assortativity boost ----------\n    assort_term = 1.0 + abs(assort)\n\n    # ---------- Assemble the invariant ----------\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using only global\n    structural statistics supplied in ``s``.  The calculation\n    employs only built‑in Python operators and functions.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (list of ints).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Convert values to float to ensure floating point arithmetic\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    avg_clus   = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degrees    = s['degrees']           # list of integers\n\n    # ---------- Size–sparsity component ----------\n    # Larger graphs with fewer edges produce larger path lengths\n    size_term  = (n ** 1.1) / (m + 1.0)\n\n    # ---------- Density penalty ----------\n    dens_term  = 1.0 / (density + 1e-6)\n\n    # ---------- Degree‑dispersion term ----------\n    deg_disp   = (max_d - min_d + 1.0) ** 0.25\n    deg_std    = (std_d + 1e-9) ** 0.15\n    disp_term  = deg_disp * deg_std\n\n    # ---------- Harmonic mean of degrees ----------\n    h_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # ---------- Clustering / transitivity penalty ----------\n    cluster_term = 1.0 / (avg_clus + trans + 1e-6)\n\n    # ---------- Triangle shortcut factor ----------\n    tri_term = (tri + 1.0) ** 0.4\n\n    # ---------- Assortativity boost ----------\n    assort_term = 1.0 + abs(assort)\n\n    # ---------- Assemble the invariant ----------\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.6580019500487513, "pearson": 0.7620723295088758, "rmse": 2.9153125570686242, "mae": 1.9888954181885794}}
{"timestamp": "2026-02-16T09:12:47.159265+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i3_p2_286930584", "generation": 9, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.4314525810324129, "fitness_mode": "correlation", "simplicity_score": 0.2484472613346054, "novelty_bonus": 0.5245481367338285, "total_score": 0.44910519456960174, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built solely from global\n    graph statistics.  The function uses only built‑in Python operations\n    and does not call any external libraries or shortest‑path routines.\n    \"\"\"\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']            # list of integers\n\n    # --- size–density blend  (larger graphs, sparser edges → larger paths)\n    size_term   = (n ** 1.1) / (m + 1.0)\n\n    # --- density penalty (sparser graphs increase the value)\n    dens_term   = 1.0 / (dens + 1e-9)\n\n    # --- degree dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.35) * (std_d + 1e-9) ** 0.2\n\n    # --- harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- clustering / transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # --- triangle shortcut effect\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- assemble the composite invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using a blend of global\n    structural statistics.  The expression mixes the size of the graph,\n    its sparsity, degree spread, harmonic degree mean, clustering\n    properties, triangle abundance and assortativity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic numeric values\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']          # list of int degrees\n\n    # --- Size and sparsity terms\n    size_term   = (n ** 0.85) / (m + 1.0)\n    dens_pen    = 1.0 / (dens + 1e-8)\n\n    # --- Degree‑dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.25) * ((std_d + 1e-6) ** 0.15)\n\n    # --- Harmonic mean of degrees\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- Clustering/transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # --- Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.35\n\n    # --- Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- Assemble the invariant\n    inv = (size_term * dens_pen * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.274910\nbelow_train_threshold: train_signal=0.163217\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from global\n    graph statistics.  The formula blends size, sparsity, degree\n    dispersion, harmonic degree mean, clustering, triangle abundance\n    and assortativity.  No external libraries or shortest‑path\n    algorithms are used.\n    \"\"\"\n\n    # basic numeric values\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    std_d  = float(s['std_degree'])\n    clus   = float(s['avg_clustering'])\n    trans  = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    tri    = float(s['num_triangles'])\n    degs   = s['degrees']              # list of ints\n\n    # 1. size–density blend: larger, sparser graphs → longer paths\n    size_term = n / (m + 1.0)\n\n    # 2. density penalty: sparse graphs give a larger contribution\n    dens_term = 1.0 / (dens + 1e-9)\n\n    # 3. degree dispersion factor\n    disp_term = (max_d - min_d + 1.0)\n\n    # 4. harmonic mean of degrees (skewness)\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. clustering/transitivity reduction: highly clustered graphs\n    #    tend to have shorter paths, so down‑weight the estimate\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # 6. triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.35\n\n    # 7. assortativity boost: assortative mixing can create shortcuts\n    assort_term = 1.0 + abs(assort)\n\n    # assemble the composite invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from global\n    graph statistics.  The formula blends size, sparsity, degree\n    dispersion, harmonic degree mean, clustering, triangle abundance\n    and assortativity.  No external libraries or shortest‑path\n    algorithms are used.\n    \"\"\"\n\n    # basic numeric values\n    n      = float(s['n'])\n    m      = float(s['m'])\n    dens   = float(s['density'])\n    max_d  = float(s['max_degree'])\n    min_d  = float(s['min_degree'])\n    std_d  = float(s['std_degree'])\n    clus   = float(s['avg_clustering'])\n    trans  = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    tri    = float(s['num_triangles'])\n    degs   = s['degrees']              # list of ints\n\n    # 1. size–density blend: larger, sparser graphs → longer paths\n    size_term = n / (m + 1.0)\n\n    # 2. density penalty: sparse graphs give a larger contribution\n    dens_term = 1.0 / (dens + 1e-9)\n\n    # 3. degree dispersion factor\n    disp_term = (max_d - min_d + 1.0)\n\n    # 4. harmonic mean of degrees (skewness)\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. clustering/transitivity reduction: highly clustered graphs\n    #    tend to have shorter paths, so down‑weight the estimate\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # 6. triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.35\n\n    # 7. assortativity boost: assortative mixing can create shortcuts\n    assort_term = 1.0 + abs(assort)\n\n    # assemble the composite invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.48410260256506416, "pearson": 0.552226679392587, "rmse": 21.284750985047843, "mae": 16.58995896777733}}
{"timestamp": "2026-02-16T09:13:19.149782+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i3_p3_17718699", "generation": 9, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6607923169267707, "fitness_mode": "correlation", "simplicity_score": 0.24851180164633907, "novelty_bonus": 0.37556738918472954, "total_score": 0.49769321010051204, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built solely from global\n    graph statistics.  The function uses only built‑in Python operations\n    and does not call any external libraries or shortest‑path routines.\n    \"\"\"\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']            # list of integers\n\n    # --- size–density blend  (larger graphs, sparser edges → larger paths)\n    size_term   = (n ** 1.1) / (m + 1.0)\n\n    # --- density penalty (sparser graphs increase the value)\n    dens_term   = 1.0 / (dens + 1e-9)\n\n    # --- degree dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.35) * (std_d + 1e-9) ** 0.2\n\n    # --- harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- clustering / transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # --- triangle shortcut effect\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- assemble the composite invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using a blend of global\n    structural statistics.  The expression mixes the size of the graph,\n    its sparsity, degree spread, harmonic degree mean, clustering\n    properties, triangle abundance and assortativity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic numeric values\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']          # list of int degrees\n\n    # --- Size and sparsity terms\n    size_term   = (n ** 0.85) / (m + 1.0)\n    dens_pen    = 1.0 / (dens + 1e-8)\n\n    # --- Degree‑dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.25) * ((std_d + 1e-6) ** 0.15)\n\n    # --- Harmonic mean of degrees\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- Clustering/transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # --- Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.35\n\n    # --- Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- Assemble the invariant\n    inv = (size_term * dens_pen * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.274910\nbelow_train_threshold: train_signal=0.163217\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without calling any graph‑theoretic routine or external library.\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed global features:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted degree list\n    Returns\n    -------\n    float\n        An invariant estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n  = float(s['n'])\n    m  = float(s['m'])\n    d  = float(s['density'])\n    max_d = float(s['max_degree'])\n    min_d = float(s['min_degree'])\n    std_d = float(s['std_degree'])\n    clus = float(s['avg_clustering'])\n    tri = float(s['num_triangles'])\n    assort = float(s['degree_assortativity'])\n    degs = s['degrees']                     # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term: larger graphs with sparser edges give\n    #    a larger contribution.\n    size_term = (n ** 1.1) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs increase the estimate.\n    dens_term = 1.0 / (d + 1e-6)\n\n    # 3. Degree‑dispersion component: wider degree spread suggests\n    #    longer paths.\n    disp_term = (max_d - min_d + 1.0) ** 0.3\n\n    # 4. Harmonic mean of degrees (captures skewness without std).\n    h_sum = 0.0\n    for dv in degs:\n        if dv > 0:\n            h_sum += 1.0 / float(dv)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. Clustering/transitivity reduction: high clustering tends to\n    #    reduce path length.\n    cluster_term = 1.0 / (clus + s['transitivity'] + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles generally shorten paths.\n    tri_term = (tri + 1.0) ** 0.4\n\n    # 7. Assortativity boost: assortative mixing often creates shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without calling any graph‑theoretic routine or external library.\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed global features:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted degree list\n    Returns\n    -------\n    float\n        An invariant estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n  = float(s['n'])\n    m  = float(s['m'])\n    d  = float(s['density'])\n    max_d = float(s['max_degree'])\n    min_d = float(s['min_degree'])\n    std_d = float(s['std_degree'])\n    clus = float(s['avg_clustering'])\n    tri = float(s['num_triangles'])\n    assort = float(s['degree_assortativity'])\n    degs = s['degrees']                     # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term: larger graphs with sparser edges give\n    #    a larger contribution.\n    size_term = (n ** 1.1) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs increase the estimate.\n    dens_term = 1.0 / (d + 1e-6)\n\n    # 3. Degree‑dispersion component: wider degree spread suggests\n    #    longer paths.\n    disp_term = (max_d - min_d + 1.0) ** 0.3\n\n    # 4. Harmonic mean of degrees (captures skewness without std).\n    h_sum = 0.0\n    for dv in degs:\n        if dv > 0:\n            h_sum += 1.0 / float(dv)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. Clustering/transitivity reduction: high clustering tends to\n    #    reduce path length.\n    cluster_term = 1.0 / (clus + s['transitivity'] + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles generally shorten paths.\n    tri_term = (tri + 1.0) ** 0.4\n\n    # 7. Assortativity boost: assortative mixing often creates shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv", "spearman": 0.6706412660316508, "pearson": 0.7710411388931561, "rmse": 3.0710315344384886, "mae": 2.0744690437015145}}
{"timestamp": "2026-02-16T09:13:53.241090+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g9_i3_p4_515817035", "generation": 9, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.609891956782713, "fitness_mode": "correlation", "simplicity_score": 0.24828860960139623, "novelty_bonus": 0.38759618990474753, "total_score": 0.4946825475409198, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built solely from global\n    graph statistics.  The function uses only built‑in Python operations\n    and does not call any external libraries or shortest‑path routines.\n    \"\"\"\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']            # list of integers\n\n    # --- size–density blend  (larger graphs, sparser edges → larger paths)\n    size_term   = (n ** 1.1) / (m + 1.0)\n\n    # --- density penalty (sparser graphs increase the value)\n    dens_term   = 1.0 / (dens + 1e-9)\n\n    # --- degree dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.35) * (std_d + 1e-9) ** 0.2\n\n    # --- harmonic mean of degrees (captures skewness)\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- clustering / transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-9)\n\n    # --- triangle shortcut effect\n    tri_term = (tri + 1.0) ** 0.4\n\n    # --- assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- assemble the composite invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length using a blend of global\n    structural statistics.  The expression mixes the size of the graph,\n    its sparsity, degree spread, harmonic degree mean, clustering\n    properties, triangle abundance and assortativity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (list).\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic numeric values\n    n          = float(s['n'])\n    m          = float(s['m'])\n    dens       = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    clus       = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    degs       = s['degrees']          # list of int degrees\n\n    # --- Size and sparsity terms\n    size_term   = (n ** 0.85) / (m + 1.0)\n    dens_pen    = 1.0 / (dens + 1e-8)\n\n    # --- Degree‑dispersion influence\n    disp_term   = ((max_d - min_d + 1.0) ** 0.25) * ((std_d + 1e-6) ** 0.15)\n\n    # --- Harmonic mean of degrees\n    h_sum = 0.0\n    for d in degs:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # --- Clustering/transitivity reduction\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # --- Triangle shortcut influence\n    tri_term = (tri + 1.0) ** 0.35\n\n    # --- Assortativity boost\n    assort_term = 1.0 + abs(assort)\n\n    # --- Assemble the invariant\n    inv = (size_term * dens_pen * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.274910\nbelow_train_threshold: train_signal=0.163217\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed graph\n    statistics.  The expression combines size, sparsity, degree dispersion,\n    harmonic degree mean, clustering/transitivity, triangle abundance and\n    assortativity.  Only built‑in Python operations are used – no external\n    libraries or graph algorithms are required.\n    \"\"\"\n    # Basic numeric values\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    degs       = s['degrees']          # list of int degrees\n\n    # ----- Size‑sparsity blend\n    size_term   = n / (m + 1.0)\n    dens_pen    = 1.0 / (density + 1e-6)\n\n    # ----- Degree dispersion\n    deg_disp    = pow(max_d - min_d + 1.0, 0.25)\n\n    # ----- Harmonic mean of degrees\n    hsum = 0.0\n    for d in degs:\n        if d > 0:\n            hsum += 1.0 / float(d)\n    harmonic_mean = n / (hsum + 1e-12)\n\n    # ----- Clustering/transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # ----- Triangle shortcut effect\n    triangle_term = pow(num_tri + 1.0, 0.30)\n\n    # ----- Assortativity boost\n    assort_term   = 1.0 + abs(assort)\n\n    # ----- Assemble the invariant\n    inv = (size_term * dens_pen * deg_disp *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of pre‑computed graph\n    statistics.  The expression combines size, sparsity, degree dispersion,\n    harmonic degree mean, clustering/transitivity, triangle abundance and\n    assortativity.  Only built‑in Python operations are used – no external\n    libraries or graph algorithms are required.\n    \"\"\"\n    # Basic numeric values\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    max_d      = float(s['max_degree'])\n    min_d      = float(s['min_degree'])\n    std_d      = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    degs       = s['degrees']          # list of int degrees\n\n    # ----- Size‑sparsity blend\n    size_term   = n / (m + 1.0)\n    dens_pen    = 1.0 / (density + 1e-6)\n\n    # ----- Degree dispersion\n    deg_disp    = pow(max_d - min_d + 1.0, 0.25)\n\n    # ----- Harmonic mean of degrees\n    hsum = 0.0\n    for d in degs:\n        if d > 0:\n            hsum += 1.0 / float(d)\n    harmonic_mean = n / (hsum + 1e-12)\n\n    # ----- Clustering/transitivity reduction\n    cluster_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # ----- Triangle shortcut effect\n    triangle_term = pow(num_tri + 1.0, 0.30)\n\n    # ----- Assortativity boost\n    assort_term   = 1.0 + abs(assort)\n\n    # ----- Assemble the invariant\n    inv = (size_term * dens_pen * deg_disp *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * triangle_term)\n\n    return inv", "spearman": 0.6574919372984326, "pearson": 0.7742004533191948, "rmse": 2.7142305717264787, "mae": 1.8394393406353464}}
{"timestamp": "2026-02-16T09:13:53.241681+00:00", "event_type": "generation_migration", "payload": {"generation": 9, "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:13:53.243351+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 10, "model_name": "gpt-oss:20b", "best_val_score": 0.5627212573413072, "no_improve_count": 2}}
{"timestamp": "2026-02-16T09:14:37.546722+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:14:37.548549+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:15:33.679767+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i0_p0_157197410", "generation": 10, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5104921968787515, "fitness_mode": "correlation", "simplicity_score": 0.11559610854354428, "novelty_bonus": 0.2687054798545443, "total_score": 0.3582272280741324, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.146508\nbelow_novelty_threshold: novelty_bonus=0.101264\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: code must define exactly one function named `new_invariant`\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global\n    graph statistics.  The expression uses only basic Python arithmetic\n    and built‑in functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Core features\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n\n    # ---------- Baseline ----------\n    # Grows with graph size, shrinks with average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # ---------- Adjustment factors ----------\n    # 1. Density: sparser graphs tend to have longer paths\n    density_adj = 1 + (1 - density) ** 1.5\n\n    # 2. Clustering / transitivity: more local clustering shortens paths\n    avg_clust_trans = (clustering + trans) * 0.5\n    clustering_adj = 1 - (avg_clust_trans ** 1.5)\n\n    # 3. Assortativity: strong assortative mixing can create longer paths\n    assort_adj = 1 + abs(assort)\n\n    # 4. Degree heterogeneity: higher std dev usually shortens paths\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n\n    # 5. Hubs: presence of high‑degree nodes shortens paths\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n\n    # 6. Triangles: more triangles typically reduce path lengths\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n\n    # 7. Minimum degree: very low min degree can increase path lengths\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) ** 0.5\n\n    # 8. Degree dispersion: larger spread can reduce average distances\n    deg_disp_adj = 1 + ((max_deg - min_deg + 1) ** 0.2)\n\n    # ---------- Clamp adjustments ----------\n    def clamp(x, lo=0.1, hi=10.0):\n        return lo if x < lo else hi if x > hi else x\n\n    density_adj   = clamp(density_adj)\n    clustering_adj = clamp(clustering_adj)\n    assort_adj    = clamp(assort_adj)\n    hetero_adj    = clamp(hetero_adj)\n    hub_adj       = clamp(hub_adj)\n    triangle_adj  = clamp(triangle_adj)\n    min_deg_adj   = clamp(min_deg_adj)\n    deg_disp_adj  = clamp(deg_disp_adj)\n\n    # ---------- Combine ----------\n    inv = (baseline *\n           density_adj *\n           clustering_adj *\n           assort_adj *\n           hetero_adj *\n           hub_adj *\n           triangle_adj *\n           min_deg_adj *\n           deg_disp_adj)\n\n    return inv\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    density = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    num_tri = float(s['num_triangles'])\n\n    # Baseline estimate\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj = 1 + (1 - density) ** 1.5\n    avg_clust_trans = (clustering + trans) * 0.5\n    clustering_adj = 1 - (avg_clust_trans ** 1.5)\n    assort_adj = 1 + abs(assort)\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) ** 0.5\n    deg_disp_adj = 1 + ((max_deg - min_deg + 1) ** 0.2)\n\n    # Clamp adjustments to avoid extreme values\n    if density_adj < 0.1: density_adj = 0.1\n    elif density_adj > 10.0: density_adj = 10.0\n\n    if clustering_adj < 0.1: clustering_adj = 0.1\n    elif clustering_adj > 10.0: clustering_adj = 10.0\n\n    if assort_adj < 0.1: assort_adj = 0.1\n    elif assort_adj > 10.0: assort_adj = 10.0\n\n    if hetero_adj < 0.1: hetero_adj = 0.1\n    elif hetero_adj > 10.0: hetero_adj = 10.0\n\n    if hub_adj < 0.1: hub_adj = 0.1\n    elif hub_adj > 10.0: hub_adj = 10.0\n\n    if triangle_adj < 0.1: triangle_adj = 0.1\n    elif triangle_adj > 10.0: triangle_adj = 10.0\n\n    if min_deg_adj < 0.1: min_deg_adj = 0.1\n    elif min_deg_adj > 10.0: min_deg_adj = 10.0\n\n    if deg_disp_adj < 0.1: deg_disp_adj = 0.1\n    elif deg_disp_adj > 10.0: deg_disp_adj = 10.0\n\n    # Combine all components\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj *\n            min_deg_adj *\n            deg_disp_adj)", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    density = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    num_tri = float(s['num_triangles'])\n\n    # Baseline estimate\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj = 1 + (1 - density) ** 1.5\n    avg_clust_trans = (clustering + trans) * 0.5\n    clustering_adj = 1 - (avg_clust_trans ** 1.5)\n    assort_adj = 1 + abs(assort)\n    hetero_adj = 1 - std_deg / (avg_deg + eps)\n    hub_adj = 1 - max_deg / (n - 1 + eps)\n    triangle_adj = 1 - num_tri / (n * (n - 1) / 2 + eps)\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) ** 0.5\n    deg_disp_adj = 1 + ((max_deg - min_deg + 1) ** 0.2)\n\n    # Clamp adjustments to avoid extreme values\n    if density_adj < 0.1: density_adj = 0.1\n    elif density_adj > 10.0: density_adj = 10.0\n\n    if clustering_adj < 0.1: clustering_adj = 0.1\n    elif clustering_adj > 10.0: clustering_adj = 10.0\n\n    if assort_adj < 0.1: assort_adj = 0.1\n    elif assort_adj > 10.0: assort_adj = 10.0\n\n    if hetero_adj < 0.1: hetero_adj = 0.1\n    elif hetero_adj > 10.0: hetero_adj = 10.0\n\n    if hub_adj < 0.1: hub_adj = 0.1\n    elif hub_adj > 10.0: hub_adj = 10.0\n\n    if triangle_adj < 0.1: triangle_adj = 0.1\n    elif triangle_adj > 10.0: triangle_adj = 10.0\n\n    if min_deg_adj < 0.1: min_deg_adj = 0.1\n    elif min_deg_adj > 10.0: min_deg_adj = 10.0\n\n    if deg_disp_adj < 0.1: deg_disp_adj = 0.1\n    elif deg_disp_adj > 10.0: deg_disp_adj = 10.0\n\n    # Combine all components\n    return (baseline *\n            density_adj *\n            clustering_adj *\n            assort_adj *\n            hetero_adj *\n            hub_adj *\n            triangle_adj *\n            min_deg_adj *\n            deg_disp_adj)", "spearman": 0.5089927248181205, "pearson": 0.3896219234315125, "rmse": 2.660566084476103, "mae": 2.019198914158017}}
{"timestamp": "2026-02-16T09:15:33.680697+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 0, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:16:07.938705+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:16:07.939383+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:16:34.763054+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:16:34.764060+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:17:03.656236+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:17:03.656645+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:17:21.487309+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 0, "population_idx": 2, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:17:21.487790+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 0, "population_idx": 2, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:17:44.866950+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:17:44.867612+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:18:18.881432+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.124218", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:18:18.881959+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:19:03.480030+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.118749", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:19:03.480244+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.118749", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:19:28.046519+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 0, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.098170", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:19:28.047026+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 0, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:20:13.141069+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.025012", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:20:13.141918+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.025012", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:20:44.742772+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 1, "population_idx": 0, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:20:44.743795+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 1, "population_idx": 0, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:21:45.938204+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.075093", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:21:45.939246+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.075093", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:22:12.824268+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 1, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:22:12.825297+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 1, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:23:09.679089+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:23:09.680834+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:23:57.656937+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 1, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.024806", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:23:57.657360+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 1, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:24:39.574919+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.024806", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:24:39.575951+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.024806", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:25:15.303957+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 1, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.119238", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:25:15.304458+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 1, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:26:05.879244+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:26:05.880018+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:27:13.674923+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 1, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:27:13.676908+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 1, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:28:04.538549+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i2_p0_453327768", "generation": 10, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.44432172869147657, "fitness_mode": "correlation", "simplicity_score": 0.2206775829744107, "novelty_bonus": 0.32179722137403877, "total_score": 0.4913204491512474, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the size of the\n    graph and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    minimum and maximum degree, density, triangle prevalence, and\n    transitivity.  All arithmetic is safe from division by zero and\n    keeps the expression compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``.\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # Positive assortativity tends to lengthen paths\n    base *= (1 + abs(assort))\n\n    # High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # Very small minimum degree can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # High maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n, 1))\n\n    # Denser graphs have shorter paths\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio indicates local cohesion\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + max_degree/(n‑1)).\n    * **Density** – denser graphs have shorter paths.  We multiply by a\n      factor proportional to (1 – density), bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.095242\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The formula is deliberately simple yet\n    incorporates several structural effects known to influence path\n    lengths: graph size, degree distribution, clustering, density,\n    assortativity, and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of vertex degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n\n    # ---- base term based on graph size and local clustering ----\n    base = (n ** 0.5) / (1 + clustering ** 0.5)\n\n    # ---- adjust for average degree ----\n    base *= (avg_deg + 1) ** 0.5\n\n    # ---- adjust for global density (denser graphs → shorter paths) ----\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # ---- adjust for degree heterogeneity and extremal degrees ----\n    base /= (1 + std_deg ** 0.5)            # hubs shorten paths\n    base *= (1 + 1 / min_deg)               # leaves lengthen paths\n    base /= (1 + max_deg / max(n - 1, 1))   # very large hubs shorten paths\n\n    # ---- adjust for assortativity (positive assortativity lengthens paths) ----\n    base *= (1 + abs(assort))\n\n    # ---- triangle (local cohesion) adjustment ----\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # ---- global transitivity adjustment ----\n    base *= (1 + trans)\n\n    # ---- additional effect from mean square degree ----\n    msd = sum(d * d for d in s['degrees']) / n\n    base *= (1 + msd / (avg_deg ** 2 + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.  The formula is deliberately simple yet\n    incorporates several structural effects known to influence path\n    lengths: graph size, degree distribution, clustering, density,\n    assortativity, and triangle density.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of vertex degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n\n    # ---- base term based on graph size and local clustering ----\n    base = (n ** 0.5) / (1 + clustering ** 0.5)\n\n    # ---- adjust for average degree ----\n    base *= (avg_deg + 1) ** 0.5\n\n    # ---- adjust for global density (denser graphs → shorter paths) ----\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # ---- adjust for degree heterogeneity and extremal degrees ----\n    base /= (1 + std_deg ** 0.5)            # hubs shorten paths\n    base *= (1 + 1 / min_deg)               # leaves lengthen paths\n    base /= (1 + max_deg / max(n - 1, 1))   # very large hubs shorten paths\n\n    # ---- adjust for assortativity (positive assortativity lengthens paths) ----\n    base *= (1 + abs(assort))\n\n    # ---- triangle (local cohesion) adjustment ----\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # ---- global transitivity adjustment ----\n    base *= (1 + trans)\n\n    # ---- additional effect from mean square degree ----\n    msd = sum(d * d for d in s['degrees']) / n\n    base *= (1 + msd / (avg_deg ** 2 + 1))\n\n    return base", "spearman": 0.7012915322883073, "pearson": 0.6967952675114364, "rmse": 17.64254122429577, "mae": 16.254298760377047}}
{"timestamp": "2026-02-16T09:28:51.559228+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i2_p1_270045649", "generation": 10, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.895126050420168, "fitness_mode": "correlation", "simplicity_score": 0.2199260487920606, "novelty_bonus": 0.1501714417161848, "total_score": 0.5635337547010782, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the size of the\n    graph and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    minimum and maximum degree, density, triangle prevalence, and\n    transitivity.  All arithmetic is safe from division by zero and\n    keeps the expression compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``.\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # Positive assortativity tends to lengthen paths\n    base *= (1 + abs(assort))\n\n    # High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # Very small minimum degree can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # High maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n, 1))\n\n    # Denser graphs have shorter paths\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio indicates local cohesion\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + max_degree/(n‑1)).\n    * **Density** – denser graphs have shorter paths.  We multiply by a\n      factor proportional to (1 – density), bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.095242\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.9489942248556215, "pearson": 0.8749023354744576, "rmse": 8.1584563303381, "mae": 4.831634142354471}}
{"timestamp": "2026-02-16T09:29:37.168970+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i2_p2_170504839", "generation": 10, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.5962545018007203, "fitness_mode": "correlation", "simplicity_score": 0.2223273988983509, "novelty_bonus": 0.21585755777573723, "total_score": 0.49614917027297045, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the size of the\n    graph and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    minimum and maximum degree, density, triangle prevalence, and\n    transitivity.  All arithmetic is safe from division by zero and\n    keeps the expression compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``.\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # Positive assortativity tends to lengthen paths\n    base *= (1 + abs(assort))\n\n    # High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # Very small minimum degree can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # High maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n, 1))\n\n    # Denser graphs have shorter paths\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio indicates local cohesion\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + max_degree/(n‑1)).\n    * **Density** – denser graphs have shorter paths.  We multiply by a\n      factor proportional to (1 – density), bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.095242\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.  The formula is a simple, interpretable product of\n    factors that are known to influence path lengths:\n\n    * a baseline that grows with the graph size and shrinks with the\n      average degree;\n    * multiplicative adjustments for clustering, assortativity, and\n      global transitivity;\n    * divisive adjustments for degree heterogeneity, high maximum degree,\n      and triangle prevalence;\n    * multiplicative adjustments for very small minimum degree and for\n      graph density.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    compact.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``.\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: larger n → longer paths; larger avg_deg → shorter paths\n    base = n / (avg_deg + 1)\n\n    # Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # Positive assortativity tends to lengthen paths\n    base *= (1 + abs(assortativity))\n\n    # Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # Very small minimum degree can lengthen paths\n    base *= (1 + min_deg / (avg_deg + 1))\n\n    # Very large maximum degree shortens paths\n    base /= (1 + max_deg / (avg_deg + 1))\n\n    # Denser graphs have shorter paths; use an inverse‑density factor\n    density_factor = 1 / (1 + density)\n    base *= density_factor\n\n    # Triangle ratio indicates local cohesion; high ratios shorten paths\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    possible_triangles = max(1, possible_triangles)\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.  The formula is a simple, interpretable product of\n    factors that are known to influence path lengths:\n\n    * a baseline that grows with the graph size and shrinks with the\n      average degree;\n    * multiplicative adjustments for clustering, assortativity, and\n      global transitivity;\n    * divisive adjustments for degree heterogeneity, high maximum degree,\n      and triangle prevalence;\n    * multiplicative adjustments for very small minimum degree and for\n      graph density.\n\n    All arithmetic is safe from division by zero and keeps the expression\n    compact.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``.\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: larger n → longer paths; larger avg_deg → shorter paths\n    base = n / (avg_deg + 1)\n\n    # Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # Positive assortativity tends to lengthen paths\n    base *= (1 + abs(assortativity))\n\n    # Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # Very small minimum degree can lengthen paths\n    base *= (1 + min_deg / (avg_deg + 1))\n\n    # Very large maximum degree shortens paths\n    base /= (1 + max_deg / (avg_deg + 1))\n\n    # Denser graphs have shorter paths; use an inverse‑density factor\n    density_factor = 1 / (1 + density)\n    base *= density_factor\n\n    # Triangle ratio indicates local cohesion; high ratios shorten paths\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    possible_triangles = max(1, possible_triangles)\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base", "spearman": 0.7738528463211581, "pearson": 0.6035242729915565, "rmse": 1.864657523346594, "mae": 1.394007690130036}}
{"timestamp": "2026-02-16T09:30:29.557505+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i2_p3_894355338", "generation": 10, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8746698679471788, "fitness_mode": "correlation", "simplicity_score": 0.22159187726343235, "novelty_bonus": 0.18040948678747581, "total_score": 0.5606717772528234, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the size of the\n    graph and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    minimum and maximum degree, density, triangle prevalence, and\n    transitivity.  All arithmetic is safe from division by zero and\n    keeps the expression compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``.\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # Positive assortativity tends to lengthen paths\n    base *= (1 + abs(assort))\n\n    # High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # Very small minimum degree can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # High maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n, 1))\n\n    # Denser graphs have shorter paths\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio indicates local cohesion\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + max_degree/(n‑1)).\n    * **Density** – denser graphs have shorter paths.  We multiply by a\n      factor proportional to (1 – density), bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.095242\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/(min_degree+1)).\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + sqrt(max_degree/(n-1))).\n    * **Density** – denser graphs have shorter paths.  We multiply by\n      a factor proportional to (1 – density), bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      2 * triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assort))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / (min_deg + 1))\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    triangle_ratio = num_tri / possible_tri\n    base /= (1 + 2 * triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/(min_degree+1)).\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + sqrt(max_degree/(n-1))).\n    * **Density** – denser graphs have shorter paths.  We multiply by\n      a factor proportional to (1 – density), bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      2 * triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assort))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / (min_deg + 1))\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    triangle_ratio = num_tri / possible_tri\n    base /= (1 + 2 * triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base", "spearman": 0.9244611115277883, "pearson": 0.8615847913951106, "rmse": 3.3195939922919036, "mae": 1.9984365461242317}}
{"timestamp": "2026-02-16T09:31:10.239685+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i2_p4_981736081", "generation": 10, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.6521488595438175, "fitness_mode": "correlation", "simplicity_score": 0.22128271627508103, "novelty_bonus": 0.16106270977481385, "total_score": 0.49760273187185255, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a set of pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the size of the\n    graph and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    minimum and maximum degree, density, triangle prevalence, and\n    transitivity.  All arithmetic is safe from division by zero and\n    keeps the expression compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``.\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # Positive assortativity tends to lengthen paths\n    base *= (1 + abs(assort))\n\n    # High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # Very small minimum degree can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # High maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n, 1))\n\n    # Denser graphs have shorter paths\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio indicates local cohesion\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + max_degree/(n‑1)).\n    * **Density** – denser graphs have shorter paths.  We multiply by a\n      factor proportional to (1 – density), bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.095242\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + max_degree/(n‑1)).\n    * **Degree ratio** – a large ratio of max to min degree also\n      indicates hub dominance; we divide by (1 + max_degree/(min_degree+1)).\n    * **Density** – denser graphs have shorter paths.  We multiply by\n      a factor proportional to the square root of (1 – density),\n      bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n    base /= (1 + max_deg / max(n - 1, 1))\n    base /= (1 + max_deg / (min_deg + 1))\n\n    # Density factor (bounded below by 0.05, using square root for smoother scaling)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    else:\n        density_factor = density_factor ** 0.5\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/min_degree) where\n      min_degree is clamped to at least 1.\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + max_degree/(n‑1)).\n    * **Degree ratio** – a large ratio of max to min degree also\n      indicates hub dominance; we divide by (1 + max_degree/(min_degree+1)).\n    * **Density** – denser graphs have shorter paths.  We multiply by\n      a factor proportional to the square root of (1 – density),\n      bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assortativity = s['degree_assortativity']\n    density = s['density']\n    num_triangles = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assortativity))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / min_deg)\n    base /= (1 + max_deg / max(n - 1, 1))\n    base /= (1 + max_deg / (min_deg + 1))\n\n    # Density factor (bounded below by 0.05, using square root for smoother scaling)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    else:\n        density_factor = density_factor ** 0.5\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    if possible_triangles == 0:\n        possible_triangles = 1\n    triangle_ratio = num_triangles / possible_triangles\n    base /= (1 + triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base", "spearman": 0.8100547513687844, "pearson": 0.6851181550413589, "rmse": 1.7305852117012168, "mae": 1.578862434821784}}
{"timestamp": "2026-02-16T09:31:48.803639+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i3_p0_120953216", "generation": 10, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.5969267707082833, "fitness_mode": "correlation", "simplicity_score": 0.24671026513036343, "novelty_bonus": 0.39124069206656775, "total_score": 0.4874290285152397, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without calling any graph‑theoretic routine or external library.\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed global features:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted degree list\n    Returns\n    -------\n    float\n        An invariant estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n  = float(s['n'])\n    m  = float(s['m'])\n    d  = float(s['density'])\n    max_d = float(s['max_degree'])\n    min_d = float(s['min_degree'])\n    std_d = float(s['std_degree'])\n    clus = float(s['avg_clustering'])\n    tri = float(s['num_triangles'])\n    assort = float(s['degree_assortativity'])\n    degs = s['degrees']                     # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term: larger graphs with sparser edges give\n    #    a larger contribution.\n    size_term = (n ** 1.1) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs increase the estimate.\n    dens_term = 1.0 / (d + 1e-6)\n\n    # 3. Degree‑dispersion component: wider degree spread suggests\n    #    longer paths.\n    disp_term = (max_d - min_d + 1.0) ** 0.3\n\n    # 4. Harmonic mean of degrees (captures skewness without std).\n    h_sum = 0.0\n    for dv in degs:\n        if dv > 0:\n            h_sum += 1.0 / float(dv)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. Clustering/transitivity reduction: high clustering tends to\n    #    reduce path length.\n    cluster_term = 1.0 / (clus + s['transitivity'] + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles generally shorten paths.\n    tri_term = (tri + 1.0) ** 0.4\n\n    # 7. Assortativity boost: assortative mixing often creates shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.274910\nbelow_train_threshold: train_signal=0.163217\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length from a set of global\n    graph statistics.  No external libraries or graph traversals are\n    required; the expression is a weighted combination of size,\n    density, degree dispersion, clustering, triangles and assortativity.\n    \"\"\"\n    # Extract basic scalars\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']                     # list of ints\n\n    # 1. Size–density hybrid: larger, sparser graphs usually have\n    #    longer paths.\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs increase the estimate.\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree dispersion (range) – a wider spread tends to increase path length.\n    disp_term = (max_deg - min_deg + 1.0) ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness without extra libraries.\n    h_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. Clustering / transitivity reduce path length; down‑weight their influence.\n    cluster_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Triangle shortcut effect – more triangles normally shorten paths.\n    possible_tri = n * (n - 1) * (n - 2) / 6.0\n    tri_ratio    = num_tri / (possible_tri + 1e-6)\n    tri_term     = (1.0 + tri_ratio) ** 0.5\n\n    # 7. Assortativity – extreme assortativity can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 8. Combine all components into a single estimate.\n    #    The degree terms are divided to dampen extremely large values.\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term *\n                 (avg_deg + std_deg + 1e-6))\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length from a set of global\n    graph statistics.  No external libraries or graph traversals are\n    required; the expression is a weighted combination of size,\n    density, degree dispersion, clustering, triangles and assortativity.\n    \"\"\"\n    # Extract basic scalars\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']                     # list of ints\n\n    # 1. Size–density hybrid: larger, sparser graphs usually have\n    #    longer paths.\n    size_term = (n ** 0.8) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs increase the estimate.\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree dispersion (range) – a wider spread tends to increase path length.\n    disp_term = (max_deg - min_deg + 1.0) ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness without extra libraries.\n    h_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. Clustering / transitivity reduce path length; down‑weight their influence.\n    cluster_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Triangle shortcut effect – more triangles normally shorten paths.\n    possible_tri = n * (n - 1) * (n - 2) / 6.0\n    tri_ratio    = num_tri / (possible_tri + 1e-6)\n    tri_term     = (1.0 + tri_ratio) ** 0.5\n\n    # 7. Assortativity – extreme assortativity can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 8. Combine all components into a single estimate.\n    #    The degree terms are divided to dampen extremely large values.\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term *\n                 (avg_deg + std_deg + 1e-6))\n\n    return inv", "spearman": 0.6414295357383935, "pearson": 0.8096130837596844, "rmse": 1.8589760907656228, "mae": 1.7521470822004854}}
{"timestamp": "2026-02-16T09:32:16.537826+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i3_p1_335521091", "generation": 10, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8373109243697479, "fitness_mode": "correlation", "simplicity_score": 0.22335485883721273, "novelty_bonus": 0.20040381990466183, "total_score": 0.5619622969933225, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without calling any graph‑theoretic routine or external library.\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed global features:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted degree list\n    Returns\n    -------\n    float\n        An invariant estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n  = float(s['n'])\n    m  = float(s['m'])\n    d  = float(s['density'])\n    max_d = float(s['max_degree'])\n    min_d = float(s['min_degree'])\n    std_d = float(s['std_degree'])\n    clus = float(s['avg_clustering'])\n    tri = float(s['num_triangles'])\n    assort = float(s['degree_assortativity'])\n    degs = s['degrees']                     # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term: larger graphs with sparser edges give\n    #    a larger contribution.\n    size_term = (n ** 1.1) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs increase the estimate.\n    dens_term = 1.0 / (d + 1e-6)\n\n    # 3. Degree‑dispersion component: wider degree spread suggests\n    #    longer paths.\n    disp_term = (max_d - min_d + 1.0) ** 0.3\n\n    # 4. Harmonic mean of degrees (captures skewness without std).\n    h_sum = 0.0\n    for dv in degs:\n        if dv > 0:\n            h_sum += 1.0 / float(dv)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. Clustering/transitivity reduction: high clustering tends to\n    #    reduce path length.\n    cluster_term = 1.0 / (clus + s['transitivity'] + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles generally shorten paths.\n    tri_term = (tri + 1.0) ** 0.4\n\n    # 7. Assortativity boost: assortative mixing often creates shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nbelow_train_threshold: train_signal=0.274910\nbelow_train_threshold: train_signal=0.163217\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base", "spearman": 0.9143403585089629, "pearson": 0.8271326217624315, "rmse": 3.359512705062122, "mae": 2.0994546103869034}}
{"timestamp": "2026-02-16T09:32:44.732153+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.102923", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:32:44.732862+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 10, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.102923", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:33:24.556675+00:00", "event_type": "candidate_rejected", "payload": {"generation": 10, "island_id": 3, "population_idx": 2, "attempt_index": 1, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.065834", "model_name": "gpt-oss:20b", "train_signal": 0.0658343337334934}}
{"timestamp": "2026-02-16T09:33:24.557628+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 10, "island_id": 3, "population_idx": 2, "status": "failed", "reason": "below_train_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:33:57.799126+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i3_p3_761440427", "generation": 10, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.30833133253301315, "fitness_mode": "correlation", "simplicity_score": 0.24724760766844345, "novelty_bonus": 0.3262639335779709, "total_score": 0.3489869930643664, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without calling any graph‑theoretic routine or external library.\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed global features:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted degree list\n    Returns\n    -------\n    float\n        An invariant estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n  = float(s['n'])\n    m  = float(s['m'])\n    d  = float(s['density'])\n    max_d = float(s['max_degree'])\n    min_d = float(s['min_degree'])\n    std_d = float(s['std_degree'])\n    clus = float(s['avg_clustering'])\n    tri = float(s['num_triangles'])\n    assort = float(s['degree_assortativity'])\n    degs = s['degrees']                     # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term: larger graphs with sparser edges give\n    #    a larger contribution.\n    size_term = (n ** 1.1) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs increase the estimate.\n    dens_term = 1.0 / (d + 1e-6)\n\n    # 3. Degree‑dispersion component: wider degree spread suggests\n    #    longer paths.\n    disp_term = (max_d - min_d + 1.0) ** 0.3\n\n    # 4. Harmonic mean of degrees (captures skewness without std).\n    h_sum = 0.0\n    for dv in degs:\n        if dv > 0:\n            h_sum += 1.0 / float(dv)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. Clustering/transitivity reduction: high clustering tends to\n    #    reduce path length.\n    cluster_term = 1.0 / (clus + s['transitivity'] + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles generally shorten paths.\n    tri_term = (tri + 1.0) ** 0.4\n\n    # 7. Assortativity boost: assortative mixing often creates shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.102923\nbelow_train_threshold: train_signal=0.065834\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built exclusively from\n    pre‑computed graph statistics.  The expression is a compact,\n    interpretable combination of size, sparsity, degree spread,\n    assortativity, clustering, and local triadic closure effects.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed global features.  Expected keys\n        include: 'n', 'm', 'density', 'avg_degree', 'max_degree',\n        'min_degree', 'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'num_triangles', and 'degrees'.\n\n    Returns\n    -------\n    float\n        A single value that approximates the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Basic scalars extracted from the dictionary\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    tri        = float(s['num_triangles'])\n    degrees    = s['degrees']               # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑sparsity backbone – larger graphs with fewer edges\n    #    naturally yield longer paths.\n    size_sparsity = (n ** 1.15) / (m + 1.0)\n\n    # 2. Degree spread – wide variation tends to increase path lengths.\n    degree_range = (max_deg - min_deg + 1.0) ** 0.35\n\n    # 3. Harmonic mean of degrees – captures skewness without std.\n    h_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 4. Density factor – sparse graphs are penalised.\n    density_factor = 1.0 / (density + 1e-6)\n\n    # 5. Clustering / transitivity dampening – higher values shorten paths.\n    clustering_factor = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing tends to create shortcuts.\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Triangle ratio – many triangles typically reduce path lengths.\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = tri / max(1, possible_tri)\n    triangle_factor = (triangle_ratio + 0.1) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant: combine all the individual components.\n    inv = (size_sparsity * density_factor * degree_range *\n           harmonic_mean * assort_factor)\n    inv = inv / (clustering_factor * triangle_factor)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built exclusively from\n    pre‑computed graph statistics.  The expression is a compact,\n    interpretable combination of size, sparsity, degree spread,\n    assortativity, clustering, and local triadic closure effects.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed global features.  Expected keys\n        include: 'n', 'm', 'density', 'avg_degree', 'max_degree',\n        'min_degree', 'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'num_triangles', and 'degrees'.\n\n    Returns\n    -------\n    float\n        A single value that approximates the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Basic scalars extracted from the dictionary\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    tri        = float(s['num_triangles'])\n    degrees    = s['degrees']               # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑sparsity backbone – larger graphs with fewer edges\n    #    naturally yield longer paths.\n    size_sparsity = (n ** 1.15) / (m + 1.0)\n\n    # 2. Degree spread – wide variation tends to increase path lengths.\n    degree_range = (max_deg - min_deg + 1.0) ** 0.35\n\n    # 3. Harmonic mean of degrees – captures skewness without std.\n    h_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            h_sum += 1.0 / float(d)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 4. Density factor – sparse graphs are penalised.\n    density_factor = 1.0 / (density + 1e-6)\n\n    # 5. Clustering / transitivity dampening – higher values shorten paths.\n    clustering_factor = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing tends to create shortcuts.\n    assort_factor = 1.0 + abs(assort)\n\n    # 7. Triangle ratio – many triangles typically reduce path lengths.\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = tri / max(1, possible_tri)\n    triangle_factor = (triangle_ratio + 0.1) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant: combine all the individual components.\n    inv = (size_sparsity * density_factor * degree_range *\n           harmonic_mean * assort_factor)\n    inv = inv / (clustering_factor * triangle_factor)\n\n    return inv", "spearman": 0.40331658291457295, "pearson": 0.5996600634227562, "rmse": 128.00787026021374, "mae": 96.07420394245622}}
{"timestamp": "2026-02-16T09:34:27.456274+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g10_i3_p4_690731003", "generation": 10, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6536854741896758, "fitness_mode": "correlation", "simplicity_score": 0.1808035593955049, "novelty_bonus": 0.3648687480563019, "total_score": 0.4983109035351725, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without calling any graph‑theoretic routine or external library.\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing pre‑computed global features:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted degree list\n    Returns\n    -------\n    float\n        An invariant estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n  = float(s['n'])\n    m  = float(s['m'])\n    d  = float(s['density'])\n    max_d = float(s['max_degree'])\n    min_d = float(s['min_degree'])\n    std_d = float(s['std_degree'])\n    clus = float(s['avg_clustering'])\n    tri = float(s['num_triangles'])\n    assort = float(s['degree_assortativity'])\n    degs = s['degrees']                     # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term: larger graphs with sparser edges give\n    #    a larger contribution.\n    size_term = (n ** 1.1) / (m + 1.0)\n\n    # 2. Density penalty: sparse graphs increase the estimate.\n    dens_term = 1.0 / (d + 1e-6)\n\n    # 3. Degree‑dispersion component: wider degree spread suggests\n    #    longer paths.\n    disp_term = (max_d - min_d + 1.0) ** 0.3\n\n    # 4. Harmonic mean of degrees (captures skewness without std).\n    h_sum = 0.0\n    for dv in degs:\n        if dv > 0:\n            h_sum += 1.0 / float(dv)\n    harmonic_mean = n / (h_sum + 1e-12)\n\n    # 5. Clustering/transitivity reduction: high clustering tends to\n    #    reduce path length.\n    cluster_term = 1.0 / (clus + s['transitivity'] + 1e-6)\n\n    # 6. Triangle shortcut effect: more triangles generally shorten paths.\n    tri_term = (tri + 1.0) ** 0.4\n\n    # 7. Assortativity boost: assortative mixing often creates shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant\n    inv = (size_term * dens_term * disp_term *\n           harmonic_mean * assort_term)\n    inv = inv / (cluster_term * tri_term)\n\n    return inv\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.102923\nbelow_train_threshold: train_signal=0.065834\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without calling any external library or running a shortest‑path algorithm.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.\n        Expected keys:\n            - n, m, density, avg_degree, max_degree, min_degree,\n              std_degree, avg_clustering, transitivity,\n              degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        A numeric estimate of the average shortest‑path length.\n    \"\"\"\n    # Extract and cast values to float for safety\n    n       = float(s['n'])\n    m       = float(s['m'])\n    dens    = float(s['density'])\n    avg_deg = float(s['avg_degree'])\n    max_d   = float(s['max_degree'])\n    min_d   = float(s['min_degree'])\n    std_d   = float(s['std_degree'])\n    clus    = float(s['avg_clustering'])\n    trans   = float(s['transitivity'])\n    assort  = float(s['degree_assortativity'])\n    tri     = float(s['num_triangles'])\n\n    # 1. Size component – grows with the number of vertices.\n    size_term = (n ** 0.7) + 1.0\n\n    # 2. Density penalty – sparse graphs increase the estimate.\n    density_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion component – wider spread tends to lengthen paths.\n    dispersion_term = (max_d - min_d + 1.0) ** 0.4\n\n    # 4. Degree‑variance dampener – high variance (hubs) shortens paths.\n    variance_term = 1.0 / (std_d + 1e-6)\n\n    # 5. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 6. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (tri + 1.0) ** 0.3\n\n    # 7. Clustering/transitivity reduction – highly clustered graphs tend\n    #    to have shorter paths, so we down‑weight them.\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # Assemble the invariant\n    estimate = (size_term * density_term * dispersion_term *\n                variance_term * assort_term)\n    estimate = estimate / (triangle_term * cluster_term)\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without calling any external library or running a shortest‑path algorithm.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.\n        Expected keys:\n            - n, m, density, avg_degree, max_degree, min_degree,\n              std_degree, avg_clustering, transitivity,\n              degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        A numeric estimate of the average shortest‑path length.\n    \"\"\"\n    # Extract and cast values to float for safety\n    n       = float(s['n'])\n    m       = float(s['m'])\n    dens    = float(s['density'])\n    avg_deg = float(s['avg_degree'])\n    max_d   = float(s['max_degree'])\n    min_d   = float(s['min_degree'])\n    std_d   = float(s['std_degree'])\n    clus    = float(s['avg_clustering'])\n    trans   = float(s['transitivity'])\n    assort  = float(s['degree_assortativity'])\n    tri     = float(s['num_triangles'])\n\n    # 1. Size component – grows with the number of vertices.\n    size_term = (n ** 0.7) + 1.0\n\n    # 2. Density penalty – sparse graphs increase the estimate.\n    density_term = 1.0 / (dens + 1e-6)\n\n    # 3. Degree‑dispersion component – wider spread tends to lengthen paths.\n    dispersion_term = (max_d - min_d + 1.0) ** 0.4\n\n    # 4. Degree‑variance dampener – high variance (hubs) shortens paths.\n    variance_term = 1.0 / (std_d + 1e-6)\n\n    # 5. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 6. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (tri + 1.0) ** 0.3\n\n    # 7. Clustering/transitivity reduction – highly clustered graphs tend\n    #    to have shorter paths, so we down‑weight them.\n    cluster_term = 1.0 / (clus + trans + 1e-6)\n\n    # Assemble the invariant\n    estimate = (size_term * density_term * dispersion_term *\n                variance_term * assort_term)\n    estimate = estimate / (triangle_term * cluster_term)\n\n    return estimate", "spearman": 0.705379134478362, "pearson": 0.6638347424970947, "rmse": 55.0412123752689, "mae": 32.74757440339347}}
{"timestamp": "2026-02-16T09:34:27.460702+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 11, "model_name": "gpt-oss:20b", "best_val_score": 0.5635337547010782, "no_improve_count": 0}}
{"timestamp": "2026-02-16T09:35:20.141995+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:35:20.143958+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:35:54.949339+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 0, "population_idx": 0, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:35:54.950390+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 0, "population_idx": 0, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:36:19.815817+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:36:19.816818+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:36:38.972392+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:36:38.973433+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:38:11.604259+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:38:11.606112+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:38:52.557996+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i0_p2_586179867", "generation": 11, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.544297719087635, "fitness_mode": "correlation", "simplicity_score": 0.12239841031352473, "novelty_bonus": 0.22169833554208662, "total_score": 0.3701994129810874, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.098170\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: code must define exactly one function named `new_invariant`\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    density = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    max_deg = float(s['max_degree'])\n    num_tri = float(s['num_triangles'])\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    def clamp(x, lo, hi):\n        return max(lo, min(hi, x))\n\n    density_adj   = clamp(density_adj,   0.1, 10)\n    clustering_adj = clamp(clustering_adj, 0.1, 10)\n    assort_adj    = clamp(assort_adj,    0.1, 10)\n    hetero_adj    = clamp(hetero_adj,    0.1, 10)\n    hub_adj       = clamp(hub_adj,       0.1, 10)\n    triangle_adj  = clamp(triangle_adj,  0.1, 10)\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    density = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    max_deg = float(s['max_degree'])\n    num_tri = float(s['num_triangles'])\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    density = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    max_deg = float(s['max_degree'])\n    num_tri = float(s['num_triangles'])\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.5584204605115128, "pearson": 0.46609151447724606, "rmse": 2.0219886270648404, "mae": 1.813566092812708}}
{"timestamp": "2026-02-16T09:38:52.558619+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 0, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:39:13.067078+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:39:13.068199+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:39:39.737181+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:39:39.738513+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:40:02.179041+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:40:02.179714+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:40:24.644412+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 0, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:40:24.645688+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 0, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:41:05.091714+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:41:05.092320+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:41:34.149651+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 1, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.024806", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:41:34.150213+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 1, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:42:13.703151+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.025045", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:42:13.703671+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.025045", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:42:54.027442+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 1, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.095667", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:42:54.028168+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 1, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:43:25.912746+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:43:25.913664+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:44:32.806599+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 1, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.024806", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:44:32.807741+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 1, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:45:17.890496+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i1_p3_691452281", "generation": 11, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14936428338287414, "novelty_bonus": 0.2098132453311331, "total_score": 0.2888499811046855, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant combining size, degree distribution,\n    clustering, triangle count, assortativity, and degree range.\n    \"\"\"\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    avg_clust = s['avg_clustering']\n    trans = s['transitivity']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    deg_assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    degrees = s['degrees']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Numerator: combines size, degree, clustering, triangle, and degree‑range information\n    numerator = (\n        (n ** 0.5) * avg_deg * (1 + avg_clust) * (1 + trans)\n        + norm_sq\n        + (num_tri + 1) ** 0.5\n        + (max_deg + 1) ** 0.5\n        + (min_deg + 1) ** 0.5\n    )\n\n    # Denominator: keeps the invariant bounded and incorporates connectivity and heterogeneity\n    denom = (\n        1\n        + m\n        + density\n        + num_tri\n        + (deg_assort if deg_assort is not None else 0)\n        + std_deg\n        + (max_deg + 1)\n        + (min_deg + 1)\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.095667\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T09:45:59.558768+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.024806", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:45:59.559321+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.024806", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:46:55.453087+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 1, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.138564", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:46:55.454273+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 1, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:47:58.487742+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i2_p0_343879082", "generation": 11, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.6945978391356541, "fitness_mode": "correlation", "simplicity_score": 0.21947833032914538, "novelty_bonus": 0.1988587612697894, "total_score": 0.5109619796638963, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/(min_degree+1)).\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + sqrt(max_degree/(n-1))).\n    * **Density** – denser graphs have shorter paths.  We multiply by\n      a factor proportional to (1 – density), bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      2 * triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assort))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / (min_deg + 1))\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    triangle_ratio = num_tri / possible_tri\n    base /= (1 + 2 * triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.095242\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a size‑based baseline and is progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  A lightweight\n    degree‑variance term is added at the end to capture subtle\n    heterogeneity effects.  Only built‑in arithmetic is used – no\n    external imports or graph algorithms.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic attributes\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Size‑based baseline (larger n, smaller avg_degree → longer paths)\n    base = (n + 1) / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours; moderate the effect\n    base *= (1 + clustering / 2)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (hubs) shortens paths\n    base /= (1 + std_deg / 2)\n\n    # 5. Very small minimum degree can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hub) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Transitivity (global clustering) further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: degree‑variance factor (lightweight)\n    if degrees:\n        sum_sq = 0\n        for d in degrees:\n            sum_sq += d * d\n        avg_sq = sum_sq / n\n        var = avg_sq - avg_deg * avg_deg\n        if var > 0:\n            base /= (1 + var / (avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a size‑based baseline and is progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  A lightweight\n    degree‑variance term is added at the end to capture subtle\n    heterogeneity effects.  Only built‑in arithmetic is used – no\n    external imports or graph algorithms.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic attributes\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Size‑based baseline (larger n, smaller avg_degree → longer paths)\n    base = (n + 1) / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours; moderate the effect\n    base *= (1 + clustering / 2)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (hubs) shortens paths\n    base /= (1 + std_deg / 2)\n\n    # 5. Very small minimum degree can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hub) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Transitivity (global clustering) further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: degree‑variance factor (lightweight)\n    if degrees:\n        sum_sq = 0\n        for d in degrees:\n            sum_sq += d * d\n        avg_sq = sum_sq / n\n        var = avg_sq - avg_deg * avg_deg\n        if var > 0:\n            base /= (1 + var / (avg_deg + 1))\n\n    return base", "spearman": 0.814817370434261, "pearson": 0.7276288632036764, "rmse": 3.011517088719286, "mae": 1.8455678119027505}}
{"timestamp": "2026-02-16T09:48:48.512356+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i2_p1_972240094", "generation": 11, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8746698679471788, "fitness_mode": "correlation", "simplicity_score": 0.22159187726343235, "novelty_bonus": 0.18040948678747581, "total_score": 0.5606717772528234, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/(min_degree+1)).\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + sqrt(max_degree/(n-1))).\n    * **Density** – denser graphs have shorter paths.  We multiply by\n      a factor proportional to (1 – density), bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      2 * triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assort))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / (min_deg + 1))\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    triangle_ratio = num_tri / possible_tri\n    base /= (1 + 2 * triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.095242\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    graph size and shrinks with the average degree.  A series of\n    multiplicative adjustments captures the influence of clustering,\n    assortativity, degree heterogeneity, minimum/maximum degree,\n    density, triangles, and global transitivity.  All arithmetic is\n    performed with built‑in operators; no external imports are used.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + 2 * tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    graph size and shrinks with the average degree.  A series of\n    multiplicative adjustments captures the influence of clustering,\n    assortativity, degree heterogeneity, minimum/maximum degree,\n    density, triangles, and global transitivity.  All arithmetic is\n    performed with built‑in operators; no external imports are used.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + 2 * tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base", "spearman": 0.9244611115277883, "pearson": 0.8615847913951106, "rmse": 3.3195939922919036, "mae": 1.9984365461242317}}
{"timestamp": "2026-02-16T09:49:22.701163+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i2_p2_833384465", "generation": 11, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8746698679471788, "fitness_mode": "correlation", "simplicity_score": 0.22159187726343235, "novelty_bonus": 0.18040948678747581, "total_score": 0.5606717772528234, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/(min_degree+1)).\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + sqrt(max_degree/(n-1))).\n    * **Density** – denser graphs have shorter paths.  We multiply by\n      a factor proportional to (1 – density), bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      2 * triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assort))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / (min_deg + 1))\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    triangle_ratio = num_tri / possible_tri\n    base /= (1 + 2 * triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.095242\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        An approximate value of the average shortest path length.\n    \"\"\"\n    # Basic attributes\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: grows with size, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + 2 * tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        An approximate value of the average shortest path length.\n    \"\"\"\n    # Basic attributes\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: grows with size, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + 2 * tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base", "spearman": 0.9244611115277883, "pearson": 0.8615847913951106, "rmse": 3.3195939922919036, "mae": 1.9984365461242317}}
{"timestamp": "2026-02-16T09:50:00.229433+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i2_p3_77854993", "generation": 11, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8746698679471788, "fitness_mode": "correlation", "simplicity_score": 0.22178457158834725, "novelty_bonus": 0.18040948678747581, "total_score": 0.5607103161178063, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/(min_degree+1)).\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + sqrt(max_degree/(n-1))).\n    * **Density** – denser graphs have shorter paths.  We multiply by\n      a factor proportional to (1 – density), bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      2 * triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assort))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / (min_deg + 1))\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    triangle_ratio = num_tri / possible_tri\n    base /= (1 + 2 * triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.095242\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    refined by a series of multiplicative and divisive adjustments\n    that capture the effects of clustering, assortativity, degree\n    heterogeneity, density, triangles, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact approximation of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + 2 * triangle_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    refined by a series of multiplicative and divisive adjustments\n    that capture the effects of clustering, assortativity, degree\n    heterogeneity, density, triangles, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact approximation of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + 2 * triangle_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base", "spearman": 0.9244611115277883, "pearson": 0.8615847913951106, "rmse": 3.3195939922919036, "mae": 1.9984365461242317}}
{"timestamp": "2026-02-16T09:50:59.458793+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i2_p4_946457991", "generation": 11, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.573781512605042, "fitness_mode": "correlation", "simplicity_score": 0.22076063924513523, "novelty_bonus": 0.1941146315922866, "total_score": 0.46620111269159714, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a baseline that grows with the graph\n    size and shrinks with the average degree.  Several structural\n    factors that are known to influence path lengths are then applied:\n\n    * **Clustering** – higher clustering tends to create detours,\n      so the estimate is multiplied by (1 + avg_clustering).\n    * **Assortativity** – positive assortativity usually increases\n      path lengths; we use the absolute value so that negative\n      assortativity shortens the estimate.\n    * **Degree heterogeneity** – a large standard deviation of\n      degrees (presence of hubs) shortens paths, so we divide by\n      (1 + std_degree).\n    * **Minimum degree** – very small minimum degree (leaves) can\n      lengthen paths; we multiply by (1 + 1/(min_degree+1)).\n    * **Maximum degree** – a very large maximum degree shortens\n      paths; we divide by (1 + sqrt(max_degree/(n-1))).\n    * **Density** – denser graphs have shorter paths.  We multiply by\n      a factor proportional to (1 – density), bounded below by 0.05.\n    * **Triangles** – a high triangle ratio indicates local cohesion\n      and tends to reduce average path lengths; we divide by (1 +\n      2 * triangle_ratio).\n    * **Transitivity** – global clustering further shortens paths,\n      so we multiply by (1 + transitivity).\n\n    All arithmetic is safe from division by zero and the formula\n    remains compact and interpretable.\n    \"\"\"\n    # Basic graph attributes\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assort))\n\n    # Adjust for degree heterogeneity and min/max degree\n    base /= (1 + std_deg)\n    base *= (1 + 1 / (min_deg + 1))\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # Density factor (bounded below by 0.05)\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio adjustment\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    triangle_ratio = num_tri / possible_tri\n    base /= (1 + 2 * triangle_ratio)\n\n    # Transitivity adjustment\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.095242\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a compact set of\n    pre‑computed graph statistics.  The estimate is built in three\n    stages:\n\n    1. **Baseline** – grows with the number of nodes and shrinks with\n       the average degree.\n    2. **Structural adjustments** – multiplicative or divisive factors\n       that capture the effect of clustering, assortativity,\n       degree heterogeneity, hub concentration, density, triangles,\n       transitivity and the raw edge count.\n    3. **Safety guards** – all divisions are protected against zero\n       denominators.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n`` (nodes), ``m`` (edges), ``density``,\n        ``avg_degree``, ``max_degree``, ``min_degree``,\n        ``std_degree``, ``avg_clustering``, ``transitivity``,\n        ``degree_assortativity``, ``num_triangles``, ``degrees``.\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # --- Basic attributes ----------------------------------------------\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 1\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n\n    # --- 1. Baseline ----------------------------------------------------\n    # Larger graphs with lower average degree tend to have longer paths.\n    base = n / (avg_deg + 1)\n\n    # --- 2. Structural adjustments -------------------------------------\n    # Clustering and positive assortativity usually increase path lengths.\n    base *= (1 + clustering)\n    base *= (1 + abs(assort))\n\n    # Degree heterogeneity (high std) shortens paths – divide by it.\n    base /= (1 + std_deg)\n\n    # A high hub-to-leaf ratio shortens paths – divide by it.\n    hub_ratio = max_deg / (min_deg + 1)\n    base /= (1 + hub_ratio)\n\n    # Denser graphs have shorter paths – multiply by a bounded factor.\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio (local cohesion) shortens paths – divide by it.\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + 2 * tri_ratio)\n\n    # Global transitivity also shortens paths – multiply by it.\n    base *= (1 + trans)\n\n    # Raw edge count: more edges reduce path lengths – include it.\n    max_edges = max(1, n * (n - 1) // 2)\n    edge_factor = m / max_edges\n    base *= (1 + edge_factor)\n\n    # --- 3. Return ------------------------------------------------------\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a compact set of\n    pre‑computed graph statistics.  The estimate is built in three\n    stages:\n\n    1. **Baseline** – grows with the number of nodes and shrinks with\n       the average degree.\n    2. **Structural adjustments** – multiplicative or divisive factors\n       that capture the effect of clustering, assortativity,\n       degree heterogeneity, hub concentration, density, triangles,\n       transitivity and the raw edge count.\n    3. **Safety guards** – all divisions are protected against zero\n       denominators.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n`` (nodes), ``m`` (edges), ``density``,\n        ``avg_degree``, ``max_degree``, ``min_degree``,\n        ``std_degree``, ``avg_clustering``, ``transitivity``,\n        ``degree_assortativity``, ``num_triangles``, ``degrees``.\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # --- Basic attributes ----------------------------------------------\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 1\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n\n    # --- 1. Baseline ----------------------------------------------------\n    # Larger graphs with lower average degree tend to have longer paths.\n    base = n / (avg_deg + 1)\n\n    # --- 2. Structural adjustments -------------------------------------\n    # Clustering and positive assortativity usually increase path lengths.\n    base *= (1 + clustering)\n    base *= (1 + abs(assort))\n\n    # Degree heterogeneity (high std) shortens paths – divide by it.\n    base /= (1 + std_deg)\n\n    # A high hub-to-leaf ratio shortens paths – divide by it.\n    hub_ratio = max_deg / (min_deg + 1)\n    base /= (1 + hub_ratio)\n\n    # Denser graphs have shorter paths – multiply by a bounded factor.\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # Triangle ratio (local cohesion) shortens paths – divide by it.\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + 2 * tri_ratio)\n\n    # Global transitivity also shortens paths – multiply by it.\n    base *= (1 + trans)\n\n    # Raw edge count: more edges reduce path lengths – include it.\n    max_edges = max(1, n * (n - 1) // 2)\n    edge_factor = m / max_edges\n    base *= (1 + edge_factor)\n\n    # --- 3. Return ------------------------------------------------------\n    return base", "spearman": 0.7276291907297683, "pearson": 0.5325317052782492, "rmse": 1.88440939462623, "mae": 1.7022135086328822}}
{"timestamp": "2026-02-16T09:51:26.830720+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i3_p0_416044695", "generation": 11, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8336614645858343, "fitness_mode": "correlation", "simplicity_score": 0.19771284545334272, "novelty_bonus": 0.19810170706694497, "total_score": 0.5505098696304626, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.102923\nbelow_train_threshold: train_signal=0.065834\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from global graph statistics.\n    The expression combines several structural descriptors in a way that\n    is consistent, numerically stable and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics.  Keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        An approximation of the graph's average shortest path length.\n    \"\"\"\n    # Basic terms\n    base = s['n'] ** 0.7 / (s['avg_degree'] + 1.0)\n\n    # Clustering encourages detours – increase the estimate\n    clust_factor = 1.0 + s['avg_clustering'] ** 0.5\n\n    # Positive assortativity usually lengthens paths\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Heterogeneous degrees (large std) shortens paths – divide by it\n    deg_variance_factor = 1.0 / (1.0 + s['std_degree'])\n\n    # Denser graphs have shorter paths – dampen the base\n    density_factor = max(0.05, 1.0 - s['density'])\n\n    # Triangles provide local shortcuts – reduce the estimate\n    n = float(s['n'])\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div‑by‑zero\n    tri_ratio = s['num_triangles'] / possible_tri\n    triangle_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    trans_factor = 1.0 + s['transitivity']\n\n    # Assemble the invariant\n    result = (base * clust_factor * assort_factor *\n              deg_variance_factor * density_factor *\n              triangle_factor * trans_factor)\n\n    return result\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from global graph statistics.\n    The expression combines several structural descriptors in a way that\n    is consistent, numerically stable and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics.  Keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        An approximation of the graph's average shortest path length.\n    \"\"\"\n    # Basic terms\n    base = s['n'] ** 0.7 / (s['avg_degree'] + 1.0)\n\n    # Clustering encourages detours – increase the estimate\n    clust_factor = 1.0 + s['avg_clustering'] ** 0.5\n\n    # Positive assortativity usually lengthens paths\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Heterogeneous degrees (large std) shortens paths – divide by it\n    deg_variance_factor = 1.0 / (1.0 + s['std_degree'])\n\n    # Denser graphs have shorter paths – dampen the base\n    density_factor = max(0.05, 1.0 - s['density'])\n\n    # Triangles provide local shortcuts – reduce the estimate\n    n = float(s['n'])\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div‑by‑zero\n    tri_ratio = s['num_triangles'] / possible_tri\n    triangle_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    trans_factor = 1.0 + s['transitivity']\n\n    # Assemble the invariant\n    result = (base * clust_factor * assort_factor *\n              deg_variance_factor * density_factor *\n              triangle_factor * trans_factor)\n\n    return result", "spearman": 0.903073576839421, "pearson": 0.8411934189221419, "rmse": 1.3504585188060654, "mae": 1.2659297459795864}}
{"timestamp": "2026-02-16T09:52:08.745890+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:52:08.747970+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:52:40.454765+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 3, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:52:40.455362+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 3, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:53:20.487683+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.133244", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:53:20.488261+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.133244", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:53:55.259834+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i3_p2_320849211", "generation": 11, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6717406962785114, "fitness_mode": "correlation", "simplicity_score": 0.2186504429337532, "novelty_bonus": 0.18078168744563727, "total_score": 0.46167343754150997, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.102923\nbelow_train_threshold: train_signal=0.065834\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.133244\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    num_tri = float(s['num_triangles'])\n    density = float(s['density'])\n    degrees = s['degrees']\n\n    base = n / (avg_deg + 1.0)\n    base *= (1.0 + clust) ** 0.5\n    base *= (1.0 + abs(assort))\n    base /= (1.0 + std_deg)\n\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    base *= (1.0 + trans)\n\n    harmonic_sum = sum(1.0 / float(d) for d in degrees if d > 0)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n    base /= harmonic_mean\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a compact mix of\n    global graph statistics.  The formula blends:\n        * graph size and mean degree (baseline length)\n        * degree heterogeneity via the Gini coefficient\n        * clustering, transitivity, and triangle prevalence (short‑cut effects)\n        * harmonic‑mean degree (captures low‑degree bottlenecks)\n\n    No external libraries or shortest‑path algorithms are used.\n    \"\"\"\n    # Basic scalars\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # sorted list of degrees\n\n    # ------------------------------------------------------------------\n    # 1. Baseline – larger graphs or smaller average degree -> longer paths\n    base = (n ** 0.6) * (1.0 + std_deg) / (avg_deg + 1.0)\n\n    # 2. Positive assortativity tends to elongate routes\n    base *= (1.0 + abs(assort))\n\n    # 3. High clustering and transitivity create detours → multiply\n    base *= (1.0 + avg_clust) ** 0.5\n    base *= (1.0 + trans) ** 0.5\n\n    # 4. Degree heterogeneity (Gini) shortens paths in the presence of hubs\n    total_deg = sum(float(d) for d in degrees if d > 0)\n    if n > 1 and total_deg > 0:\n        # Gini coefficient: 1 - sum((2*i - n - 1) * x_i) / (n * sum x_i)\n        gini_sum = 0.0\n        for i, d in enumerate(degrees, start=1):\n            gini_sum += (2.0 * i - n - 1.0) * float(d)\n        gini = 1.0 - gini_sum / (n * total_deg)\n        base *= (1.0 + gini)   # larger Gini → shorter paths\n    else:\n        base *= 1.0            # no effect if degrees empty\n\n    # 5. Triangle shortcut effect – more triangles → shorter paths\n    possible_tri = max(1.0, n * (n - 1.0) * (n - 2.0) / 6.0)\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 6. Density penalty – sparse graphs tend to have longer routes\n    dens_factor = max(0.05, 1.0 - density)   # ensures at least a small factor\n    base *= dens_factor\n\n    # 7. Harmonic mean of degrees – low‑degree nodes increase path lengths\n    harmonic_sum = sum(1.0 / float(d) for d in degrees if d > 0)\n    if harmonic_sum > 0:\n        harmonic_mean = n / harmonic_sum\n        base /= harmonic_mean\n    else:\n        base /= 1.0  # no effect if no positive degrees\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a compact mix of\n    global graph statistics.  The formula blends:\n        * graph size and mean degree (baseline length)\n        * degree heterogeneity via the Gini coefficient\n        * clustering, transitivity, and triangle prevalence (short‑cut effects)\n        * harmonic‑mean degree (captures low‑degree bottlenecks)\n\n    No external libraries or shortest‑path algorithms are used.\n    \"\"\"\n    # Basic scalars\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # sorted list of degrees\n\n    # ------------------------------------------------------------------\n    # 1. Baseline – larger graphs or smaller average degree -> longer paths\n    base = (n ** 0.6) * (1.0 + std_deg) / (avg_deg + 1.0)\n\n    # 2. Positive assortativity tends to elongate routes\n    base *= (1.0 + abs(assort))\n\n    # 3. High clustering and transitivity create detours → multiply\n    base *= (1.0 + avg_clust) ** 0.5\n    base *= (1.0 + trans) ** 0.5\n\n    # 4. Degree heterogeneity (Gini) shortens paths in the presence of hubs\n    total_deg = sum(float(d) for d in degrees if d > 0)\n    if n > 1 and total_deg > 0:\n        # Gini coefficient: 1 - sum((2*i - n - 1) * x_i) / (n * sum x_i)\n        gini_sum = 0.0\n        for i, d in enumerate(degrees, start=1):\n            gini_sum += (2.0 * i - n - 1.0) * float(d)\n        gini = 1.0 - gini_sum / (n * total_deg)\n        base *= (1.0 + gini)   # larger Gini → shorter paths\n    else:\n        base *= 1.0            # no effect if degrees empty\n\n    # 5. Triangle shortcut effect – more triangles → shorter paths\n    possible_tri = max(1.0, n * (n - 1.0) * (n - 2.0) / 6.0)\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 6. Density penalty – sparse graphs tend to have longer routes\n    dens_factor = max(0.05, 1.0 - density)   # ensures at least a small factor\n    base *= dens_factor\n\n    # 7. Harmonic mean of degrees – low‑degree nodes increase path lengths\n    harmonic_sum = sum(1.0 / float(d) for d in degrees if d > 0)\n    if harmonic_sum > 0:\n        harmonic_mean = n / harmonic_sum\n        base /= harmonic_mean\n    else:\n        base /= 1.0  # no effect if no positive degrees\n\n    return base", "spearman": 0.7274176854421363, "pearson": 0.49618877665834527, "rmse": 4.201998819548039, "mae": 1.9480817098923213}}
{"timestamp": "2026-02-16T09:53:55.260652+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 3, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:54:36.743533+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.148275", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:54:36.744020+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.148275", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:55:33.207739+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 3, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.144000", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:55:33.208843+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 3, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:56:20.502330+00:00", "event_type": "candidate_rejected", "payload": {"generation": 11, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:56:20.503542+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 11, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:56:52.120889+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g11_i3_p4_993491220", "generation": 11, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.3759423769507803, "fitness_mode": "correlation", "simplicity_score": 0.15829933769759405, "novelty_bonus": 0.4577194859378516, "total_score": 0.4316277796225319, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.133244\nbelow_novelty_threshold: novelty_bonus=0.148275\nbelow_novelty_threshold: novelty_bonus=0.144000\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    A compact invariant that estimates the average shortest‑path length\n    from a handful of global graph statistics.\n\n    The construction blends several structural aspects:\n    • a size term (n^0.4) that grows sub‑linearly with the number of nodes,\n    • a degree‑skew factor obtained from the ratio of the mean degree to\n      its harmonic mean (captures the presence of hubs),\n    • exponential amplification of the joint effect of average clustering\n      and transitivity,\n    • a square‑root lift for assortativity,\n    • a square‑root penalisation of sparsity (1‑density) and of the\n      triangle‑ratio,\n    • a mild normalisation by the square‑root of the degree standard\n      deviation.\n\n    All arithmetic is safe from division‑by‑zero; the returned value is\n    bounded below by 0.1 to avoid spurious negatives.\n    \"\"\"\n    import math\n\n    n                = float(s['n'])\n    density          = float(s['density'])\n    avg_deg          = float(s['avg_degree'])\n    std_deg          = float(s['std_degree'])\n    avg_clust        = float(s['avg_clustering'])\n    transitivity     = float(s['transitivity'])\n    assortativity    = float(s['degree_assortativity'])\n    num_triangles    = float(s['num_triangles'])\n    degrees          = s['degrees']          # list of ints\n\n    # ---------- harmonic mean of degrees ----------\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)\n\n    # ---------- skew factor (mean / harmonic mean) ----------\n    skew_factor = avg_deg / (harmonic_mean + 1e-6)\n\n    # ---------- base term (sub‑linear growth with n) ----------\n    base = math.pow(n, 0.4) / (skew_factor + 1.0)\n\n    # ---------- exponential boost from clustering + transitivity ----------\n    exp_factor = math.exp(avg_clust * transitivity * 0.3)\n    base *= exp_factor\n\n    # ---------- assortativity lift ----------\n    base *= math.sqrt(1.0 + abs(assortativity))\n\n    # ---------- sparsity penalty (square‑root of (1 - density)) ----------\n    base *= math.sqrt(max(0.0, 1.0 - density))\n\n    # ---------- triangle shortcut penalty ----------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    tri_ratio = num_triangles / max(1.0, possible_tri)\n    base *= math.sqrt(max(0.0, 1.0 - tri_ratio))\n\n    # ---------- normalise by degree dispersion ----------\n    base /= (1.0 + math.sqrt(std_deg))\n\n    # ---------- guard against very small values ----------\n    return max(0.1, base)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The formula is fully expressed with\n    Python built‑in arithmetic operations; no external modules are\n    imported and no graph algorithm is executed.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    # Constant for exponential calculations\n    _E = 2.718281828459045\n\n    n               = float(s['n'])\n    density         = float(s['density'])\n    avg_deg         = float(s['avg_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_tri         = float(s['num_triangles'])\n    degrees         = s['degrees']          # list of ints\n\n    # Harmonic mean of degrees\n    hsum = 0.0\n    for d in degrees:\n        if d > 0:\n            hsum += 1.0 / float(d)\n    harmonic_mean = n / (hsum + 1e-12)\n\n    # Skew factor (captures hubiness)\n    skew = avg_deg / (harmonic_mean + 1e-6)\n\n    # Base term: sub‑linear growth with size, tempered by skew\n    base = pow(n, 0.4) / (skew + 1.0)\n\n    # Exponential boost from joint clustering‑transitivity\n    base *= pow(_E, avg_clust * trans * 0.3)\n\n    # Assortativity lift (sqrt of 1+|assort|)\n    base *= pow(1.0 + abs(assort), 0.5)\n\n    # Penalty for sparsity: sqrt(1‑density)\n    base *= pow(max(0.0, 1.0 - density), 0.5)\n\n    # Triangle shortcut penalty: sqrt(1‑triangle_ratio)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    tri_ratio = num_tri / max(1.0, possible_tri)\n    base *= pow(max(0.0, 1.0 - tri_ratio), 0.5)\n\n    # Normalise by degree dispersion (1+sqrt(std_deg))\n    base /= (1.0 + pow(std_deg, 0.5))\n\n    # Guard against extremely small values\n    return max(0.1, base)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The formula is fully expressed with\n    Python built‑in arithmetic operations; no external modules are\n    imported and no graph algorithm is executed.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    # Constant for exponential calculations\n    _E = 2.718281828459045\n\n    n               = float(s['n'])\n    density         = float(s['density'])\n    avg_deg         = float(s['avg_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_tri         = float(s['num_triangles'])\n    degrees         = s['degrees']          # list of ints\n\n    # Harmonic mean of degrees\n    hsum = 0.0\n    for d in degrees:\n        if d > 0:\n            hsum += 1.0 / float(d)\n    harmonic_mean = n / (hsum + 1e-12)\n\n    # Skew factor (captures hubiness)\n    skew = avg_deg / (harmonic_mean + 1e-6)\n\n    # Base term: sub‑linear growth with size, tempered by skew\n    base = pow(n, 0.4) / (skew + 1.0)\n\n    # Exponential boost from joint clustering‑transitivity\n    base *= pow(_E, avg_clust * trans * 0.3)\n\n    # Assortativity lift (sqrt of 1+|assort|)\n    base *= pow(1.0 + abs(assort), 0.5)\n\n    # Penalty for sparsity: sqrt(1‑density)\n    base *= pow(max(0.0, 1.0 - density), 0.5)\n\n    # Triangle shortcut penalty: sqrt(1‑triangle_ratio)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    tri_ratio = num_tri / max(1.0, possible_tri)\n    base *= pow(max(0.0, 1.0 - tri_ratio), 0.5)\n\n    # Normalise by degree dispersion (1+sqrt(std_deg))\n    base /= (1.0 + pow(std_deg, 0.5))\n\n    # Guard against extremely small values\n    return max(0.1, base)", "spearman": 0.5253041326033152, "pearson": 0.44964332210588975, "rmse": 1.966767269253011, "mae": 1.7513090091206658}}
{"timestamp": "2026-02-16T09:56:52.121365+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 11, "island_id": 3, "population_idx": 4, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:56:52.124701+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 12, "model_name": "gpt-oss:20b", "best_val_score": 0.5635337547010782, "no_improve_count": 1}}
{"timestamp": "2026-02-16T09:57:35.218622+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i0_p0_668385800", "generation": 12, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5044417767106842, "fitness_mode": "correlation", "simplicity_score": 0.12258652715897767, "novelty_bonus": 0.2412013955605099, "total_score": 0.34034656082086656, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.098170\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.5)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.5)          # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort) * 0.5              # assortative → longer paths\n    hetero_adj    = 1 - pow(std_deg / (avg_deg + eps), 1.2)   # heterogeneity → shorter paths\n    hub_adj       = 1 - pow(max_deg / (n - 1 + eps), 1.2)     # presence of hubs → shorter paths\n    triangle_adj  = 1 - pow(num_tri / (n * (n - 1) / 2 + eps), 1.2)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.5)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.5)          # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort) * 0.5              # assortative → longer paths\n    hetero_adj    = 1 - pow(std_deg / (avg_deg + eps), 1.2)   # heterogeneity → shorter paths\n    hub_adj       = 1 - pow(max_deg / (n - 1 + eps), 1.2)     # presence of hubs → shorter paths\n    triangle_adj  = 1 - pow(num_tri / (n * (n - 1) / 2 + eps), 1.2)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.48693767344183614, "pearson": 0.37422248812201886, "rmse": 1.9943177745738492, "mae": 1.7433651127772865}}
{"timestamp": "2026-02-16T09:57:56.907931+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i0_p1_871493473", "generation": 12, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.544297719087635, "fitness_mode": "correlation", "simplicity_score": 0.12242494699568865, "novelty_bonus": 0.22169833554208662, "total_score": 0.37020472031752016, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.098170\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    density = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    max_deg = float(s['max_degree'])\n    num_tri = float(s['num_triangles'])\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) ** 2          # sparser → longer paths\n    clustering_adj = 1 - clustering ** 2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)                # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)    # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    density = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    max_deg = float(s['max_degree'])\n    num_tri = float(s['num_triangles'])\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) ** 2          # sparser → longer paths\n    clustering_adj = 1 - clustering ** 2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)                # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)    # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.5584204605115128, "pearson": 0.46609151447724606, "rmse": 2.0219886270648404, "mae": 1.813566092812708}}
{"timestamp": "2026-02-16T09:58:19.758989+00:00", "event_type": "candidate_rejected", "payload": {"generation": 12, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:58:19.759998+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 12, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:58:43.107105+00:00", "event_type": "candidate_rejected", "payload": {"generation": 12, "island_id": 0, "population_idx": 2, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:58:43.108730+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 12, "island_id": 0, "population_idx": 2, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:59:23.119514+00:00", "event_type": "candidate_rejected", "payload": {"generation": 12, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:59:23.120502+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 12, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T09:59:58.568880+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i0_p3_316796559", "generation": 12, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.544297719087635, "fitness_mode": "correlation", "simplicity_score": 0.1223456665943444, "novelty_bonus": 0.22169833554208662, "total_score": 0.3701888642372513, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.098170\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: code must define exactly one function named `new_invariant`\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    density = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    max_deg = float(s['max_degree'])\n    num_tri = float(s['num_triangles'])\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 2)          # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)                  # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)    # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)      # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    def clamp(x):\n        if x < 0.1:\n            return 0.1\n        if x > 10:\n            return 10\n        return x\n\n    density_adj   = clamp(density_adj)\n    clustering_adj = clamp(clustering_adj)\n    assort_adj    = clamp(assort_adj)\n    hetero_adj    = clamp(hetero_adj)\n    hub_adj       = clamp(hub_adj)\n    triangle_adj  = clamp(triangle_adj)\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    density = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    max_deg = float(s['max_degree'])\n    num_tri = float(s['num_triangles'])\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 2)          # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)                  # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)    # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)      # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    density = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    max_deg = float(s['max_degree'])\n    num_tri = float(s['num_triangles'])\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 2)          # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)                  # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)    # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)      # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.5584204605115128, "pearson": 0.46609151447724606, "rmse": 2.0219886270648404, "mae": 1.813566092812708}}
{"timestamp": "2026-02-16T09:59:58.570162+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 12, "island_id": 0, "population_idx": 3, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:01:28.240024+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i0_p4_358093391", "generation": 12, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.544297719087635, "fitness_mode": "correlation", "simplicity_score": 0.12300920756803593, "novelty_bonus": 0.22169833554208662, "total_score": 0.3703215724319896, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.098170\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 2)          # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)                  # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)    # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)      # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 2)          # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)                  # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)    # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)      # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.5584204605115128, "pearson": 0.46609151447724606, "rmse": 2.0219886270648404, "mae": 1.813566092812708}}
{"timestamp": "2026-02-16T10:02:07.227159+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i1_p0_297878181", "generation": 12, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14988041412197797, "novelty_bonus": 0.2098132453311331, "total_score": 0.2889532072525063, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T10:02:44.575840+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i1_p1_723788830", "generation": 12, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14941561423430663, "novelty_bonus": 0.2098132453311331, "total_score": 0.28886024727497195, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph statistics\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    std_deg    = s['std_degree']\n    max_deg    = s['max_degree']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combined adjustment factor\n    adj_factor = (density_adj * clustering_adj * assort_adj *\n                  hetero_adj * hub_adj * triangle_adj)\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Numerator: baseline with adjustments plus extra structural terms\n    numerator = baseline * adj_factor + norm_sq + extra_term\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph statistics\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    std_deg    = s['std_degree']\n    max_deg    = s['max_degree']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combined adjustment factor\n    adj_factor = (density_adj * clustering_adj * assort_adj *\n                  hetero_adj * hub_adj * triangle_adj)\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Numerator: baseline with adjustments plus extra structural terms\n    numerator = baseline * adj_factor + norm_sq + extra_term\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T10:03:22.626076+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i1_p2_792785001", "generation": 12, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14953717349512105, "novelty_bonus": 0.2098132453311331, "total_score": 0.28888455912713484, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = (n ** 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = (n ** 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T10:04:03.564227+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i1_p3_750190150", "generation": 12, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14953717349512105, "novelty_bonus": 0.2098132453311331, "total_score": 0.28888455912713484, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T10:04:43.873298+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i1_p4_749510831", "generation": 12, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14934727325649777, "novelty_bonus": 0.2098132453311331, "total_score": 0.28884657907941025, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    n = s['n']\n    m = s['m']\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1\n        + m\n        + s['density']\n        + s['num_triangles']\n        + abs(s['degree_assortativity'])\n        + s['std_degree']\n    )\n\n    # Combine features into a single dimensionless quantity\n    numerator = (\n        (n ** 0.5)\n        * s['avg_degree']\n        * (1 + s['avg_clustering'])\n        * (1 + s['transitivity'])\n        + norm_sq\n    )\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    # Small epsilon to avoid division by zero\n    eps = 1e-12\n\n    # Basic graph attributes\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combined adjusted baseline\n    adjusted = (baseline *\n                density_adj *\n                clustering_adj *\n                assort_adj *\n                hetero_adj *\n                hub_adj *\n                triangle_adj)\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity together\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Numerator combines all components\n    numerator = adjusted + norm_sq + extra_term\n\n    # Denominator that keeps the invariant bounded\n    denom = (1 + m + density + num_tri + abs(assort) + std_deg)\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    # Small epsilon to avoid division by zero\n    eps = 1e-12\n\n    # Basic graph attributes\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combined adjusted baseline\n    adjusted = (baseline *\n                density_adj *\n                clustering_adj *\n                assort_adj *\n                hetero_adj *\n                hub_adj *\n                triangle_adj)\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity together\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Numerator combines all components\n    numerator = adjusted + norm_sq + extra_term\n\n    # Denominator that keeps the invariant bounded\n    denom = (1 + m + density + num_tri + abs(assort) + std_deg)\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T10:05:44.424406+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i2_p0_580063942", "generation": 12, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8946458583433373, "fitness_mode": "correlation", "simplicity_score": 0.21999977568039208, "novelty_bonus": 0.16697410473657626, "total_score": 0.5655869739267355, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    refined by a series of multiplicative and divisive adjustments\n    that capture the effects of clustering, assortativity, degree\n    heterogeneity, density, triangles, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact approximation of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + 2 * triangle_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.095242\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.9429895747393685, "pearson": 0.8632108460038201, "rmse": 4.972345233705198, "mae": 2.980742759578851}}
{"timestamp": "2026-02-16T10:06:32.121502+00:00", "event_type": "candidate_rejected", "payload": {"generation": 12, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.116683", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:06:32.122121+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 12, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.116683", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:07:03.872319+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i2_p1_731890368", "generation": 12, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8866746698679471, "fitness_mode": "correlation", "simplicity_score": 0.21995052817975927, "novelty_bonus": 0.1526890421313163, "total_score": 0.5593123061625439, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    refined by a series of multiplicative and divisive adjustments\n    that capture the effects of clustering, assortativity, degree\n    heterogeneity, density, triangles, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact approximation of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + 2 * triangle_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.095242\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.116683\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a compact set of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n, m, density\n        - avg_degree, max_degree, min_degree, std_degree\n        - avg_clustering, transitivity, degree_assortativity\n        - num_triangles\n        - degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – moderate effect\n    base *= (1 + clustering**0.5)\n\n    # 3. Positive assortativity usually lengthens paths – moderate effect\n    base *= (1 + abs(assort)**0.5)\n\n    # 4. Degree heterogeneity (high std) shortens paths – moderate effect\n    base /= (1 + std_deg**0.5)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths – moderate effect\n    base *= (1 + 1 / (min_deg**0.5))\n\n    # 6. Very large maximum degree (hubs) shortens paths – moderate effect\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion – moderate effect\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + (tri_ratio * 2)**0.5)\n\n    # 9. Global transitivity further shortens paths – moderate effect\n    base *= (1 + trans**0.5)\n\n    # 10. Optional variance term from degree list – keeps formula compact\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + (variance / (avg_deg * avg_deg + 1))**0.5)\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a compact set of\n    pre‑computed graph statistics.  The formula starts from a simple\n    baseline that grows with the number of nodes and shrinks with the\n    average degree, and is then refined by multiplicative and\n    divisive adjustments that capture the effects of clustering,\n    assortativity, degree heterogeneity, density, triangles,\n    transitivity, and degree variance.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering increases detours → multiply\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity tends to lengthen paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Small minimum degree (leaves) lengthens paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom))\n\n    # 7. Denser graphs have shorter paths – bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion – more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Add a small adjustment for degree variance from the degree list\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base += 0.05 * variance / (avg_deg * avg_deg + 1)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a compact set of\n    pre‑computed graph statistics.  The formula starts from a simple\n    baseline that grows with the number of nodes and shrinks with the\n    average degree, and is then refined by multiplicative and\n    divisive adjustments that capture the effects of clustering,\n    assortativity, degree heterogeneity, density, triangles,\n    transitivity, and degree variance.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering increases detours → multiply\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity tends to lengthen paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Small minimum degree (leaves) lengthens paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom))\n\n    # 7. Denser graphs have shorter paths – bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion – more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Add a small adjustment for degree variance from the degree list\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base += 0.05 * variance / (avg_deg * avg_deg + 1)\n\n    return base", "spearman": 0.9390309757743944, "pearson": 0.9163035398753151, "rmse": 5.692107989719803, "mae": 3.5756232090498217}}
{"timestamp": "2026-02-16T10:07:03.873161+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 12, "island_id": 2, "population_idx": 1, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:07:43.467755+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i2_p2_123221393", "generation": 12, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8764945978391356, "fitness_mode": "correlation", "simplicity_score": 0.22178457158834725, "novelty_bonus": 0.17855522001812207, "total_score": 0.5605785466997655, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    refined by a series of multiplicative and divisive adjustments\n    that capture the effects of clustering, assortativity, degree\n    heterogeneity, density, triangles, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact approximation of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + 2 * triangle_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.116683\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a compact\n    combination of basic graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted degree list).\n\n    Returns\n    -------\n    float\n        A scalar estimate of the average shortest path length.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: larger graphs with lower average degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + 1.5 * tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a compact\n    combination of basic graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted degree list).\n\n    Returns\n    -------\n    float\n        A scalar estimate of the average shortest path length.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: larger graphs with lower average degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + 1.5 * tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base", "spearman": 0.9253101327533189, "pearson": 0.8620893362600847, "rmse": 3.3241926236597434, "mae": 2.0014423718900334}}
{"timestamp": "2026-02-16T10:08:28.744955+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i2_p3_122802177", "generation": 12, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8746698679471788, "fitness_mode": "correlation", "simplicity_score": 0.22211866077003525, "novelty_bonus": 0.18040948678747581, "total_score": 0.560777133954144, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    refined by a series of multiplicative and divisive adjustments\n    that capture the effects of clustering, assortativity, degree\n    heterogeneity, density, triangles, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact approximation of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + 2 * triangle_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.116683\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a compact set of\n    pre‑computed graph statistics.  The estimate is built on a simple\n    baseline that grows with the number of nodes and shrinks with the\n    average degree, then progressively adjusted for clustering,\n    assortativity, degree heterogeneity, density, triangles, and\n    transitivity.  All operations use only built‑in functions.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + 2 * triangle_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a compact set of\n    pre‑computed graph statistics.  The estimate is built on a simple\n    baseline that grows with the number of nodes and shrinks with the\n    average degree, then progressively adjusted for clustering,\n    assortativity, degree heterogeneity, density, triangles, and\n    transitivity.  All operations use only built‑in functions.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + 2 * triangle_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base", "spearman": 0.9244611115277883, "pearson": 0.8615847913951106, "rmse": 3.3195939922919036, "mae": 1.9984365461242317}}
{"timestamp": "2026-02-16T10:08:54.839599+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i2_p4_774644060", "generation": 12, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8746698679471788, "fitness_mode": "correlation", "simplicity_score": 0.22211866077003525, "novelty_bonus": 0.18040948678747581, "total_score": 0.560777133954144, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    refined by a series of multiplicative and divisive adjustments\n    that capture the effects of clustering, assortativity, degree\n    heterogeneity, density, triangles, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact approximation of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + 2 * triangle_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.116683\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    multiplicative and divisive adjustments capture the effects of\n    clustering, assortativity, degree heterogeneity, density,\n    triangles, transitivity, and the presence of leaves and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        An invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 1. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 2. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 3. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 4. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 5. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 6. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 7. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + 2 * triangle_ratio)\n\n    # 8. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    multiplicative and divisive adjustments capture the effects of\n    clustering, assortativity, degree heterogeneity, density,\n    triangles, transitivity, and the presence of leaves and hubs.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        An invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 1. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 2. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 3. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 4. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 5. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 6. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 7. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + 2 * triangle_ratio)\n\n    # 8. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base", "spearman": 0.9244611115277883, "pearson": 0.8615847913951106, "rmse": 3.3195939922919036, "mae": 1.9984365461242317}}
{"timestamp": "2026-02-16T10:09:35.542061+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i3_p0_967218597", "generation": 12, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8373109243697479, "fitness_mode": "correlation", "simplicity_score": 0.1958389408842495, "novelty_bonus": 0.20040381990466183, "total_score": 0.5564591134027299, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from global graph statistics.\n    The expression combines several structural descriptors in a way that\n    is consistent, numerically stable and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics.  Keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        An approximation of the graph's average shortest path length.\n    \"\"\"\n    # Basic terms\n    base = s['n'] ** 0.7 / (s['avg_degree'] + 1.0)\n\n    # Clustering encourages detours – increase the estimate\n    clust_factor = 1.0 + s['avg_clustering'] ** 0.5\n\n    # Positive assortativity usually lengthens paths\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Heterogeneous degrees (large std) shortens paths – divide by it\n    deg_variance_factor = 1.0 / (1.0 + s['std_degree'])\n\n    # Denser graphs have shorter paths – dampen the base\n    density_factor = max(0.05, 1.0 - s['density'])\n\n    # Triangles provide local shortcuts – reduce the estimate\n    n = float(s['n'])\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div‑by‑zero\n    tri_ratio = s['num_triangles'] / possible_tri\n    triangle_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    trans_factor = 1.0 + s['transitivity']\n\n    # Assemble the invariant\n    result = (base * clust_factor * assort_factor *\n              deg_variance_factor * density_factor *\n              triangle_factor * trans_factor)\n\n    return result\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.148275\nbelow_novelty_threshold: novelty_bonus=0.144000\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph statistics.\n    The expression is a hand‑crafted combination of terms that encode\n    known influences on path length:\n\n    * Size versus connectivity (n / (avg_degree + 1))\n    * Clustering and assortativity act as “detour” factors (multiplicative\n      adjustments > 1)\n    * Degree heterogeneity (high std > 0) shortens paths (division)\n    * Graph density and global transitivity reduce the estimate\n    * The presence of triangles is treated as local shortcuts\n      (division by a factor that grows with the triangle density)\n\n    The function is intentionally written without external imports, using\n    only built‑in arithmetic functions so it can be executed on any\n    compliant Python environment.\n    \"\"\"\n\n    # Cast to float for safety and avoid accidental integer division\n    n            = float(s['n'])\n    avg_deg      = float(s['avg_degree'])\n    std_deg      = float(s['std_degree'])\n    clust        = float(s['avg_clustering'])\n    trans        = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    tri          = float(s['num_triangles'])\n    density      = float(s['density'])\n\n    # --------------------------------------------------------------------\n    # 1. Baseline: larger networks or smaller average degree → longer paths\n    # --------------------------------------------------------------------\n    baseline = n / (avg_deg + 1.0)\n\n    # --------------------------------------------------------------------\n    # 2. Detour multipliers – clustering & assortativity increase typical\n    #    path length by creating more local “dead‑ends” or tightly\n    #    clustered sub‑structures.\n    # --------------------------------------------------------------------\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n\n    # --------------------------------------------------------------------\n    # 3. Degree heterogeneity – a few hubs (large std) create shortcuts\n    #    that lower the average path length.\n    # --------------------------------------------------------------------\n    hetero = 1.0 / (1.0 + std_deg)\n\n    # --------------------------------------------------------------------\n    # 4. Graph density – denser connectivity shortens paths\n    # --------------------------------------------------------------------\n    dens_factor = max(0.05, 1.0 - density)    # keep factor in (0,1]\n\n    # --------------------------------------------------------------------\n    # 5. Triangle‑based shortcut factor – triangles are local shortcuts\n    # --------------------------------------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)      # avoid division by zero\n    tri_ratio    = tri / possible_tri\n    tri_factor   = 1.0 / (1.0 + tri_ratio)\n\n    # --------------------------------------------------------------------\n    # 6. Global transitivity – overall clustering across the network\n    #    further reduces the average path length.\n    # --------------------------------------------------------------------\n    trans_factor = 1.0 + trans\n\n    # --------------------------------------------------------------------\n    # Assemble the final invariant by combining all the factors.\n    # --------------------------------------------------------------------\n    result = baseline * detour * hetero * dens_factor * tri_factor * trans_factor\n\n    return result\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph statistics.\n    The expression is a hand‑crafted combination of terms that encode\n    known influences on path length:\n\n    * Size versus connectivity (n / (avg_degree + 1))\n    * Clustering and assortativity act as “detour” factors (multiplicative\n      adjustments > 1)\n    * Degree heterogeneity (high std > 0) shortens paths (division)\n    * Graph density and global transitivity reduce the estimate\n    * The presence of triangles is treated as local shortcuts\n      (division by a factor that grows with the triangle density)\n\n    The function is intentionally written without external imports, using\n    only built‑in arithmetic functions so it can be executed on any\n    compliant Python environment.\n    \"\"\"\n\n    # Cast to float for safety and avoid accidental integer division\n    n            = float(s['n'])\n    avg_deg      = float(s['avg_degree'])\n    std_deg      = float(s['std_degree'])\n    clust        = float(s['avg_clustering'])\n    trans        = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    tri          = float(s['num_triangles'])\n    density      = float(s['density'])\n\n    # --------------------------------------------------------------------\n    # 1. Baseline: larger networks or smaller average degree → longer paths\n    # --------------------------------------------------------------------\n    baseline = n / (avg_deg + 1.0)\n\n    # --------------------------------------------------------------------\n    # 2. Detour multipliers – clustering & assortativity increase typical\n    #    path length by creating more local “dead‑ends” or tightly\n    #    clustered sub‑structures.\n    # --------------------------------------------------------------------\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n\n    # --------------------------------------------------------------------\n    # 3. Degree heterogeneity – a few hubs (large std) create shortcuts\n    #    that lower the average path length.\n    # --------------------------------------------------------------------\n    hetero = 1.0 / (1.0 + std_deg)\n\n    # --------------------------------------------------------------------\n    # 4. Graph density – denser connectivity shortens paths\n    # --------------------------------------------------------------------\n    dens_factor = max(0.05, 1.0 - density)    # keep factor in (0,1]\n\n    # --------------------------------------------------------------------\n    # 5. Triangle‑based shortcut factor – triangles are local shortcuts\n    # --------------------------------------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)      # avoid division by zero\n    tri_ratio    = tri / possible_tri\n    tri_factor   = 1.0 / (1.0 + tri_ratio)\n\n    # --------------------------------------------------------------------\n    # 6. Global transitivity – overall clustering across the network\n    #    further reduces the average path length.\n    # --------------------------------------------------------------------\n    trans_factor = 1.0 + trans\n\n    # --------------------------------------------------------------------\n    # Assemble the final invariant by combining all the factors.\n    # --------------------------------------------------------------------\n    result = baseline * detour * hetero * dens_factor * tri_factor * trans_factor\n\n    return result", "spearman": 0.9143403585089629, "pearson": 0.8271326217624315, "rmse": 3.359512705062122, "mae": 2.0994546103869034}}
{"timestamp": "2026-02-16T10:10:23.079553+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i3_p1_46245332", "generation": 12, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.3540456182472989, "fitness_mode": "correlation", "simplicity_score": 0.2223984364555807, "novelty_bonus": 0.3906861327650336, "total_score": 0.39783718091197107, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from global graph statistics.\n    The expression combines several structural descriptors in a way that\n    is consistent, numerically stable and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics.  Keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        An approximation of the graph's average shortest path length.\n    \"\"\"\n    # Basic terms\n    base = s['n'] ** 0.7 / (s['avg_degree'] + 1.0)\n\n    # Clustering encourages detours – increase the estimate\n    clust_factor = 1.0 + s['avg_clustering'] ** 0.5\n\n    # Positive assortativity usually lengthens paths\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Heterogeneous degrees (large std) shortens paths – divide by it\n    deg_variance_factor = 1.0 / (1.0 + s['std_degree'])\n\n    # Denser graphs have shorter paths – dampen the base\n    density_factor = max(0.05, 1.0 - s['density'])\n\n    # Triangles provide local shortcuts – reduce the estimate\n    n = float(s['n'])\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div‑by‑zero\n    tri_ratio = s['num_triangles'] / possible_tri\n    triangle_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    trans_factor = 1.0 + s['transitivity']\n\n    # Assemble the invariant\n    result = (base * clust_factor * assort_factor *\n              deg_variance_factor * density_factor *\n              triangle_factor * trans_factor)\n\n    return result\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.148275\nbelow_novelty_threshold: novelty_bonus=0.144000\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global\n    statistics provided in ``s``.  The formula is fully algebraic and\n    does not depend on any external libraries or graph traversal\n    algorithms.\n\n    The expression is a product of several terms that capture\n    complementary structural aspects:\n\n        1.  Basic growth with size and reduction with local\n            clustering and degree heterogeneity.\n        2.  Adjustment for degree variance and the spread between\n            maximum and minimum degrees.\n        3.  A penalty for strong positive assortativity (which tends\n            to elongate paths).\n        4.  Reduction factors for abundant triangles and high\n            global transitivity, both of which provide shortcut\n            opportunities.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following pre‑computed graph\n        features.  All values are treated as floating‑point numbers.\n\n            n                 : number of nodes\n            avg_degree        : average degree\n            std_degree        : standard deviation of degree\n            avg_clustering    : average local clustering coefficient\n            max_degree        : maximum degree\n            min_degree        : minimum degree\n            degree_assortativity : degree assortativity coefficient\n            num_triangles     : number of (non‑overlapping) triangles\n            density           : graph density\n            transitivity      : global transitivity (fraction of closed\n                                 triplets over all triplets)\n\n    Returns\n    -------\n    float\n        A heuristic estimate of the graph's average shortest‑path\n        length.  The result is dimensionless and comparable across\n        graphs of different sizes and densities.\n    \"\"\"\n\n    # ----- cast everything to float to guarantee real division -----\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    trans      = float(s['transitivity'])\n\n    # ---------- 1. Baseline that grows with size and decays with clustering ----------\n    base = n * (1.0 + clust) / (1.0 + std_deg)\n\n    # ---------- 2. Heterogeneity adjustment ----------\n    # When max and min degrees differ greatly (presence of hubs),\n    # paths tend to be shorter.  The following factor decreases\n    # the estimate as the spread grows.\n    spread = max_deg - min_deg\n    hetero_factor = 1.0 / (1.0 + spread / (max_deg + 1.0))\n    base *= hetero_factor\n\n    # ---------- 3. Assortativity adjustment ----------\n    # Positive assortativity (high‑degree nodes tend to connect to\n    # other high‑degree nodes) usually increases path length.\n    assort_factor = 1.0 + abs(assort)\n    base *= assort_factor\n\n    # ---------- 4. Triangles factor ----------\n    # More triangles provide local shortcuts that reduce overall path length.\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid division by zero\n    tri_ratio = tri / possible_tri\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n    base *= tri_factor\n\n    # ---------- 5. Transitivity factor ----------\n    # High global transitivity is another indicator of local clustering,\n    # which generally shortens paths.\n    trans_factor = 1.0 / (1.0 + trans)\n    base *= trans_factor\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global\n    statistics provided in ``s``.  The formula is fully algebraic and\n    does not depend on any external libraries or graph traversal\n    algorithms.\n\n    The expression is a product of several terms that capture\n    complementary structural aspects:\n\n        1.  Basic growth with size and reduction with local\n            clustering and degree heterogeneity.\n        2.  Adjustment for degree variance and the spread between\n            maximum and minimum degrees.\n        3.  A penalty for strong positive assortativity (which tends\n            to elongate paths).\n        4.  Reduction factors for abundant triangles and high\n            global transitivity, both of which provide shortcut\n            opportunities.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following pre‑computed graph\n        features.  All values are treated as floating‑point numbers.\n\n            n                 : number of nodes\n            avg_degree        : average degree\n            std_degree        : standard deviation of degree\n            avg_clustering    : average local clustering coefficient\n            max_degree        : maximum degree\n            min_degree        : minimum degree\n            degree_assortativity : degree assortativity coefficient\n            num_triangles     : number of (non‑overlapping) triangles\n            density           : graph density\n            transitivity      : global transitivity (fraction of closed\n                                 triplets over all triplets)\n\n    Returns\n    -------\n    float\n        A heuristic estimate of the graph's average shortest‑path\n        length.  The result is dimensionless and comparable across\n        graphs of different sizes and densities.\n    \"\"\"\n\n    # ----- cast everything to float to guarantee real division -----\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    trans      = float(s['transitivity'])\n\n    # ---------- 1. Baseline that grows with size and decays with clustering ----------\n    base = n * (1.0 + clust) / (1.0 + std_deg)\n\n    # ---------- 2. Heterogeneity adjustment ----------\n    # When max and min degrees differ greatly (presence of hubs),\n    # paths tend to be shorter.  The following factor decreases\n    # the estimate as the spread grows.\n    spread = max_deg - min_deg\n    hetero_factor = 1.0 / (1.0 + spread / (max_deg + 1.0))\n    base *= hetero_factor\n\n    # ---------- 3. Assortativity adjustment ----------\n    # Positive assortativity (high‑degree nodes tend to connect to\n    # other high‑degree nodes) usually increases path length.\n    assort_factor = 1.0 + abs(assort)\n    base *= assort_factor\n\n    # ---------- 4. Triangles factor ----------\n    # More triangles provide local shortcuts that reduce overall path length.\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid division by zero\n    tri_ratio = tri / possible_tri\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n    base *= tri_factor\n\n    # ---------- 5. Transitivity factor ----------\n    # High global transitivity is another indicator of local clustering,\n    # which generally shortens paths.\n    trans_factor = 1.0 / (1.0 + trans)\n    base *= trans_factor\n\n    return base", "spearman": 0.4723033075826896, "pearson": 0.38014176716677156, "rmse": 12.678159717739916, "mae": 10.685361367883406}}
{"timestamp": "2026-02-16T10:10:58.970914+00:00", "event_type": "candidate_rejected", "payload": {"generation": 12, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.096086", "model_name": "gpt-oss:20b", "train_signal": 0.09608643457382952}}
{"timestamp": "2026-02-16T10:11:36.591588+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g12_i3_p3_628308254", "generation": 12, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8556542617046817, "fitness_mode": "correlation", "simplicity_score": 0.1801179049216806, "novelty_bonus": 0.18087343690966706, "total_score": 0.5539052025469986, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from global graph statistics.\n    The expression combines several structural descriptors in a way that\n    is consistent, numerically stable and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics.  Keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        An approximation of the graph's average shortest path length.\n    \"\"\"\n    # Basic terms\n    base = s['n'] ** 0.7 / (s['avg_degree'] + 1.0)\n\n    # Clustering encourages detours – increase the estimate\n    clust_factor = 1.0 + s['avg_clustering'] ** 0.5\n\n    # Positive assortativity usually lengthens paths\n    assort_factor = 1.0 + abs(s['degree_assortativity'])\n\n    # Heterogeneous degrees (large std) shortens paths – divide by it\n    deg_variance_factor = 1.0 / (1.0 + s['std_degree'])\n\n    # Denser graphs have shorter paths – dampen the base\n    density_factor = max(0.05, 1.0 - s['density'])\n\n    # Triangles provide local shortcuts – reduce the estimate\n    n = float(s['n'])\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div‑by‑zero\n    tri_ratio = s['num_triangles'] / possible_tri\n    triangle_factor = 1.0 / (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    trans_factor = 1.0 + s['transitivity']\n\n    # Assemble the invariant\n    result = (base * clust_factor * assort_factor *\n              deg_variance_factor * density_factor *\n              triangle_factor * trans_factor)\n\n    return result\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.144000\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.096086\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed global graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features with keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        An invariant that approximates the graph's average shortest path length.\n    \"\"\"\n    # basic scalars (use float for safety)\n    n        = float(s['n'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    num_tri  = float(s['num_triangles'])\n\n    # ------------------------------------------------------------------\n    # 1. Baseline length grows with size and shrinks with connectivity\n    # ------------------------------------------------------------------\n    base = n / (avg_deg + 1.0)\n\n    # ------------------------------------------------------------------\n    # 2. Clustering creates detours – increase the estimate\n    # ------------------------------------------------------------------\n    cluster_factor = 1.0 + clust\n\n    # ------------------------------------------------------------------\n    # 3. Positive assortativity tends to lengthen paths\n    # ------------------------------------------------------------------\n    assort_factor = 1.0 + abs(assort)\n\n    # ------------------------------------------------------------------\n    # 4. High degree heterogeneity (large std) shortens paths\n    # ------------------------------------------------------------------\n    heter_factor = 1.0 / (1.0 + std_deg**0.5)\n\n    # ------------------------------------------------------------------\n    # 5. Denser graphs have shorter paths – dampen the base\n    # ------------------------------------------------------------------\n    dens_factor = max(0.05, 1.0 - density)\n\n    # ------------------------------------------------------------------\n    # 6. Triangles provide local shortcuts – shrink the estimate\n    # ------------------------------------------------------------------\n    possible_tri = max(1.0, n * (n - 1.0) * (n - 2.0) / 6.0)\n    tri_ratio = num_tri / possible_tri\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # ------------------------------------------------------------------\n    # 7. Global transitivity further shortens paths\n    # ------------------------------------------------------------------\n    trans_factor = 1.0 + trans\n\n    # ------------------------------------------------------------------\n    # 8. Max/min degree span influences path length (optional refinement)\n    # ------------------------------------------------------------------\n    max_min_factor = 1.0 + (s['max_degree'] - s['min_degree']) / (s['max_degree'] + 1.0)\n\n    # ------------------------------------------------------------------\n    # Combine all factors multiplicatively\n    # ------------------------------------------------------------------\n    estimate = (base * cluster_factor * assort_factor *\n                heter_factor * dens_factor * tri_factor *\n                trans_factor * max_min_factor)\n\n    return estimate\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed global graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of graph features with keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        An invariant that approximates the graph's average shortest path length.\n    \"\"\"\n    # basic scalars (use float for safety)\n    n        = float(s['n'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    num_tri  = float(s['num_triangles'])\n\n    # ------------------------------------------------------------------\n    # 1. Baseline length grows with size and shrinks with connectivity\n    # ------------------------------------------------------------------\n    base = n / (avg_deg + 1.0)\n\n    # ------------------------------------------------------------------\n    # 2. Clustering creates detours – increase the estimate\n    # ------------------------------------------------------------------\n    cluster_factor = 1.0 + clust\n\n    # ------------------------------------------------------------------\n    # 3. Positive assortativity tends to lengthen paths\n    # ------------------------------------------------------------------\n    assort_factor = 1.0 + abs(assort)\n\n    # ------------------------------------------------------------------\n    # 4. High degree heterogeneity (large std) shortens paths\n    # ------------------------------------------------------------------\n    heter_factor = 1.0 / (1.0 + std_deg**0.5)\n\n    # ------------------------------------------------------------------\n    # 5. Denser graphs have shorter paths – dampen the base\n    # ------------------------------------------------------------------\n    dens_factor = max(0.05, 1.0 - density)\n\n    # ------------------------------------------------------------------\n    # 6. Triangles provide local shortcuts – shrink the estimate\n    # ------------------------------------------------------------------\n    possible_tri = max(1.0, n * (n - 1.0) * (n - 2.0) / 6.0)\n    tri_ratio = num_tri / possible_tri\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # ------------------------------------------------------------------\n    # 7. Global transitivity further shortens paths\n    # ------------------------------------------------------------------\n    trans_factor = 1.0 + trans\n\n    # ------------------------------------------------------------------\n    # 8. Max/min degree span influences path length (optional refinement)\n    # ------------------------------------------------------------------\n    max_min_factor = 1.0 + (s['max_degree'] - s['min_degree']) / (s['max_degree'] + 1.0)\n\n    # ------------------------------------------------------------------\n    # Combine all factors multiplicatively\n    # ------------------------------------------------------------------\n    estimate = (base * cluster_factor * assort_factor *\n                heter_factor * dens_factor * tri_factor *\n                trans_factor * max_min_factor)\n\n    return estimate", "spearman": 0.9272391809795246, "pearson": 0.9043954121658471, "rmse": 8.839838931534759, "mae": 6.866527804198651}}
{"timestamp": "2026-02-16T10:12:11.101780+00:00", "event_type": "candidate_rejected", "payload": {"generation": 12, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:12:11.101988+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 12, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:12:45.352774+00:00", "event_type": "candidate_rejected", "payload": {"generation": 12, "island_id": 3, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.094594", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:12:45.353439+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 12, "island_id": 3, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:12:45.356213+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 13, "model_name": "gpt-oss:20b", "best_val_score": 0.5655869739267355, "no_improve_count": 0}}
{"timestamp": "2026-02-16T10:22:35.381540+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.124218", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:22:35.382470+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 13, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.124218", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:23:05.992771+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 0, "population_idx": 0, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:23:05.993497+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 13, "island_id": 0, "population_idx": 0, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:23:56.307404+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i0_p1_672115920", "generation": 13, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.544297719087635, "fitness_mode": "correlation", "simplicity_score": 0.12239841031352473, "novelty_bonus": 0.22169833554208662, "total_score": 0.3701994129810874, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.124218\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    density = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    max_deg = float(s['max_degree'])\n    num_tri = float(s['num_triangles'])\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2            # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    density = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    max_deg = float(s['max_degree'])\n    num_tri = float(s['num_triangles'])\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2            # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj", "spearman": 0.5584204605115128, "pearson": 0.46609151447724606, "rmse": 2.0219886270648404, "mae": 1.813566092812708}}
{"timestamp": "2026-02-16T10:24:30.793790+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:24:30.794571+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 13, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:24:49.682777+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i0_p2_464891512", "generation": 13, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.544297719087635, "fitness_mode": "correlation", "simplicity_score": 0.12325800208793525, "novelty_bonus": 0.22169833554208662, "total_score": 0.37037133133596944, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.124218\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: code must define exactly one function named `new_invariant`\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    density = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    max_deg = float(s['max_degree'])\n    num_tri = float(s['num_triangles'])\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 2)          # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)                  # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)    # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)      # presence of hubs → shorter paths\n    tri_adj       = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    def clamp(x):\n        return max(0.1, min(10, x))\n\n    density_adj   = clamp(density_adj)\n    clustering_adj = clamp(clustering_adj)\n    assort_adj    = clamp(assort_adj)\n    hetero_adj    = clamp(hetero_adj)\n    hub_adj       = clamp(hub_adj)\n    tri_adj       = clamp(tri_adj)\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * tri_adj\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    density = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    max_deg = float(s['max_degree'])\n    num_tri = float(s['num_triangles'])\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 2)          # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)                  # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)    # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)      # presence of hubs → shorter paths\n    tri_adj       = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    tri_adj       = max(0.1, min(10, tri_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * tri_adj\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    avg_deg = float(s['avg_degree'])\n    density = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort = float(s['degree_assortativity'])\n    std_deg = float(s['std_degree'])\n    max_deg = float(s['max_degree'])\n    num_tri = float(s['num_triangles'])\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 2)          # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)                  # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps)    # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)      # presence of hubs → shorter paths\n    tri_adj       = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    tri_adj       = max(0.1, min(10, tri_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * tri_adj", "spearman": 0.5584204605115128, "pearson": 0.46609151447724606, "rmse": 2.0219886270648404, "mae": 1.813566092812708}}
{"timestamp": "2026-02-16T10:24:49.683369+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 13, "island_id": 0, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:25:15.533807+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.141259", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:25:15.535201+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 13, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.141259", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:25:56.744642+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i0_p3_333800005", "generation": 13, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.6368787515006001, "fitness_mode": "correlation", "simplicity_score": 0.1900184737509212, "novelty_bonus": 0.21491187279681978, "total_score": 0.40071171245062676, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density)**2          # sparser → longer paths\n    clustering_adj = 1 - clustering**2           # more clustering → shorter paths\n    assort_adj    = 1 + abs(assort)               # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) # more heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps)   # presence of hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps)  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.124218\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.141259\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The formula is intentionally simple, uses only basic\n    arithmetic and built‑in functions, and avoids any direct use of a single\n    feature as the result.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    num_tri    = float(s['num_triangles'])\n\n    # ------------------------------------------------------------------\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # ------------------------------------------------------------------\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.5)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.5)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.5)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.5)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.5)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.5)  # more triangles → shorter paths\n\n    # ------------------------------------------------------------------\n    # 3. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n\n    # ------------------------------------------------------------------\n    # 4. Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and built‑in\n    functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and built‑in\n    functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "spearman": 0.5964689117227931, "pearson": 0.32267285769287385, "rmse": 2.731162131708067, "mae": 2.569228981971275}}
{"timestamp": "2026-02-16T10:25:56.745793+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 13, "island_id": 0, "population_idx": 3, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:26:23.218676+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:26:23.219814+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 13, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:26:46.295780+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 0, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:26:46.296526+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 13, "island_id": 0, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:27:18.564175+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i1_p0_912859373", "generation": 13, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14950218330425635, "novelty_bonus": 0.2098132453311331, "total_score": 0.2888775610889619, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = (n ** 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T10:27:44.102669+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i1_p1_936610287", "generation": 13, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14953717349512105, "novelty_bonus": 0.2098132453311331, "total_score": 0.28888455912713484, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = (n ** 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    The formula is a weighted combination of a baseline estimate and\n    several structural adjustment factors, plus a normalised degree‑variance\n    term and an extra clustering/transitivity term.  All components are\n    bounded to keep the invariant stable across a wide range of graphs.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # ---------- Baseline ----------\n    # Roughly scales as sqrt(n) and inversely with average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # ---------- Adjustment factors ----------\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n\n    # ---------- Degree‑variance term ----------\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # ---------- Extra clustering/transitivity term ----------\n    extra_term = (n ** 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # ---------- Combine everything ----------\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    The formula is a weighted combination of a baseline estimate and\n    several structural adjustment factors, plus a normalised degree‑variance\n    term and an extra clustering/transitivity term.  All components are\n    bounded to keep the invariant stable across a wide range of graphs.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # ---------- Baseline ----------\n    # Roughly scales as sqrt(n) and inversely with average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # ---------- Adjustment factors ----------\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n\n    # ---------- Degree‑variance term ----------\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # ---------- Extra clustering/transitivity term ----------\n    extra_term = (n ** 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # ---------- Combine everything ----------\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T10:28:17.289938+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i1_p2_111708427", "generation": 13, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14948476645553802, "novelty_bonus": 0.2098132453311331, "total_score": 0.28887407771921825, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = (n ** 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * pow(max_deg + 1, 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * pow(max_deg + 1, 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T10:29:10.969593+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i1_p3_301293807", "generation": 13, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14957237422515934, "novelty_bonus": 0.2098132453311331, "total_score": 0.28889159927314256, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = (n ** 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T10:30:07.588703+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i1_p4_143172077", "generation": 13, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.1495196522239334, "novelty_bonus": 0.2098132453311331, "total_score": 0.28888105487289734, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = (n ** 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * pow(max_deg + 1, 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * pow(max_deg + 1, 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T10:30:44.614545+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i2_p0_429720202", "generation": 13, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.895126050420168, "fitness_mode": "correlation", "simplicity_score": 0.21975732605103246, "novelty_bonus": 0.1501714417161848, "total_score": 0.5635000101528727, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.116683\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Basic descriptors with safety checks\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1)\n    std_deg    = s.get('std_degree', 0)\n    min_deg    = s.get('min_degree', 1)\n    max_deg    = s.get('max_degree', 0)\n    clustering = s.get('avg_clustering', 0)\n    trans      = s.get('transitivity', 0)\n    assort     = s.get('degree_assortativity', 0)\n    density    = s.get('density', 0)\n    num_tri    = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours; scale up\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg if min_deg > 0 else 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    if degrees:\n        deg_sq_avg = sum(d * d for d in degrees) / n\n        variance = deg_sq_avg - avg_deg * avg_deg\n        if variance > 0:\n            base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Basic descriptors with safety checks\n    n          = s.get('n', 1)\n    avg_deg    = s.get('avg_degree', 1)\n    std_deg    = s.get('std_degree', 0)\n    min_deg    = s.get('min_degree', 1)\n    max_deg    = s.get('max_degree', 0)\n    clustering = s.get('avg_clustering', 0)\n    trans      = s.get('transitivity', 0)\n    assort     = s.get('degree_assortativity', 0)\n    density    = s.get('density', 0)\n    num_tri    = s.get('num_triangles', 0)\n    degrees    = s.get('degrees', [])\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours; scale up\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg if min_deg > 0 else 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    if degrees:\n        deg_sq_avg = sum(d * d for d in degrees) / n\n        variance = deg_sq_avg - avg_deg * avg_deg\n        if variance > 0:\n            base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.9489942248556215, "pearson": 0.8749023354744576, "rmse": 8.1584563303381, "mae": 4.831634142354471}}
{"timestamp": "2026-02-16T10:31:04.246307+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i2_p1_327465746", "generation": 13, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8884033613445379, "fitness_mode": "correlation", "simplicity_score": 0.223192647377777, "novelty_bonus": 0.15310237951290506, "total_score": 0.5598139744477049, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.116683\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a compact\n    combination of basic graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys:\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Base estimate: larger graphs with smaller average degree tend to\n    # have longer average paths.\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # 1. Clustering increases detours → lengthen paths\n    base *= (1 + s['avg_clustering'])\n\n    # 2. Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # 3. Degree heterogeneity (high std) shortens paths → divide\n    base /= (1 + s['std_degree'])\n\n    # 4. Very small minimum degree (many leaves) can lengthen paths\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    base *= (1 + 1 / min_deg)\n\n    # 5. Very large maximum degree (hub) shortens paths\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    denom = max(s['n'] - 1, 1)\n    base /= (1 + max_deg / denom)\n\n    # 6. Denser graphs have shorter paths\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # 7. Triangle ratio (local cohesion) shortens paths\n    n = s['n']\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = s['num_triangles'] / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 8. Global transitivity (overall clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a compact\n    combination of basic graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys:\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Base estimate: larger graphs with smaller average degree tend to\n    # have longer average paths.\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # 1. Clustering increases detours → lengthen paths\n    base *= (1 + s['avg_clustering'])\n\n    # 2. Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # 3. Degree heterogeneity (high std) shortens paths → divide\n    base /= (1 + s['std_degree'])\n\n    # 4. Very small minimum degree (many leaves) can lengthen paths\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    base *= (1 + 1 / min_deg)\n\n    # 5. Very large maximum degree (hub) shortens paths\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    denom = max(s['n'] - 1, 1)\n    base /= (1 + max_deg / denom)\n\n    # 6. Denser graphs have shorter paths\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # 7. Triangle ratio (local cohesion) shortens paths\n    n = s['n']\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = s['num_triangles'] / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 8. Global transitivity (overall clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base", "spearman": 0.938489462236556, "pearson": 0.9160330136036973, "rmse": 5.685515483370974, "mae": 3.5693698485684333}}
{"timestamp": "2026-02-16T10:31:41.161150+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i2_p2_892707235", "generation": 13, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8849459783913565, "fitness_mode": "correlation", "simplicity_score": 0.21966292554789707, "novelty_bonus": 0.15962145387447446, "total_score": 0.5636333166293057, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.116683\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate follows a simple baseline that grows with the number\n    of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators are used; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    # Dampen the effect with a square‑root\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate follows a simple baseline that grows with the number\n    of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators are used; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    # Dampen the effect with a square‑root\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.943628590714768, "pearson": 0.8614449735920473, "rmse": 7.905774164087407, "mae": 4.588158534015637}}
{"timestamp": "2026-02-16T10:32:18.238252+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i2_p3_786778693", "generation": 13, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.895126050420168, "fitness_mode": "correlation", "simplicity_score": 0.220226290956892, "novelty_bonus": 0.1501714417161848, "total_score": 0.5635938031340446, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.116683\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours; scale up\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours; scale up\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.9489942248556215, "pearson": 0.8749023354744576, "rmse": 8.1584563303381, "mae": 4.831634142354471}}
{"timestamp": "2026-02-16T10:32:44.395080+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i2_p4_860258127", "generation": 13, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.7706602641056423, "fitness_mode": "correlation", "simplicity_score": 0.22243423636554488, "novelty_bonus": 0.25293294291291324, "total_score": 0.5519552698604758, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  A series of\n    structural adjustments are then applied.  All arithmetic uses\n    only built‑in functions; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    #    (this term is small and keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.136526\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.116683\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.\n\n    The estimate is built from a compact baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and the\n    relative sizes of the minimum and maximum degrees.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths,\n    #    relative to the maximum degree\n    base *= (1 + min_deg / (max_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + (max_deg / max(n - 1, 1)) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - 0.8 * density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.\n\n    The estimate is built from a compact baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and the\n    relative sizes of the minimum and maximum degrees.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths,\n    #    relative to the maximum degree\n    base *= (1 + min_deg / (max_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + (max_deg / max(n - 1, 1)) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - 0.8 * density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    return base", "spearman": 0.8631770794269857, "pearson": 0.705999852337919, "rmse": 3.2539377000181293, "mae": 1.79032705867819}}
{"timestamp": "2026-02-16T10:33:20.122342+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i3_p0_413756642", "generation": 13, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8169507803121248, "fitness_mode": "correlation", "simplicity_score": 0.19649582147972267, "novelty_bonus": 0.1714197854946372, "total_score": 0.5364342426729041, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph statistics.\n    The expression is a hand‑crafted combination of terms that encode\n    known influences on path length:\n\n    * Size versus connectivity (n / (avg_degree + 1))\n    * Clustering and assortativity act as “detour” factors (multiplicative\n      adjustments > 1)\n    * Degree heterogeneity (high std > 0) shortens paths (division)\n    * Graph density and global transitivity reduce the estimate\n    * The presence of triangles is treated as local shortcuts\n      (division by a factor that grows with the triangle density)\n\n    The function is intentionally written without external imports, using\n    only built‑in arithmetic functions so it can be executed on any\n    compliant Python environment.\n    \"\"\"\n\n    # Cast to float for safety and avoid accidental integer division\n    n            = float(s['n'])\n    avg_deg      = float(s['avg_degree'])\n    std_deg      = float(s['std_degree'])\n    clust        = float(s['avg_clustering'])\n    trans        = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    tri          = float(s['num_triangles'])\n    density      = float(s['density'])\n\n    # --------------------------------------------------------------------\n    # 1. Baseline: larger networks or smaller average degree → longer paths\n    # --------------------------------------------------------------------\n    baseline = n / (avg_deg + 1.0)\n\n    # --------------------------------------------------------------------\n    # 2. Detour multipliers – clustering & assortativity increase typical\n    #    path length by creating more local “dead‑ends” or tightly\n    #    clustered sub‑structures.\n    # --------------------------------------------------------------------\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n\n    # --------------------------------------------------------------------\n    # 3. Degree heterogeneity – a few hubs (large std) create shortcuts\n    #    that lower the average path length.\n    # --------------------------------------------------------------------\n    hetero = 1.0 / (1.0 + std_deg)\n\n    # --------------------------------------------------------------------\n    # 4. Graph density – denser connectivity shortens paths\n    # --------------------------------------------------------------------\n    dens_factor = max(0.05, 1.0 - density)    # keep factor in (0,1]\n\n    # --------------------------------------------------------------------\n    # 5. Triangle‑based shortcut factor – triangles are local shortcuts\n    # --------------------------------------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)      # avoid division by zero\n    tri_ratio    = tri / possible_tri\n    tri_factor   = 1.0 / (1.0 + tri_ratio)\n\n    # --------------------------------------------------------------------\n    # 6. Global transitivity – overall clustering across the network\n    #    further reduces the average path length.\n    # --------------------------------------------------------------------\n    trans_factor = 1.0 + trans\n\n    # --------------------------------------------------------------------\n    # Assemble the final invariant by combining all the factors.\n    # --------------------------------------------------------------------\n    result = baseline * detour * hetero * dens_factor * tri_factor * trans_factor\n\n    return result\nRecent failures:\nbelow_train_threshold: train_signal=0.096086\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.094594\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    \n    Parameters\n    ----------\n    s : dict\n        Expected keys are\n        - n, m\n        - density\n        - avg_degree, std_degree\n        - avg_clustering, transitivity\n        - degree_assortativity\n        - num_triangles\n\n    Returns\n    -------\n    float\n        An invariant that approximates the average shortest path length.\n    \"\"\"\n    # cast to float to avoid accidental integer arithmetic\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    dens       = float(s['density'])\n    tri        = float(s['num_triangles'])\n\n    # 1. Baseline grows with network size (√n) and shrinks with average degree\n    result = (n ** 0.5) / (avg_deg + 1.0)\n\n    # 2. Clustering and assortativity tend to create detours, so increase length\n    detour = 1.0 + clust + abs(assort)\n    result *= detour\n\n    # 3. Degree heterogeneity (high std) introduces hubs, shortening paths\n    result /= (1.0 + std_deg)\n\n    # 4. Denser graphs are more connected, thus shorter\n    dens_factor = max(0.05, 1.0 - dens)   # keep factor positive and ≤ 1\n    result *= dens_factor\n\n    # 5. Triangles act as local shortcuts; divide by a factor that grows with triangle density\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)     # avoid division by zero\n    tri_ratio = tri / possible_tri\n    result /= (1.0 + tri_ratio)\n\n    # 6. Global transitivity further reduces the average distance\n    result *= (1.0 + trans)\n\n    return result\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    \n    Parameters\n    ----------\n    s : dict\n        Expected keys are\n        - n, m\n        - density\n        - avg_degree, std_degree\n        - avg_clustering, transitivity\n        - degree_assortativity\n        - num_triangles\n\n    Returns\n    -------\n    float\n        An invariant that approximates the average shortest path length.\n    \"\"\"\n    # cast to float to avoid accidental integer arithmetic\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    dens       = float(s['density'])\n    tri        = float(s['num_triangles'])\n\n    # 1. Baseline grows with network size (√n) and shrinks with average degree\n    result = (n ** 0.5) / (avg_deg + 1.0)\n\n    # 2. Clustering and assortativity tend to create detours, so increase length\n    detour = 1.0 + clust + abs(assort)\n    result *= detour\n\n    # 3. Degree heterogeneity (high std) introduces hubs, shortening paths\n    result /= (1.0 + std_deg)\n\n    # 4. Denser graphs are more connected, thus shorter\n    dens_factor = max(0.05, 1.0 - dens)   # keep factor positive and ≤ 1\n    result *= dens_factor\n\n    # 5. Triangles act as local shortcuts; divide by a factor that grows with triangle density\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)     # avoid division by zero\n    tri_ratio = tri / possible_tri\n    result /= (1.0 + tri_ratio)\n\n    # 6. Global transitivity further reduces the average distance\n    result *= (1.0 + trans)\n\n    return result", "spearman": 0.8914182854571366, "pearson": 0.8504791918747048, "rmse": 2.2772728618248537, "mae": 2.174819021450318}}
{"timestamp": "2026-02-16T10:33:53.779434+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i3_p1_761340914", "generation": 13, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8373109243697479, "fitness_mode": "correlation", "simplicity_score": 0.18202434865415773, "novelty_bonus": 0.20040381990466183, "total_score": 0.5536961949567115, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph statistics.\n    The expression is a hand‑crafted combination of terms that encode\n    known influences on path length:\n\n    * Size versus connectivity (n / (avg_degree + 1))\n    * Clustering and assortativity act as “detour” factors (multiplicative\n      adjustments > 1)\n    * Degree heterogeneity (high std > 0) shortens paths (division)\n    * Graph density and global transitivity reduce the estimate\n    * The presence of triangles is treated as local shortcuts\n      (division by a factor that grows with the triangle density)\n\n    The function is intentionally written without external imports, using\n    only built‑in arithmetic functions so it can be executed on any\n    compliant Python environment.\n    \"\"\"\n\n    # Cast to float for safety and avoid accidental integer division\n    n            = float(s['n'])\n    avg_deg      = float(s['avg_degree'])\n    std_deg      = float(s['std_degree'])\n    clust        = float(s['avg_clustering'])\n    trans        = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    tri          = float(s['num_triangles'])\n    density      = float(s['density'])\n\n    # --------------------------------------------------------------------\n    # 1. Baseline: larger networks or smaller average degree → longer paths\n    # --------------------------------------------------------------------\n    baseline = n / (avg_deg + 1.0)\n\n    # --------------------------------------------------------------------\n    # 2. Detour multipliers – clustering & assortativity increase typical\n    #    path length by creating more local “dead‑ends” or tightly\n    #    clustered sub‑structures.\n    # --------------------------------------------------------------------\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n\n    # --------------------------------------------------------------------\n    # 3. Degree heterogeneity – a few hubs (large std) create shortcuts\n    #    that lower the average path length.\n    # --------------------------------------------------------------------\n    hetero = 1.0 / (1.0 + std_deg)\n\n    # --------------------------------------------------------------------\n    # 4. Graph density – denser connectivity shortens paths\n    # --------------------------------------------------------------------\n    dens_factor = max(0.05, 1.0 - density)    # keep factor in (0,1]\n\n    # --------------------------------------------------------------------\n    # 5. Triangle‑based shortcut factor – triangles are local shortcuts\n    # --------------------------------------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)      # avoid division by zero\n    tri_ratio    = tri / possible_tri\n    tri_factor   = 1.0 / (1.0 + tri_ratio)\n\n    # --------------------------------------------------------------------\n    # 6. Global transitivity – overall clustering across the network\n    #    further reduces the average path length.\n    # --------------------------------------------------------------------\n    trans_factor = 1.0 + trans\n\n    # --------------------------------------------------------------------\n    # Assemble the final invariant by combining all the factors.\n    # --------------------------------------------------------------------\n    result = baseline * detour * hetero * dens_factor * tri_factor * trans_factor\n\n    return result\nRecent failures:\nbelow_train_threshold: train_signal=0.096086\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.094594\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Roughly estimates the average shortest‑path length using only\n    global graph statistics that are known to influence path lengths.\n\n    The formula combines:\n    • a baseline proportional to the size / average degree\n    • multiplicative detour factors from clustering and assortativity\n    • a division by the degree‑distribution standard deviation (hubs shrink paths)\n    • a density factor (denser graphs shrink paths)\n    • a triangle‑ratio factor (more triangles → shortcuts)\n    • a final multiplicative term from transitivity\n\n    The expression is constructed entirely from built‑in arithmetic\n    operators; no external imports or shortest‑path algorithms are used.\n    \"\"\"\n    # Convert to floats to avoid integer division issues\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    dens       = float(s['density'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    trans      = float(s['transitivity'])\n\n    # 1. Baseline: larger networks or lower average degree → longer paths\n    baseline = n / (avg_deg + 1.0)\n\n    # 2. Detour factors: clustering and assortativity tend to lengthen paths\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n    baseline *= detour\n\n    # 3. Degree heterogeneity (hubs) shorten paths\n    baseline /= (1.0 + std_deg)\n\n    # 4. Graph density shortens paths; keep factor in (0,1]\n    dens_factor = max(0.05, 1.0 - dens)\n    baseline *= dens_factor\n\n    # 5. Triangles provide local shortcuts; reduce estimate\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio = tri / possible_tri\n    baseline /= (1.0 + tri_ratio)\n\n    # 6. Transitivity (global clustering) further shortens paths\n    baseline *= (1.0 + trans)\n\n    return baseline\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Roughly estimates the average shortest‑path length using only\n    global graph statistics that are known to influence path lengths.\n\n    The formula combines:\n    • a baseline proportional to the size / average degree\n    • multiplicative detour factors from clustering and assortativity\n    • a division by the degree‑distribution standard deviation (hubs shrink paths)\n    • a density factor (denser graphs shrink paths)\n    • a triangle‑ratio factor (more triangles → shortcuts)\n    • a final multiplicative term from transitivity\n\n    The expression is constructed entirely from built‑in arithmetic\n    operators; no external imports or shortest‑path algorithms are used.\n    \"\"\"\n    # Convert to floats to avoid integer division issues\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    dens       = float(s['density'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    trans      = float(s['transitivity'])\n\n    # 1. Baseline: larger networks or lower average degree → longer paths\n    baseline = n / (avg_deg + 1.0)\n\n    # 2. Detour factors: clustering and assortativity tend to lengthen paths\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n    baseline *= detour\n\n    # 3. Degree heterogeneity (hubs) shorten paths\n    baseline /= (1.0 + std_deg)\n\n    # 4. Graph density shortens paths; keep factor in (0,1]\n    dens_factor = max(0.05, 1.0 - dens)\n    baseline *= dens_factor\n\n    # 5. Triangles provide local shortcuts; reduce estimate\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio = tri / possible_tri\n    baseline /= (1.0 + tri_ratio)\n\n    # 6. Transitivity (global clustering) further shortens paths\n    baseline *= (1.0 + trans)\n\n    return baseline", "spearman": 0.9143403585089629, "pearson": 0.8271326217624315, "rmse": 3.359512705062122, "mae": 2.0994546103869034}}
{"timestamp": "2026-02-16T10:34:32.650624+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i3_p2_41843087", "generation": 13, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.7020888355342136, "fitness_mode": "correlation", "simplicity_score": 0.19433367880969035, "novelty_bonus": 0.29242621777714406, "total_score": 0.5418814832671356, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph statistics.\n    The expression is a hand‑crafted combination of terms that encode\n    known influences on path length:\n\n    * Size versus connectivity (n / (avg_degree + 1))\n    * Clustering and assortativity act as “detour” factors (multiplicative\n      adjustments > 1)\n    * Degree heterogeneity (high std > 0) shortens paths (division)\n    * Graph density and global transitivity reduce the estimate\n    * The presence of triangles is treated as local shortcuts\n      (division by a factor that grows with the triangle density)\n\n    The function is intentionally written without external imports, using\n    only built‑in arithmetic functions so it can be executed on any\n    compliant Python environment.\n    \"\"\"\n\n    # Cast to float for safety and avoid accidental integer division\n    n            = float(s['n'])\n    avg_deg      = float(s['avg_degree'])\n    std_deg      = float(s['std_degree'])\n    clust        = float(s['avg_clustering'])\n    trans        = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    tri          = float(s['num_triangles'])\n    density      = float(s['density'])\n\n    # --------------------------------------------------------------------\n    # 1. Baseline: larger networks or smaller average degree → longer paths\n    # --------------------------------------------------------------------\n    baseline = n / (avg_deg + 1.0)\n\n    # --------------------------------------------------------------------\n    # 2. Detour multipliers – clustering & assortativity increase typical\n    #    path length by creating more local “dead‑ends” or tightly\n    #    clustered sub‑structures.\n    # --------------------------------------------------------------------\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n\n    # --------------------------------------------------------------------\n    # 3. Degree heterogeneity – a few hubs (large std) create shortcuts\n    #    that lower the average path length.\n    # --------------------------------------------------------------------\n    hetero = 1.0 / (1.0 + std_deg)\n\n    # --------------------------------------------------------------------\n    # 4. Graph density – denser connectivity shortens paths\n    # --------------------------------------------------------------------\n    dens_factor = max(0.05, 1.0 - density)    # keep factor in (0,1]\n\n    # --------------------------------------------------------------------\n    # 5. Triangle‑based shortcut factor – triangles are local shortcuts\n    # --------------------------------------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)      # avoid division by zero\n    tri_ratio    = tri / possible_tri\n    tri_factor   = 1.0 / (1.0 + tri_ratio)\n\n    # --------------------------------------------------------------------\n    # 6. Global transitivity – overall clustering across the network\n    #    further reduces the average path length.\n    # --------------------------------------------------------------------\n    trans_factor = 1.0 + trans\n\n    # --------------------------------------------------------------------\n    # Assemble the final invariant by combining all the factors.\n    # --------------------------------------------------------------------\n    result = baseline * detour * hetero * dens_factor * tri_factor * trans_factor\n\n    return result\nRecent failures:\nbelow_train_threshold: train_signal=0.096086\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.094594\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A composite estimate of the average shortest‑path length based solely\n    on pre‑computed global graph statistics.\n\n    The formula combines several structural cues:\n      * Larger networks or sparser connectivity ⇒ longer paths\n      * Clustering and positive assortativity tend to create detours\n      * High degree heterogeneity (large std + hub ratio) shortens paths\n      * Denser graphs and high triangle density provide shortcuts\n      * Global transitivity (overall clustering) further shortens paths\n\n    The expression is deliberately written without imports, using only\n    built‑in arithmetic to remain portable.\n    \"\"\"\n    # Cast to float for safety and avoid accidental integer division\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    dens       = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n\n    # 1. Baseline: size vs connectivity\n    baseline = n / (avg_deg + 1.0)\n\n    # 2. Detour multipliers: clustering + assortativity\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n\n    # 3. Degree heterogeneity: std + hub ratio shortens paths\n    hub_ratio = (max_deg + 1.0) / (min_deg + 1.0)\n    hetero_factor = 1.0 / (1.0 + std_deg + hub_ratio)\n\n    # 4. Density: denser graphs reduce path length\n    dens_factor = max(0.01, 1.0 - dens)\n\n    # 5. Triangle‑based shortcut factor\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div/0\n    tri_ratio = tri / possible_tri\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # 6. Global transitivity factor\n    trans_factor = 1.0 + trans\n\n    # Assemble all components multiplicatively\n    result = baseline * detour * hetero_factor * dens_factor\n    result *= tri_factor * trans_factor\n\n    return result\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A composite estimate of the average shortest‑path length based solely\n    on pre‑computed global graph statistics.\n\n    The formula combines several structural cues:\n      * Larger networks or sparser connectivity ⇒ longer paths\n      * Clustering and positive assortativity tend to create detours\n      * High degree heterogeneity (large std + hub ratio) shortens paths\n      * Denser graphs and high triangle density provide shortcuts\n      * Global transitivity (overall clustering) further shortens paths\n\n    The expression is deliberately written without imports, using only\n    built‑in arithmetic to remain portable.\n    \"\"\"\n    # Cast to float for safety and avoid accidental integer division\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    dens       = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n\n    # 1. Baseline: size vs connectivity\n    baseline = n / (avg_deg + 1.0)\n\n    # 2. Detour multipliers: clustering + assortativity\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n\n    # 3. Degree heterogeneity: std + hub ratio shortens paths\n    hub_ratio = (max_deg + 1.0) / (min_deg + 1.0)\n    hetero_factor = 1.0 / (1.0 + std_deg + hub_ratio)\n\n    # 4. Density: denser graphs reduce path length\n    dens_factor = max(0.01, 1.0 - dens)\n\n    # 5. Triangle‑based shortcut factor\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div/0\n    tri_ratio = tri / possible_tri\n    tri_factor = 1.0 / (1.0 + tri_ratio)\n\n    # 6. Global transitivity factor\n    trans_factor = 1.0 + trans\n\n    # Assemble all components multiplicatively\n    result = baseline * detour * hetero_factor * dens_factor\n    result *= tri_factor * trans_factor\n\n    return result", "spearman": 0.8305737643441087, "pearson": 0.68648139220929, "rmse": 1.3432628666934505, "mae": 1.195412365676197}}
{"timestamp": "2026-02-16T10:35:01.790432+00:00", "event_type": "candidate_rejected", "payload": {"generation": 13, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.133061", "model_name": "gpt-oss:20b", "train_signal": 0.1330612244897959}}
{"timestamp": "2026-02-16T10:36:04.111191+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g13_i3_p4_598017057", "generation": 13, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6134453781512604, "fitness_mode": "correlation", "simplicity_score": 0.12636580476057513, "novelty_bonus": 0.21610092351600174, "total_score": 0.4460413364543768, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph statistics.\n    The expression is a hand‑crafted combination of terms that encode\n    known influences on path length:\n\n    * Size versus connectivity (n / (avg_degree + 1))\n    * Clustering and assortativity act as “detour” factors (multiplicative\n      adjustments > 1)\n    * Degree heterogeneity (high std > 0) shortens paths (division)\n    * Graph density and global transitivity reduce the estimate\n    * The presence of triangles is treated as local shortcuts\n      (division by a factor that grows with the triangle density)\n\n    The function is intentionally written without external imports, using\n    only built‑in arithmetic functions so it can be executed on any\n    compliant Python environment.\n    \"\"\"\n\n    # Cast to float for safety and avoid accidental integer division\n    n            = float(s['n'])\n    avg_deg      = float(s['avg_degree'])\n    std_deg      = float(s['std_degree'])\n    clust        = float(s['avg_clustering'])\n    trans        = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    tri          = float(s['num_triangles'])\n    density      = float(s['density'])\n\n    # --------------------------------------------------------------------\n    # 1. Baseline: larger networks or smaller average degree → longer paths\n    # --------------------------------------------------------------------\n    baseline = n / (avg_deg + 1.0)\n\n    # --------------------------------------------------------------------\n    # 2. Detour multipliers – clustering & assortativity increase typical\n    #    path length by creating more local “dead‑ends” or tightly\n    #    clustered sub‑structures.\n    # --------------------------------------------------------------------\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n\n    # --------------------------------------------------------------------\n    # 3. Degree heterogeneity – a few hubs (large std) create shortcuts\n    #    that lower the average path length.\n    # --------------------------------------------------------------------\n    hetero = 1.0 / (1.0 + std_deg)\n\n    # --------------------------------------------------------------------\n    # 4. Graph density – denser connectivity shortens paths\n    # --------------------------------------------------------------------\n    dens_factor = max(0.05, 1.0 - density)    # keep factor in (0,1]\n\n    # --------------------------------------------------------------------\n    # 5. Triangle‑based shortcut factor – triangles are local shortcuts\n    # --------------------------------------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)      # avoid division by zero\n    tri_ratio    = tri / possible_tri\n    tri_factor   = 1.0 / (1.0 + tri_ratio)\n\n    # --------------------------------------------------------------------\n    # 6. Global transitivity – overall clustering across the network\n    #    further reduces the average path length.\n    # --------------------------------------------------------------------\n    trans_factor = 1.0 + trans\n\n    # --------------------------------------------------------------------\n    # Assemble the final invariant by combining all the factors.\n    # --------------------------------------------------------------------\n    result = baseline * detour * hetero * dens_factor * tri_factor * trans_factor\n\n    return result\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.094594\nbelow_train_threshold: train_signal=0.133061\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed global graph\n    statistics without performing any graph traversal.\n\n    The formula combines several intuitive relationships:\n    * size vs. connectivity (n / (avg_degree + 1)),\n    * detours caused by local clustering and assortativity,\n    * degree range and heterogeneity (hubs shorten paths),\n    * overall density (denser graphs → shorter paths),\n    * triangles as local shortcuts,\n    * global transitivity reducing overall length.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with keys:\n        n, avg_degree, std_degree, avg_clustering,\n        transitivity, degree_assortativity,\n        num_triangles, density,\n        max_degree, min_degree\n\n    Returns\n    -------\n    float\n        A heuristic estimate of the average shortest‑path length.\n    \"\"\"\n    # basic scalars\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n\n    # 1. Baseline: more nodes or lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # 2. Detour factor: clustering & assortativity create local dead‑ends\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n\n    # 3. Degree‑range adjustment: high range indicates hubs, shortening paths\n    deg_range = max_deg - min_deg\n    range_factor = 1.0 + deg_range / (avg_deg + 1.0)\n    range_adj = 1.0 / range_factor\n\n    # 4. Heterogeneity adjustment: higher std → more hubs → shorter paths\n    hetero_adj = 1.0 / (1.0 + std_deg)\n\n    # 5. Density factor: denser graph reduces path length\n    dens_factor = max(0.01, 1.0 - density)\n\n    # 6. Triangle shortcut factor: more triangles → shorter paths\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)\n    tri_ratio = tri / possible_tri\n    tri_adj = 1.0 / (1.0 + tri_ratio)\n\n    # 7. Transitivity factor: higher global clustering reduces paths\n    trans_adj = 1.0 / (1.0 + trans)\n\n    # Assemble all pieces\n    return (\n        base * detour * range_adj * hetero_adj *\n        dens_factor * tri_adj * trans_adj\n    )\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed global graph\n    statistics without performing any graph traversal.\n\n    The formula combines several intuitive relationships:\n    * size vs. connectivity (n / (avg_degree + 1)),\n    * detours caused by local clustering and assortativity,\n    * degree range and heterogeneity (hubs shorten paths),\n    * overall density (denser graphs → shorter paths),\n    * triangles as local shortcuts,\n    * global transitivity reducing overall length.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with keys:\n        n, avg_degree, std_degree, avg_clustering,\n        transitivity, degree_assortativity,\n        num_triangles, density,\n        max_degree, min_degree\n\n    Returns\n    -------\n    float\n        A heuristic estimate of the average shortest‑path length.\n    \"\"\"\n    # basic scalars\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n\n    # 1. Baseline: more nodes or lower degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # 2. Detour factor: clustering & assortativity create local dead‑ends\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n\n    # 3. Degree‑range adjustment: high range indicates hubs, shortening paths\n    deg_range = max_deg - min_deg\n    range_factor = 1.0 + deg_range / (avg_deg + 1.0)\n    range_adj = 1.0 / range_factor\n\n    # 4. Heterogeneity adjustment: higher std → more hubs → shorter paths\n    hetero_adj = 1.0 / (1.0 + std_deg)\n\n    # 5. Density factor: denser graph reduces path length\n    dens_factor = max(0.01, 1.0 - density)\n\n    # 6. Triangle shortcut factor: more triangles → shorter paths\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)\n    tri_ratio = tri / possible_tri\n    tri_adj = 1.0 / (1.0 + tri_ratio)\n\n    # 7. Transitivity factor: higher global clustering reduces paths\n    trans_adj = 1.0 / (1.0 + trans)\n\n    # Assemble all pieces\n    return (\n        base * detour * range_adj * hetero_adj *\n        dens_factor * tri_adj * trans_adj\n    )", "spearman": 0.7118757968949225, "pearson": 0.5194078515123989, "rmse": 1.8005135323981176, "mae": 1.5855578148723777}}
{"timestamp": "2026-02-16T10:36:04.114213+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 14, "model_name": "gpt-oss:20b", "best_val_score": 0.5655869739267355, "no_improve_count": 1}}
{"timestamp": "2026-02-16T10:36:51.042218+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i0_p0_136275395", "generation": 14, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.569267707082833, "fitness_mode": "correlation", "simplicity_score": 0.1900184737509212, "novelty_bonus": 0.23736763402251504, "total_score": 0.39032476272638306, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and built‑in\n    functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.141259\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  Only built‑in Python functions are used; no external\n    libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.1)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.1)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.5)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.9)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.8)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.7)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.4\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  Only built‑in Python functions are used; no external\n    libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.1)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.1)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.5)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.9)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.8)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.7)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.4\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "spearman": 0.5622215555388886, "pearson": 0.3446338382487786, "rmse": 2.515245351582526, "mae": 2.3314930403406184}}
{"timestamp": "2026-02-16T10:37:22.140527+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.091891", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:37:22.141102+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 14, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.091891", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:37:55.348174+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:37:55.348912+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 14, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:38:36.357691+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:38:36.358803+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 14, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:39:12.381640+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 0, "population_idx": 2, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:39:12.382681+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 14, "island_id": 0, "population_idx": 2, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:40:38.541183+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i0_p3_329598789", "generation": 14, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.6368787515006001, "fitness_mode": "correlation", "simplicity_score": 0.1897162416490303, "novelty_bonus": 0.21491187279681978, "total_score": 0.4006512660302486, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and built‑in\n    functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.091891\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    avg_deg = float(s['avg_degree'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    std_deg = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(avg_clust, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(density_adj, 10.0))\n    clustering_adj = max(0.1, min(clustering_adj, 10.0))\n    assort_adj    = max(0.1, min(assort_adj, 10.0))\n    hetero_adj    = max(0.1, min(hetero_adj, 10.0))\n    hub_adj       = max(0.1, min(hub_adj, 10.0))\n    triangle_adj  = max(0.1, min(triangle_adj, 10.0))\n    harmonic_adj  = max(0.1, min(harmonic_adj, 10.0))\n    min_deg_adj   = max(0.1, min(min_deg_adj, 10.0))\n\n    # Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    avg_deg = float(s['avg_degree'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    std_deg = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(avg_clust, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(density_adj, 10.0))\n    clustering_adj = max(0.1, min(clustering_adj, 10.0))\n    assort_adj    = max(0.1, min(assort_adj, 10.0))\n    hetero_adj    = max(0.1, min(hetero_adj, 10.0))\n    hub_adj       = max(0.1, min(hub_adj, 10.0))\n    triangle_adj  = max(0.1, min(triangle_adj, 10.0))\n    harmonic_adj  = max(0.1, min(harmonic_adj, 10.0))\n    min_deg_adj   = max(0.1, min(min_deg_adj, 10.0))\n\n    # Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "spearman": 0.5964689117227931, "pearson": 0.32267285769287385, "rmse": 2.731162131708067, "mae": 2.569228981971275}}
{"timestamp": "2026-02-16T10:41:13.120252+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i0_p4_93238858", "generation": 14, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5742617046818728, "fitness_mode": "correlation", "simplicity_score": 0.1900184737509212, "novelty_bonus": 0.23819387573328976, "total_score": 0.3927469395972244, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and built‑in\n    functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.091891\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  Only built‑in Python functions are used; no external\n    libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.1)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.1)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.5)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.9)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.8)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.7)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.2\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.1\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  Only built‑in Python functions are used; no external\n    libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.1)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.1)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.5)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.9)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.8)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.7)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.2\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.1\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "spearman": 0.5665701642541064, "pearson": 0.3513242043953153, "rmse": 2.5184842111988397, "mae": 2.3378004129723955}}
{"timestamp": "2026-02-16T10:42:26.573043+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i1_p0_849757296", "generation": 14, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14953717349512105, "novelty_bonus": 0.2098132453311331, "total_score": 0.28888455912713484, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T10:43:33.394053+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i1_p1_502503797", "generation": 14, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14957237422515934, "novelty_bonus": 0.2098132453311331, "total_score": 0.28889159927314256, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate based on size and average degree\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T10:44:28.996566+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i1_p2_42503945", "generation": 14, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14957237422515934, "novelty_bonus": 0.2098132453311331, "total_score": 0.28889159927314256, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T10:45:03.737586+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i1_p3_409728232", "generation": 14, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14953717349512105, "novelty_bonus": 0.2098132453311331, "total_score": 0.28888455912713484, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T10:45:53.777870+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i1_p4_243540503", "generation": 14, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14953717349512105, "novelty_bonus": 0.2098132453311331, "total_score": 0.28888455912713484, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (baseline * density_adj * clustering_adj * assort_adj *\n                 hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term)\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (baseline * density_adj * clustering_adj * assort_adj *\n                 hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term)\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T10:46:29.567765+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.069825", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:46:29.568417+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 14, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.069825", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:46:56.684679+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 2, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.055237", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:46:56.685294+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 14, "island_id": 2, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:47:31.227361+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:47:31.228502+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 14, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:48:05.768687+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i2_p1_570424635", "generation": 14, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8849459783913565, "fitness_mode": "correlation", "simplicity_score": 0.21990166475003348, "novelty_bonus": 0.15962145387447446, "total_score": 0.563681064469733, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate follows a simple baseline that grows with the number\n    of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators are used; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    # Dampen the effect with a square‑root\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours; scale up\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.116683\nbelow_novelty_threshold: novelty_bonus=0.069825\nbelow_novelty_threshold: novelty_bonus=0.055237\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    logarithm of the node count and shrinks with the logarithm of the\n    average degree.  It is then progressively adjusted for clustering,\n    assortativity, degree heterogeneity, density, triangle prevalence,\n    and transitivity.  Only built‑in arithmetic and the :mod:`math`\n    module are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        An approximation of the average shortest path length.\n    \"\"\"\n    import math\n\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # ------------------------------------------------------------------\n    # 1. Baseline: log‑scale growth with size, shrinkage with avg degree\n    # ------------------------------------------------------------------\n    base = math.log(n + 1) / (math.log(avg_deg + 2))\n\n    # ------------------------------------------------------------------\n    # 2. Adjustments\n    # ------------------------------------------------------------------\n    # 2a. Clustering increases detours\n    base *= (1 + clustering)\n\n    # 2b. Positive assortativity tends to lengthen paths\n    base *= (1 + abs(assort))\n\n    # 2c. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 2d. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 2e. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 2f. Denser graphs have shorter paths – bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 2g. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 2h. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 2i. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.943628590714768, "pearson": 0.8614449735920473, "rmse": 7.905774164087407, "mae": 4.588158534015637}}
{"timestamp": "2026-02-16T10:48:05.769427+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 14, "island_id": 2, "population_idx": 1, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:48:59.410467+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i2_p2_500235689", "generation": 14, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8397118847539016, "fitness_mode": "correlation", "simplicity_score": 0.21990166475003348, "novelty_bonus": 0.1617027111168341, "total_score": 0.5579947838759968, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate follows a simple baseline that grows with the number\n    of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators are used; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    # Dampen the effect with a square‑root\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours; scale up\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.069825\nbelow_novelty_threshold: novelty_bonus=0.055237\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a compact set of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths – moderate effect\n    base /= (1 + std_deg / (avg_deg + 1e-6))\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – bounded factor\n    density_factor = max(0.05, (1 - density) ** 0.5)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term using degree squares\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a compact set of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths – moderate effect\n    base /= (1 + std_deg / (avg_deg + 1e-6))\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – bounded factor\n    density_factor = max(0.05, (1 - density) ** 0.5)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term using degree squares\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.9310072751818796, "pearson": 0.8913265355987465, "rmse": 17.243660895368205, "mae": 12.54156024332679}}
{"timestamp": "2026-02-16T10:49:35.972841+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.056673", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:49:35.973440+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 14, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.056673", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:50:09.426001+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 2, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.088032", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:50:09.426550+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 14, "island_id": 2, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:50:55.375245+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i2_p4_724471558", "generation": 14, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8879231692677071, "fitness_mode": "correlation", "simplicity_score": 0.22007437900550175, "novelty_bonus": 0.1516762919072976, "total_score": 0.563012850750474, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate follows a simple baseline that grows with the number\n    of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators are used; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    # Dampen the effect with a square‑root\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours; scale up\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.056673\nbelow_novelty_threshold: novelty_bonus=0.088032\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, (1 - density) ** 0.5)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, (1 - density) ** 0.5)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.946990174754369, "pearson": 0.8688108239775192, "rmse": 8.202294945287418, "mae": 4.867208317672224}}
{"timestamp": "2026-02-16T10:51:42.721254+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i3_p0_400234815", "generation": 14, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.802641056422569, "fitness_mode": "correlation", "simplicity_score": 0.22178457158834725, "novelty_bonus": 0.21928390586888258, "total_score": 0.5579347808957047, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph statistics.\n    The expression is a hand‑crafted combination of terms that encode\n    known influences on path length:\n\n    * Size versus connectivity (n / (avg_degree + 1))\n    * Clustering and assortativity act as “detour” factors (multiplicative\n      adjustments > 1)\n    * Degree heterogeneity (high std > 0) shortens paths (division)\n    * Graph density and global transitivity reduce the estimate\n    * The presence of triangles is treated as local shortcuts\n      (division by a factor that grows with the triangle density)\n\n    The function is intentionally written without external imports, using\n    only built‑in arithmetic functions so it can be executed on any\n    compliant Python environment.\n    \"\"\"\n\n    # Cast to float for safety and avoid accidental integer division\n    n            = float(s['n'])\n    avg_deg      = float(s['avg_degree'])\n    std_deg      = float(s['std_degree'])\n    clust        = float(s['avg_clustering'])\n    trans        = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    tri          = float(s['num_triangles'])\n    density      = float(s['density'])\n\n    # --------------------------------------------------------------------\n    # 1. Baseline: larger networks or smaller average degree → longer paths\n    # --------------------------------------------------------------------\n    baseline = n / (avg_deg + 1.0)\n\n    # --------------------------------------------------------------------\n    # 2. Detour multipliers – clustering & assortativity increase typical\n    #    path length by creating more local “dead‑ends” or tightly\n    #    clustered sub‑structures.\n    # --------------------------------------------------------------------\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n\n    # --------------------------------------------------------------------\n    # 3. Degree heterogeneity – a few hubs (large std) create shortcuts\n    #    that lower the average path length.\n    # --------------------------------------------------------------------\n    hetero = 1.0 / (1.0 + std_deg)\n\n    # --------------------------------------------------------------------\n    # 4. Graph density – denser connectivity shortens paths\n    # --------------------------------------------------------------------\n    dens_factor = max(0.05, 1.0 - density)    # keep factor in (0,1]\n\n    # --------------------------------------------------------------------\n    # 5. Triangle‑based shortcut factor – triangles are local shortcuts\n    # --------------------------------------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)      # avoid division by zero\n    tri_ratio    = tri / possible_tri\n    tri_factor   = 1.0 / (1.0 + tri_ratio)\n\n    # --------------------------------------------------------------------\n    # 6. Global transitivity – overall clustering across the network\n    #    further reduces the average path length.\n    # --------------------------------------------------------------------\n    trans_factor = 1.0 + trans\n\n    # --------------------------------------------------------------------\n    # Assemble the final invariant by combining all the factors.\n    # --------------------------------------------------------------------\n    result = baseline * detour * hetero * dens_factor * tri_factor * trans_factor\n\n    return result\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.094594\nbelow_train_threshold: train_signal=0.133061\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only global graph\n    statistics.  The formula combines several structural cues:\n\n    * A baseline n / (avg_degree + 1) that grows with size and shrinks\n      with connectivity.\n    * Multiplicative detour factors for clustering and positive\n      assortativity.\n    * Division by (1 + std_degree) to reflect the shortcut effect of\n      hubs.\n    * A density factor that reduces the estimate for denser graphs.\n    * A triangle‑ratio divisor that shortens paths when triangles are\n      abundant.\n    * A transitivity multiplier that captures global clustering.\n    * Finally, an adjustment with the top three degrees to account for\n      highly connected nodes that can serve as shortcuts.\n\n    The function uses only built‑in operations and no imports or\n    graph traversal algorithms.\n    \"\"\"\n    # Basic scalars ---------------------------------------------------\n    n           = float(s['n'])\n    avg_deg     = float(s['avg_degree'])\n    std_deg     = float(s['std_degree'])\n    clust       = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    dens        = float(s['density'])\n    tri         = float(s['num_triangles'])\n\n    # Baseline --------------------------------------------------------\n    base = n / (avg_deg + 1.0)\n\n    # Clustering and assortativity increase detours ------------------\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # Degree heterogeneity (hubs) shorten paths ----------------------\n    base /= (1.0 + std_deg)\n\n    # Denser graphs have shorter paths --------------------------------\n    dens_factor = max(0.05, 1.0 - dens)\n    base *= dens_factor\n\n    # Triangles provide local shortcuts -------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div/0\n    tri_ratio = tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # Global transitivity reduces path length -------------------------\n    base *= (1.0 + trans)\n\n    # Adjustment with top three degrees (extra local shortcuts) -------\n    top_degrees = sum(s['degrees'][-3:]) if len(s['degrees']) >= 3 else sum(s['degrees'])\n    base /= (1.0 + top_degrees / (n * avg_deg))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only global graph\n    statistics.  The formula combines several structural cues:\n\n    * A baseline n / (avg_degree + 1) that grows with size and shrinks\n      with connectivity.\n    * Multiplicative detour factors for clustering and positive\n      assortativity.\n    * Division by (1 + std_degree) to reflect the shortcut effect of\n      hubs.\n    * A density factor that reduces the estimate for denser graphs.\n    * A triangle‑ratio divisor that shortens paths when triangles are\n      abundant.\n    * A transitivity multiplier that captures global clustering.\n    * Finally, an adjustment with the top three degrees to account for\n      highly connected nodes that can serve as shortcuts.\n\n    The function uses only built‑in operations and no imports or\n    graph traversal algorithms.\n    \"\"\"\n    # Basic scalars ---------------------------------------------------\n    n           = float(s['n'])\n    avg_deg     = float(s['avg_degree'])\n    std_deg     = float(s['std_degree'])\n    clust       = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    dens        = float(s['density'])\n    tri         = float(s['num_triangles'])\n\n    # Baseline --------------------------------------------------------\n    base = n / (avg_deg + 1.0)\n\n    # Clustering and assortativity increase detours ------------------\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # Degree heterogeneity (hubs) shorten paths ----------------------\n    base /= (1.0 + std_deg)\n\n    # Denser graphs have shorter paths --------------------------------\n    dens_factor = max(0.05, 1.0 - dens)\n    base *= dens_factor\n\n    # Triangles provide local shortcuts -------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div/0\n    tri_ratio = tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # Global transitivity reduces path length -------------------------\n    base *= (1.0 + trans)\n\n    # Adjustment with top three degrees (extra local shortcuts) -------\n    top_degrees = sum(s['degrees'][-3:]) if len(s['degrees']) >= 3 else sum(s['degrees'])\n    base /= (1.0 + top_degrees / (n * avg_deg))\n\n    return base", "spearman": 0.895585389634741, "pearson": 0.7979033595465568, "rmse": 2.989062891687626, "mae": 1.7850314866602142}}
{"timestamp": "2026-02-16T10:52:23.139468+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i3_p1_922347790", "generation": 14, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6440816326530613, "fitness_mode": "correlation", "simplicity_score": 0.22211866077003525, "novelty_bonus": 0.15183438878671252, "total_score": 0.421974348797521, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph statistics.\n    The expression is a hand‑crafted combination of terms that encode\n    known influences on path length:\n\n    * Size versus connectivity (n / (avg_degree + 1))\n    * Clustering and assortativity act as “detour” factors (multiplicative\n      adjustments > 1)\n    * Degree heterogeneity (high std > 0) shortens paths (division)\n    * Graph density and global transitivity reduce the estimate\n    * The presence of triangles is treated as local shortcuts\n      (division by a factor that grows with the triangle density)\n\n    The function is intentionally written without external imports, using\n    only built‑in arithmetic functions so it can be executed on any\n    compliant Python environment.\n    \"\"\"\n\n    # Cast to float for safety and avoid accidental integer division\n    n            = float(s['n'])\n    avg_deg      = float(s['avg_degree'])\n    std_deg      = float(s['std_degree'])\n    clust        = float(s['avg_clustering'])\n    trans        = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    tri          = float(s['num_triangles'])\n    density      = float(s['density'])\n\n    # --------------------------------------------------------------------\n    # 1. Baseline: larger networks or smaller average degree → longer paths\n    # --------------------------------------------------------------------\n    baseline = n / (avg_deg + 1.0)\n\n    # --------------------------------------------------------------------\n    # 2. Detour multipliers – clustering & assortativity increase typical\n    #    path length by creating more local “dead‑ends” or tightly\n    #    clustered sub‑structures.\n    # --------------------------------------------------------------------\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n\n    # --------------------------------------------------------------------\n    # 3. Degree heterogeneity – a few hubs (large std) create shortcuts\n    #    that lower the average path length.\n    # --------------------------------------------------------------------\n    hetero = 1.0 / (1.0 + std_deg)\n\n    # --------------------------------------------------------------------\n    # 4. Graph density – denser connectivity shortens paths\n    # --------------------------------------------------------------------\n    dens_factor = max(0.05, 1.0 - density)    # keep factor in (0,1]\n\n    # --------------------------------------------------------------------\n    # 5. Triangle‑based shortcut factor – triangles are local shortcuts\n    # --------------------------------------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)      # avoid division by zero\n    tri_ratio    = tri / possible_tri\n    tri_factor   = 1.0 / (1.0 + tri_ratio)\n\n    # --------------------------------------------------------------------\n    # 6. Global transitivity – overall clustering across the network\n    #    further reduces the average path length.\n    # --------------------------------------------------------------------\n    trans_factor = 1.0 + trans\n\n    # --------------------------------------------------------------------\n    # Assemble the final invariant by combining all the factors.\n    # --------------------------------------------------------------------\n    result = baseline * detour * hetero * dens_factor * tri_factor * trans_factor\n\n    return result\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.094594\nbelow_train_threshold: train_signal=0.133061\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a collection of\n    pre‑computed graph statistics.\n\n    The construction follows these principles:\n\n    1.  The baseline grows with the size of the graph and shrinks\n        when the average degree is large:  n / (avg_degree + 1)\n\n    2.  Clustering introduces detours – we scale the baseline by\n        sqrt(1 + avg_clustering).\n\n    3.  Positive assortativity tends to lengthen paths – we multiply\n        by (1 + |assortativity|).\n\n    4.  Dense graphs are shorter – an exponential decay with the\n        density (approximated via pow(e, -density * 10)).\n\n    5.  Heterogeneity (high degree standard deviation) shortens\n        paths – we divide by (1 + std_degree).\n\n    6.  A wide degree spread increases detours – we multiply by\n        (min_degree+1)/(max_degree+1).\n\n    7.  Triangles provide local shortcuts – we divide by\n        (1 + triangle_ratio) where triangle_ratio is the density of\n        triangles in the graph.\n\n    8.  Global transitivity (overall clustering) further reduces\n        the average path length – we divide by (1 + transitivity).\n\n    All operations are implemented with built‑in arithmetic to avoid\n    external imports and to guarantee portability.\n    \"\"\"\n\n    # --- constants ---------------------------------------------------\n    e = 2.718281828459045  # base of natural logarithm\n\n    # --- cast to float for safety ------------------------------------\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    density    = float(s['density'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    trans      = float(s['transitivity'])\n\n    # --- baseline ----------------------------------------------------\n    base = n / (avg_deg + 1.0)\n\n    # --- detour from clustering --------------------------------------\n    base *= pow(1.0 + clust, 0.5)\n\n    # --- assortativity detour ----------------------------------------\n    base *= (1.0 + abs(assort))\n\n    # --- density effect ---------------------------------------------\n    base *= pow(e, -density * 10.0)\n\n    # --- heterogeneity (hubs) ----------------------------------------\n    base /= (1.0 + std_deg)\n\n    # --- degree spread effect ----------------------------------------\n    base *= (min_deg + 1.0) / (max_deg + 1.0)\n\n    # --- triangle shortcut factor ------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)\n    tri_ratio = tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # --- global transitivity effect ----------------------------------\n    base /= (1.0 + trans)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a collection of\n    pre‑computed graph statistics.\n\n    The construction follows these principles:\n\n    1.  The baseline grows with the size of the graph and shrinks\n        when the average degree is large:  n / (avg_degree + 1)\n\n    2.  Clustering introduces detours – we scale the baseline by\n        sqrt(1 + avg_clustering).\n\n    3.  Positive assortativity tends to lengthen paths – we multiply\n        by (1 + |assortativity|).\n\n    4.  Dense graphs are shorter – an exponential decay with the\n        density (approximated via pow(e, -density * 10)).\n\n    5.  Heterogeneity (high degree standard deviation) shortens\n        paths – we divide by (1 + std_degree).\n\n    6.  A wide degree spread increases detours – we multiply by\n        (min_degree+1)/(max_degree+1).\n\n    7.  Triangles provide local shortcuts – we divide by\n        (1 + triangle_ratio) where triangle_ratio is the density of\n        triangles in the graph.\n\n    8.  Global transitivity (overall clustering) further reduces\n        the average path length – we divide by (1 + transitivity).\n\n    All operations are implemented with built‑in arithmetic to avoid\n    external imports and to guarantee portability.\n    \"\"\"\n\n    # --- constants ---------------------------------------------------\n    e = 2.718281828459045  # base of natural logarithm\n\n    # --- cast to float for safety ------------------------------------\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    density    = float(s['density'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    trans      = float(s['transitivity'])\n\n    # --- baseline ----------------------------------------------------\n    base = n / (avg_deg + 1.0)\n\n    # --- detour from clustering --------------------------------------\n    base *= pow(1.0 + clust, 0.5)\n\n    # --- assortativity detour ----------------------------------------\n    base *= (1.0 + abs(assort))\n\n    # --- density effect ---------------------------------------------\n    base *= pow(e, -density * 10.0)\n\n    # --- heterogeneity (hubs) ----------------------------------------\n    base /= (1.0 + std_deg)\n\n    # --- degree spread effect ----------------------------------------\n    base *= (min_deg + 1.0) / (max_deg + 1.0)\n\n    # --- triangle shortcut factor ------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)\n    tri_ratio = tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # --- global transitivity effect ----------------------------------\n    base /= (1.0 + trans)\n\n    return base", "spearman": 0.6640006000150004, "pearson": 0.44767121413193234, "rmse": 2.5431850150786084, "mae": 2.386442717848529}}
{"timestamp": "2026-02-16T10:53:08.808421+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.053296", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:53:08.809429+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 14, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.053296", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:53:45.743617+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i3_p2_384755507", "generation": 14, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6311164465786315, "fitness_mode": "correlation", "simplicity_score": 0.19353764054510608, "novelty_bonus": 0.23108187517820844, "total_score": 0.5167915596492085, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph statistics.\n    The expression is a hand‑crafted combination of terms that encode\n    known influences on path length:\n\n    * Size versus connectivity (n / (avg_degree + 1))\n    * Clustering and assortativity act as “detour” factors (multiplicative\n      adjustments > 1)\n    * Degree heterogeneity (high std > 0) shortens paths (division)\n    * Graph density and global transitivity reduce the estimate\n    * The presence of triangles is treated as local shortcuts\n      (division by a factor that grows with the triangle density)\n\n    The function is intentionally written without external imports, using\n    only built‑in arithmetic functions so it can be executed on any\n    compliant Python environment.\n    \"\"\"\n\n    # Cast to float for safety and avoid accidental integer division\n    n            = float(s['n'])\n    avg_deg      = float(s['avg_degree'])\n    std_deg      = float(s['std_degree'])\n    clust        = float(s['avg_clustering'])\n    trans        = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    tri          = float(s['num_triangles'])\n    density      = float(s['density'])\n\n    # --------------------------------------------------------------------\n    # 1. Baseline: larger networks or smaller average degree → longer paths\n    # --------------------------------------------------------------------\n    baseline = n / (avg_deg + 1.0)\n\n    # --------------------------------------------------------------------\n    # 2. Detour multipliers – clustering & assortativity increase typical\n    #    path length by creating more local “dead‑ends” or tightly\n    #    clustered sub‑structures.\n    # --------------------------------------------------------------------\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n\n    # --------------------------------------------------------------------\n    # 3. Degree heterogeneity – a few hubs (large std) create shortcuts\n    #    that lower the average path length.\n    # --------------------------------------------------------------------\n    hetero = 1.0 / (1.0 + std_deg)\n\n    # --------------------------------------------------------------------\n    # 4. Graph density – denser connectivity shortens paths\n    # --------------------------------------------------------------------\n    dens_factor = max(0.05, 1.0 - density)    # keep factor in (0,1]\n\n    # --------------------------------------------------------------------\n    # 5. Triangle‑based shortcut factor – triangles are local shortcuts\n    # --------------------------------------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)      # avoid division by zero\n    tri_ratio    = tri / possible_tri\n    tri_factor   = 1.0 / (1.0 + tri_ratio)\n\n    # --------------------------------------------------------------------\n    # 6. Global transitivity – overall clustering across the network\n    #    further reduces the average path length.\n    # --------------------------------------------------------------------\n    trans_factor = 1.0 + trans\n\n    # --------------------------------------------------------------------\n    # Assemble the final invariant by combining all the factors.\n    # --------------------------------------------------------------------\n    result = baseline * detour * hetero * dens_factor * tri_factor * trans_factor\n\n    return result\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.094594\nbelow_train_threshold: train_signal=0.133061\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.053296\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest‑path length using only global graph statistics.\n    The expression is a combination of several structural cues:\n\n    * A baseline that grows with the number of nodes and shrinks with the average degree.\n    * Multiplicative “detour” factors from clustering, assortativity, and degree heterogeneity.\n    * Factors that shorten paths in dense, triangle‑rich, or heterogeneous‑degree graphs.\n    * A final adjustment that rewards large degree dispersion.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics. Keys must include:\n        - 'n'            : number of nodes\n        - 'm'            : number of edges\n        - 'density'      : edge density\n        - 'avg_degree'   : mean degree\n        - 'max_degree'   : maximum degree\n        - 'min_degree'   : minimum degree\n        - 'std_degree'   : degree standard deviation\n        - 'avg_clustering' : average local clustering coefficient\n        - 'transitivity'   : global transitivity (network clustering)\n        - 'degree_assortativity' : degree assortativity coefficient\n        - 'num_triangles'   : number of triangles\n        - 'degrees' : sorted list of degrees (unused in this formula)\n\n    Returns\n    -------\n    float\n        An invariant estimate of the average shortest‑path length.\n    \"\"\"\n    # --- cast to float for safety ------------------------------------\n    n            = float(s['n'])\n    avg_deg      = float(s['avg_degree'])\n    std_deg      = float(s['std_degree'])\n    clust        = float(s['avg_clustering'])\n    trans        = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    tri          = float(s['num_triangles'])\n    density      = float(s['density'])\n    max_deg      = float(s['max_degree'])\n    min_deg      = float(s['min_degree'])\n\n    # --- baseline: larger networks or lower average degree give longer paths ---\n    base = n / (avg_deg + 1.0)\n\n    # --- clustering detour (more clustered ⇒ longer detours) ----------------\n    cluster_factor = 1.0 + 0.5 * clust\n\n    # --- assortativity detour (positive assortativity tends to elongate paths) ---\n    assort_factor = 1.0 + 0.3 * abs(assort)\n\n    # --- degree heterogeneity (hubs shorten paths) ---------------------------\n    hetero_factor = 1.0 / (1.0 + 0.4 * std_deg)\n\n    # --- density factor (denser graphs short paths) --------------------------\n    density_factor = 1.0 - 0.4 * density\n    density_factor = max(0.1, density_factor)   # keep in a sane range\n\n    # --- triangle shortcut factor -------------------------------------------\n    max_possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    max_possible_tri = max(1.0, max_possible_tri)\n    tri_ratio = tri / max_possible_tri\n    tri_factor = 1.0 / (1.0 + 0.5 * tri_ratio)\n\n    # --- global transitivity adjustment --------------------------------------\n    trans_factor = 1.0 + 0.3 * trans\n\n    # --- size heterogeneity (max/min degree spread) --------------------------\n    size_factor = 1.0 + (max_deg - min_deg) / (avg_deg + 1.0)\n\n    # --- final invariant ------------------------------------------------------\n    result = (base * cluster_factor * assort_factor * hetero_factor *\n              density_factor * tri_factor * trans_factor * size_factor)\n\n    return result\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from only global statistics.\n\n    The formula combines several intuitive trends that affect path length:\n\n    1.  Baseline length grows with network size (n) and shrinks with mean degree.\n    2.  Highly clustered, assortative or tightly knit graphs tend to\n        create “dead‑ends” that lengthen typical routes.\n    3.  Degree heterogeneity (large std) shortens paths through hubs.\n    4.  Dense connectivity, many triangles and global transitivity\n        provide shortcuts, thus reducing the estimate.\n    5.  A small penalty for a large spread between maximum and minimum\n        degrees encourages more balanced graphs to have longer paths.\n\n    No graph traversal is performed; only the pre‑computed features in `s`\n    are used.  All arithmetic is safe from division‑by‑zero and uses only\n    built‑in Python operators.\n\n    Parameters\n    ----------\n    s : dict\n        Feature dictionary with keys:\n        'n', 'm', 'density', 'avg_degree', 'max_degree', 'min_degree',\n        'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'num_triangles', 'degrees'.\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # --- Pull and cast all relevant scalars --------------------------------\n    n             = float(s['n'])\n    avg_deg       = float(s['avg_degree'])\n    std_deg       = float(s['std_degree'])\n    clust         = float(s['avg_clustering'])\n    trans         = float(s['transitivity'])\n    assort        = float(s['degree_assortativity'])\n    tri           = float(s['num_triangles'])\n    density       = float(s['density'])\n    max_deg       = float(s['max_degree'])\n    min_deg       = float(s['min_degree'])\n\n    # --- Baseline: size over connectivity ----------------------------------\n    base = n / (avg_deg + 1.0)                    # +1 avoids division by zero\n\n    # --- “Detour” factors: clustering, assortativity, degree spread --------\n    cluster_factor = 1.0 + clust ** 0.5              # sqrt → sub‑linear growth\n    assort_factor  = 1.0 + abs(assort) ** 0.5\n    size_factor    = 1.0 + (max_deg / (min_deg + 1.0)) ** 0.3\n\n    # --- Heterogeneity factor (hubs reduce paths) --------------------------\n    hetero_factor  = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # --- Density shortcut factor -------------------------------------------\n    dens_factor = 1.0 / (1.0 + 0.8 * density)        # denser → smaller\n\n    # --- Triangle shortcut factor -----------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)            # avoid zero division\n    tri_ratio    = tri / possible_tri\n    tri_factor   = 1.0 / (1.0 + 0.5 * tri_ratio)\n\n    # --- Transitivity factor ----------------------------------------------\n    trans_factor = 1.0 + trans ** 0.4\n\n    # --- Assemble ----------------------------------------------------------\n    result = (base *\n              cluster_factor *\n              assort_factor *\n              hetero_factor *\n              dens_factor *\n              tri_factor *\n              trans_factor *\n              size_factor)\n\n    return result\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from only global statistics.\n\n    The formula combines several intuitive trends that affect path length:\n\n    1.  Baseline length grows with network size (n) and shrinks with mean degree.\n    2.  Highly clustered, assortative or tightly knit graphs tend to\n        create “dead‑ends” that lengthen typical routes.\n    3.  Degree heterogeneity (large std) shortens paths through hubs.\n    4.  Dense connectivity, many triangles and global transitivity\n        provide shortcuts, thus reducing the estimate.\n    5.  A small penalty for a large spread between maximum and minimum\n        degrees encourages more balanced graphs to have longer paths.\n\n    No graph traversal is performed; only the pre‑computed features in `s`\n    are used.  All arithmetic is safe from division‑by‑zero and uses only\n    built‑in Python operators.\n\n    Parameters\n    ----------\n    s : dict\n        Feature dictionary with keys:\n        'n', 'm', 'density', 'avg_degree', 'max_degree', 'min_degree',\n        'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'num_triangles', 'degrees'.\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # --- Pull and cast all relevant scalars --------------------------------\n    n             = float(s['n'])\n    avg_deg       = float(s['avg_degree'])\n    std_deg       = float(s['std_degree'])\n    clust         = float(s['avg_clustering'])\n    trans         = float(s['transitivity'])\n    assort        = float(s['degree_assortativity'])\n    tri           = float(s['num_triangles'])\n    density       = float(s['density'])\n    max_deg       = float(s['max_degree'])\n    min_deg       = float(s['min_degree'])\n\n    # --- Baseline: size over connectivity ----------------------------------\n    base = n / (avg_deg + 1.0)                    # +1 avoids division by zero\n\n    # --- “Detour” factors: clustering, assortativity, degree spread --------\n    cluster_factor = 1.0 + clust ** 0.5              # sqrt → sub‑linear growth\n    assort_factor  = 1.0 + abs(assort) ** 0.5\n    size_factor    = 1.0 + (max_deg / (min_deg + 1.0)) ** 0.3\n\n    # --- Heterogeneity factor (hubs reduce paths) --------------------------\n    hetero_factor  = 1.0 / (1.0 + std_deg / (avg_deg + 1.0))\n\n    # --- Density shortcut factor -------------------------------------------\n    dens_factor = 1.0 / (1.0 + 0.8 * density)        # denser → smaller\n\n    # --- Triangle shortcut factor -----------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)            # avoid zero division\n    tri_ratio    = tri / possible_tri\n    tri_factor   = 1.0 / (1.0 + 0.5 * tri_ratio)\n\n    # --- Transitivity factor ----------------------------------------------\n    trans_factor = 1.0 + trans ** 0.4\n\n    # --- Assemble ----------------------------------------------------------\n    result = (base *\n              cluster_factor *\n              assort_factor *\n              hetero_factor *\n              dens_factor *\n              tri_factor *\n              trans_factor *\n              size_factor)\n\n    return result", "spearman": 0.8175189379734494, "pearson": 0.8175525636313068, "rmse": 46.10968897012344, "mae": 40.62994462137224}}
{"timestamp": "2026-02-16T10:53:45.744401+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 14, "island_id": 3, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:54:13.688006+00:00", "event_type": "candidate_rejected", "payload": {"generation": 14, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:54:13.688489+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 14, "island_id": 3, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:54:41.879822+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i3_p3_997176936", "generation": 14, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6987274909963985, "fitness_mode": "correlation", "simplicity_score": 0.1566048041021667, "novelty_bonus": 0.21998827711634383, "total_score": 0.5229478347151055, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph statistics.\n    The expression is a hand‑crafted combination of terms that encode\n    known influences on path length:\n\n    * Size versus connectivity (n / (avg_degree + 1))\n    * Clustering and assortativity act as “detour” factors (multiplicative\n      adjustments > 1)\n    * Degree heterogeneity (high std > 0) shortens paths (division)\n    * Graph density and global transitivity reduce the estimate\n    * The presence of triangles is treated as local shortcuts\n      (division by a factor that grows with the triangle density)\n\n    The function is intentionally written without external imports, using\n    only built‑in arithmetic functions so it can be executed on any\n    compliant Python environment.\n    \"\"\"\n\n    # Cast to float for safety and avoid accidental integer division\n    n            = float(s['n'])\n    avg_deg      = float(s['avg_degree'])\n    std_deg      = float(s['std_degree'])\n    clust        = float(s['avg_clustering'])\n    trans        = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    tri          = float(s['num_triangles'])\n    density      = float(s['density'])\n\n    # --------------------------------------------------------------------\n    # 1. Baseline: larger networks or smaller average degree → longer paths\n    # --------------------------------------------------------------------\n    baseline = n / (avg_deg + 1.0)\n\n    # --------------------------------------------------------------------\n    # 2. Detour multipliers – clustering & assortativity increase typical\n    #    path length by creating more local “dead‑ends” or tightly\n    #    clustered sub‑structures.\n    # --------------------------------------------------------------------\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n\n    # --------------------------------------------------------------------\n    # 3. Degree heterogeneity – a few hubs (large std) create shortcuts\n    #    that lower the average path length.\n    # --------------------------------------------------------------------\n    hetero = 1.0 / (1.0 + std_deg)\n\n    # --------------------------------------------------------------------\n    # 4. Graph density – denser connectivity shortens paths\n    # --------------------------------------------------------------------\n    dens_factor = max(0.05, 1.0 - density)    # keep factor in (0,1]\n\n    # --------------------------------------------------------------------\n    # 5. Triangle‑based shortcut factor – triangles are local shortcuts\n    # --------------------------------------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)      # avoid division by zero\n    tri_ratio    = tri / possible_tri\n    tri_factor   = 1.0 / (1.0 + tri_ratio)\n\n    # --------------------------------------------------------------------\n    # 6. Global transitivity – overall clustering across the network\n    #    further reduces the average path length.\n    # --------------------------------------------------------------------\n    trans_factor = 1.0 + trans\n\n    # --------------------------------------------------------------------\n    # Assemble the final invariant by combining all the factors.\n    # --------------------------------------------------------------------\n    result = baseline * detour * hetero * dens_factor * tri_factor * trans_factor\n\n    return result\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.094594\nbelow_train_threshold: train_signal=0.133061\nbelow_novelty_threshold: novelty_bonus=0.053296\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics.\n\n    The expression is a hand‑crafted combination of features that are\n    known to influence path length in undirected graphs.  The formula\n    is deliberately compact, numerically safe, and interpretable:\n\n    1. Baseline : n / (avg_degree + 1)\n    2. Clustering detour : * (1 + avg_clustering)\n    3. Assortativity detour : * (1 + |degree_assortativity|**2)\n    4. Degree heterogeneity shortcut : * exp(- std_degree / max_degree)\n    5. Density shortcut : * (1 - density + ε)   (ε ≈ 1e-9)\n    6. Triangle density shortcut : / (1 + log(num_triangles + 1))\n    7. Global transitivity shortcut : * (1 + transitivity)\n\n    All divisions are protected against zero by adding a tiny constant.\n    The function does **not** use any graph‑algorithm libraries and\n    returns a floating‑point estimate that can be used as an invariant\n    for the target average_shortest_path_length.\n    \"\"\"\n    import math\n\n    eps = 1e-9  # small constant to avoid zero division / log(0)\n\n    n            = float(s.get('n', 0))\n    avg_deg      = float(s.get('avg_degree', 0))\n    std_deg      = float(s.get('std_degree', 0))\n    max_deg      = float(s.get('max_degree', 1))   # fallback to 1 to avoid div/0\n    avg_clust    = float(s.get('avg_clustering', 0))\n    assort       = float(s.get('degree_assortativity', 0))\n    density      = float(s.get('density', 0))\n    num_tri      = float(s.get('num_triangles', 0))\n    trans        = float(s.get('transitivity', 0))\n\n    # 1. Baseline\n    baseline = n / (avg_deg + 1.0)\n\n    # 2. Clustering detour\n    detour_clust = 1.0 + avg_clust\n\n    # 3. Assortativity detour (squared magnitude to emphasise sign‑independent effect)\n    detour_assort = 1.0 + abs(assort)**2\n\n    # 4. Degree heterogeneity shortcut via exponential decay\n    hetero_factor = math.exp(- std_deg / (max_deg + eps))\n\n    # 5. Density shortcut\n    density_factor = max(0.05, 1.0 - density)  # keep in a sensible range\n\n    # 6. Triangle density shortcut\n    tri_ratio = num_tri / (n * (n - 1.0) * (n - 2.0) / 6.0 + eps)\n    tri_factor = 1.0 / (1.0 + math.log(tri_ratio + 1.0))\n\n    # 7. Global transitivity shortcut\n    trans_factor = 1.0 + trans\n\n    # Assemble the final estimate\n    estimate = (\n        baseline\n        * detour_clust\n        * detour_assort\n        * hetero_factor\n        * density_factor\n        * tri_factor\n        * trans_factor\n    )\n\n    return float(estimate)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from only global graph statistics.\n    The expression combines well‑known influences on path length while staying\n    fully self‑contained (no external imports).  All divisions are protected\n    against zero and the resulting value is a single floating‑point number.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features (see problem statement for keys).\n\n    Returns\n    -------\n    float\n        An invariant approximating the average shortest‑path length.\n    \"\"\"\n    # Small constant to avoid division by zero\n    eps = 1e-9\n\n    n          = float(s.get('n', 0))\n    avg_deg    = float(s.get('avg_degree', 0))\n    std_deg    = float(s.get('std_degree', 0))\n    max_deg    = float(s.get('max_degree', 1))  # avoid division by zero\n    avg_clust  = float(s.get('avg_clustering', 0))\n    assort     = float(s.get('degree_assortativity', 0))\n    density    = float(s.get('density', 0))\n    num_tri    = float(s.get('num_triangles', 0))\n\n    # ---------- 1. Baseline ----------\n    baseline = n / (avg_deg + 1.0)\n\n    # ---------- 2. Clustering detour ----------\n    detour_clust = 1.0 + avg_clust\n\n    # ---------- 3. Assortativity detour ----------\n    detour_assort = 1.0 + abs(assort)\n\n    # ---------- 4. Degree heterogeneity shortcut ----------\n    hetero_factor = 1.0 / (1.0 + std_deg / (max_deg + eps))\n\n    # ---------- 5. Density shortcut ----------\n    density_factor = max(0.05, 1.0 - density)\n\n    # ---------- 6. Triangle density shortcut ----------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div by zero\n    tri_ratio    = num_tri / (possible_tri + eps)\n    tri_factor   = 1.0 / (1.0 + tri_ratio)\n\n    # ---------- 7. Global transitivity shortcut ----------\n    trans_factor = 1.0 + float(s.get('transitivity', 0))\n\n    # ---------- Assemble ----------\n    estimate = (\n        baseline *\n        detour_clust *\n        detour_assort *\n        hetero_factor *\n        density_factor *\n        tri_factor *\n        trans_factor\n    )\n\n    return float(estimate)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from only global graph statistics.\n    The expression combines well‑known influences on path length while staying\n    fully self‑contained (no external imports).  All divisions are protected\n    against zero and the resulting value is a single floating‑point number.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features (see problem statement for keys).\n\n    Returns\n    -------\n    float\n        An invariant approximating the average shortest‑path length.\n    \"\"\"\n    # Small constant to avoid division by zero\n    eps = 1e-9\n\n    n          = float(s.get('n', 0))\n    avg_deg    = float(s.get('avg_degree', 0))\n    std_deg    = float(s.get('std_degree', 0))\n    max_deg    = float(s.get('max_degree', 1))  # avoid division by zero\n    avg_clust  = float(s.get('avg_clustering', 0))\n    assort     = float(s.get('degree_assortativity', 0))\n    density    = float(s.get('density', 0))\n    num_tri    = float(s.get('num_triangles', 0))\n\n    # ---------- 1. Baseline ----------\n    baseline = n / (avg_deg + 1.0)\n\n    # ---------- 2. Clustering detour ----------\n    detour_clust = 1.0 + avg_clust\n\n    # ---------- 3. Assortativity detour ----------\n    detour_assort = 1.0 + abs(assort)\n\n    # ---------- 4. Degree heterogeneity shortcut ----------\n    hetero_factor = 1.0 / (1.0 + std_deg / (max_deg + eps))\n\n    # ---------- 5. Density shortcut ----------\n    density_factor = max(0.05, 1.0 - density)\n\n    # ---------- 6. Triangle density shortcut ----------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div by zero\n    tri_ratio    = num_tri / (possible_tri + eps)\n    tri_factor   = 1.0 / (1.0 + tri_ratio)\n\n    # ---------- 7. Global transitivity shortcut ----------\n    trans_factor = 1.0 + float(s.get('transitivity', 0))\n\n    # ---------- Assemble ----------\n    estimate = (\n        baseline *\n        detour_clust *\n        detour_assort *\n        hetero_factor *\n        density_factor *\n        tri_factor *\n        trans_factor\n    )\n\n    return float(estimate)", "spearman": 0.8512607815195381, "pearson": 0.8562150588765176, "rmse": 10.98637362666515, "mae": 8.965219119529733}}
{"timestamp": "2026-02-16T10:54:41.881575+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 14, "island_id": 3, "population_idx": 3, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:55:18.846583+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g14_i3_p4_984758234", "generation": 14, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.7066026410564226, "fitness_mode": "correlation", "simplicity_score": 0.2223273988983509, "novelty_bonus": 0.19637740943523563, "total_score": 0.544985242773745, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph statistics.\n    The expression is a hand‑crafted combination of terms that encode\n    known influences on path length:\n\n    * Size versus connectivity (n / (avg_degree + 1))\n    * Clustering and assortativity act as “detour” factors (multiplicative\n      adjustments > 1)\n    * Degree heterogeneity (high std > 0) shortens paths (division)\n    * Graph density and global transitivity reduce the estimate\n    * The presence of triangles is treated as local shortcuts\n      (division by a factor that grows with the triangle density)\n\n    The function is intentionally written without external imports, using\n    only built‑in arithmetic functions so it can be executed on any\n    compliant Python environment.\n    \"\"\"\n\n    # Cast to float for safety and avoid accidental integer division\n    n            = float(s['n'])\n    avg_deg      = float(s['avg_degree'])\n    std_deg      = float(s['std_degree'])\n    clust        = float(s['avg_clustering'])\n    trans        = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    tri          = float(s['num_triangles'])\n    density      = float(s['density'])\n\n    # --------------------------------------------------------------------\n    # 1. Baseline: larger networks or smaller average degree → longer paths\n    # --------------------------------------------------------------------\n    baseline = n / (avg_deg + 1.0)\n\n    # --------------------------------------------------------------------\n    # 2. Detour multipliers – clustering & assortativity increase typical\n    #    path length by creating more local “dead‑ends” or tightly\n    #    clustered sub‑structures.\n    # --------------------------------------------------------------------\n    detour = (1.0 + clust) * (1.0 + abs(assort))\n\n    # --------------------------------------------------------------------\n    # 3. Degree heterogeneity – a few hubs (large std) create shortcuts\n    #    that lower the average path length.\n    # --------------------------------------------------------------------\n    hetero = 1.0 / (1.0 + std_deg)\n\n    # --------------------------------------------------------------------\n    # 4. Graph density – denser connectivity shortens paths\n    # --------------------------------------------------------------------\n    dens_factor = max(0.05, 1.0 - density)    # keep factor in (0,1]\n\n    # --------------------------------------------------------------------\n    # 5. Triangle‑based shortcut factor – triangles are local shortcuts\n    # --------------------------------------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)      # avoid division by zero\n    tri_ratio    = tri / possible_tri\n    tri_factor   = 1.0 / (1.0 + tri_ratio)\n\n    # --------------------------------------------------------------------\n    # 6. Global transitivity – overall clustering across the network\n    #    further reduces the average path length.\n    # --------------------------------------------------------------------\n    trans_factor = 1.0 + trans\n\n    # --------------------------------------------------------------------\n    # Assemble the final invariant by combining all the factors.\n    # --------------------------------------------------------------------\n    result = baseline * detour * hetero * dens_factor * tri_factor * trans_factor\n\n    return result\nRecent failures:\nbelow_train_threshold: train_signal=0.133061\nbelow_novelty_threshold: novelty_bonus=0.053296\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a handful of global graph statistics.\n    The formula combines several intuitive structural effects:\n    • The raw size versus average degree (larger, sparser graphs → longer paths).\n    • A contrast between the largest and smallest degrees (hub‑rich networks shorten paths).\n    • Clustering and assortativity tend to create detours (increase path length).\n    • High degree heterogeneity (large std) shortens paths.\n    • Greater density, triangles, and global transitivity all reduce the expected path length.\n    All operations use only basic arithmetic and built‑in Python functions; no imports are required.\n    \"\"\"\n\n    # ---- Cast all relevant features to float for numerical stability ----\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n\n    # ---- 1. Baseline: size vs connectivity ---------------------------------\n    base = n / (avg_deg + 1.0)\n\n    # ---- 2. Effect of extreme degrees (hubs vs isolated nodes) ------------\n    base *= (max_deg + 1.0) / (min_deg + 1.0)\n\n    # ---- 3. Clustering and assortativity create detours --------------------\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # ---- 4. High degree variance shortens paths ----------------------------\n    base /= (1.0 + std_deg)\n\n    # ---- 5. Graph density reduces expected length --------------------------\n    dens_factor = max(0.05, 1.0 - density)      # keep factor positive and <=1\n    base *= dens_factor\n\n    # ---- 6. Triangles are local shortcuts ---------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)       # avoid div‑by‑zero\n    tri_ratio = tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # ---- 7. Global transitivity (overall clustering) shortens paths --------\n    base *= (1.0 + trans)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a handful of global graph statistics.\n    The formula combines several intuitive structural effects:\n    • The raw size versus average degree (larger, sparser graphs → longer paths).\n    • A contrast between the largest and smallest degrees (hub‑rich networks shorten paths).\n    • Clustering and assortativity tend to create detours (increase path length).\n    • High degree heterogeneity (large std) shortens paths.\n    • Greater density, triangles, and global transitivity all reduce the expected path length.\n    All operations use only basic arithmetic and built‑in Python functions; no imports are required.\n    \"\"\"\n\n    # ---- Cast all relevant features to float for numerical stability ----\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    tri        = float(s['num_triangles'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n\n    # ---- 1. Baseline: size vs connectivity ---------------------------------\n    base = n / (avg_deg + 1.0)\n\n    # ---- 2. Effect of extreme degrees (hubs vs isolated nodes) ------------\n    base *= (max_deg + 1.0) / (min_deg + 1.0)\n\n    # ---- 3. Clustering and assortativity create detours --------------------\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # ---- 4. High degree variance shortens paths ----------------------------\n    base /= (1.0 + std_deg)\n\n    # ---- 5. Graph density reduces expected length --------------------------\n    dens_factor = max(0.05, 1.0 - density)      # keep factor positive and <=1\n    base *= dens_factor\n\n    # ---- 6. Triangles are local shortcuts ---------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)       # avoid div‑by‑zero\n    tri_ratio = tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # ---- 7. Global transitivity (overall clustering) shortens paths --------\n    base *= (1.0 + trans)\n\n    return base", "spearman": 0.8832130803270083, "pearson": 0.8011705911038051, "rmse": 24.41482222756521, "mae": 16.640462097904344}}
{"timestamp": "2026-02-16T10:55:18.849525+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 15, "model_name": "gpt-oss:20b", "best_val_score": 0.5655869739267355, "no_improve_count": 2}}
{"timestamp": "2026-02-16T10:56:08.908683+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i0_p0_549031750", "generation": 15, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.506842737094838, "fitness_mode": "correlation", "simplicity_score": 0.1900184737509212, "novelty_bonus": 0.26556120696794405, "total_score": 0.377719308021847, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and built‑in\n    functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.091891\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  Only built‑in Python functions are used; no external\n    libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.1)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.1)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.5)           # assortative → longer paths\n    hetero_adj    = 1 - pow(std_deg / (avg_deg + eps), 0.7)  # heterogeneity → shorter paths\n    hub_adj       = 1 - pow(max_deg / (n - 1 + eps), 0.6)   # hubs → shorter paths\n    triangle_adj  = 1 - pow(num_tri / (n * (n - 1) / 2 + eps), 0.5)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  Only built‑in Python functions are used; no external\n    libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.1)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.1)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.5)           # assortative → longer paths\n    hetero_adj    = 1 - pow(std_deg / (avg_deg + eps), 0.7)  # heterogeneity → shorter paths\n    hub_adj       = 1 - pow(max_deg / (n - 1 + eps), 0.6)   # hubs → shorter paths\n    triangle_adj  = 1 - pow(num_tri / (n * (n - 1) / 2 + eps), 0.5)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "spearman": 0.5200945023625592, "pearson": 0.3753682944473076, "rmse": 2.378270006135042, "mae": 2.1956008458462537}}
{"timestamp": "2026-02-16T10:56:44.552494+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:56:44.554084+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 15, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:57:15.364602+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:57:15.365588+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 15, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:58:03.173853+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i0_p2_147373253", "generation": 15, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.6368787515006001, "fitness_mode": "correlation", "simplicity_score": 0.1900184737509212, "novelty_bonus": 0.21491187279681978, "total_score": 0.40071171245062676, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and built‑in\n    functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.091891\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and\n    built‑in functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and\n    built‑in functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "spearman": 0.5964689117227931, "pearson": 0.32267285769287385, "rmse": 2.731162131708067, "mae": 2.569228981971275}}
{"timestamp": "2026-02-16T10:59:08.062231+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:59:08.062827+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 15, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:59:33.524045+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T10:59:33.525112+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 15, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:00:19.024014+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.132734", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:00:19.025537+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 15, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.132734", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:00:56.842368+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 0, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:00:56.843567+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 15, "island_id": 0, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:01:41.082621+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:01:41.084483+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 15, "island_id": 1, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:02:16.408610+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i1_p0_661159474", "generation": 15, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14957237422515934, "novelty_bonus": 0.2098132453311331, "total_score": 0.28889159927314256, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.024806\nbelow_novelty_threshold: novelty_bonus=0.138564\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: code must define exactly one function named `new_invariant`\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    def clamp(x):\n        return max(0.1, min(10, x))\n    density_adj   = clamp(density_adj)\n    clustering_adj = clamp(clustering_adj)\n    assort_adj    = clamp(assort_adj)\n    hetero_adj    = clamp(hetero_adj)\n    hub_adj       = clamp(hub_adj)\n    triangle_adj  = clamp(triangle_adj)\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n ** 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n ** 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T11:02:16.409275+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 15, "island_id": 1, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:03:01.959431+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:03:01.960125+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 15, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:03:46.463603+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 1, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:03:46.464646+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 15, "island_id": 1, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:04:50.913229+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i1_p2_717602995", "generation": 15, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14957237422515934, "novelty_bonus": 0.2098132453311331, "total_score": 0.28889159927314256, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T11:06:36.704805+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i1_p3_455838720", "generation": 15, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14957237422515934, "novelty_bonus": 0.2098132453311331, "total_score": 0.28889159927314256, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T11:07:13.341349+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i1_p4_159754052", "generation": 15, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14957237422515934, "novelty_bonus": 0.2098132453311331, "total_score": 0.28889159927314256, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components into numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components into numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T11:07:59.622689+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i2_p0_198680246", "generation": 15, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8796638655462184, "fitness_mode": "correlation", "simplicity_score": 0.21980506886437962, "novelty_bonus": 0.15783832716040103, "total_score": 0.559180958632164, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate follows a simple baseline that grows with the number\n    of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators are used; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    # Dampen the effect with a square‑root\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.056673\nbelow_novelty_threshold: novelty_bonus=0.088032\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a set of\n    pre‑computed graph statistics.\n\n    The estimate starts with a baseline that grows with the number\n    of nodes and shrinks with the average degree.  It is then\n    successively adjusted for clustering, assortativity,\n    degree heterogeneity, leaves, hubs, density, triangle\n    prevalence, transitivity and a variance correction.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density ** 0.5)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / (possible_tri if possible_tri > 0 else 1)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a set of\n    pre‑computed graph statistics.\n\n    The estimate starts with a baseline that grows with the number\n    of nodes and shrinks with the average degree.  It is then\n    successively adjusted for clustering, assortativity,\n    degree heterogeneity, leaves, hubs, density, triangle\n    prevalence, transitivity and a variance correction.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density ** 0.5)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / (possible_tri if possible_tri > 0 else 1)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.9357368934223356, "pearson": 0.8371779580781659, "rmse": 6.132894302430286, "mae": 3.2703347418926945}}
{"timestamp": "2026-02-16T11:08:53.565387+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i2_p1_350316207", "generation": 15, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8879231692677071, "fitness_mode": "correlation", "simplicity_score": 0.21968639156965597, "novelty_bonus": 0.1516762919072976, "total_score": 0.562935253263305, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate follows a simple baseline that grows with the number\n    of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators are used; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    # Dampen the effect with a square‑root\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.056673\nbelow_novelty_threshold: novelty_bonus=0.088032\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    successively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    No external libraries are imported – only built‑in functions are\n    used.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    trans      = s['transitivity']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= pow(density_factor, 0.5)\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + pow(tri_ratio, 0.5))\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    successively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    No external libraries are imported – only built‑in functions are\n    used.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Estimated average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    trans      = s['transitivity']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= pow(density_factor, 0.5)\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + pow(tri_ratio, 0.5))\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.946990174754369, "pearson": 0.8688108239775192, "rmse": 8.202294945287418, "mae": 4.867208317672224}}
{"timestamp": "2026-02-16T11:09:41.266132+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.085924", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:09:41.266643+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 15, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.085924", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:10:19.645631+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 2, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.105788", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:10:19.646283+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 15, "island_id": 2, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:11:00.340733+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i2_p3_104015764", "generation": 15, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8699639855942376, "fitness_mode": "correlation", "simplicity_score": 0.21982907809447566, "novelty_bonus": 0.15272541674273266, "total_score": 0.5522622526120143, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate follows a simple baseline that grows with the number\n    of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators are used; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    # Dampen the effect with a square‑root\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.088032\nbelow_novelty_threshold: novelty_bonus=0.085924\nbelow_novelty_threshold: novelty_bonus=0.105788\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, transitivity, assortativity, degree\n    heterogeneity, density, triangle prevalence, and the presence of\n    hubs/leaves.  Only built‑in arithmetic operations and functions are\n    used – no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic graph descriptors (guard against missing or zero values)\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1e-6)          # avoid division by zero\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering and transitivity tend to create detours → increase estimate\n    base *= (1 + clustering + trans)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (presence of hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, transitivity, assortativity, degree\n    heterogeneity, density, triangle prevalence, and the presence of\n    hubs/leaves.  Only built‑in arithmetic operations and functions are\n    used – no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic graph descriptors (guard against missing or zero values)\n    n          = s['n']\n    avg_deg    = max(s['avg_degree'], 1e-6)          # avoid division by zero\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering and transitivity tend to create detours → increase estimate\n    base *= (1 + clustering + trans)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (presence of hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.9249576239405987, "pearson": 0.8243776588399785, "rmse": 7.4408441074528655, "mae": 4.2409729336190045}}
{"timestamp": "2026-02-16T11:11:56.451581+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i2_p4_691908570", "generation": 15, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8919567827130852, "fitness_mode": "correlation", "simplicity_score": 0.21950110553726354, "novelty_bonus": 0.1711320180630589, "total_score": 0.56514307410756, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate follows a simple baseline that grows with the number\n    of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators are used; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 - density\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    # Dampen the effect with a square‑root\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.088032\nbelow_novelty_threshold: novelty_bonus=0.085924\nbelow_novelty_threshold: novelty_bonus=0.105788\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and\n    subtle heterogeneity effects.  Only built‑in arithmetic operators\n    are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and\n    subtle heterogeneity effects.  Only built‑in arithmetic operators\n    are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.9398064951623792, "pearson": 0.8604698002733029, "rmse": 15.1786617312704, "mae": 10.276117121445346}}
{"timestamp": "2026-02-16T11:12:34.003969+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i3_p0_755585444", "generation": 15, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8509483793517406, "fitness_mode": "correlation", "simplicity_score": 0.2220166707476116, "novelty_bonus": 0.15422546380673996, "total_score": 0.5425062691739415, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only global graph\n    statistics.  The formula combines several structural cues:\n\n    * A baseline n / (avg_degree + 1) that grows with size and shrinks\n      with connectivity.\n    * Multiplicative detour factors for clustering and positive\n      assortativity.\n    * Division by (1 + std_degree) to reflect the shortcut effect of\n      hubs.\n    * A density factor that reduces the estimate for denser graphs.\n    * A triangle‑ratio divisor that shortens paths when triangles are\n      abundant.\n    * A transitivity multiplier that captures global clustering.\n    * Finally, an adjustment with the top three degrees to account for\n      highly connected nodes that can serve as shortcuts.\n\n    The function uses only built‑in operations and no imports or\n    graph traversal algorithms.\n    \"\"\"\n    # Basic scalars ---------------------------------------------------\n    n           = float(s['n'])\n    avg_deg     = float(s['avg_degree'])\n    std_deg     = float(s['std_degree'])\n    clust       = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    dens        = float(s['density'])\n    tri         = float(s['num_triangles'])\n\n    # Baseline --------------------------------------------------------\n    base = n / (avg_deg + 1.0)\n\n    # Clustering and assortativity increase detours ------------------\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # Degree heterogeneity (hubs) shorten paths ----------------------\n    base /= (1.0 + std_deg)\n\n    # Denser graphs have shorter paths --------------------------------\n    dens_factor = max(0.05, 1.0 - dens)\n    base *= dens_factor\n\n    # Triangles provide local shortcuts -------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div/0\n    tri_ratio = tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # Global transitivity reduces path length -------------------------\n    base *= (1.0 + trans)\n\n    # Adjustment with top three degrees (extra local shortcuts) -------\n    top_degrees = sum(s['degrees'][-3:]) if len(s['degrees']) >= 3 else sum(s['degrees'])\n    base /= (1.0 + top_degrees / (n * avg_deg))\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.133061\nbelow_novelty_threshold: novelty_bonus=0.053296\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without importing any external modules.\n\n    The estimate grows with the graph size and becomes smaller when\n    connectivity, clustering, or degree heterogeneity increases.\n    All operations are safe from division by zero and avoid hidden\n    features such as diameter or explicit traversal algorithms.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Extract scalars as floats\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    num_tri    = float(s['num_triangles'])\n    min_deg    = float(s['min_degree'])\n    max_deg    = float(s['max_degree'])\n    deg_spread = max_deg - min_deg\n\n    # Baseline: larger graph or smaller average degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Clustering and assortativity usually increase detours\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # Degree heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # Denser graphs have shorter paths (reduce the estimate)\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # Triangles provide local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # guard against division by zero\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # Global transitivity further reduces path length\n    base *= (1.0 + trans)\n\n    # Extra adjustment for the spread between max and min degrees\n    base *= (1.0 + deg_spread / (avg_deg + 1.0))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without importing any external modules.\n\n    The estimate grows with the graph size and becomes smaller when\n    connectivity, clustering, or degree heterogeneity increases.\n    All operations are safe from division by zero and avoid hidden\n    features such as diameter or explicit traversal algorithms.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Extract scalars as floats\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    num_tri    = float(s['num_triangles'])\n    min_deg    = float(s['min_degree'])\n    max_deg    = float(s['max_degree'])\n    deg_spread = max_deg - min_deg\n\n    # Baseline: larger graph or smaller average degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # Clustering and assortativity usually increase detours\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # Degree heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # Denser graphs have shorter paths (reduce the estimate)\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # Triangles provide local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # guard against division by zero\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # Global transitivity further reduces path length\n    base *= (1.0 + trans)\n\n    # Extra adjustment for the spread between max and min degrees\n    base *= (1.0 + deg_spread / (avg_deg + 1.0))\n\n    return base", "spearman": 0.9036705917647943, "pearson": 0.749435036067878, "rmse": 13.952720110557198, "mae": 8.878611881966268}}
{"timestamp": "2026-02-16T11:13:13.175887+00:00", "event_type": "candidate_rejected", "payload": {"generation": 15, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.129785", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:13:13.176721+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 15, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.129785", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:14:09.411869+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i3_p1_980469831", "generation": 15, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8062905162064825, "fitness_mode": "correlation", "simplicity_score": 0.16618807982832887, "novelty_bonus": 0.16034715587495296, "total_score": 0.5286499454327194, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only global graph\n    statistics.  The formula combines several structural cues:\n\n    * A baseline n / (avg_degree + 1) that grows with size and shrinks\n      with connectivity.\n    * Multiplicative detour factors for clustering and positive\n      assortativity.\n    * Division by (1 + std_degree) to reflect the shortcut effect of\n      hubs.\n    * A density factor that reduces the estimate for denser graphs.\n    * A triangle‑ratio divisor that shortens paths when triangles are\n      abundant.\n    * A transitivity multiplier that captures global clustering.\n    * Finally, an adjustment with the top three degrees to account for\n      highly connected nodes that can serve as shortcuts.\n\n    The function uses only built‑in operations and no imports or\n    graph traversal algorithms.\n    \"\"\"\n    # Basic scalars ---------------------------------------------------\n    n           = float(s['n'])\n    avg_deg     = float(s['avg_degree'])\n    std_deg     = float(s['std_degree'])\n    clust       = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    dens        = float(s['density'])\n    tri         = float(s['num_triangles'])\n\n    # Baseline --------------------------------------------------------\n    base = n / (avg_deg + 1.0)\n\n    # Clustering and assortativity increase detours ------------------\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # Degree heterogeneity (hubs) shorten paths ----------------------\n    base /= (1.0 + std_deg)\n\n    # Denser graphs have shorter paths --------------------------------\n    dens_factor = max(0.05, 1.0 - dens)\n    base *= dens_factor\n\n    # Triangles provide local shortcuts -------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div/0\n    tri_ratio = tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # Global transitivity reduces path length -------------------------\n    base *= (1.0 + trans)\n\n    # Adjustment with top three degrees (extra local shortcuts) -------\n    top_degrees = sum(s['degrees'][-3:]) if len(s['degrees']) >= 3 else sum(s['degrees'])\n    base /= (1.0 + top_degrees / (n * avg_deg))\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.133061\nbelow_novelty_threshold: novelty_bonus=0.053296\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.129785\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only static\n    statistics of the graph.  The expression is purely arithmetic\n    and does not rely on any external libraries or graph traversal\n    procedures.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        An invariant approximating the average shortest path length.\n    \"\"\"\n    # ------------------------------------------------------------------\n    # Basic scalars – cast to float to be explicit (Python3 division already\n    # yields float, but this makes intent clear).\n    n               = float(s['n'])\n    avg_deg         = float(s['avg_degree'])\n    std_deg         = float(s['std_degree'])\n    clust           = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    density         = float(s['density'])\n    num_tri         = float(s['num_triangles'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n\n    # ------------------------------------------------------------------\n    # 1. Baseline: larger graphs or lower average degree → longer paths\n    base = n / (avg_deg + 1.0)\n\n    # 2. Clustering and assortativity introduce detours → increase length\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # 3. High degree variance (hubs) shortens paths → divide by it\n    base /= (1.0 + std_deg)\n\n    # 4. Density: denser graphs tend to have shorter paths\n    dens_factor = max(0.05, 1.0 - density)          # keep value away from zero\n    base *= dens_factor\n\n    # 5. Triangles provide local shortcuts → shorten paths\n    # Compute possible number of triangles in an undirected graph\n    if n >= 3:\n        possible_tri = (n * (n - 1.0) * (n - 2.0)) / 6.0\n    else:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 6. Global transitivity further shortens paths\n    base *= (1.0 + trans)\n\n    # 7. Degree range: a large spread in degrees can offer more shortcuts\n    deg_range = max_deg - min_deg + 1.0          # +1 avoids division by zero\n    base /= deg_range\n\n    return float(base)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of\n    pre‑computed global graph statistics.  The formula combines\n    multiplicative and divisive adjustments for clustering,\n    assortativity, degree heterogeneity, density, triangles,\n    transitivity and the degree range.  No external libraries are\n    required and the function can be executed directly on the\n    feature dictionary.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n        - n, m, density, avg_degree, max_degree, min_degree,\n          std_degree, avg_clustering, transitivity,\n          degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        A scalar that approximates the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Extract and cast to float for safety\n    n           = float(s['n'])\n    avg_deg     = float(s['avg_degree'])\n    std_deg     = float(s['std_degree'])\n    clust       = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    density     = float(s['density'])\n    num_tri     = float(s['num_triangles'])\n    max_deg     = float(s['max_degree'])\n    min_deg     = float(s['min_degree'])\n\n    # Baseline inversely proportional to the average degree\n    base = n / (avg_deg + 1.0)\n\n    # Increase length when clustering or assortativity create detours\n    base *= (1.0 + clust + 0.5 * abs(assort) + clust * abs(assort))\n\n    # Shorten length when there is high degree variance or very large hubs\n    base /= (1.0 + (avg_deg ** 0.5) + (std_deg ** 0.5) + max_deg / (n + 1.0))\n\n    # Density reduces average path length; use a quadratic factor\n    dens_factor = 0.5 + 0.5 * ((1.0 - density) ** 2)\n    base *= dens_factor\n\n    # Triangles provide local shortcuts\n    if n >= 3:\n        possible_tri = (n * (n - 1.0) * (n - 2.0)) / 6.0\n    else:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + 0.3 * tri_ratio)\n\n    # Global transitivity (overall clustering) shortens paths\n    base *= (1.0 + trans / 2.0)\n\n    # Degree range: a wider spread offers more shortcut opportunities\n    deg_range = max_deg - min_deg + 1.0\n    base += min_deg / deg_range\n\n    return float(base)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a set of\n    pre‑computed global graph statistics.  The formula combines\n    multiplicative and divisive adjustments for clustering,\n    assortativity, degree heterogeneity, density, triangles,\n    transitivity and the degree range.  No external libraries are\n    required and the function can be executed directly on the\n    feature dictionary.\n\n    Parameters\n    ----------\n    s : dict\n        Expected keys:\n        - n, m, density, avg_degree, max_degree, min_degree,\n          std_degree, avg_clustering, transitivity,\n          degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        A scalar that approximates the average shortest‑path\n        length of the graph.\n    \"\"\"\n    # Extract and cast to float for safety\n    n           = float(s['n'])\n    avg_deg     = float(s['avg_degree'])\n    std_deg     = float(s['std_degree'])\n    clust       = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    density     = float(s['density'])\n    num_tri     = float(s['num_triangles'])\n    max_deg     = float(s['max_degree'])\n    min_deg     = float(s['min_degree'])\n\n    # Baseline inversely proportional to the average degree\n    base = n / (avg_deg + 1.0)\n\n    # Increase length when clustering or assortativity create detours\n    base *= (1.0 + clust + 0.5 * abs(assort) + clust * abs(assort))\n\n    # Shorten length when there is high degree variance or very large hubs\n    base /= (1.0 + (avg_deg ** 0.5) + (std_deg ** 0.5) + max_deg / (n + 1.0))\n\n    # Density reduces average path length; use a quadratic factor\n    dens_factor = 0.5 + 0.5 * ((1.0 - density) ** 2)\n    base *= dens_factor\n\n    # Triangles provide local shortcuts\n    if n >= 3:\n        possible_tri = (n * (n - 1.0) * (n - 2.0)) / 6.0\n    else:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + 0.3 * tri_ratio)\n\n    # Global transitivity (overall clustering) shortens paths\n    base *= (1.0 + trans / 2.0)\n\n    # Degree range: a wider spread offers more shortcut opportunities\n    deg_range = max_deg - min_deg + 1.0\n    base += min_deg / deg_range\n\n    return float(base)", "spearman": 0.8946163654091354, "pearson": 0.8300765739652037, "rmse": 0.9472595050125997, "mae": 0.7347660549556764}}
{"timestamp": "2026-02-16T11:14:09.413093+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 15, "island_id": 3, "population_idx": 1, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:14:44.927725+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i3_p2_723124771", "generation": 15, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8541176470588233, "fitness_mode": "correlation", "simplicity_score": 0.22276519780937393, "novelty_bonus": 0.19250133063328534, "total_score": 0.5628569525897064, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only global graph\n    statistics.  The formula combines several structural cues:\n\n    * A baseline n / (avg_degree + 1) that grows with size and shrinks\n      with connectivity.\n    * Multiplicative detour factors for clustering and positive\n      assortativity.\n    * Division by (1 + std_degree) to reflect the shortcut effect of\n      hubs.\n    * A density factor that reduces the estimate for denser graphs.\n    * A triangle‑ratio divisor that shortens paths when triangles are\n      abundant.\n    * A transitivity multiplier that captures global clustering.\n    * Finally, an adjustment with the top three degrees to account for\n      highly connected nodes that can serve as shortcuts.\n\n    The function uses only built‑in operations and no imports or\n    graph traversal algorithms.\n    \"\"\"\n    # Basic scalars ---------------------------------------------------\n    n           = float(s['n'])\n    avg_deg     = float(s['avg_degree'])\n    std_deg     = float(s['std_degree'])\n    clust       = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    dens        = float(s['density'])\n    tri         = float(s['num_triangles'])\n\n    # Baseline --------------------------------------------------------\n    base = n / (avg_deg + 1.0)\n\n    # Clustering and assortativity increase detours ------------------\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # Degree heterogeneity (hubs) shorten paths ----------------------\n    base /= (1.0 + std_deg)\n\n    # Denser graphs have shorter paths --------------------------------\n    dens_factor = max(0.05, 1.0 - dens)\n    base *= dens_factor\n\n    # Triangles provide local shortcuts -------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div/0\n    tri_ratio = tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # Global transitivity reduces path length -------------------------\n    base *= (1.0 + trans)\n\n    # Adjustment with top three degrees (extra local shortcuts) -------\n    top_degrees = sum(s['degrees'][-3:]) if len(s['degrees']) >= 3 else sum(s['degrees'])\n    base /= (1.0 + top_degrees / (n * avg_deg))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.053296\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.129785\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base", "spearman": 0.9211070276756921, "pearson": 0.838758509476395, "rmse": 3.535256854652958, "mae": 2.25668274824942}}
{"timestamp": "2026-02-16T11:15:27.446595+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i3_p3_991635074", "generation": 15, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6273709483793517, "fitness_mode": "correlation", "simplicity_score": 0.22025196878984116, "novelty_bonus": 0.3355046514449359, "total_score": 0.5198994191321976, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only global graph\n    statistics.  The formula combines several structural cues:\n\n    * A baseline n / (avg_degree + 1) that grows with size and shrinks\n      with connectivity.\n    * Multiplicative detour factors for clustering and positive\n      assortativity.\n    * Division by (1 + std_degree) to reflect the shortcut effect of\n      hubs.\n    * A density factor that reduces the estimate for denser graphs.\n    * A triangle‑ratio divisor that shortens paths when triangles are\n      abundant.\n    * A transitivity multiplier that captures global clustering.\n    * Finally, an adjustment with the top three degrees to account for\n      highly connected nodes that can serve as shortcuts.\n\n    The function uses only built‑in operations and no imports or\n    graph traversal algorithms.\n    \"\"\"\n    # Basic scalars ---------------------------------------------------\n    n           = float(s['n'])\n    avg_deg     = float(s['avg_degree'])\n    std_deg     = float(s['std_degree'])\n    clust       = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    dens        = float(s['density'])\n    tri         = float(s['num_triangles'])\n\n    # Baseline --------------------------------------------------------\n    base = n / (avg_deg + 1.0)\n\n    # Clustering and assortativity increase detours ------------------\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # Degree heterogeneity (hubs) shorten paths ----------------------\n    base /= (1.0 + std_deg)\n\n    # Denser graphs have shorter paths --------------------------------\n    dens_factor = max(0.05, 1.0 - dens)\n    base *= dens_factor\n\n    # Triangles provide local shortcuts -------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div/0\n    tri_ratio = tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # Global transitivity reduces path length -------------------------\n    base *= (1.0 + trans)\n\n    # Adjustment with top three degrees (extra local shortcuts) -------\n    top_degrees = sum(s['degrees'][-3:]) if len(s['degrees']) >= 3 else sum(s['degrees'])\n    base /= (1.0 + top_degrees / (n * avg_deg))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.053296\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.129785\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without performing any graph traversal.  The formula blends several\n    structural cues:\n\n    * a baseline proportional to n² / (m + 1)  – larger graphs or fewer\n      edges give longer paths;\n    * multiplicative detour factors for clustering, assortativity and\n      degree imbalance;\n    * division by a term that captures degree heterogeneity, density,\n      triangle abundance, and the influence of the three highest degrees.\n\n    All intermediate values are guarded against division‑by‑zero with\n    suitable lower bounds.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed features.  Expected keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    num_tri  = float(s['num_triangles'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    degrees  = s['degrees']          # sorted list of degrees\n\n    # ---------- Baseline ----------\n    base = (n * n) / (m + 1.0)\n\n    # ---------- Detour penalties ----------\n    base *= (1.0 + clust)                    # clustering creates detours\n    base *= (1.0 + abs(assort))              # positive assortativity lengthens\n\n    # ---------- Shortcut amplifiers ----------\n    deg_ratio = max_deg / max(1.0, min_deg)  # degree imbalance\n    base /= (1.0 + std_deg + deg_ratio)      # hubs & variance shorten paths\n\n    dens_factor = max(0.05, 1.0 - density)  # denser graphs are shorter\n    base *= dens_factor\n\n    # Triangle shortcut factor\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # Transitivity shortens paths further\n    base *= (1.0 + trans)\n\n    # Top‑degree shortcut effect\n    top_sum = sum(degrees[-3:]) if len(degrees) >= 3 else sum(degrees)\n    base /= (1.0 + top_sum / (n * max_deg))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without performing any graph traversal.  The formula blends several\n    structural cues:\n\n    * a baseline proportional to n² / (m + 1)  – larger graphs or fewer\n      edges give longer paths;\n    * multiplicative detour factors for clustering, assortativity and\n      degree imbalance;\n    * division by a term that captures degree heterogeneity, density,\n      triangle abundance, and the influence of the three highest degrees.\n\n    All intermediate values are guarded against division‑by‑zero with\n    suitable lower bounds.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed features.  Expected keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees (sorted list).\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    num_tri  = float(s['num_triangles'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    degrees  = s['degrees']          # sorted list of degrees\n\n    # ---------- Baseline ----------\n    base = (n * n) / (m + 1.0)\n\n    # ---------- Detour penalties ----------\n    base *= (1.0 + clust)                    # clustering creates detours\n    base *= (1.0 + abs(assort))              # positive assortativity lengthens\n\n    # ---------- Shortcut amplifiers ----------\n    deg_ratio = max_deg / max(1.0, min_deg)  # degree imbalance\n    base /= (1.0 + std_deg + deg_ratio)      # hubs & variance shorten paths\n\n    dens_factor = max(0.05, 1.0 - density)  # denser graphs are shorter\n    base *= dens_factor\n\n    # Triangle shortcut factor\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # Transitivity shortens paths further\n    base *= (1.0 + trans)\n\n    # Top‑degree shortcut effect\n    top_sum = sum(degrees[-3:]) if len(degrees) >= 3 else sum(degrees)\n    base /= (1.0 + top_sum / (n * max_deg))\n\n    return base", "spearman": 0.7503952598814971, "pearson": 0.5658824589773535, "rmse": 2.8990100190781716, "mae": 1.572574409055095}}
{"timestamp": "2026-02-16T11:16:08.280748+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g15_i3_p4_981012877", "generation": 15, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8225210084033613, "fitness_mode": "correlation", "simplicity_score": 0.2209014926046282, "novelty_bonus": 0.20694436633800217, "total_score": 0.5584484130424419, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only global graph\n    statistics.  The formula combines several structural cues:\n\n    * A baseline n / (avg_degree + 1) that grows with size and shrinks\n      with connectivity.\n    * Multiplicative detour factors for clustering and positive\n      assortativity.\n    * Division by (1 + std_degree) to reflect the shortcut effect of\n      hubs.\n    * A density factor that reduces the estimate for denser graphs.\n    * A triangle‑ratio divisor that shortens paths when triangles are\n      abundant.\n    * A transitivity multiplier that captures global clustering.\n    * Finally, an adjustment with the top three degrees to account for\n      highly connected nodes that can serve as shortcuts.\n\n    The function uses only built‑in operations and no imports or\n    graph traversal algorithms.\n    \"\"\"\n    # Basic scalars ---------------------------------------------------\n    n           = float(s['n'])\n    avg_deg     = float(s['avg_degree'])\n    std_deg     = float(s['std_degree'])\n    clust       = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    dens        = float(s['density'])\n    tri         = float(s['num_triangles'])\n\n    # Baseline --------------------------------------------------------\n    base = n / (avg_deg + 1.0)\n\n    # Clustering and assortativity increase detours ------------------\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # Degree heterogeneity (hubs) shorten paths ----------------------\n    base /= (1.0 + std_deg)\n\n    # Denser graphs have shorter paths --------------------------------\n    dens_factor = max(0.05, 1.0 - dens)\n    base *= dens_factor\n\n    # Triangles provide local shortcuts -------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div/0\n    tri_ratio = tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # Global transitivity reduces path length -------------------------\n    base *= (1.0 + trans)\n\n    # Adjustment with top three degrees (extra local shortcuts) -------\n    top_degrees = sum(s['degrees'][-3:]) if len(s['degrees']) >= 3 else sum(s['degrees'])\n    base /= (1.0 + top_degrees / (n * avg_deg))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.053296\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.129785\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a handful of global\n    graph statistics.  No external imports or graph traversal are used.\n    The formula blends a size/degree baseline with multiplicative and\n    divisive adjustments for clustering, assortativity, degree\n    heterogeneity, density, triangles, transitivity, and a shortcut\n    bonus from the most connected nodes.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed features of a graph.\n        Required keys: n, m, density, avg_degree, max_degree,\n        min_degree, std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    # Basic scalars – cast to float to avoid integer division\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    num_tri    = float(s['num_triangles'])\n    max_deg    = float(s['max_degree'])\n    degrees    = s.get('degrees', [])\n\n    # ------------------------------------------------------------------\n    # 1. Size–degree baseline (larger graphs, lower connectivity → longer paths)\n    # ------------------------------------------------------------------\n    base = n / (avg_deg + 1.0)\n\n    # ------------------------------------------------------------------\n    # 2. Detour penalties: clustering and positive assortativity\n    # ------------------------------------------------------------------\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # ------------------------------------------------------------------\n    # 3. Shortcut bonus: degree heterogeneity (high std → hubs shorten paths)\n    # ------------------------------------------------------------------\n    base /= (1.0 + std_deg)\n\n    # ------------------------------------------------------------------\n    # 4. Density factor: dense graphs are more connected → shorten paths\n    # ------------------------------------------------------------------\n    dens_factor = pow(max(0.01, 1.0 - density), 0.6)\n    base *= dens_factor\n\n    # ------------------------------------------------------------------\n    # 5. Triangle bonus: many triangles → many local shortcuts\n    # ------------------------------------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # ------------------------------------------------------------------\n    # 6. Global transitivity further reduces average path length\n    # ------------------------------------------------------------------\n    base *= (1.0 + trans)\n\n    # ------------------------------------------------------------------\n    # 7. Max‑degree bonus: very high‑degree nodes can serve as hubs\n    # ------------------------------------------------------------------\n    base *= 1.0 + max_deg / (n * avg_deg + 1.0)\n\n    # ------------------------------------------------------------------\n    # 8. Top‑three degree adjustment: most connected nodes provide shortcuts\n    # ------------------------------------------------------------------\n    if degrees:\n        top_three_sum = sum(degrees[-3:])\n        base /= (1.0 + top_three_sum / (n * avg_deg + 1.0))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from a handful of global\n    graph statistics.  No external imports or graph traversal are used.\n    The formula blends a size/degree baseline with multiplicative and\n    divisive adjustments for clustering, assortativity, degree\n    heterogeneity, density, triangles, transitivity, and a shortcut\n    bonus from the most connected nodes.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed features of a graph.\n        Required keys: n, m, density, avg_degree, max_degree,\n        min_degree, std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    # Basic scalars – cast to float to avoid integer division\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    num_tri    = float(s['num_triangles'])\n    max_deg    = float(s['max_degree'])\n    degrees    = s.get('degrees', [])\n\n    # ------------------------------------------------------------------\n    # 1. Size–degree baseline (larger graphs, lower connectivity → longer paths)\n    # ------------------------------------------------------------------\n    base = n / (avg_deg + 1.0)\n\n    # ------------------------------------------------------------------\n    # 2. Detour penalties: clustering and positive assortativity\n    # ------------------------------------------------------------------\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # ------------------------------------------------------------------\n    # 3. Shortcut bonus: degree heterogeneity (high std → hubs shorten paths)\n    # ------------------------------------------------------------------\n    base /= (1.0 + std_deg)\n\n    # ------------------------------------------------------------------\n    # 4. Density factor: dense graphs are more connected → shorten paths\n    # ------------------------------------------------------------------\n    dens_factor = pow(max(0.01, 1.0 - density), 0.6)\n    base *= dens_factor\n\n    # ------------------------------------------------------------------\n    # 5. Triangle bonus: many triangles → many local shortcuts\n    # ------------------------------------------------------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # ------------------------------------------------------------------\n    # 6. Global transitivity further reduces average path length\n    # ------------------------------------------------------------------\n    base *= (1.0 + trans)\n\n    # ------------------------------------------------------------------\n    # 7. Max‑degree bonus: very high‑degree nodes can serve as hubs\n    # ------------------------------------------------------------------\n    base *= 1.0 + max_deg / (n * avg_deg + 1.0)\n\n    # ------------------------------------------------------------------\n    # 8. Top‑three degree adjustment: most connected nodes provide shortcuts\n    # ------------------------------------------------------------------\n    if degrees:\n        top_three_sum = sum(degrees[-3:])\n        base /= (1.0 + top_three_sum / (n * avg_deg + 1.0))\n\n    return base", "spearman": 0.9043696092402311, "pearson": 0.812302108977238, "rmse": 3.273602964623537, "mae": 2.024136775376723}}
{"timestamp": "2026-02-16T11:16:08.287659+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 16, "model_name": "gpt-oss:20b", "best_val_score": 0.5655869739267355, "no_improve_count": 3}}
{"timestamp": "2026-02-16T11:16:37.789535+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i0_p0_565227697", "generation": 16, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.6368787515006001, "fitness_mode": "correlation", "simplicity_score": 0.1900184737509212, "novelty_bonus": 0.21491187279681978, "total_score": 0.40071171245062676, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and built‑in\n    functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.091891\nbelow_novelty_threshold: novelty_bonus=0.132734\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and\n    built‑in functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and\n    built‑in functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "spearman": 0.5964689117227931, "pearson": 0.32267285769287385, "rmse": 2.731162131708067, "mae": 2.569228981971275}}
{"timestamp": "2026-02-16T11:18:29.055259+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:18:29.057170+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 16, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:18:59.007695+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:18:59.008447+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 16, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:19:35.810397+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i0_p2_393751889", "generation": 16, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5742617046818728, "fitness_mode": "correlation", "simplicity_score": 0.1900184737509212, "novelty_bonus": 0.23819387573328976, "total_score": 0.3927469395972244, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and built‑in\n    functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.091891\nbelow_novelty_threshold: novelty_bonus=0.132734\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  Only built‑in Python functions are used; no external\n    libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.1)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.1)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.5)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.9)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.8)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.7)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.2\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.1\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  Only built‑in Python functions are used; no external\n    libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.1)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.1)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.5)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.9)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.8)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.7)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.2\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.1\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "spearman": 0.5665701642541064, "pearson": 0.3513242043953153, "rmse": 2.5184842111988397, "mae": 2.3378004129723955}}
{"timestamp": "2026-02-16T11:20:22.586290+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:20:22.587223+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 16, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:20:51.882547+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:20:51.883587+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 16, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:21:27.303947+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:21:27.305305+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 16, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:21:57.564419+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 0, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:21:57.565153+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 16, "island_id": 0, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:22:36.264598+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i1_p0_864280628", "generation": 16, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14953717349512105, "novelty_bonus": 0.2098132453311331, "total_score": 0.28888455912713484, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T11:23:12.905802+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i1_p1_375255403", "generation": 16, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14953717349512105, "novelty_bonus": 0.2098132453311331, "total_score": 0.28888455912713484, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T11:23:52.368569+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:23:52.369754+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 16, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:24:20.722212+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i1_p2_191877019", "generation": 16, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.40004801920768307, "fitness_mode": "correlation", "simplicity_score": 0.14957237422515934, "novelty_bonus": 0.20360309007725186, "total_score": 0.2898756238737576, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: code must define exactly one function named `new_invariant`\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    def clamp(x, lo, hi):\n        return max(lo, min(hi, x))\n\n    density_adj   = clamp(density_adj,   0.1, 10)\n    clustering_adj = clamp(clustering_adj, 0.1, 10)\n    assort_adj    = clamp(assort_adj,    0.1, 10)\n    hetero_adj    = clamp(hetero_adj,    0.1, 10)\n    hub_adj       = clamp(hub_adj,       0.1, 10)\n    triangle_adj  = clamp(triangle_adj,  0.1, 10)\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39776044401110033, "pearson": 0.2706257650750893, "rmse": 2.6395642267374715, "mae": 2.4619211786827204}}
{"timestamp": "2026-02-16T11:24:20.722825+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 16, "island_id": 1, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:25:10.914227+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i1_p3_573687465", "generation": 16, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14950218330425635, "novelty_bonus": 0.2098132453311331, "total_score": 0.2888775610889619, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * pow(max_deg + 1, 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * pow(max_deg + 1, 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T11:25:58.620636+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i1_p4_398456665", "generation": 16, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.39351740696278503, "fitness_mode": "correlation", "simplicity_score": 0.14953717349512105, "novelty_bonus": 0.2098132453311331, "total_score": 0.28888455912713484, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n**0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d*d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1)**2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n**0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.5\n    clustering_adj = 1 - clustering * 0.5\n    assort_adj    = 1 + assort * 0.5\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39206630165754147, "pearson": 0.26792520496624384, "rmse": 2.640284511770306, "mae": 2.46253313191928}}
{"timestamp": "2026-02-16T11:27:42.722272+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:27:42.723338+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 16, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:28:23.550595+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 2, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.094943", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:28:23.551598+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 16, "island_id": 2, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:28:59.842988+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.121130", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:28:59.843566+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 16, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.121130", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:29:31.774781+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:29:31.775796+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 16, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:30:03.772836+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i2_p2_48183479", "generation": 16, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8849459783913565, "fitness_mode": "correlation", "simplicity_score": 0.2197811517270328, "novelty_bonus": 0.15962145387447446, "total_score": 0.5636569618651329, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and\n    subtle heterogeneity effects.  Only built‑in arithmetic operators\n    are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.094943\nbelow_novelty_threshold: novelty_bonus=0.121130\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is then adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and a\n    subtle heterogeneity term.  No external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is then adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and a\n    subtle heterogeneity term.  No external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.943628590714768, "pearson": 0.8614449735920473, "rmse": 7.905774164087407, "mae": 4.588158534015637}}
{"timestamp": "2026-02-16T11:31:19.131659+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i2_p3_963579122", "generation": 16, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.6632893157262905, "fitness_mode": "correlation", "simplicity_score": 0.21929909943905956, "novelty_bonus": 0.18366042056450238, "total_score": 0.4783759315067989, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and\n    subtle heterogeneity effects.  Only built‑in arithmetic operators\n    are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.094943\nbelow_novelty_threshold: novelty_bonus=0.121130\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, minimum/maximum degree, density, triangle prevalence,\n    transitivity, and a subtle heterogeneity term.  Only built‑in\n    arithmetic operators are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering) ** 0.5\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort) ** 0.5)\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1)) ** 0.5\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = density if density > 0.01 else 0.01\n    base *= density_factor ** 0.5\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6 if n >= 3 else 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base /= (1 + trans) ** 0.5\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base /= (1 + variance / (avg_deg * avg_deg + 1)) ** 0.5\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, minimum/maximum degree, density, triangle prevalence,\n    transitivity, and a subtle heterogeneity term.  Only built‑in\n    arithmetic operators are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering) ** 0.5\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort) ** 0.5)\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1)) ** 0.5\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = density if density > 0.01 else 0.01\n    base *= density_factor ** 0.5\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6 if n >= 3 else 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base /= (1 + trans) ** 0.5\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base /= (1 + variance / (avg_deg * avg_deg + 1)) ** 0.5\n\n    return base", "spearman": 0.7588359708992726, "pearson": 0.6389979787967207, "rmse": 2.098390917959805, "mae": 1.9509002119557852}}
{"timestamp": "2026-02-16T11:32:11.066859+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i2_p4_797379809", "generation": 16, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8764945978391356, "fitness_mode": "correlation", "simplicity_score": 0.21956993949421266, "novelty_bonus": 0.16326099729678678, "total_score": 0.5590146901479552, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and\n    subtle heterogeneity effects.  Only built‑in arithmetic operators\n    are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.094943\nbelow_novelty_threshold: novelty_bonus=0.121130\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using a compact combination of\n    global graph statistics.  The formula starts from a baseline that grows\n    with the number of nodes and shrinks with the average degree, then\n    progressively adjusts for clustering, assortativity, degree variance,\n    minimum/maximum degree, density, triangle prevalence, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # High degree variance (presence of hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # Very small minimum degree (many leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using a compact combination of\n    global graph statistics.  The formula starts from a baseline that grows\n    with the number of nodes and shrinks with the average degree, then\n    progressively adjusts for clustering, assortativity, degree variance,\n    minimum/maximum degree, density, triangle prevalence, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # High degree variance (presence of hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # Very small minimum degree (many leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + (max_deg / denom) ** 0.5)\n\n    # Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.9322448061201533, "pearson": 0.8434729833307654, "rmse": 4.6127978659435485, "mae": 2.6414140173382052}}
{"timestamp": "2026-02-16T11:32:45.631891+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.144867", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:32:45.632353+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 16, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.144867", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:33:35.408290+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 3, "population_idx": 0, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.135885", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:33:35.409266+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 16, "island_id": 3, "population_idx": 0, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:34:16.802034+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:34:16.802767+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 16, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:35:05.339704+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i3_p1_709046706", "generation": 16, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.6567587034813925, "fitness_mode": "correlation", "simplicity_score": 0.2192770589217591, "novelty_bonus": 0.21711752719914557, "total_score": 0.5074621317306401, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.129785\nbelow_novelty_threshold: novelty_bonus=0.144867\nbelow_novelty_threshold: novelty_bonus=0.135885\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport math\n\ndef new_invariant(s: dict) -> float:\n    \"\"\"\n    A composite estimator for the average shortest‑path length that uses\n    only globally aggregated graph features.  The expression combines\n    size, density, degree heterogeneity, clustering, assortativity,\n    triangle abundance and hub prominence in a nonlinear way.  All\n    operations are guarded against division‑by‑zero and the result\n    is always a positive real number.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Cast to float for safe arithmetic\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    degrees    = s['degrees']\n\n    # Basic baseline: grow with size, shrink with connectivity\n    base = (n ** 0.4) / (avg_deg + 1e-6) ** 0.6\n\n    # Degree heterogeneity shortens paths\n    base *= 1.0 + std_deg / (avg_deg + 1e-6)\n\n    # Clustering creates detours – increase the estimate\n    base *= math.exp(avg_clust)\n\n    # Transitivity (global clustering) reduces the estimate\n    base *= (1.0 + trans)\n\n    # Positive assortativity tends to lengthen paths\n    base *= 1.0 + abs(assort)\n\n    # Denser graphs have shorter paths – apply exponential decay\n    base *= math.exp(-density)\n\n    # Triangle shortcuts – divide by one plus the relative abundance\n    possible_tri = n * (n - 1) * (n - 2) / 6.0\n    tri_ratio    = num_tri / max(1.0, possible_tri)\n    base /= (1.0 + tri_ratio)\n\n    # Hub prominence – very high max degree can reduce path length\n    base /= (1.0 + math.log1p(max_deg))\n\n    # Low min degree suggests loose ends – mildly increase estimate\n    base *= (1.0 + math.log1p(min_deg))\n\n    # Degree list – incorporate harmonic mean to capture presence of\n    # many low‑degree nodes (which tends to lengthen paths)\n    pos_deg = [d for d in degrees if d > 0]\n    if pos_deg:\n        harm_mean = len(pos_deg) / sum(1.0 / d for d in pos_deg)\n        base *= (1.0 + harm_mean / (1.0 + max_deg))\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s: dict) -> float:\n    \"\"\"\n    A composite estimator for the average shortest‑path length that uses\n    only globally aggregated graph features.  The expression combines\n    size, density, degree heterogeneity, clustering, assortativity,\n    triangle abundance and hub prominence in a nonlinear way.  All\n    operations are guarded against division‑by‑zero and the result\n    is always a positive real number.\n    \"\"\"\n    # Basic scalars (cast to float for safety)\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    degrees    = s['degrees']\n\n    # constant used for exponential approximations\n    e = 2.718281828459045\n\n    # 1. Baseline: grows with size, shrinks with average connectivity\n    base = (n ** 0.4) / ((avg_deg + 1e-6) ** 0.6)\n\n    # 2. Degree heterogeneity shortens paths\n    base *= 1.0 + std_deg / (avg_deg + 1e-6)\n\n    # 3. Clustering creates detours – approximate exp(avg_clust)\n    base *= pow(e, avg_clust)\n\n    # 4. Global transitivity reduces the estimate\n    base *= (1.0 + trans)\n\n    # 5. Positive assortativity tends to lengthen paths\n    base *= 1.0 + abs(assort)\n\n    # 6. Denser graphs have shorter paths – approximate exp(-density)\n    base *= pow(e, -density)\n\n    # 7. Triangle shortcuts – divide by one plus the relative abundance\n    possible_tri = n * (n - 1) * (n - 2) / 6.0\n    tri_ratio = num_tri / (possible_tri if possible_tri > 1.0 else 1.0)\n    base /= (1.0 + tri_ratio)\n\n    # 8. Hub prominence – approximate log1p(max_deg) ≈ max_deg/(max_deg+1)\n    base /= (1.0 + (max_deg / (max_deg + 1.0)))\n\n    # 9. Low min degree suggests loose ends – mildly increase estimate\n    base *= (1.0 + (min_deg / (min_deg + 1.0)))\n\n    # 10. Degree list – incorporate harmonic mean to capture presence of\n    # many low‑degree nodes (which tends to lengthen paths)\n    pos_deg = [d for d in degrees if d > 0]\n    if pos_deg:\n        harm_mean = len(pos_deg) / sum(1.0 / d for d in pos_deg)\n        base *= (1.0 + harm_mean / (1.0 + max_deg))\n\n    return base\n```", "extracted_code": "def new_invariant(s: dict) -> float:\n    \"\"\"\n    A composite estimator for the average shortest‑path length that uses\n    only globally aggregated graph features.  The expression combines\n    size, density, degree heterogeneity, clustering, assortativity,\n    triangle abundance and hub prominence in a nonlinear way.  All\n    operations are guarded against division‑by‑zero and the result\n    is always a positive real number.\n    \"\"\"\n    # Basic scalars (cast to float for safety)\n    n          = float(s['n'])\n    m          = float(s['m'])\n    density    = float(s['density'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    avg_clust  = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    num_tri    = float(s['num_triangles'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    degrees    = s['degrees']\n\n    # constant used for exponential approximations\n    e = 2.718281828459045\n\n    # 1. Baseline: grows with size, shrinks with average connectivity\n    base = (n ** 0.4) / ((avg_deg + 1e-6) ** 0.6)\n\n    # 2. Degree heterogeneity shortens paths\n    base *= 1.0 + std_deg / (avg_deg + 1e-6)\n\n    # 3. Clustering creates detours – approximate exp(avg_clust)\n    base *= pow(e, avg_clust)\n\n    # 4. Global transitivity reduces the estimate\n    base *= (1.0 + trans)\n\n    # 5. Positive assortativity tends to lengthen paths\n    base *= 1.0 + abs(assort)\n\n    # 6. Denser graphs have shorter paths – approximate exp(-density)\n    base *= pow(e, -density)\n\n    # 7. Triangle shortcuts – divide by one plus the relative abundance\n    possible_tri = n * (n - 1) * (n - 2) / 6.0\n    tri_ratio = num_tri / (possible_tri if possible_tri > 1.0 else 1.0)\n    base /= (1.0 + tri_ratio)\n\n    # 8. Hub prominence – approximate log1p(max_deg) ≈ max_deg/(max_deg+1)\n    base /= (1.0 + (max_deg / (max_deg + 1.0)))\n\n    # 9. Low min degree suggests loose ends – mildly increase estimate\n    base *= (1.0 + (min_deg / (min_deg + 1.0)))\n\n    # 10. Degree list – incorporate harmonic mean to capture presence of\n    # many low‑degree nodes (which tends to lengthen paths)\n    pos_deg = [d for d in degrees if d > 0]\n    if pos_deg:\n        harm_mean = len(pos_deg) / sum(1.0 / d for d in pos_deg)\n        base *= (1.0 + harm_mean / (1.0 + max_deg))\n\n    return base", "spearman": 0.7969429235730894, "pearson": 0.8210974446318953, "rmse": 2.936149465298474, "mae": 2.383067055807553}}
{"timestamp": "2026-02-16T11:35:05.340202+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 16, "island_id": 3, "population_idx": 1, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:35:40.288473+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:35:40.289333+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 16, "island_id": 3, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:36:13.445435+00:00", "event_type": "candidate_rejected", "payload": {"generation": 16, "island_id": 3, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.044252", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:36:13.446088+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 16, "island_id": 3, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:36:54.504206+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i3_p3_732785846", "generation": 16, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8274189675870347, "fitness_mode": "correlation", "simplicity_score": 0.22364810639891763, "novelty_bonus": 0.15704342608565203, "total_score": 0.5427899227873212, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.135885\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.044252\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features\n    without performing any explicit graph search.  The estimate is built from\n    multiplicative and divisive adjustments that reflect the influence of\n    network size, connectivity, degree heterogeneity, clustering,\n    assortativity, density, triangle abundance and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys:\n        'n', 'avg_degree', 'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'density', 'num_triangles'.\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    # Core scalars\n    n         = float(s['n'])\n    avg_deg   = float(s['avg_degree'])\n    std_deg   = float(s['std_degree'])\n    clust     = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    density   = float(s['density'])\n    num_tri   = float(s['num_triangles'])\n\n    # Ratio of observed to possible triangles\n    possible_tri = float(n * (n - 1.0) * (n - 2.0) / 6.0)\n    possible_tri = max(1.0, possible_tri)          # avoid division by zero\n    tri_ratio = num_tri / possible_tri\n\n    # 1. Baseline grows with size, shrinks with mean connectivity\n    base = (n ** 0.5) / (avg_deg + 1.0)\n\n    # 2. Detours from clustering and assortativity lengthen paths\n    base *= (1.0 + clust) * (1.0 + abs(assort))\n\n    # 3. Degree heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 4. Higher density reduces path length\n    dens_factor = max(0.01, 1.0 - density)   # never reach zero\n    base *= dens_factor\n\n    # 5. Triangle abundance provides local shortcuts\n    base /= (1.0 + tri_ratio)\n\n    # 6. Global transitivity further shortens paths\n    base *= (1.0 + trans)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features\n    without performing any explicit graph search.  The estimate is built from\n    multiplicative and divisive adjustments that reflect the influence of\n    network size, connectivity, degree heterogeneity, clustering,\n    assortativity, density, triangle abundance and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys:\n        'n', 'avg_degree', 'std_degree', 'avg_clustering', 'transitivity',\n        'degree_assortativity', 'density', 'num_triangles'.\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    # Core scalars\n    n         = float(s['n'])\n    avg_deg   = float(s['avg_degree'])\n    std_deg   = float(s['std_degree'])\n    clust     = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    density   = float(s['density'])\n    num_tri   = float(s['num_triangles'])\n\n    # Ratio of observed to possible triangles\n    possible_tri = float(n * (n - 1.0) * (n - 2.0) / 6.0)\n    possible_tri = max(1.0, possible_tri)          # avoid division by zero\n    tri_ratio = num_tri / possible_tri\n\n    # 1. Baseline grows with size, shrinks with mean connectivity\n    base = (n ** 0.5) / (avg_deg + 1.0)\n\n    # 2. Detours from clustering and assortativity lengthen paths\n    base *= (1.0 + clust) * (1.0 + abs(assort))\n\n    # 3. Degree heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 4. Higher density reduces path length\n    dens_factor = max(0.01, 1.0 - density)   # never reach zero\n    base *= dens_factor\n\n    # 5. Triangle abundance provides local shortcuts\n    base /= (1.0 + tri_ratio)\n\n    # 6. Global transitivity further shortens paths\n    base *= (1.0 + trans)\n\n    return base", "spearman": 0.9018945473636841, "pearson": 0.877208730436956, "rmse": 2.2477351097841276, "mae": 2.1535233438852064}}
{"timestamp": "2026-02-16T11:37:21.383486+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g16_i3_p4_580152953", "generation": 16, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.7893877551020407, "fitness_mode": "correlation", "simplicity_score": 0.22181723815302037, "novelty_bonus": 0.24419304284247356, "total_score": 0.5548222905065967, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.135885\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.044252\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph statistics.\n\n    The estimate is built as a composite baseline that grows with network size\n    and decreases with mean connectivity.  The baseline is then scaled up or\n    down by a set of dimensionless factors that encode the influence of\n    assortativity, clustering, degree heterogeneity, density, triangle\n    abundance and the relative position of the minimum degree.\n    All operations are safe from division by zero and rely only on the\n    standard Python arithmetic operators.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the following keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        An approximate value of the average shortest‑path length.\n    \"\"\"\n    # --- Basic scalars (float conversion for safety) --------------------\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    num_tri  = float(s['num_triangles'])\n\n    # --- Baseline: larger n or smaller average degree → longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # --- Assortativity tends to stretch paths --------------------------------\n    base *= (1.0 + abs(assort))\n\n    # --- Clustering creates detours ----------------------------------------\n    base *= (1.0 + clust)\n\n    # --- Degree heterogeneity (presence of hubs) shortens paths ----------\n    base /= (1.0 + std_deg)\n\n    # --- Density reduces path length ---------------------------------------\n    base *= max(0.05, 1.0 - density)\n\n    # --- Triangle abundance provides local shortcuts --------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid division by zero\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # --- Transitivity further shortens paths ------------------------------\n    base *= (1.0 + trans)\n\n    # --- Relative position of the minimum degree -------------------------\n    # Very low min_degree relative to max_degree tends to increase path length\n    if max_deg + 1e-6 > 0:\n        base *= (1.0 + min_deg / (max_deg + 1e-6))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph statistics.\n\n    The estimate is built as a composite baseline that grows with network size\n    and decreases with mean connectivity.  The baseline is then scaled up or\n    down by a set of dimensionless factors that encode the influence of\n    assortativity, clustering, degree heterogeneity, density, triangle\n    abundance and the relative position of the minimum degree.\n    All operations are safe from division by zero and rely only on the\n    standard Python arithmetic operators.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features with the following keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        An approximate value of the average shortest‑path length.\n    \"\"\"\n    # --- Basic scalars (float conversion for safety) --------------------\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    num_tri  = float(s['num_triangles'])\n\n    # --- Baseline: larger n or smaller average degree → longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # --- Assortativity tends to stretch paths --------------------------------\n    base *= (1.0 + abs(assort))\n\n    # --- Clustering creates detours ----------------------------------------\n    base *= (1.0 + clust)\n\n    # --- Degree heterogeneity (presence of hubs) shortens paths ----------\n    base /= (1.0 + std_deg)\n\n    # --- Density reduces path length ---------------------------------------\n    base *= max(0.05, 1.0 - density)\n\n    # --- Triangle abundance provides local shortcuts --------------------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid division by zero\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # --- Transitivity further shortens paths ------------------------------\n    base *= (1.0 + trans)\n\n    # --- Relative position of the minimum degree -------------------------\n    # Very low min_degree relative to max_degree tends to increase path length\n    if max_deg + 1e-6 > 0:\n        base *= (1.0 + min_deg / (max_deg + 1e-6))\n\n    return base", "spearman": 0.8744018600465012, "pearson": 0.723631490361704, "rmse": 5.044029733494355, "mae": 3.0669385935282274}}
{"timestamp": "2026-02-16T11:37:21.387377+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 17, "model_name": "gpt-oss:20b", "best_val_score": 0.5655869739267355, "no_improve_count": 4}}
{"timestamp": "2026-02-16T11:38:05.764098+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:38:05.764856+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 17, "island_id": 0, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:38:37.554099+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 0, "population_idx": 0, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:38:37.554768+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 17, "island_id": 0, "population_idx": 0, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:39:12.963559+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i0_p1_94079113", "generation": 17, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.6368787515006001, "fitness_mode": "correlation", "simplicity_score": 0.1900184737509212, "novelty_bonus": 0.21491187279681978, "total_score": 0.40071171245062676, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and built‑in\n    functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.091891\nbelow_novelty_threshold: novelty_bonus=0.132734\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  Only built‑in Python functions are used; no external\n    libraries are imported.  The formula is a weighted product of a\n    baseline term and several adjustment factors that capture\n    sparsity, clustering, assortativity, degree heterogeneity,\n    hub‑presence, triangle density, harmonic mean of degrees and\n    minimum degree effects.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  Only built‑in Python functions are used; no external\n    libraries are imported.  The formula is a weighted product of a\n    baseline term and several adjustment factors that capture\n    sparsity, clustering, assortativity, degree heterogeneity,\n    hub‑presence, triangle density, harmonic mean of degrees and\n    minimum degree effects.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "spearman": 0.5964689117227931, "pearson": 0.32267285769287385, "rmse": 2.731162131708067, "mae": 2.569228981971275}}
{"timestamp": "2026-02-16T11:39:49.057095+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:39:49.058158+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 17, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:40:18.117792+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 0, "population_idx": 2, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:40:18.118891+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 17, "island_id": 0, "population_idx": 2, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:40:49.747113+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.101399", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:40:49.747598+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 17, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.101399", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:41:29.183927+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:41:29.185056+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 17, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:42:02.912750+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:42:02.914611+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 17, "island_id": 0, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:42:27.371088+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 0, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:42:27.372129+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 17, "island_id": 0, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:43:10.590681+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i1_p0_712348245", "generation": 17, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.40004801920768307, "fitness_mode": "correlation", "simplicity_score": 0.14948476645553802, "novelty_bonus": 0.20360309007725186, "total_score": 0.28985810231983333, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Graph invariant that estimates the average shortest path length\n    using a combination of structural properties.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        Dimensionless invariant value.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri +\n        abs(assort) + std_deg\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Graph invariant that estimates the average shortest path length\n    using a combination of structural properties.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        Dimensionless invariant value.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri +\n        abs(assort) + std_deg\n    )\n\n    return numerator / denom", "spearman": 0.39776044401110033, "pearson": 0.2706257650750893, "rmse": 2.6395642267374715, "mae": 2.4619211786827204}}
{"timestamp": "2026-02-16T11:43:43.644340+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:43:43.645502+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 17, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:44:08.771564+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i1_p1_792846533", "generation": 17, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.40004801920768307, "fitness_mode": "correlation", "simplicity_score": 0.14957237422515934, "novelty_bonus": 0.2064756618915471, "total_score": 0.28942261254847446, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: code must define exactly one function named `new_invariant`\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.45\n    clustering_adj = 1 - clustering * 0.45\n    assort_adj    = 1 + assort * 0.45\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.45\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.45\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.45\n\n    # Clamp adjustments to avoid extreme values\n    def clamp(x):\n        return max(0.1, min(10, x))\n    density_adj   = clamp(density_adj)\n    clustering_adj = clamp(clustering_adj)\n    assort_adj    = clamp(assort_adj)\n    hetero_adj    = clamp(hetero_adj)\n    hub_adj       = clamp(hub_adj)\n    triangle_adj  = clamp(triangle_adj)\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.45\n    clustering_adj = 1 - clustering * 0.45\n    assort_adj    = 1 + assort * 0.45\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.45\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.45\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.45\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n ** 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = (n ** 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.45\n    clustering_adj = 1 - clustering * 0.45\n    assort_adj    = 1 + assort * 0.45\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.45\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.45\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.45\n\n    # Clamp adjustments to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = (n ** 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39513087827195686, "pearson": 0.26931748007991974, "rmse": 2.6399198384970286, "mae": 2.4622241723281153}}
{"timestamp": "2026-02-16T11:44:08.772221+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 17, "island_id": 1, "population_idx": 1, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:44:41.767407+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i1_p2_339256912", "generation": 17, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.40004801920768307, "fitness_mode": "correlation", "simplicity_score": 0.14950218330425635, "novelty_bonus": 0.2064756618915471, "total_score": 0.2894085743642938, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Dimensionless graph invariant that blends size, degree distribution,\n    clustering, triangle count, assortativity, and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n\n    # Baseline estimate based on size and average degree\n    baseline = pow(n, 0.5) / (s['avg_degree'] + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - s['density']) * 0.5\n    clustering_adj = 1 - s['avg_clustering'] * 0.5\n    assort_adj    = 1 + s['degree_assortativity'] * 0.5\n    hetero_adj    = 1 - s['std_degree'] / (s['avg_degree'] + eps) * 0.5\n    hub_adj       = 1 - s['max_degree'] / (n - 1 + eps) * 0.5\n    triangle_adj  = 1 - s['num_triangles'] / (n * (n - 1) / 2 + eps) * 0.5\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in s['degrees'])\n    norm_sq = sum_sq / (n * ((s['max_degree'] + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * s['avg_degree'] * (1 + s['avg_clustering']) * (1 + s['transitivity'])\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + s['density'] + s['num_triangles'] +\n        abs(s['degree_assortativity']) + s['std_degree']\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Graph invariant that estimates the average shortest path length\n    using a combination of size, degree distribution, clustering,\n    triangle count, assortativity and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties (weights averaged from the two top formulas)\n    density_adj   = 1 + (1 - density) * 0.45\n    clustering_adj = 1 - clustering * 0.45\n    assort_adj    = 1 + assort * 0.45\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.45\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.45\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.45\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Graph invariant that estimates the average shortest path length\n    using a combination of size, degree distribution, clustering,\n    triangle count, assortativity and degree heterogeneity.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties (weights averaged from the two top formulas)\n    density_adj   = 1 + (1 - density) * 0.45\n    clustering_adj = 1 - clustering * 0.45\n    assort_adj    = 1 + assort * 0.45\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.45\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.45\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.45\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom", "spearman": 0.39513087827195686, "pearson": 0.26931748007991974, "rmse": 2.6399198384970286, "mae": 2.4622241723281153}}
{"timestamp": "2026-02-16T11:45:13.848523+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:45:13.849653+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 17, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:45:39.337586+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 1, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:45:39.338039+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 17, "island_id": 1, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:46:11.706658+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:46:11.707705+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 17, "island_id": 1, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:46:31.901851+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 1, "population_idx": 4, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:46:31.902480+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 17, "island_id": 1, "population_idx": 4, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:47:27.582057+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.101785", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:47:27.582511+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 17, "island_id": 2, "population_idx": 0, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.101785", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:48:04.964109+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i2_p0_723830413", "generation": 17, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8019687875150059, "fitness_mode": "correlation", "simplicity_score": 0.21869025525839322, "novelty_bonus": 0.1552439957632008, "total_score": 0.5361043946092596, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and\n    subtle heterogeneity effects.  Only built‑in arithmetic operators\n    are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.094943\nbelow_novelty_threshold: novelty_bonus=0.121130\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: novelty_bonus=0.101785\nPrevious candidate code:\n```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate starts with a baseline that scales with the square root\n    of the node count and inversely with the average degree.  The baseline\n    is then progressively adjusted for clustering, assortativity,\n    degree heterogeneity, density, triangle prevalence, transitivity,\n    and subtle heterogeneity effects.  Only built‑in arithmetic operators\n    and functions are used; no external libraries are imported.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Baseline: larger graphs with smaller average degree have longer paths\n    base = pow(n, 0.5) / (avg_deg + 1)\n\n    # 1. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 2. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 3. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 4. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 5. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 6. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 7. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 8. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 9. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a compact set of\n    pre‑computed graph statistics.  The estimate starts from a baseline\n    that grows with the size of the graph and shrinks with the average\n    degree.  A sequence of multiplicative adjustments accounts for\n    clustering, assortativity, degree heterogeneity, density,\n    triangle prevalence, transitivity, and a subtle heterogeneity\n    correction.  Only built‑in arithmetic operations are used; no\n    external imports are required.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Baseline: larger graphs with lower average degree yield longer paths\n    base = pow(n, 0.5) / (avg_deg + 1)\n\n    # 1. Clustering tends to increase detours\n    base *= (1 + clustering * 0.5)\n\n    # 2. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort) * 0.5)\n\n    # 3. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg * 0.3)\n\n    # 4. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 5. Very large maximum degree (hubs) shortens paths\n    base /= (1 + pow(max_deg / max(n - 1, 1), 0.7))\n\n    # 6. Denser graphs have shorter paths – bounded factor\n    density_factor = pow(max(0.05, 1 - density), 0.8)\n    base *= density_factor\n\n    # 7. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + pow(tri_ratio, 0.4))\n\n    # 8. Global transitivity further shortens paths\n    base *= (1 + trans * 0.3)\n\n    # 9. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1) * 0.4)\n\n    # 10. Ratio of extreme degrees – captures extreme skew\n    deg_ratio = max_deg / (min_deg + 1)\n    base *= (1 + deg_ratio * 0.1)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length using a compact set of\n    pre‑computed graph statistics.  The estimate starts from a baseline\n    that grows with the size of the graph and shrinks with the average\n    degree.  A sequence of multiplicative adjustments accounts for\n    clustering, assortativity, degree heterogeneity, density,\n    triangle prevalence, transitivity, and a subtle heterogeneity\n    correction.  Only built‑in arithmetic operations are used; no\n    external imports are required.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # Baseline: larger graphs with lower average degree yield longer paths\n    base = pow(n, 0.5) / (avg_deg + 1)\n\n    # 1. Clustering tends to increase detours\n    base *= (1 + clustering * 0.5)\n\n    # 2. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort) * 0.5)\n\n    # 3. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg * 0.3)\n\n    # 4. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 5. Very large maximum degree (hubs) shortens paths\n    base /= (1 + pow(max_deg / max(n - 1, 1), 0.7))\n\n    # 6. Denser graphs have shorter paths – bounded factor\n    density_factor = pow(max(0.05, 1 - density), 0.8)\n    base *= density_factor\n\n    # 7. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + pow(tri_ratio, 0.4))\n\n    # 8. Global transitivity further shortens paths\n    base *= (1 + trans * 0.3)\n\n    # 9. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1) * 0.4)\n\n    # 10. Ratio of extreme degrees – captures extreme skew\n    deg_ratio = max_deg / (min_deg + 1)\n    base *= (1 + deg_ratio * 0.1)\n\n    return base", "spearman": 0.8915862896572415, "pearson": 0.706732742612696, "rmse": 1.7798548691899736, "mae": 1.6892275411502373}}
{"timestamp": "2026-02-16T11:48:04.964821+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 17, "island_id": 2, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:48:56.534945+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i2_p1_432210113", "generation": 17, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8849459783913565, "fitness_mode": "correlation", "simplicity_score": 0.2197811517270328, "novelty_bonus": 0.15962145387447446, "total_score": 0.5636569618651329, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and\n    subtle heterogeneity effects.  Only built‑in arithmetic operators\n    are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.121130\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.101785\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The formula starts from a simple baseline that grows with\n    the number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, minimum/maximum degree effects, graph density,\n    triangle prevalence, and transitivity.  No external libraries are\n    required.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n    \n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length using only pre‑computed graph\n    statistics.  The formula starts from a simple baseline that grows with\n    the number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, minimum/maximum degree effects, graph density,\n    triangle prevalence, and transitivity.  No external libraries are\n    required.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n    \n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg degree → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.943628590714768, "pearson": 0.8614449735920473, "rmse": 7.905774164087407, "mae": 4.588158534015637}}
{"timestamp": "2026-02-16T11:49:43.066701+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i2_p2_360673801", "generation": 17, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8886914765906362, "fitness_mode": "correlation", "simplicity_score": 0.21980506886437962, "novelty_bonus": 0.15611490287257168, "total_score": 0.5631287929673557, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and\n    subtle heterogeneity effects.  Only built‑in arithmetic operators\n    are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.121130\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.101785\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.  The formula is intentionally compact, uses only\n    built‑in arithmetic, and avoids any external libraries or graph\n    traversal algorithms.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float): graph density\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted list of degrees\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / (1 + density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + pow(tri_ratio, 0.5))\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.  The formula is intentionally compact, uses only\n    built‑in arithmetic, and avoids any external libraries or graph\n    traversal algorithms.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float): graph density\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted list of degrees\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / (1 + density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + pow(tri_ratio, 0.5))\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.9446666166654167, "pearson": 0.8632691418411942, "rmse": 7.946755398101251, "mae": 4.63646599696451}}
{"timestamp": "2026-02-16T11:50:53.924066+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.144329", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:50:53.924694+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 17, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.144329", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:51:20.146645+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 2, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: __class__", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:51:20.147272+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 17, "island_id": 2, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:52:05.635471+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:52:05.636154+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 17, "island_id": 2, "population_idx": 4, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:52:46.515774+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 2, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.085950", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:52:46.516396+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 17, "island_id": 2, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:53:21.372716+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i3_p0_201513980", "generation": 17, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.7975510204081632, "fitness_mode": "correlation", "simplicity_score": 0.22165548823651432, "novelty_bonus": 0.2348664950968664, "total_score": 0.5557218194456945, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.135885\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.044252\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph\n    statistics only.  The estimate grows with the size of the graph and\n    with clustering/assortativity and shrinks with average degree,\n    degree heterogeneity, density, transitivity, and the abundance of\n    triangles.  All operations use only Python built‑ins and simple\n    arithmetic.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed features.  Expected keys are:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n\n    # 1. Baseline grows with n and shrinks with avg_degree\n    base = n / (avg_deg + 1.0)\n\n    # 2. Clustering and assortativity increase detours\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # 3. Degree heterogeneity (large std) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 4. Density reduces expected distance (but keep factor ≥ 0.05)\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 5. Triangle abundance provides local shortcuts\n    max_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    max_tri = max(1.0, max_tri)\n    tri_ratio = num_tri / max_tri\n    base /= (1.0 + tri_ratio)\n\n    # 6. Global transitivity further shortens paths\n    base *= (1.0 + trans)\n\n    # 7. Very large hubs act as efficient connectors\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    # 8. Minimal nodes also contribute to connectivity\n    base *= (1.0 + min_deg / (max_deg + 1e-6))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph\n    statistics only.  The estimate grows with the size of the graph and\n    with clustering/assortativity and shrinks with average degree,\n    degree heterogeneity, density, transitivity, and the abundance of\n    triangles.  All operations use only Python built‑ins and simple\n    arithmetic.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed features.  Expected keys are:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        Estimated average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n\n    # 1. Baseline grows with n and shrinks with avg_degree\n    base = n / (avg_deg + 1.0)\n\n    # 2. Clustering and assortativity increase detours\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # 3. Degree heterogeneity (large std) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 4. Density reduces expected distance (but keep factor ≥ 0.05)\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 5. Triangle abundance provides local shortcuts\n    max_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    max_tri = max(1.0, max_tri)\n    tri_ratio = num_tri / max_tri\n    base /= (1.0 + tri_ratio)\n\n    # 6. Global transitivity further shortens paths\n    base *= (1.0 + trans)\n\n    # 7. Very large hubs act as efficient connectors\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    # 8. Minimal nodes also contribute to connectivity\n    base *= (1.0 + min_deg / (max_deg + 1e-6))\n\n    return base", "spearman": 0.8818615465386636, "pearson": 0.7374430148448976, "rmse": 5.244119204350732, "mae": 3.264007970799076}}
{"timestamp": "2026-02-16T11:54:01.396002+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i3_p1_635457581", "generation": 17, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.876110444177671, "fitness_mode": "correlation", "simplicity_score": 0.24693498306801742, "novelty_bonus": 0.18294472497584757, "total_score": 0.5711878370419312, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.135885\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.044252\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    only.  The expression combines size, degree distribution, assortativity,\n    clustering, density, triangle prevalence, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n, m\n        - density\n        - avg_degree\n        - max_degree, min_degree\n        - std_degree\n        - avg_clustering\n        - transitivity\n        - degree_assortativity\n        - num_triangles\n        - degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    num_tri  = float(s['num_triangles'])\n    degrees  = s['degrees']\n\n    # Harmonic mean of positive degrees (avoid division by zero)\n    positive_degrees = [d for d in degrees if d > 0]\n    if positive_degrees:\n        hm_den = sum(1.0 / d for d in positive_degrees)\n        harmonic = float(len(positive_degrees)) / hm_den\n    else:\n        harmonic = 0.1  # fallback for empty or all-zero degree lists\n\n    # Triangle ratio (fraction of possible triangles that exist)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n\n    # Degree heterogeneity adjustment (larger std or spread shortens paths)\n    heter = 1.0 + std_deg + (max_deg - min_deg) / (max_deg if max_deg > 0 else 1.0)\n\n    # Baseline: larger n or smaller connectivity yields longer paths\n    inv = n / (harmonic + 1.0)\n\n    # Positive assortativity tends to stretch paths\n    inv *= (1.0 + abs(assort))\n\n    # Local clustering tends to create detours\n    inv *= (1.0 + clust)\n\n    # Heterogeneity (hubs) shortens paths\n    inv /= heter\n\n    # Density reduces expected distance (cap at 0.05)\n    density_factor = max(0.05, 1.0 - density)\n    inv *= density_factor\n\n    # Triangle abundance shortens paths\n    inv /= (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    inv *= (1.0 + trans)\n\n    return inv\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    only.  The expression combines size, degree distribution, assortativity,\n    clustering, density, triangle prevalence, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n, m\n        - density\n        - avg_degree\n        - max_degree, min_degree\n        - std_degree\n        - avg_clustering\n        - transitivity\n        - degree_assortativity\n        - num_triangles\n        - degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    num_tri  = float(s['num_triangles'])\n    degrees  = s['degrees']\n\n    # Harmonic mean of positive degrees (avoid division by zero)\n    positive_degrees = [d for d in degrees if d > 0]\n    if positive_degrees:\n        hm_den = sum(1.0 / d for d in positive_degrees)\n        harmonic = float(len(positive_degrees)) / hm_den\n    else:\n        harmonic = 0.1  # fallback for empty or all-zero degree lists\n\n    # Triangle ratio (fraction of possible triangles that exist)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n\n    # Degree heterogeneity adjustment (larger std or spread shortens paths)\n    heter = 1.0 + std_deg + (max_deg - min_deg) / (max_deg if max_deg > 0 else 1.0)\n\n    # Baseline: larger n or smaller connectivity yields longer paths\n    inv = n / (harmonic + 1.0)\n\n    # Positive assortativity tends to stretch paths\n    inv *= (1.0 + abs(assort))\n\n    # Local clustering tends to create detours\n    inv *= (1.0 + clust)\n\n    # Heterogeneity (hubs) shortens paths\n    inv /= heter\n\n    # Density reduces expected distance (cap at 0.05)\n    density_factor = max(0.05, 1.0 - density)\n    inv *= density_factor\n\n    # Triangle abundance shortens paths\n    inv /= (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    inv *= (1.0 + trans)\n\n    return inv", "spearman": 0.933834845871147, "pearson": 0.8754135056825203, "rmse": 2.5943091281376445, "mae": 1.6498210030209972}}
{"timestamp": "2026-02-16T11:54:39.807399+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i3_p2_687984645", "generation": 17, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8600720288115246, "fitness_mode": "correlation", "simplicity_score": 0.15832813488420003, "novelty_bonus": 0.17417338365745771, "total_score": 0.5477179870827026, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.135885\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.044252\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global\n    network statistics.  The expression is a compact composition of\n    scaling, dampening and boosting factors that encode the influence\n    of size, connectivity, heterogeneity, clustering and density on\n    typical path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features containing the keys\n\n        - n (int)             : number of nodes\n        - m (int)             : number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list of int)   : sorted list of degrees\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # ---- cast to floats for numeric safety ----\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # ---- compute derived helpers ----\n    # triangle abundance ratio\n    possible_tri = max(1.0, n * (n - 1.0) * (n - 2.0) / 6.0)\n    tri_ratio = num_tri / possible_tri\n\n    # degree spread (max – min)\n    deg_spread = max_deg - min_deg\n\n    # total degree (sum of degrees) normalised by n^2 to keep scale\n    sum_deg = float(sum(s['degrees']))\n    norm_deg_sum = sum_deg / (n * n + 1e-6)  # tiny eps to avoid div/0\n\n    # ---- baseline: grows with size, shrinks with connectivity ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- adjust for structural properties ----\n    # 1. clustering creates detours → lengthens paths\n    base *= (1.0 + clust)\n\n    # 2. assortativity usually lengthens paths\n    base *= (1.0 + abs(assort))\n\n    # 3. degree heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 4. dense graphs have shorter distances\n    base *= max(0.05, 1.0 - density)\n\n    # 5. many triangles give local shortcuts → shorten paths\n    base /= (1.0 + tri_ratio)\n\n    # 6. global transitivity acts similarly to triangles\n    base *= (1.0 + trans)\n\n    # 7. large degree spread tends to increase distances\n    base *= (1.0 + deg_spread / (n + 1.0))\n\n    # 8. normalised total degree contributes to connectivity\n    base *= (1.0 + norm_deg_sum)\n\n    # ---- final safeguard ----\n    return max(base, 0.1)\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global\n    network statistics.  The expression is a compact composition of\n    scaling, dampening and boosting factors that encode the influence\n    of size, connectivity, heterogeneity, clustering and density on\n    typical path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features containing the keys\n\n        - n (int)             : number of nodes\n        - m (int)             : number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list of int)   : sorted list of degrees\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # ---- cast to floats for numeric safety ----\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # ---- compute derived helpers ----\n    # triangle abundance ratio\n    possible_tri = max(1.0, n * (n - 1.0) * (n - 2.0) / 6.0)\n    tri_ratio = num_tri / possible_tri\n\n    # degree spread (max – min)\n    deg_spread = max_deg - min_deg\n\n    # total degree (sum of degrees) normalised by n^2 to keep scale\n    sum_deg = float(sum(s['degrees']))\n    norm_deg_sum = sum_deg / (n * n + 1e-6)  # tiny eps to avoid div/0\n\n    # ---- baseline: grows with size, shrinks with connectivity ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- adjust for structural properties ----\n    # 1. clustering creates detours → lengthens paths\n    base *= (1.0 + clust)\n\n    # 2. assortativity usually lengthens paths\n    base *= (1.0 + abs(assort))\n\n    # 3. degree heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 4. dense graphs have shorter distances\n    base *= max(0.05, 1.0 - density)\n\n    # 5. many triangles give local shortcuts → shorten paths\n    base /= (1.0 + tri_ratio)\n\n    # 6. global transitivity acts similarly to triangles\n    base *= (1.0 + trans)\n\n    # 7. large degree spread tends to increase distances\n    base *= (1.0 + deg_spread / (n + 1.0))\n\n    # 8. normalised total degree contributes to connectivity\n    base *= (1.0 + norm_deg_sum)\n\n    # ---- final safeguard ----\n    return max(base, 0.1)", "spearman": 0.9276006900172505, "pearson": 0.8606518034850514, "rmse": 4.397274672966168, "mae": 3.106565996615443}}
{"timestamp": "2026-02-16T11:55:09.859749+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g17_i3_p3_955272304", "generation": 17, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8373109243697479, "fitness_mode": "correlation", "simplicity_score": 0.22335485883721273, "novelty_bonus": 0.20040381990466183, "total_score": 0.5619622969933225, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    without any external imports or graph algorithms.\n\n    The invariant is built from several structural features:\n    - size versus average degree (baseline length)\n    - increased detours in highly clustered or assortative graphs\n    - reduced length in graphs with high degree heterogeneity,\n      dense connectivity, many triangles, or high transitivity\n    \"\"\"\n    # ---- Extract basic scalars (cast to float for safety) ----\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    tri      = float(s['num_triangles'])\n    # ---- Baseline: larger graphs or smaller average degree => longer paths ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- Clustering tends to create detours (increase path length) ----\n    base *= (1.0 + clust)\n\n    # ---- Positive assortativity usually lengthens paths ----\n    base *= (1.0 + abs(assort))\n\n    # ---- High degree variance (hubs) shortens paths ----\n    base /= (1.0 + std_deg)\n\n    # ---- Denser graphs have shorter paths (reduce the estimate) ----\n    dens_factor = max(0.05, 1.0 - density)\n    base *= dens_factor\n\n    # ---- Triangles provide local shortcuts (reduce path length) ----\n    possible_triangles = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_triangles = max(1.0, possible_triangles)   # avoid division by zero\n    tri_ratio = tri / possible_triangles\n    base /= (1.0 + tri_ratio)\n\n    # ---- Global transitivity (another form of clustering) reduces paths ----\n    base *= (1.0 + trans)\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.135885\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.044252\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    A compact, heuristic estimate of the average shortest‑path length\n    that combines size, connectivity, degree heterogeneity,\n    clustering, assortativity, density and triangle prevalence.\n    All arithmetic is performed with built‑in operators only.\n    \"\"\"\n    # Extract features as floats for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    density = float(s['density'])\n    avg_deg   = float(s['avg_degree'])\n    std_deg   = float(s['std_degree'])\n    clust     = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    num_tri   = float(s['num_triangles'])\n\n    # Baseline proportional to graph size and inversely to average degree\n    base = n / (avg_deg + 1.0)\n\n    # Add detour effects of clustering and assortativity\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # Heterogeneous degree distributions with hubs tend to shorten paths\n    base /= (1.0 + std_deg)\n\n    # Densification shortens paths; cap the multiplicative factor\n    dens_factor = max(0.001, 1.0 - density)\n    base *= dens_factor\n\n    # Triangles provide local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid division by zero\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # Global transitivity further reduces distances\n    base *= (1.0 + trans)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    A compact, heuristic estimate of the average shortest‑path length\n    that combines size, connectivity, degree heterogeneity,\n    clustering, assortativity, density and triangle prevalence.\n    All arithmetic is performed with built‑in operators only.\n    \"\"\"\n    # Extract features as floats for safety\n    n      = float(s['n'])\n    m      = float(s['m'])\n    density = float(s['density'])\n    avg_deg   = float(s['avg_degree'])\n    std_deg   = float(s['std_degree'])\n    clust     = float(s['avg_clustering'])\n    trans     = float(s['transitivity'])\n    assort    = float(s['degree_assortativity'])\n    num_tri   = float(s['num_triangles'])\n\n    # Baseline proportional to graph size and inversely to average degree\n    base = n / (avg_deg + 1.0)\n\n    # Add detour effects of clustering and assortativity\n    base *= (1.0 + clust)\n    base *= (1.0 + abs(assort))\n\n    # Heterogeneous degree distributions with hubs tend to shorten paths\n    base /= (1.0 + std_deg)\n\n    # Densification shortens paths; cap the multiplicative factor\n    dens_factor = max(0.001, 1.0 - density)\n    base *= dens_factor\n\n    # Triangles provide local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid division by zero\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # Global transitivity further reduces distances\n    base *= (1.0 + trans)\n\n    return base", "spearman": 0.9143403585089629, "pearson": 0.8271326217624315, "rmse": 3.359512705062122, "mae": 2.0994546103869034}}
{"timestamp": "2026-02-16T11:55:49.137557+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.125443", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:55:49.138399+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 17, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.125443", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:56:23.189176+00:00", "event_type": "candidate_rejected", "payload": {"generation": 17, "island_id": 3, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.121857", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:56:23.189977+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 17, "island_id": 3, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:56:23.191646+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 18, "model_name": "gpt-oss:20b", "best_val_score": 0.5711878370419312, "no_improve_count": 0}}
{"timestamp": "2026-02-16T11:57:20.099682+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i0_p0_577871084", "generation": 18, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.6368787515006001, "fitness_mode": "correlation", "simplicity_score": 0.1900184737509212, "novelty_bonus": 0.21491187279681978, "total_score": 0.40071171245062676, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and built‑in\n    functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.101399\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only built‑in Python functions; no\n    external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only built‑in Python functions; no\n    external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "spearman": 0.5964689117227931, "pearson": 0.32267285769287385, "rmse": 2.731162131708067, "mae": 2.569228981971275}}
{"timestamp": "2026-02-16T11:58:52.661757+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:58:52.663780+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 18, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:59:17.588942+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:59:17.590018+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 18, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:59:57.544507+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T11:59:57.545908+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 18, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:00:34.973443+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 0, "population_idx": 2, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:00:34.974309+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 18, "island_id": 0, "population_idx": 2, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:01:45.057888+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:01:45.058781+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 18, "island_id": 0, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:02:08.559352+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 0, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:02:08.560057+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 18, "island_id": 0, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:03:13.222029+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i0_p4_983470462", "generation": 18, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.6354381752701079, "fitness_mode": "correlation", "simplicity_score": 0.1897162416490303, "novelty_bonus": 0.2156963924098102, "total_score": 0.3978250453747322, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and built‑in\n    functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.101399\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    avg_deg = float(s['avg_degree'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    std_deg = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n    degrees = s['degrees']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + pow(1 - density, 1.1)\n    clustering_adj = 1 - pow(avg_clust, 1.1)\n    assort_adj = 1 + pow(abs(assort), 0.5)\n    hetero_adj = 1 - std_deg / pow(avg_deg + eps, 0.8)\n    hub_adj = 1 - max_deg / pow(n - 1 + eps, 0.7)\n    triangle_adj = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)\n\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    density_adj = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj = max(0.1, min(10.0, assort_adj))\n    hetero_adj = max(0.1, min(10.0, hetero_adj))\n    hub_adj = max(0.1, min(10.0, hub_adj))\n    triangle_adj = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj = max(0.1, min(10.0, min_deg_adj))\n\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n    return result", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    avg_deg = float(s['avg_degree'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    std_deg = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n    degrees = s['degrees']\n\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    density_adj = 1 + pow(1 - density, 1.1)\n    clustering_adj = 1 - pow(avg_clust, 1.1)\n    assort_adj = 1 + pow(abs(assort), 0.5)\n    hetero_adj = 1 - std_deg / pow(avg_deg + eps, 0.8)\n    hub_adj = 1 - max_deg / pow(n - 1 + eps, 0.7)\n    triangle_adj = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)\n\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    density_adj = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj = max(0.1, min(10.0, assort_adj))\n    hetero_adj = max(0.1, min(10.0, hetero_adj))\n    hub_adj = max(0.1, min(10.0, hub_adj))\n    triangle_adj = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj = max(0.1, min(10.0, min_deg_adj))\n\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n    return result", "spearman": 0.5903457586439661, "pearson": 0.31914470171513076, "rmse": 2.728101844583237, "mae": 2.5653790282412716}}
{"timestamp": "2026-02-16T12:04:05.449376+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i1_p0_22933025", "generation": 18, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.40004801920768307, "fitness_mode": "correlation", "simplicity_score": 0.1495196522239334, "novelty_bonus": 0.20360309007725186, "total_score": 0.28986507947351237, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Graph invariant that estimates the average shortest path length\n    using a combination of structural properties.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        Dimensionless invariant value.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri +\n        abs(assort) + std_deg\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39776044401110033, "pearson": 0.2706257650750893, "rmse": 2.6395642267374715, "mae": 2.4619211786827204}}
{"timestamp": "2026-02-16T12:04:55.182640+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:04:55.183364+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 18, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:05:20.312315+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 1, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:05:20.313335+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 18, "island_id": 1, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:05:52.369885+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i1_p2_289156802", "generation": 18, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.40004801920768307, "fitness_mode": "correlation", "simplicity_score": 0.14948476645553802, "novelty_bonus": 0.20360309007725186, "total_score": 0.28985810231983333, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Graph invariant that estimates the average shortest path length\n    using a combination of structural properties.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        Dimensionless invariant value.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri +\n        abs(assort) + std_deg\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula combines a baseline size/degree term with multiplicative\n    adjustments for density, clustering, assortativity, degree heterogeneity,\n    hubs, and triangles.  It also adds a normalised degree‑squared term and an\n    extra term that couples clustering with transitivity.  The result is\n    normalised by a denominator that keeps the invariant bounded.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri +\n        abs(assort) + std_deg\n    )\n\n    return numerator / denom", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula combines a baseline size/degree term with multiplicative\n    adjustments for density, clustering, assortativity, degree heterogeneity,\n    hubs, and triangles.  It also adds a normalised degree‑squared term and an\n    extra term that couples clustering with transitivity.  The result is\n    normalised by a denominator that keeps the invariant bounded.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri +\n        abs(assort) + std_deg\n    )\n\n    return numerator / denom", "spearman": 0.39776044401110033, "pearson": 0.2706257650750893, "rmse": 2.6395642267374715, "mae": 2.4619211786827204}}
{"timestamp": "2026-02-16T12:06:27.694923+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i1_p3_149529601", "generation": 18, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.40004801920768307, "fitness_mode": "correlation", "simplicity_score": 0.14939845360689755, "novelty_bonus": 0.2064756618915471, "total_score": 0.289387828424822, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Graph invariant that estimates the average shortest path length\n    using a combination of structural properties.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        Dimensionless invariant value.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri +\n        abs(assort) + std_deg\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a baseline size/degree term with multiplicative\n    adjustments for density, clustering, assortativity, degree heterogeneity,\n    hubs, and triangles, plus additive corrections for degree variance and\n    clustering/transitivity interaction.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        Dimensionless estimate of the average shortest path length.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.45\n    clustering_adj = 1 - clustering * 0.45\n    assort_adj    = 1 + assort * 0.45\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.45\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.45\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.45\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combined multiplicative adjustment\n    adjusted = (baseline * density_adj * clustering_adj * assort_adj *\n                hetero_adj * hub_adj * triangle_adj)\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Numerator: adjusted baseline plus additive corrections\n    numerator = adjusted + norm_sq + extra_term\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n    The formula blends a baseline size/degree term with multiplicative\n    adjustments for density, clustering, assortativity, degree heterogeneity,\n    hubs, and triangles, plus additive corrections for degree variance and\n    clustering/transitivity interaction.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        Dimensionless estimate of the average shortest path length.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.45\n    clustering_adj = 1 - clustering * 0.45\n    assort_adj    = 1 + assort * 0.45\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.45\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.45\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.45\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combined multiplicative adjustment\n    adjusted = (baseline * density_adj * clustering_adj * assort_adj *\n                hetero_adj * hub_adj * triangle_adj)\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Numerator: adjusted baseline plus additive corrections\n    numerator = adjusted + norm_sq + extra_term\n\n    # Denominator to keep the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39513087827195686, "pearson": 0.26931748007991974, "rmse": 2.6399198384970286, "mae": 2.4622241723281153}}
{"timestamp": "2026-02-16T12:07:05.195584+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i1_p4_568781706", "generation": 18, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.40004801920768307, "fitness_mode": "correlation", "simplicity_score": 0.14948476645553802, "novelty_bonus": 0.2064756618915471, "total_score": 0.28940509099455014, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n\ndef new_invariant(s):\n    \"\"\"\n    Graph invariant that estimates the average shortest path length\n    using a combination of structural properties.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics with keys:\n        n, m, density, avg_degree, max_degree, min_degree,\n        std_degree, avg_clustering, transitivity,\n        degree_assortativity, num_triangles, degrees.\n\n    Returns\n    -------\n    float\n        Dimensionless invariant value.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri +\n        abs(assort) + std_deg\n    )\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted degree list\n\n    Returns\n    -------\n    float\n        Dimensionless invariant value that correlates with the average shortest\n        path length of the graph.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors (weights averaged from the two candidate formulas)\n    density_adj   = 1 + (1 - density) * 0.45\n    clustering_adj = 1 - clustering * 0.45\n    assort_adj    = 1 + assort * 0.45\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.45\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.45\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.45\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n (int): number of nodes\n        - m (int): number of edges\n        - density (float)\n        - avg_degree (float)\n        - max_degree (int)\n        - min_degree (int)\n        - std_degree (float)\n        - avg_clustering (float)\n        - transitivity (float)\n        - degree_assortativity (float)\n        - num_triangles (int)\n        - degrees (list[int]): sorted degree list\n\n    Returns\n    -------\n    float\n        Dimensionless invariant value that correlates with the average shortest\n        path length of the graph.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors (weights averaged from the two candidate formulas)\n    density_adj   = 1 + (1 - density) * 0.45\n    clustering_adj = 1 - clustering * 0.45\n    assort_adj    = 1 + assort * 0.45\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.45\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.45\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.45\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = (\n        1 + m + density + num_tri + abs(assort) + std_deg\n    )\n\n    return numerator / denom", "spearman": 0.39513087827195686, "pearson": 0.26931748007991974, "rmse": 2.6399198384970286, "mae": 2.4622241723281153}}
{"timestamp": "2026-02-16T12:07:50.073708+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i2_p0_732389078", "generation": 18, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8879231692677071, "fitness_mode": "correlation", "simplicity_score": 0.2197811517270328, "novelty_bonus": 0.1516762919072976, "total_score": 0.5629542052947802, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and\n    subtle heterogeneity effects.  Only built‑in arithmetic operators\n    are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: __class__\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.085950\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.  The formula is a simple baseline that grows with the\n    number of nodes and shrinks with the average degree, and it is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity and subtle\n    heterogeneity effects.  Only built‑in arithmetic operators are used;\n    no external modules are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 5. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 8. Denser graphs have shorter paths – use a bounded factor\n    density_factor = (1 - density)**0.5\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 9. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio**0.5)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.  The formula is a simple baseline that grows with the\n    number of nodes and shrinks with the average degree, and it is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity and subtle\n    heterogeneity effects.  Only built‑in arithmetic operators are used;\n    no external modules are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 5. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 8. Denser graphs have shorter paths – use a bounded factor\n    density_factor = (1 - density)**0.5\n    if density_factor < 0.05:\n        density_factor = 0.05\n    base *= density_factor\n\n    # 9. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio**0.5)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.946990174754369, "pearson": 0.8688108239775192, "rmse": 8.202294945287418, "mae": 4.867208317672224}}
{"timestamp": "2026-02-16T12:08:40.969896+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.143071", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:08:40.970997+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 18, "island_id": 2, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.143071", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:09:20.596935+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 2, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.100579", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:09:20.597755+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 18, "island_id": 2, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:10:01.128021+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:10:01.128853+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 18, "island_id": 2, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:10:32.335071+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 2, "population_idx": 2, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.069169", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:10:32.335617+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 18, "island_id": 2, "population_idx": 2, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:11:15.687735+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.008791", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:11:15.688103+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 18, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.008791", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:11:45.636771+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 2, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:11:45.638447+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 18, "island_id": 2, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:12:14.471367+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i2_p4_476297302", "generation": 18, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8849459783913565, "fitness_mode": "correlation", "simplicity_score": 0.21990166475003348, "novelty_bonus": 0.15962145387447446, "total_score": 0.563681064469733, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and\n    subtle heterogeneity effects.  Only built‑in arithmetic operators\n    are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.069169\nbelow_novelty_threshold: novelty_bonus=0.008791\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.943628590714768, "pearson": 0.8614449735920473, "rmse": 7.905774164087407, "mae": 4.588158534015637}}
{"timestamp": "2026-02-16T12:12:49.703438+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:12:49.704221+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 18, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:13:19.188784+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i3_p0_134411329", "generation": 18, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8575750300120047, "fitness_mode": "correlation", "simplicity_score": 0.16550465813897652, "novelty_bonus": 0.18744465773125152, "total_score": 0.5517403890986746, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    only.  The expression combines size, degree distribution, assortativity,\n    clustering, density, triangle prevalence, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n, m\n        - density\n        - avg_degree\n        - max_degree, min_degree\n        - std_degree\n        - avg_clustering\n        - transitivity\n        - degree_assortativity\n        - num_triangles\n        - degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    num_tri  = float(s['num_triangles'])\n    degrees  = s['degrees']\n\n    # Harmonic mean of positive degrees (avoid division by zero)\n    positive_degrees = [d for d in degrees if d > 0]\n    if positive_degrees:\n        hm_den = sum(1.0 / d for d in positive_degrees)\n        harmonic = float(len(positive_degrees)) / hm_den\n    else:\n        harmonic = 0.1  # fallback for empty or all-zero degree lists\n\n    # Triangle ratio (fraction of possible triangles that exist)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n\n    # Degree heterogeneity adjustment (larger std or spread shortens paths)\n    heter = 1.0 + std_deg + (max_deg - min_deg) / (max_deg if max_deg > 0 else 1.0)\n\n    # Baseline: larger n or smaller connectivity yields longer paths\n    inv = n / (harmonic + 1.0)\n\n    # Positive assortativity tends to stretch paths\n    inv *= (1.0 + abs(assort))\n\n    # Local clustering tends to create detours\n    inv *= (1.0 + clust)\n\n    # Heterogeneity (hubs) shortens paths\n    inv /= heter\n\n    # Density reduces expected distance (cap at 0.05)\n    density_factor = max(0.05, 1.0 - density)\n    inv *= density_factor\n\n    # Triangle abundance shortens paths\n    inv /= (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    inv *= (1.0 + trans)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.044252\nbelow_novelty_threshold: novelty_bonus=0.125443\nbelow_novelty_threshold: novelty_bonus=0.121857\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\ndef new_invariant(s: dict) -> float:\n    \"\"\"\n    Estimate the average shortest‑path length from only pre‑computed\n    graph statistics.\n\n    The expression follows a physics‑style product of factors that grow\n    with network size and with properties that tend to *increase* path\n    length (clustering, assortativity, density gap) and divide by\n    factors that tend to *decrease* path length (hubs, triangles,\n    heterogeneity).  All operations are safe from division by zero.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics.  Required keys:\n            - n, m, density\n            - avg_degree, max_degree, min_degree, std_degree\n            - avg_clustering, transitivity\n            - degree_assortativity\n            - num_triangles\n            - degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    import math\n\n    n       = float(s[\"n\"])\n    m       = float(s[\"m\"])\n    density = float(s[\"density\"])\n\n    avg_deg   = float(s[\"avg_degree\"])\n    max_deg   = float(s[\"max_degree\"])\n    min_deg   = float(s[\"min_degree\"])\n    std_deg   = float(s[\"std_degree\"])\n\n    clust     = float(s[\"avg_clustering\"])\n    trans     = float(s[\"transitivity\"])\n    assort    = float(s[\"degree_assortativity\"])\n\n    num_tri   = float(s[\"num_triangles\"])\n    degrees   = list(s[\"degrees\"])\n\n    # ---------------------------\n    # 1. Size/average‑degree baseline\n    #    Larger n -> longer paths, higher avg_deg -> shorter paths\n    base = n / (avg_deg + 1.0)\n\n    # 2. Degree heterogeneity: hubs (large std) shorten paths\n    heter = 1.0 + std_deg\n    base /= heter\n\n    # 3. Assortativity: positively correlated degrees tend to stretch\n    #    the network, so multiply by a factor > 1.\n    base *= (1.0 + abs(assort))\n\n    # 4. Local clustering creates detours, so increase length.\n    base *= (1.0 + clust)\n\n    # 5. Density: a denser graph usually has shorter distances.\n    #    We cap the multiplicative factor at a small value to avoid\n    #    excessive reduction for very dense graphs.\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 6. Triangle abundance: triangles provide local shortcuts.\n    #    Use the ratio of actual to possible triangles.\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid div/zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another measure of clustering) shortens\n    #    paths; we amplify the effect with a mild factor.\n    base *= (1.0 + trans)\n\n    # 8. Influence of the most connected node: very large hubs can\n    #    serve as a backbone and reduce typical distances.\n    #    We modulate this effect by normalising with the total number\n    #    of edges (m).\n    hub_factor = 1.0 + max_deg / max(1.0, m)\n    base *= hub_factor\n\n    # 9. Optional: use min_degree to guard against isolated nodes.\n    #    If many nodes have degree 0, paths become large.\n    if min_deg == 0:\n        # Estimate a penalty that grows with the proportion of isolated nodes.\n        isolated_ratio = (n - len([d for d in degrees if d > 0])) / n\n        base *= (1.0 + isolated_ratio)\n\n    return float(base)\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s: dict) -> float:\n    \"\"\"\n    Estimate the average shortest‑path length from only pre‑computed\n    graph statistics.\n\n    The expression is a physics‑style product of factors that grow with\n    network size and properties that tend to *increase* path length\n    (clustering, assortativity, density gap) and divide by factors\n    that tend to *decrease* path length (hubs, triangles, heterogeneity).\n    All operations are safe from division by zero.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics. Required keys:\n            n, m, density,\n            avg_degree, max_degree, min_degree, std_degree,\n            avg_clustering, transitivity,\n            degree_assortativity,\n            num_triangles,\n            degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    n = float(s[\"n\"])\n    m = float(s[\"m\"])\n    density = float(s[\"density\"])\n\n    avg_deg = float(s[\"avg_degree\"])\n    max_deg = float(s[\"max_degree\"])\n    min_deg = float(s[\"min_degree\"])\n    std_deg = float(s[\"std_degree\"])\n\n    clust = float(s[\"avg_clustering\"])\n    trans = float(s[\"transitivity\"])\n    assort = float(s[\"degree_assortativity\"])\n\n    num_tri = float(s[\"num_triangles\"])\n    degrees = list(s[\"degrees\"])\n\n    # 1. Size/average‑degree baseline\n    base = n / (avg_deg + 1.0)\n\n    # 2. Degree heterogeneity: hubs (large std) shorten paths\n    base /= (1.0 + std_deg)\n\n    # 3. Assortativity: positively correlated degrees tend to stretch\n    #    the network, so multiply by a factor > 1.\n    base *= (1.0 + abs(assort))\n\n    # 4. Local clustering creates detours, so increase length.\n    base *= (1.0 + clust)\n\n    # 5. Density: a denser graph usually has shorter distances.\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 6. Triangle abundance: triangles provide local shortcuts.\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths.\n    base *= (1.0 + trans)\n\n    # 8. Influence of the most connected node: very large hubs can\n    #    act as a backbone and reduce typical distances.\n    hub_factor = 1.0 + max_deg / max(1.0, m)\n    base *= hub_factor\n\n    # 9. If there are isolated nodes, penalize the estimate.\n    if min_deg == 0:\n        isolated_ratio = (n - len([d for d in degrees if d > 0])) / n\n        base *= (1.0 + isolated_ratio)\n\n    return float(base)", "extracted_code": "def new_invariant(s: dict) -> float:\n    \"\"\"\n    Estimate the average shortest‑path length from only pre‑computed\n    graph statistics.\n\n    The expression is a physics‑style product of factors that grow with\n    network size and properties that tend to *increase* path length\n    (clustering, assortativity, density gap) and divide by factors\n    that tend to *decrease* path length (hubs, triangles, heterogeneity).\n    All operations are safe from division by zero.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph statistics. Required keys:\n            n, m, density,\n            avg_degree, max_degree, min_degree, std_degree,\n            avg_clustering, transitivity,\n            degree_assortativity,\n            num_triangles,\n            degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    n = float(s[\"n\"])\n    m = float(s[\"m\"])\n    density = float(s[\"density\"])\n\n    avg_deg = float(s[\"avg_degree\"])\n    max_deg = float(s[\"max_degree\"])\n    min_deg = float(s[\"min_degree\"])\n    std_deg = float(s[\"std_degree\"])\n\n    clust = float(s[\"avg_clustering\"])\n    trans = float(s[\"transitivity\"])\n    assort = float(s[\"degree_assortativity\"])\n\n    num_tri = float(s[\"num_triangles\"])\n    degrees = list(s[\"degrees\"])\n\n    # 1. Size/average‑degree baseline\n    base = n / (avg_deg + 1.0)\n\n    # 2. Degree heterogeneity: hubs (large std) shorten paths\n    base /= (1.0 + std_deg)\n\n    # 3. Assortativity: positively correlated degrees tend to stretch\n    #    the network, so multiply by a factor > 1.\n    base *= (1.0 + abs(assort))\n\n    # 4. Local clustering creates detours, so increase length.\n    base *= (1.0 + clust)\n\n    # 5. Density: a denser graph usually has shorter distances.\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 6. Triangle abundance: triangles provide local shortcuts.\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths.\n    base *= (1.0 + trans)\n\n    # 8. Influence of the most connected node: very large hubs can\n    #    act as a backbone and reduce typical distances.\n    hub_factor = 1.0 + max_deg / max(1.0, m)\n    base *= hub_factor\n\n    # 9. If there are isolated nodes, penalize the estimate.\n    if min_deg == 0:\n        isolated_ratio = (n - len([d for d in degrees if d > 0])) / n\n        base *= (1.0 + isolated_ratio)\n\n    return float(base)", "spearman": 0.9248121203030077, "pearson": 0.8477885948094507, "rmse": 3.7236283937010572, "mae": 2.420984310073697}}
{"timestamp": "2026-02-16T12:13:19.190108+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 18, "island_id": 3, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:13:59.495795+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 3, "population_idx": 1, "attempt_index": 0, "reason": "below_train_threshold", "failure_feedback": "train_signal=0.285858", "model_name": "gpt-oss:20b", "train_signal": 0.28585834333733495}}
{"timestamp": "2026-02-16T12:14:41.485602+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i3_p2_351801839", "generation": 18, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8541176470588233, "fitness_mode": "correlation", "simplicity_score": 0.22236282455199058, "novelty_bonus": 0.19250133063328534, "total_score": 0.5627764779382297, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    only.  The expression combines size, degree distribution, assortativity,\n    clustering, density, triangle prevalence, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n, m\n        - density\n        - avg_degree\n        - max_degree, min_degree\n        - std_degree\n        - avg_clustering\n        - transitivity\n        - degree_assortativity\n        - num_triangles\n        - degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    num_tri  = float(s['num_triangles'])\n    degrees  = s['degrees']\n\n    # Harmonic mean of positive degrees (avoid division by zero)\n    positive_degrees = [d for d in degrees if d > 0]\n    if positive_degrees:\n        hm_den = sum(1.0 / d for d in positive_degrees)\n        harmonic = float(len(positive_degrees)) / hm_den\n    else:\n        harmonic = 0.1  # fallback for empty or all-zero degree lists\n\n    # Triangle ratio (fraction of possible triangles that exist)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n\n    # Degree heterogeneity adjustment (larger std or spread shortens paths)\n    heter = 1.0 + std_deg + (max_deg - min_deg) / (max_deg if max_deg > 0 else 1.0)\n\n    # Baseline: larger n or smaller connectivity yields longer paths\n    inv = n / (harmonic + 1.0)\n\n    # Positive assortativity tends to stretch paths\n    inv *= (1.0 + abs(assort))\n\n    # Local clustering tends to create detours\n    inv *= (1.0 + clust)\n\n    # Heterogeneity (hubs) shortens paths\n    inv /= heter\n\n    # Density reduces expected distance (cap at 0.05)\n    density_factor = max(0.05, 1.0 - density)\n    inv *= density_factor\n\n    # Triangle abundance shortens paths\n    inv /= (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    inv *= (1.0 + trans)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.121857\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.285858\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics provided in the dictionary `s`.  The formula is a\n    product‑sum of terms that capture how size, connectivity, degree\n    heterogeneity, clustering, assortativity, density, triangles and\n    transitivity influence expected path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys:\n            n, avg_degree, std_degree, avg_clustering,\n            degree_assortativity, density, max_degree,\n            num_triangles, transitivity\n\n    Returns\n    -------\n    float\n        An approximation of the average shortest‑path length.\n    \"\"\"\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    num_tri    = float(s['num_triangles'])\n    trans      = float(s['transitivity'])\n\n    # 1. Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1.0)\n\n    # 2. Clustering tends to create detours\n    base *= (1.0 + clust)\n\n    # 3. Positive assortativity typically lengthens paths\n    base *= (1.0 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Higher density reduces expected distance\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0.0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Effect of the most connected nodes as central hubs\n    hub_factor = 1.0 + max_deg / (n * (avg_deg + 1e-6))\n    base *= hub_factor\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics provided in the dictionary `s`.  The formula is a\n    product‑sum of terms that capture how size, connectivity, degree\n    heterogeneity, clustering, assortativity, density, triangles and\n    transitivity influence expected path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys:\n            n, avg_degree, std_degree, avg_clustering,\n            degree_assortativity, density, max_degree,\n            num_triangles, transitivity\n\n    Returns\n    -------\n    float\n        An approximation of the average shortest‑path length.\n    \"\"\"\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    num_tri    = float(s['num_triangles'])\n    trans      = float(s['transitivity'])\n\n    # 1. Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1.0)\n\n    # 2. Clustering tends to create detours\n    base *= (1.0 + clust)\n\n    # 3. Positive assortativity typically lengthens paths\n    base *= (1.0 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Higher density reduces expected distance\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0.0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Effect of the most connected nodes as central hubs\n    hub_factor = 1.0 + max_deg / (n * (avg_deg + 1e-6))\n    base *= hub_factor\n\n    return base", "spearman": 0.9211070276756921, "pearson": 0.838758509476395, "rmse": 3.535256854652958, "mae": 2.25668274824942}}
{"timestamp": "2026-02-16T12:15:04.387449+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g18_i3_p3_466817927", "generation": 18, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8541176470588233, "fitness_mode": "correlation", "simplicity_score": 0.22236282455199058, "novelty_bonus": 0.19250133063328534, "total_score": 0.5627764779382297, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    only.  The expression combines size, degree distribution, assortativity,\n    clustering, density, triangle prevalence, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n, m\n        - density\n        - avg_degree\n        - max_degree, min_degree\n        - std_degree\n        - avg_clustering\n        - transitivity\n        - degree_assortativity\n        - num_triangles\n        - degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    num_tri  = float(s['num_triangles'])\n    degrees  = s['degrees']\n\n    # Harmonic mean of positive degrees (avoid division by zero)\n    positive_degrees = [d for d in degrees if d > 0]\n    if positive_degrees:\n        hm_den = sum(1.0 / d for d in positive_degrees)\n        harmonic = float(len(positive_degrees)) / hm_den\n    else:\n        harmonic = 0.1  # fallback for empty or all-zero degree lists\n\n    # Triangle ratio (fraction of possible triangles that exist)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n\n    # Degree heterogeneity adjustment (larger std or spread shortens paths)\n    heter = 1.0 + std_deg + (max_deg - min_deg) / (max_deg if max_deg > 0 else 1.0)\n\n    # Baseline: larger n or smaller connectivity yields longer paths\n    inv = n / (harmonic + 1.0)\n\n    # Positive assortativity tends to stretch paths\n    inv *= (1.0 + abs(assort))\n\n    # Local clustering tends to create detours\n    inv *= (1.0 + clust)\n\n    # Heterogeneity (hubs) shortens paths\n    inv /= heter\n\n    # Density reduces expected distance (cap at 0.05)\n    density_factor = max(0.05, 1.0 - density)\n    inv *= density_factor\n\n    # Triangle abundance shortens paths\n    inv /= (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    inv *= (1.0 + trans)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from basic graph statistics.\n\n    The estimate follows a simple baseline that grows with the number of\n    nodes and shrinks with the average degree.  It is then progressively\n    adjusted for clustering, assortativity, degree heterogeneity,\n    density, triangle prevalence, and transitivity.  All arithmetic\n    operations are safe from division by zero and keep the expression\n    compact and interpretable.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        The invariant value approximating the average shortest path\n        length.\n    \"\"\"\n    # Baseline: larger n or smaller avg_degree → longer paths\n    base = s['n'] / (s['avg_degree'] + 1)\n\n    # Clustering tends to increase detours; scale up\n    base *= (1 + s['avg_clustering'])\n\n    # Positive assortativity usually lengthens paths\n    base *= (1 + abs(s['degree_assortativity']))\n\n    # High degree variance (hubs) shortens paths; divide by it\n    base /= (1 + s['std_degree'])\n\n    # Denser graphs have shorter paths; multiply by a factor\n    density_factor = max(0.05, 1 - s['density'])\n    base *= density_factor\n\n    # Triangles indicate local cohesion; divide by (1 + triangle_ratio)\n    n = s['n']\n    possible_triangles = n * (n - 1) * (n - 2) // 6\n    triangle_ratio = s['num_triangles'] / max(1, possible_triangles)\n    base /= (1 + triangle_ratio)\n\n    # Transitivity (global clustering) further shortens paths\n    base *= (1 + s['transitivity'])\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.121857\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_train_threshold: train_signal=0.285858\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    # Basic scalars extracted once\n    n            = float(s['n'])\n    avg_deg      = float(s['avg_degree'])\n    std_deg      = float(s['std_degree'])\n    max_deg      = float(s['max_degree'])\n    clust        = float(s['avg_clustering'])\n    trans        = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    density      = float(s['density'])\n    num_tri      = float(s['num_triangles'])\n\n    # 1. Baseline: grows with graph size, shrinks with connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Positive assortativity tends to elongate paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours – scale up\n    base *= (1.0 + clust)\n\n    # 4. Degree heterogeneity (large variance → hubs → shorter paths)\n    base /= (1.0 + std_deg)\n\n    # 5. Density effect – denser graphs have shorter paths\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 6. Triangle abundance provides local shortcuts\n    # Compute triangle ratio: triangles / possible triangles\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0:\n        possible_tri = 1.0  # avoid division by zero\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity further shortens distances\n    base *= (1.0 + trans)\n\n    # 8. Extra contribution from the most connected nodes\n    # Very large hubs act as a backbone shortening overall distance\n    hub_factor = max_deg / (n * (avg_deg + 1e-6))\n    base *= (1.0 + hub_factor)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary with pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    # Basic scalars extracted once\n    n            = float(s['n'])\n    avg_deg      = float(s['avg_degree'])\n    std_deg      = float(s['std_degree'])\n    max_deg      = float(s['max_degree'])\n    clust        = float(s['avg_clustering'])\n    trans        = float(s['transitivity'])\n    assort       = float(s['degree_assortativity'])\n    density      = float(s['density'])\n    num_tri      = float(s['num_triangles'])\n\n    # 1. Baseline: grows with graph size, shrinks with connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Positive assortativity tends to elongate paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours – scale up\n    base *= (1.0 + clust)\n\n    # 4. Degree heterogeneity (large variance → hubs → shorter paths)\n    base /= (1.0 + std_deg)\n\n    # 5. Density effect – denser graphs have shorter paths\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 6. Triangle abundance provides local shortcuts\n    # Compute triangle ratio: triangles / possible triangles\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0:\n        possible_tri = 1.0  # avoid division by zero\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity further shortens distances\n    base *= (1.0 + trans)\n\n    # 8. Extra contribution from the most connected nodes\n    # Very large hubs act as a backbone shortening overall distance\n    hub_factor = max_deg / (n * (avg_deg + 1e-6))\n    base *= (1.0 + hub_factor)\n\n    return base", "spearman": 0.9211070276756921, "pearson": 0.838758509476395, "rmse": 3.535256854652958, "mae": 2.25668274824942}}
{"timestamp": "2026-02-16T12:16:01.025915+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.107422", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:16:01.026994+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 18, "island_id": 3, "population_idx": 4, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.107422", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:16:47.667114+00:00", "event_type": "candidate_rejected", "payload": {"generation": 18, "island_id": 3, "population_idx": 4, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.048614", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:16:47.667517+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 18, "island_id": 3, "population_idx": 4, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:16:47.669257+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 19, "model_name": "gpt-oss:20b", "best_val_score": 0.5711878370419312, "no_improve_count": 1}}
{"timestamp": "2026-02-16T12:18:11.780491+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i0_p0_141689279", "generation": 19, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.4952220888355342, "fitness_mode": "correlation", "simplicity_score": 0.19004959915245107, "novelty_bonus": 0.2656889464813884, "total_score": 0.3715251989897872, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and built‑in\n    functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.101399\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.1)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.1)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.5)           # assortative → longer paths\n    hetero_adj    = 1 - pow(std_deg / (avg_deg + eps), 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - pow(max_deg / (n - 1 + eps), 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - pow(num_tri / (n * (n - 1) / 2 + eps), 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.1)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.1)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.5)           # assortative → longer paths\n    hetero_adj    = 1 - pow(std_deg / (avg_deg + eps), 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - pow(max_deg / (n - 1 + eps), 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - pow(num_tri / (n * (n - 1) / 2 + eps), 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "spearman": 0.5076171904297608, "pearson": 0.3689762770638298, "rmse": 2.265403790694517, "mae": 2.063713548594293}}
{"timestamp": "2026-02-16T12:19:03.081909+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:19:03.082724+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 19, "island_id": 0, "population_idx": 1, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:19:33.476470+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 0, "population_idx": 1, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:19:33.477339+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 19, "island_id": 0, "population_idx": 1, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:20:26.233864+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:20:26.235587+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 19, "island_id": 0, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:20:48.488602+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 0, "population_idx": 2, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:20:48.489667+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 19, "island_id": 0, "population_idx": 2, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:23:15.779784+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i0_p3_669125651", "generation": 19, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.5317166866746699, "fitness_mode": "correlation", "simplicity_score": 0.18942936520613307, "novelty_bonus": 0.26903922598064944, "total_score": 0.3736182663510594, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and built‑in\n    functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.101399\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  Only basic Python arithmetic and built‑in functions are used.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.5)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.5)          # more clustering → shorter paths\n    trans_adj      = 1 - pow(trans, 1.2)               # higher transitivity → shorter paths\n    assort_adj     = 1 + pow(abs(assort), 0.7)          # assortative → longer paths\n    hetero_adj     = 1 - std_deg / pow(avg_deg + eps, 0.9)  # heterogeneity → shorter paths\n    hub_adj        = 1 - max_deg / pow(n - 1 + eps, 0.8)   # hubs → shorter paths\n    triangle_adj   = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.7)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.4\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.5\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    trans_adj      = max(0.1, min(10.0, trans_adj))\n    assort_adj     = max(0.1, min(10.0, assort_adj))\n    hetero_adj     = max(0.1, min(10.0, hetero_adj))\n    hub_adj        = max(0.1, min(10.0, hub_adj))\n    triangle_adj   = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj   = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj    = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline *\n              density_adj *\n              clustering_adj *\n              trans_adj *\n              assort_adj *\n              hetero_adj *\n              hub_adj *\n              triangle_adj *\n              harmonic_adj *\n              min_deg_adj)\n\n    return result", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  Only basic Python arithmetic and built‑in functions are used.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    trans      = float(s['transitivity'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.5)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.5)          # more clustering → shorter paths\n    trans_adj      = 1 - pow(trans, 1.2)               # higher transitivity → shorter paths\n    assort_adj     = 1 + pow(abs(assort), 0.7)          # assortative → longer paths\n    hetero_adj     = 1 - std_deg / pow(avg_deg + eps, 0.9)  # heterogeneity → shorter paths\n    hub_adj        = 1 - max_deg / pow(n - 1 + eps, 0.8)   # hubs → shorter paths\n    triangle_adj   = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.7)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.4\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.5\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    trans_adj      = max(0.1, min(10.0, trans_adj))\n    assort_adj     = max(0.1, min(10.0, assort_adj))\n    hetero_adj     = max(0.1, min(10.0, hetero_adj))\n    hub_adj        = max(0.1, min(10.0, hub_adj))\n    triangle_adj   = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj   = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj    = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline *\n              density_adj *\n              clustering_adj *\n              trans_adj *\n              assort_adj *\n              hetero_adj *\n              hub_adj *\n              triangle_adj *\n              harmonic_adj *\n              min_deg_adj)\n\n    return result", "spearman": 0.5100412510312758, "pearson": 0.29661184884684394, "rmse": 2.544509911243, "mae": 2.353083779986456}}
{"timestamp": "2026-02-16T12:23:45.792339+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i0_p4_353976831", "generation": 19, "island_id": 0, "model_name": "gpt-oss:20b", "train_signal": 0.6368787515006001, "fitness_mode": "correlation", "simplicity_score": 0.1900184737509212, "novelty_bonus": 0.21491187279681978, "total_score": 0.40071171245062676, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_0_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length built from a mix of\n    global graph statistics.  The expression uses only basic Python\n    arithmetic and built‑in functions; no external libraries are\n    imported, and it does not rely on any single feature directly.\n    \"\"\"\n    # Extract key features from the dictionary\n    n               = float(s['n'])\n    m               = float(s['m'])\n    density         = float(s['density'])\n    max_deg         = float(s['max_degree'])\n    min_deg         = float(s['min_degree'])\n    std_deg         = float(s['std_degree'])\n    avg_clust       = float(s['avg_clustering'])\n    trans           = float(s['transitivity'])\n    assort          = float(s['degree_assortativity'])\n    num_triangles   = float(s['num_triangles'])\n    degrees         = s['degrees']            # list of ints\n\n    # ------------------------------------------------------------------\n    # 1. Size‑density hybrid term\n    #    Encourages larger graphs and penalises sparsity\n    size_term = (n ** 1.2) / (m + 1.0)\n\n    # 2. Density penalty – sparse graphs get a larger contribution\n    dens_term = 1.0 / (density + 1e-6)\n\n    # 3. Degree‑dispersion component\n    deg_range = (max_deg - min_deg + 1.0)\n    deg_disp_term = deg_range ** 0.3\n\n    # 4. Harmonic mean of degrees – captures skewness of the degree\n    #    distribution without using external math functions.\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + 1e-12)  # avoid divide‑by‑zero\n    harmonic_term = harmonic_mean\n\n    # 5. Clustering‑transitivity reduction – highly clustered graphs\n    #    tend to have shorter paths, so we down‑weight them.\n    clustering_term = 1.0 / (avg_clust + trans + 1e-6)\n\n    # 6. Assortativity boost – assortative mixing can create shortcuts.\n    assort_term = 1.0 + abs(assort)\n\n    # 7. Triangle shortcut influence – more triangles usually shorten paths.\n    triangle_term = (num_triangles + 1.0) ** 0.4\n\n    # ------------------------------------------------------------------\n    # Assemble the invariant from the individual components.\n    inv = (size_term * dens_term * deg_disp_term *\n           harmonic_term * assort_term)\n    inv = inv / (clustering_term * triangle_term)\n\n    return inv\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and built‑in\n    functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.101399\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and\n    built‑in functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate of the average shortest‑path length from a mix of global graph\n    statistics.  The expression uses only basic Python arithmetic and\n    built‑in functions; no external libraries are imported.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic graph attributes\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    density    = float(s['density'])\n    clustering = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    std_deg    = float(s['std_degree'])\n    max_deg    = float(s['max_degree'])\n    min_deg    = float(s['min_degree'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']          # list of ints\n\n    # 1. Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # 2. Adjustment factors for structural properties\n    density_adj   = 1 + pow(1 - density, 1.2)          # sparser → longer paths\n    clustering_adj = 1 - pow(clustering, 1.2)          # more clustering → shorter paths\n    assort_adj    = 1 + pow(abs(assort), 0.6)           # assortative → longer paths\n    hetero_adj    = 1 - std_deg / pow(avg_deg + eps, 0.8)  # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / pow(n - 1 + eps, 0.7)   # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / pow(n * (n - 1) / 2 + eps, 0.6)  # more triangles → shorter paths\n\n    # 3. Harmonic mean of degrees – captures skewness of the degree distribution\n    harmonic_sum = 0.0\n    for d in degrees:\n        if d > 0:\n            harmonic_sum += 1.0 / float(d)\n    harmonic_mean = n / (harmonic_sum + eps)\n    harmonic_adj  = 1 + (harmonic_mean - avg_deg) / (avg_deg + eps) * 0.3\n\n    # 4. Minimum degree influence – very low min degree can increase path length\n    min_deg_adj = 1 + (min_deg / (avg_deg + eps)) * 0.2\n\n    # 5. Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n    harmonic_adj  = max(0.1, min(10.0, harmonic_adj))\n    min_deg_adj   = max(0.1, min(10.0, min_deg_adj))\n\n    # 6. Combine baseline with all adjustments\n    result = (baseline * density_adj * clustering_adj * assort_adj *\n              hetero_adj * hub_adj * triangle_adj * harmonic_adj * min_deg_adj)\n\n    return result", "spearman": 0.5964689117227931, "pearson": 0.32267285769287385, "rmse": 2.731162131708067, "mae": 2.569228981971275}}
{"timestamp": "2026-02-16T12:24:23.619705+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i1_p0_169687392", "generation": 19, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.40004801920768307, "fitness_mode": "correlation", "simplicity_score": 0.1494328255618632, "novelty_bonus": 0.2064756618915471, "total_score": 0.2893947028158152, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.138564\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties (balanced coefficients)\n    density_adj   = 1 + (1 - density) * 0.45\n    clustering_adj = 1 - clustering * 0.45\n    assort_adj    = 1 + assort * 0.45\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.45\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.45\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.45\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Product of all adjustment factors\n    prod_adj = (density_adj * clustering_adj * assort_adj *\n                hetero_adj * hub_adj * triangle_adj)\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = baseline * prod_adj + norm_sq + extra_term\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties (balanced coefficients)\n    density_adj   = 1 + (1 - density) * 0.45\n    clustering_adj = 1 - clustering * 0.45\n    assort_adj    = 1 + assort * 0.45\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.45\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.45\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.45\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Product of all adjustment factors\n    prod_adj = (density_adj * clustering_adj * assort_adj *\n                hetero_adj * hub_adj * triangle_adj)\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = baseline * prod_adj + norm_sq + extra_term\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39513087827195686, "pearson": 0.2693174800799197, "rmse": 2.6399198384970286, "mae": 2.4622241723281153}}
{"timestamp": "2026-02-16T12:24:57.660719+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.144304", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:24:57.661695+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 19, "island_id": 1, "population_idx": 1, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.144304", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:25:28.440795+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 1, "population_idx": 1, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.123869", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:25:28.441149+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 19, "island_id": 1, "population_idx": 1, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:26:17.018775+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:26:17.020076+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 19, "island_id": 1, "population_idx": 2, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:27:04.510491+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i1_p2_487667568", "generation": 19, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.40004801920768307, "fitness_mode": "correlation", "simplicity_score": 0.1494328255618632, "novelty_bonus": 0.20360309007725186, "total_score": 0.28984771414109833, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nbelow_novelty_threshold: novelty_bonus=0.144304\nbelow_novelty_threshold: novelty_bonus=0.123869\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport numpy as np\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed graph features.\n    The formula blends a baseline size/degree term, structural adjustment\n    factors, and several higher‑order corrections that capture clustering,\n    transitivity, degree heterogeneity, and degree extremes.\n    \"\"\"\n    eps = 1e-12\n\n    # Basic statistics\n    n          = s['n']\n    m          = s['m']\n    density    = s['density']\n    avg_deg    = s['avg_degree']\n    max_deg    = s['max_degree']\n    min_deg    = s['min_degree']\n    std_deg    = s['std_degree']\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # ---------- Baseline ----------\n    baseline = np.sqrt(n) / (avg_deg + eps)\n\n    # ---------- Adjustment factors ----------\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustments to avoid extreme scaling\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n\n    # ---------- Higher‑order corrections ----------\n    # Normalised sum of squared degrees (captures degree dispersion)\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Interaction of clustering and transitivity\n    extra_term = np.sqrt(n) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Effect of degree extremes weighted by graph size and assortativity\n    extra_term2 = np.log1p(m) * (max_deg / (min_deg + eps)) * (1 - abs(assort))\n\n    # ---------- Combine everything ----------\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj\n        + norm_sq\n        + extra_term\n        + extra_term2\n    )\n\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "```python\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Interaction of clustering and transitivity\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine everything\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n```", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10.0, density_adj))\n    clustering_adj = max(0.1, min(10.0, clustering_adj))\n    assort_adj    = max(0.1, min(10.0, assort_adj))\n    hetero_adj    = max(0.1, min(10.0, hetero_adj))\n    hub_adj       = max(0.1, min(10.0, hub_adj))\n    triangle_adj  = max(0.1, min(10.0, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Interaction of clustering and transitivity\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine everything\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39776044401110033, "pearson": 0.2706257650750893, "rmse": 2.6395642267374715, "mae": 2.4619211786827204}}
{"timestamp": "2026-02-16T12:27:04.511084+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 19, "island_id": 1, "population_idx": 2, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:27:55.073419+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:27:55.074129+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 19, "island_id": 1, "population_idx": 3, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:28:19.624520+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 1, "population_idx": 3, "attempt_index": 1, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: code must define exactly one function named `new_invariant`", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:28:19.625044+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 19, "island_id": 1, "population_idx": 3, "status": "failed", "reason": "no_valid_train_predictions", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:29:32.152902+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i1_p4_497853332", "generation": 19, "island_id": 1, "model_name": "gpt-oss:20b", "train_signal": 0.40004801920768307, "fitness_mode": "correlation", "simplicity_score": 0.1495196522239334, "novelty_bonus": 0.2064756618915471, "total_score": 0.28941206814822923, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_1_free\n\nStrategy: Combine elements from the top 2 formulas into a new one. Merge their strengths into a single improved formula.\nBest formulas:\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    avg_deg = s['avg_degree']\n    density = s['density']\n    clustering = s['avg_clustering']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n\n    # Baseline estimate: grows with graph size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.5          # sparser → longer paths\n    clustering_adj = 1 - clustering * 0.5            # more clustering → shorter paths\n    assort_adj    = 1 + assort * 0.5                 # assortative → longer paths\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.5   # heterogeneity → shorter paths\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.5     # hubs → shorter paths\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.5  # more triangles → shorter paths\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Combine baseline with all adjustments\n    return baseline * density_adj * clustering_adj * assort_adj * hetero_adj * hub_adj * triangle_adj\n\ndef new_invariant(s):\n    eps = 1e-12\n\n    # Basic graph statistics\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    std_deg = s['std_degree']\n    max_deg = s['max_degree']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = n**0.5 / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = sum(d * d for d in degrees)\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = n**0.5 * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\n\ndef new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate: grows with size, shrinks with average degree\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors for structural properties\n    density_adj   = 1 + (1 - density) * 0.4\n    clustering_adj = 1 - clustering * 0.4\n    assort_adj    = 1 + assort * 0.4\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.4\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.4\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.4\n\n    # Clamp adjustment factors to avoid extreme values\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term that captures clustering and transitivity together\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine all components into the numerator\n    numerator = (\n        baseline * density_adj * clustering_adj * assort_adj *\n        hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term\n    )\n\n    # Denominator that keeps the invariant bounded\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.123869\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nno_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.45\n    clustering_adj = 1 - clustering * 0.45\n    assort_adj    = 1 + assort * 0.45\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.45\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.45\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.45\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (baseline * density_adj * clustering_adj * assort_adj *\n                 hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term)\n\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "extracted_code": "def new_invariant(s):\n    eps = 1e-12\n    n = s['n']\n    m = s['m']\n    density = s['density']\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    std_deg = s['std_degree']\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Baseline estimate\n    baseline = pow(n, 0.5) / (avg_deg + eps)\n\n    # Adjustment factors\n    density_adj   = 1 + (1 - density) * 0.45\n    clustering_adj = 1 - clustering * 0.45\n    assort_adj    = 1 + assort * 0.45\n    hetero_adj    = 1 - std_deg / (avg_deg + eps) * 0.45\n    hub_adj       = 1 - max_deg / (n - 1 + eps) * 0.45\n    triangle_adj  = 1 - num_tri / (n * (n - 1) / 2 + eps) * 0.45\n\n    # Clamp adjustments\n    density_adj   = max(0.1, min(10, density_adj))\n    clustering_adj = max(0.1, min(10, clustering_adj))\n    assort_adj    = max(0.1, min(10, assort_adj))\n    hetero_adj    = max(0.1, min(10, hetero_adj))\n    hub_adj       = max(0.1, min(10, hub_adj))\n    triangle_adj  = max(0.1, min(10, triangle_adj))\n\n    # Normalised sum of squared degrees\n    sum_sq = 0\n    for d in degrees:\n        sum_sq += d * d\n    norm_sq = sum_sq / (n * ((max_deg + 1) ** 2))\n\n    # Extra term capturing clustering and transitivity\n    extra_term = pow(n, 0.5) * avg_deg * (1 + clustering) * (1 + trans)\n\n    # Combine components\n    numerator = (baseline * density_adj * clustering_adj * assort_adj *\n                 hetero_adj * hub_adj * triangle_adj + norm_sq + extra_term)\n\n    denom = 1 + m + density + num_tri + abs(assort) + std_deg\n\n    return numerator / denom", "spearman": 0.39513087827195686, "pearson": 0.26931748007991974, "rmse": 2.6399198384970286, "mae": 2.4622241723281153}}
{"timestamp": "2026-02-16T12:30:18.853457+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i2_p0_705155959", "generation": 19, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8879231692677071, "fitness_mode": "correlation", "simplicity_score": 0.21995052817975927, "novelty_bonus": 0.1516762919072976, "total_score": 0.5629880805853256, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and\n    subtle heterogeneity effects.  Only built‑in arithmetic operators\n    are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.069169\nbelow_novelty_threshold: novelty_bonus=0.008791\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Basic baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assort))\n\n    # Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # Small minimum degree can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # Large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # Denser graphs tend to have shorter paths\n    base *= (1 - density) ** 0.5\n\n    # Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n = s['n']\n    avg_deg = s['avg_degree']\n    std_deg = s['std_degree']\n    min_deg = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans = s['transitivity']\n    assort = s['degree_assortativity']\n    density = s['density']\n    num_tri = s['num_triangles']\n    degrees = s['degrees']\n\n    # Basic baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # Adjust for clustering and assortativity\n    base *= (1 + clustering)\n    base *= (1 + abs(assort))\n\n    # Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # Small minimum degree can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # Large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # Denser graphs tend to have shorter paths\n    base *= (1 - density) ** 0.5\n\n    # Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.946990174754369, "pearson": 0.8688108239775192, "rmse": 8.202294945287418, "mae": 4.867208317672224}}
{"timestamp": "2026-02-16T12:31:00.999585+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i2_p1_420193956", "generation": 19, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8879231692677071, "fitness_mode": "correlation", "simplicity_score": 0.2196395479219538, "novelty_bonus": 0.1516762919072976, "total_score": 0.5629258845337645, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and\n    subtle heterogeneity effects.  Only built‑in arithmetic operators\n    are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.069169\nbelow_novelty_threshold: novelty_bonus=0.008791\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.  The estimate is built on a simple baseline that\n    grows with the number of nodes and shrinks with the average degree.\n    It is progressively adjusted for clustering, assortativity,\n    degree heterogeneity, minimum/maximum degree, density, triangle\n    prevalence, transitivity, and a subtle heterogeneity term.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)  # keep factor positive\n    base *= density_factor ** 0.5\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a handful of pre‑computed\n    graph statistics.  The estimate is built on a simple baseline that\n    grows with the number of nodes and shrinks with the average degree.\n    It is progressively adjusted for clustering, assortativity,\n    degree heterogeneity, minimum/maximum degree, density, triangle\n    prevalence, transitivity, and a subtle heterogeneity term.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)  # keep factor positive\n    base *= density_factor ** 0.5\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base", "spearman": 0.946990174754369, "pearson": 0.8688108239775192, "rmse": 8.202294945287418, "mae": 4.867208317672224}}
{"timestamp": "2026-02-16T12:31:50.384500+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i2_p2_99991078", "generation": 19, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.8879231692677071, "fitness_mode": "correlation", "simplicity_score": 0.21968639156965597, "novelty_bonus": 0.1516762919072976, "total_score": 0.562935253263305, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and\n    subtle heterogeneity effects.  Only built‑in arithmetic operators\n    are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.069169\nbelow_novelty_threshold: novelty_bonus=0.008791\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a small set of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n    trans      = s['transitivity']\n\n    # Guard against degenerate graphs\n    if n <= 1:\n        return 0.0\n\n    # 1. Baseline: grows with n, shrinks with avg degree\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    min_factor = 1 + (1 / min_deg if min_deg > 0 else 0)\n    base *= min_factor\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – bounded factor\n    density_factor = (1 - density) ** 0.5 if density < 1 else 0\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(possible_tri, 1)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg ** 2\n    if variance > 0:\n        base *= (1 + variance / (avg_deg ** 2 + 1))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest path length from a small set of\n    pre‑computed graph statistics.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree']\n    max_deg    = s['max_degree']\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n    trans      = s['transitivity']\n\n    # Guard against degenerate graphs\n    if n <= 1:\n        return 0.0\n\n    # 1. Baseline: grows with n, shrinks with avg degree\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    min_factor = 1 + (1 / min_deg if min_deg > 0 else 0)\n    base *= min_factor\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – bounded factor\n    density_factor = (1 - density) ** 0.5 if density < 1 else 0\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(possible_tri, 1)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg ** 2\n    if variance > 0:\n        base *= (1 + variance / (avg_deg ** 2 + 1))\n\n    return base", "spearman": 0.946990174754369, "pearson": 0.8688108239775192, "rmse": 8.202294945287418, "mae": 4.867208317672224}}
{"timestamp": "2026-02-16T12:32:49.368048+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.031009", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:32:49.368422+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 19, "island_id": 2, "population_idx": 3, "attempt_index": 0, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.031009", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:33:24.715359+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 2, "population_idx": 3, "attempt_index": 1, "reason": "below_novelty_threshold", "failure_feedback": "novelty_bonus=0.085950", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:33:24.715850+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 19, "island_id": 2, "population_idx": 3, "status": "failed", "reason": "below_novelty_threshold", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:34:08.580580+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i2_p4_140392485", "generation": 19, "island_id": 2, "model_name": "gpt-oss:20b", "train_signal": 0.836830732292917, "fitness_mode": "correlation", "simplicity_score": 0.2192770589217591, "novelty_bonus": 0.16085117168845942, "total_score": 0.5450793375052451, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_2_free\n\nStrategy: Improve the best existing formula. Make small targeted changes to refine accuracy while keeping the formula simple.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    All arithmetic uses only built‑in functions; no external libraries\n    are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        A compact estimate of the average shortest path length.\n    \"\"\"\n    # Basic graph descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with lower average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1/(min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = max(n - 1, 1)\n    base /= (1 + (max_deg/denom)**0.5)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density) ** 0.5\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + s['transitivity'])\n\n    # 10. Optional: use degree square average to capture subtle heterogeneity\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, transitivity, and\n    subtle heterogeneity effects.  Only built‑in arithmetic operators\n    are used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger graphs with smaller average degree have longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to create detours – increase estimate\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. Degree heterogeneity (high std) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    denom = n - 1 if n > 1 else 1\n    base /= (1 + max_deg / denom)\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    possible_tri = n * (n - 1) * (n - 2) // 6\n    if possible_tri == 0:\n        possible_tri = 1\n    tri_ratio = num_tri / possible_tri\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term (keeps the formula compact)\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is based on a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  It is then\n    progressively adjusted for clustering, assortativity, degree\n    heterogeneity, density, triangle prevalence, and transitivity.\n    Only built‑in arithmetic operators and functions are used; no\n    external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features. Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / min_deg)\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use a bounded factor\n    density_factor = max(0.05, 1 - density)\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Optional subtle heterogeneity term\n    deg_sq_avg = sum(d * d for d in degrees) / n\n    variance   = deg_sq_avg - avg_deg * avg_deg\n    if variance > 0:\n        base *= (1 + variance / (avg_deg * avg_deg + 1))\n\n    return base\nRecent failures:\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nbelow_novelty_threshold: novelty_bonus=0.031009\nbelow_novelty_threshold: novelty_bonus=0.085950\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is then progressively adjusted for clustering, assortativity,\n    degree heterogeneity, density, triangle prevalence, transitivity,\n    and degree‑skewness.  Only built‑in arithmetic operators are\n    used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use an inverse factor,\n    #    capped at a factor of 2 to avoid over‑correction.\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Degree skewness (third moment) captures subtle heterogeneity.\n    #     Normalise by avg_deg³ to keep the factor bounded.\n    avg_deg_cubed = avg_deg ** 3\n    if avg_deg_cubed == 0:\n        degree_skew = 0\n    else:\n        skew_sum = 0\n        for d in degrees:\n            diff = d - avg_deg\n            skew_sum += diff * diff * diff\n        degree_skew = skew_sum / n / avg_deg_cubed\n    base *= (1 + abs(degree_skew))\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Approximate the average shortest path length from a handful of\n    pre‑computed graph statistics.\n\n    The estimate is built from a simple baseline that grows with the\n    number of nodes and shrinks with the average degree.  The baseline\n    is then progressively adjusted for clustering, assortativity,\n    degree heterogeneity, density, triangle prevalence, transitivity,\n    and degree‑skewness.  Only built‑in arithmetic operators are\n    used; no external libraries are imported.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys are\n        ``n``, ``m``, ``density``, ``avg_degree``, ``max_degree``,\n        ``min_degree``, ``std_degree``, ``avg_clustering``,\n        ``transitivity``, ``degree_assortativity``, ``num_triangles``,\n        ``degrees`` (sorted list of degrees).\n\n    Returns\n    -------\n    float\n        Approximate average shortest path length.\n    \"\"\"\n    # Basic descriptors\n    n          = s['n']\n    avg_deg    = s['avg_degree']\n    std_deg    = s['std_degree']\n    min_deg    = s['min_degree'] if s['min_degree'] > 0 else 1\n    max_deg    = s['max_degree'] if s['max_degree'] > 0 else 0\n    clustering = s['avg_clustering']\n    trans      = s['transitivity']\n    assort     = s['degree_assortativity']\n    density    = s['density']\n    num_tri    = s['num_triangles']\n    degrees    = s['degrees']\n\n    # 1. Baseline: larger n or smaller avg_deg → longer paths\n    base = n / (avg_deg + 1)\n\n    # 2. Clustering tends to increase detours\n    base *= (1 + clustering)\n\n    # 3. Positive assortativity usually lengthens paths\n    base *= (1 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1 + std_deg)\n\n    # 5. Very small minimum degree (leaves) can lengthen paths\n    base *= (1 + 1 / (min_deg + 1))\n\n    # 6. Very large maximum degree (hubs) shortens paths\n    base /= (1 + max_deg / max(n - 1, 1))\n\n    # 7. Denser graphs have shorter paths – use an inverse factor,\n    #    capped at a factor of 2 to avoid over‑correction.\n    density_factor = 1 / max(density, 0.01)          # avoid division by zero\n    if density_factor > 2:                          # cap the influence\n        density_factor = 2\n    base *= density_factor\n\n    # 8. Triangle ratio indicates local cohesion; more triangles shorten paths\n    if n >= 3:\n        possible_tri = n * (n - 1) * (n - 2) // 6\n    else:\n        possible_tri = 1\n    tri_ratio = num_tri / max(1, possible_tri)\n    base /= (1 + tri_ratio ** 0.5)\n\n    # 9. Global transitivity further shortens paths\n    base *= (1 + trans)\n\n    # 10. Degree skewness (third moment) captures subtle heterogeneity.\n    #     Normalise by avg_deg³ to keep the factor bounded.\n    avg_deg_cubed = avg_deg ** 3\n    if avg_deg_cubed == 0:\n        degree_skew = 0\n    else:\n        skew_sum = 0\n        for d in degrees:\n            diff = d - avg_deg\n            skew_sum += diff * diff * diff\n        degree_skew = skew_sum / n / avg_deg_cubed\n    base *= (1 + abs(degree_skew))\n\n    return base", "spearman": 0.9059371484287109, "pearson": 0.4099628171874736, "rmse": 47.48835497738329, "mae": 16.486363815009046}}
{"timestamp": "2026-02-16T12:35:09.480654+00:00", "event_type": "candidate_rejected", "payload": {"generation": 19, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:35:09.481922+00:00", "event_type": "candidate_repair_attempted", "payload": {"generation": 19, "island_id": 3, "population_idx": 0, "attempt_index": 0, "reason": "no_valid_train_predictions", "failure_feedback": "static_invalid: forbidden token detected: import ", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:35:50.046622+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i3_p0_891371253", "generation": 19, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8351020408163264, "fitness_mode": "correlation", "simplicity_score": 0.21990166475003348, "novelty_bonus": 0.18153983799426943, "total_score": 0.5585292865233419, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    only.  The expression combines size, degree distribution, assortativity,\n    clustering, density, triangle prevalence, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n, m\n        - density\n        - avg_degree\n        - max_degree, min_degree\n        - std_degree\n        - avg_clustering\n        - transitivity\n        - degree_assortativity\n        - num_triangles\n        - degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    num_tri  = float(s['num_triangles'])\n    degrees  = s['degrees']\n\n    # Harmonic mean of positive degrees (avoid division by zero)\n    positive_degrees = [d for d in degrees if d > 0]\n    if positive_degrees:\n        hm_den = sum(1.0 / d for d in positive_degrees)\n        harmonic = float(len(positive_degrees)) / hm_den\n    else:\n        harmonic = 0.1  # fallback for empty or all-zero degree lists\n\n    # Triangle ratio (fraction of possible triangles that exist)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n\n    # Degree heterogeneity adjustment (larger std or spread shortens paths)\n    heter = 1.0 + std_deg + (max_deg - min_deg) / (max_deg if max_deg > 0 else 1.0)\n\n    # Baseline: larger n or smaller connectivity yields longer paths\n    inv = n / (harmonic + 1.0)\n\n    # Positive assortativity tends to stretch paths\n    inv *= (1.0 + abs(assort))\n\n    # Local clustering tends to create detours\n    inv *= (1.0 + clust)\n\n    # Heterogeneity (hubs) shortens paths\n    inv /= heter\n\n    # Density reduces expected distance (cap at 0.05)\n    density_factor = max(0.05, 1.0 - density)\n    inv *= density_factor\n\n    # Triangle abundance shortens paths\n    inv /= (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    inv *= (1.0 + trans)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics provided in the dictionary `s`.  The formula is a\n    product‑sum of terms that capture how size, connectivity, degree\n    heterogeneity, clustering, assortativity, density, triangles and\n    transitivity influence expected path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys:\n            n, avg_degree, std_degree, avg_clustering,\n            degree_assortativity, density, max_degree,\n            num_triangles, transitivity\n\n    Returns\n    -------\n    float\n        An approximation of the average shortest‑path length.\n    \"\"\"\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    num_tri    = float(s['num_triangles'])\n    trans      = float(s['transitivity'])\n\n    # 1. Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1.0)\n\n    # 2. Clustering tends to create detours\n    base *= (1.0 + clust)\n\n    # 3. Positive assortativity typically lengthens paths\n    base *= (1.0 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Higher density reduces expected distance\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0.0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Effect of the most connected nodes as central hubs\n    hub_factor = 1.0 + max_deg / (n * (avg_deg + 1e-6))\n    base *= hub_factor\n\n    return base\nRecent failures:\nbelow_train_threshold: train_signal=0.285858\nbelow_novelty_threshold: novelty_bonus=0.107422\nbelow_novelty_threshold: novelty_bonus=0.048614\nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n\n\nRepair this candidate. It failed evaluation.\nFailure: static_invalid: forbidden token detected: import \nPrevious candidate code:\n```python\nimport math\nfrom typing import Dict, Any\n\ndef new_invariant(s: Dict[str, Any]) -> float:\n    \"\"\"\n    Rough estimate of the *average shortest‑path length* for an arbitrary graph,\n    using only global statistics supplied in ``s``.\n    \n    The expression is intentionally a product of several dimensionless terms\n    that capture how different structural properties influence the expected\n    distance between two randomly chosen vertices:\n    \n    1. A size/degree baseline that grows with the number of nodes and\n       shrinks with average degree.\n    2. Adjustments for heterogeneity (degree variance and range).\n    3. Penalties for assortativity and local clustering (both tend to\n       stretch paths).\n    4. Short‑cut contributions from triangles and global transitivity.\n    5. A dampening factor that scales inversely with density.\n    6. An amplification from very high‑degree hubs.\n\n    All operations avoid division by zero and rely solely on the numeric\n    fields of ``s``; no graph traversal is performed.\n    \n    Parameters\n    ----------\n    s : dict\n        Must contain at least the following keys:\n        - n, m                     # node and edge count\n        - avg_degree, std_degree   # mean and standard deviation of degrees\n        - max_degree, min_degree\n        - density\n        - avg_clustering\n        - transitivity\n        - degree_assortativity\n        - num_triangles\n        - degrees (list of ints, sorted)\n    \n    Returns\n    -------\n    float\n        Estimated average shortest‑path length (dimensionless).\n    \"\"\"\n    # ---------- basic scalars ----------\n    n           = float(s['n'])\n    m           = float(s['m'])\n    avg_deg     = float(s['avg_degree'])\n    std_deg     = float(s['std_degree'])\n    min_deg     = float(s['min_degree'])\n    max_deg     = float(s['max_degree'])\n    density     = float(s['density'])\n    clust       = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    num_tri     = float(s['num_triangles'])\n    degrees     = [float(d) for d in s['degrees'] if d > 0]\n\n    # ---------- auxiliary quantities ----------\n    # 1. Harmonic mean of the positive degrees\n    if degrees:\n        harmonic_deg = len(degrees) / sum(1.0 / d for d in degrees)\n    else:\n        harmonic_deg = 1.0\n\n    # 2. Triangle ratio (fraction of possible triangles that actually exist)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    tri_ratio = num_tri / possible_tri if possible_tri > 0 else 0.0\n\n    # 3. Degree‑range factor – captures how stretched the degree distribution is\n    deg_range = (max_deg - min_deg) / (max_deg + 1e-12)\n\n    # ---------- construct the estimate ----------\n    # Baseline: larger networks have longer paths; higher average degree shortens them\n    baseline = math.log(n + 1.0) * math.log(m + 1.0) / (avg_deg + 1.0)\n\n    # Heterogeneity adjustment – high variance or wide range shortens paths\n    hetero = 1.0 + std_deg / (avg_deg + 1e-12) + deg_range\n    baseline *= hetero\n\n    # Local clustering detours – add a penalty proportional to clustering\n    baseline *= (1.0 + clust)\n\n    # Assortativity tends to spread edges among similar degrees, generally\n    # lengthening shortest paths.  We penalise absolute assortativity.\n    baseline *= (1.0 + abs(assort))\n\n    # Triangle shortcuts – reduce path lengths.  The more triangles, the smaller\n    # the expected distance.  We divide by (1 + tri_ratio) to model this effect.\n    baseline /= (1.0 + tri_ratio)\n\n    # Global transitivity provides another source of short cuts; we boost the\n    # estimate multiplicatively.\n    baseline *= (1.0 + trans)\n\n    # Density effect – a denser graph should have shorter paths.\n    density_factor = max(0.01, 1.0 - density)\n    baseline *= density_factor\n\n    # Hub factor – a very large maximum degree can act as a super‑hub,\n    # dramatically reducing the average distance.\n    hub_factor = 1.0 + max_deg / (n * (avg_deg + 1e-12))\n    baseline *= hub_factor\n\n    # Harmonic degree correction – a very low harmonic mean indicates many\n    # dangling nodes that inflate distances; we scale up accordingly.\n    baseline *= (1.0 + 1.0 / (harmonic_deg + 1e-12))\n\n    return baseline\n```\nReturn only corrected python code defining `def new_invariant(s):`.", "llm_response": "def new_invariant(s):\n    \"\"\"\n    Rough estimate of the average shortest‑path length using only the\n    pre‑computed global statistics in the dictionary *s*.\n    The formula is a product of dimensionless terms that capture\n    the influence of size, connectivity, degree heterogeneity,\n    assortativity, clustering, density, triangle abundance and\n    hub prominence.  No graph traversal or external libraries are used.\n    \"\"\"\n    # Basic scalars\n    n           = float(s['n'])\n    avg_deg     = float(s['avg_degree'])\n    std_deg     = float(s['std_degree'])\n    max_deg     = float(s['max_degree'])\n    min_deg     = float(s['min_degree'])\n    density     = float(s['density'])\n    clust       = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    num_tri     = float(s['num_triangles'])\n    degrees     = [float(d) for d in s['degrees'] if d > 0]\n\n    # ---- base length: grows with size, shrinks with mean connectivity ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- penalties for assortativity (edges among similar degrees) ----\n    base *= 1.0 + abs(assort)\n\n    # ---- penalties for local clustering (more detours) ----\n    base *= 1.0 + clust\n\n    # ---- benefit from degree heterogeneity (hubs shorten paths) ----\n    heter_factor = 1.0 + std_deg / (avg_deg + 1e-6)\n    base /= heter_factor\n\n    # ---- triangle shortcut effect ----\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    tri_ratio    = num_tri / (possible_tri + 1e-6)\n    base /= 1.0 + tri_ratio\n\n    # ---- boost from global transitivity ----\n    base *= 1.0 + trans\n\n    # ---- density factor (denser graphs -> shorter paths) ----\n    density_factor = max(0.01, 1.0 - density)\n    base *= density_factor\n\n    # ---- hub factor (very large max degree can act as a super‑hub) ----\n    hub_factor = 1.0 + max_deg / (n * (avg_deg + 1e-6))\n    base *= hub_factor\n\n    # ---- harmonic degree correction (dangling nodes inflate distances) ----\n    if degrees:\n        harmonic = len(degrees) / sum(1.0 / d for d in degrees)\n    else:\n        harmonic = 1.0\n    base *= 1.0 + 1.0 / (harmonic + 1e-6)\n\n    return base", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Rough estimate of the average shortest‑path length using only the\n    pre‑computed global statistics in the dictionary *s*.\n    The formula is a product of dimensionless terms that capture\n    the influence of size, connectivity, degree heterogeneity,\n    assortativity, clustering, density, triangle abundance and\n    hub prominence.  No graph traversal or external libraries are used.\n    \"\"\"\n    # Basic scalars\n    n           = float(s['n'])\n    avg_deg     = float(s['avg_degree'])\n    std_deg     = float(s['std_degree'])\n    max_deg     = float(s['max_degree'])\n    min_deg     = float(s['min_degree'])\n    density     = float(s['density'])\n    clust       = float(s['avg_clustering'])\n    trans       = float(s['transitivity'])\n    assort      = float(s['degree_assortativity'])\n    num_tri     = float(s['num_triangles'])\n    degrees     = [float(d) for d in s['degrees'] if d > 0]\n\n    # ---- base length: grows with size, shrinks with mean connectivity ----\n    base = n / (avg_deg + 1.0)\n\n    # ---- penalties for assortativity (edges among similar degrees) ----\n    base *= 1.0 + abs(assort)\n\n    # ---- penalties for local clustering (more detours) ----\n    base *= 1.0 + clust\n\n    # ---- benefit from degree heterogeneity (hubs shorten paths) ----\n    heter_factor = 1.0 + std_deg / (avg_deg + 1e-6)\n    base /= heter_factor\n\n    # ---- triangle shortcut effect ----\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    tri_ratio    = num_tri / (possible_tri + 1e-6)\n    base /= 1.0 + tri_ratio\n\n    # ---- boost from global transitivity ----\n    base *= 1.0 + trans\n\n    # ---- density factor (denser graphs -> shorter paths) ----\n    density_factor = max(0.01, 1.0 - density)\n    base *= density_factor\n\n    # ---- hub factor (very large max degree can act as a super‑hub) ----\n    hub_factor = 1.0 + max_deg / (n * (avg_deg + 1e-6))\n    base *= hub_factor\n\n    # ---- harmonic degree correction (dangling nodes inflate distances) ----\n    if degrees:\n        harmonic = len(degrees) / sum(1.0 / d for d in degrees)\n    else:\n        harmonic = 1.0\n    base *= 1.0 + 1.0 / (harmonic + 1e-6)\n\n    return base", "spearman": 0.9201740043501089, "pearson": 0.8997063999218115, "rmse": 12.116695558464038, "mae": 9.854984415624862}}
{"timestamp": "2026-02-16T12:35:50.047345+00:00", "event_type": "candidate_repair_result", "payload": {"generation": 19, "island_id": 3, "population_idx": 0, "status": "success", "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:36:38.678843+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i3_p1_788685105", "generation": 19, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.4756302521008403, "fitness_mode": "correlation", "simplicity_score": 0.22137394722358028, "novelty_bonus": 0.4302278395247714, "total_score": 0.48468792492173807, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    only.  The expression combines size, degree distribution, assortativity,\n    clustering, density, triangle prevalence, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n, m\n        - density\n        - avg_degree\n        - max_degree, min_degree\n        - std_degree\n        - avg_clustering\n        - transitivity\n        - degree_assortativity\n        - num_triangles\n        - degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    num_tri  = float(s['num_triangles'])\n    degrees  = s['degrees']\n\n    # Harmonic mean of positive degrees (avoid division by zero)\n    positive_degrees = [d for d in degrees if d > 0]\n    if positive_degrees:\n        hm_den = sum(1.0 / d for d in positive_degrees)\n        harmonic = float(len(positive_degrees)) / hm_den\n    else:\n        harmonic = 0.1  # fallback for empty or all-zero degree lists\n\n    # Triangle ratio (fraction of possible triangles that exist)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n\n    # Degree heterogeneity adjustment (larger std or spread shortens paths)\n    heter = 1.0 + std_deg + (max_deg - min_deg) / (max_deg if max_deg > 0 else 1.0)\n\n    # Baseline: larger n or smaller connectivity yields longer paths\n    inv = n / (harmonic + 1.0)\n\n    # Positive assortativity tends to stretch paths\n    inv *= (1.0 + abs(assort))\n\n    # Local clustering tends to create detours\n    inv *= (1.0 + clust)\n\n    # Heterogeneity (hubs) shortens paths\n    inv /= heter\n\n    # Density reduces expected distance (cap at 0.05)\n    density_factor = max(0.05, 1.0 - density)\n    inv *= density_factor\n\n    # Triangle abundance shortens paths\n    inv /= (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    inv *= (1.0 + trans)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics provided in the dictionary `s`.  The formula is a\n    product‑sum of terms that capture how size, connectivity, degree\n    heterogeneity, clustering, assortativity, density, triangles and\n    transitivity influence expected path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys:\n            n, avg_degree, std_degree, avg_clustering,\n            degree_assortativity, density, max_degree,\n            num_triangles, transitivity\n\n    Returns\n    -------\n    float\n        An approximation of the average shortest‑path length.\n    \"\"\"\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    num_tri    = float(s['num_triangles'])\n    trans      = float(s['transitivity'])\n\n    # 1. Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1.0)\n\n    # 2. Clustering tends to create detours\n    base *= (1.0 + clust)\n\n    # 3. Positive assortativity typically lengthens paths\n    base *= (1.0 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Higher density reduces expected distance\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0.0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Effect of the most connected nodes as central hubs\n    hub_factor = 1.0 + max_deg / (n * (avg_deg + 1e-6))\n    base *= hub_factor\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.107422\nbelow_novelty_threshold: novelty_bonus=0.048614\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed global\n    statistics only.  The expression is a series of multiplications and\n    divisions that capture how size, density, degree heterogeneity,\n    clustering, assortativity, triangles, and transitivity jointly\n    influence expected path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the following keys (all numeric):\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    # Convert to float to keep arithmetic in floating point\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    avg_deg = float(s['avg_degree'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    std_deg = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n    # ---------- 1. Baseline: grows with size, shrinks with mean connectivity ----------\n    base = n / (avg_deg + 1.0)  # +1 avoids division by zero when avg_deg == 0\n\n    # ---------- 2. Positive assortativity tends to lengthen paths ----------\n    base *= (1.0 + abs(assort))\n\n    # ---------- 3. Local clustering creates detours ----------\n    base *= (1.0 + avg_clust)\n\n    # ---------- 4. Degree heterogeneity (hubs) shortens paths ----------\n    heter_factor = 1.0 + std_deg / (avg_deg + 1e-6)\n    base /= heter_factor\n\n    # ---------- 5. Effect of the most connected nodes as central hubs ----------\n    hub_factor = 1.0 + max_deg / (avg_deg + 1e-6)\n    base /= hub_factor\n\n    # ---------- 6. Density reduction (higher density → shorter paths) ----------\n    dens_factor = max(0.05, 1.0 - density)   # cap at a small positive value\n    base *= dens_factor\n\n    # ---------- 7. Triangle abundance provides local shortcuts ----------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0.0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # ---------- 8. Global transitivity (another form of clustering) ----------\n    base *= (1.0 + trans)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from pre‑computed global\n    statistics only.  The expression is a series of multiplications and\n    divisions that capture how size, density, degree heterogeneity,\n    clustering, assortativity, triangles, and transitivity jointly\n    influence expected path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the following keys (all numeric):\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees\n\n    Returns\n    -------\n    float\n        Approximate average shortest‑path length.\n    \"\"\"\n    # Convert to float to keep arithmetic in floating point\n    n = float(s['n'])\n    m = float(s['m'])\n    density = float(s['density'])\n    avg_deg = float(s['avg_degree'])\n    max_deg = float(s['max_degree'])\n    min_deg = float(s['min_degree'])\n    std_deg = float(s['std_degree'])\n    avg_clust = float(s['avg_clustering'])\n    trans = float(s['transitivity'])\n    assort = float(s['degree_assortativity'])\n    num_tri = float(s['num_triangles'])\n    # ---------- 1. Baseline: grows with size, shrinks with mean connectivity ----------\n    base = n / (avg_deg + 1.0)  # +1 avoids division by zero when avg_deg == 0\n\n    # ---------- 2. Positive assortativity tends to lengthen paths ----------\n    base *= (1.0 + abs(assort))\n\n    # ---------- 3. Local clustering creates detours ----------\n    base *= (1.0 + avg_clust)\n\n    # ---------- 4. Degree heterogeneity (hubs) shortens paths ----------\n    heter_factor = 1.0 + std_deg / (avg_deg + 1e-6)\n    base /= heter_factor\n\n    # ---------- 5. Effect of the most connected nodes as central hubs ----------\n    hub_factor = 1.0 + max_deg / (avg_deg + 1e-6)\n    base /= hub_factor\n\n    # ---------- 6. Density reduction (higher density → shorter paths) ----------\n    dens_factor = max(0.05, 1.0 - density)   # cap at a small positive value\n    base *= dens_factor\n\n    # ---------- 7. Triangle abundance provides local shortcuts ----------\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0.0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # ---------- 8. Global transitivity (another form of clustering) ----------\n    base *= (1.0 + trans)\n\n    return base", "spearman": 0.6226895672391811, "pearson": 0.6598114126002939, "rmse": 1.8770106269889248, "mae": 1.3060722822480582}}
{"timestamp": "2026-02-16T12:37:16.268326+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i3_p2_82500222", "generation": 19, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8365426170468188, "fitness_mode": "correlation", "simplicity_score": 0.22339600781462388, "novelty_bonus": 0.15667879077992342, "total_score": 0.5323646058410779, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    only.  The expression combines size, degree distribution, assortativity,\n    clustering, density, triangle prevalence, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n, m\n        - density\n        - avg_degree\n        - max_degree, min_degree\n        - std_degree\n        - avg_clustering\n        - transitivity\n        - degree_assortativity\n        - num_triangles\n        - degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    num_tri  = float(s['num_triangles'])\n    degrees  = s['degrees']\n\n    # Harmonic mean of positive degrees (avoid division by zero)\n    positive_degrees = [d for d in degrees if d > 0]\n    if positive_degrees:\n        hm_den = sum(1.0 / d for d in positive_degrees)\n        harmonic = float(len(positive_degrees)) / hm_den\n    else:\n        harmonic = 0.1  # fallback for empty or all-zero degree lists\n\n    # Triangle ratio (fraction of possible triangles that exist)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n\n    # Degree heterogeneity adjustment (larger std or spread shortens paths)\n    heter = 1.0 + std_deg + (max_deg - min_deg) / (max_deg if max_deg > 0 else 1.0)\n\n    # Baseline: larger n or smaller connectivity yields longer paths\n    inv = n / (harmonic + 1.0)\n\n    # Positive assortativity tends to stretch paths\n    inv *= (1.0 + abs(assort))\n\n    # Local clustering tends to create detours\n    inv *= (1.0 + clust)\n\n    # Heterogeneity (hubs) shortens paths\n    inv /= heter\n\n    # Density reduces expected distance (cap at 0.05)\n    density_factor = max(0.05, 1.0 - density)\n    inv *= density_factor\n\n    # Triangle abundance shortens paths\n    inv /= (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    inv *= (1.0 + trans)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics provided in the dictionary `s`.  The formula is a\n    product‑sum of terms that capture how size, connectivity, degree\n    heterogeneity, clustering, assortativity, density, triangles and\n    transitivity influence expected path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys:\n            n, avg_degree, std_degree, avg_clustering,\n            degree_assortativity, density, max_degree,\n            num_triangles, transitivity\n\n    Returns\n    -------\n    float\n        An approximation of the average shortest‑path length.\n    \"\"\"\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    num_tri    = float(s['num_triangles'])\n    trans      = float(s['transitivity'])\n\n    # 1. Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1.0)\n\n    # 2. Clustering tends to create detours\n    base *= (1.0 + clust)\n\n    # 3. Positive assortativity typically lengthens paths\n    base *= (1.0 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Higher density reduces expected distance\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0.0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Effect of the most connected nodes as central hubs\n    hub_factor = 1.0 + max_deg / (n * (avg_deg + 1e-6))\n    base *= hub_factor\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.107422\nbelow_novelty_threshold: novelty_bonus=0.048614\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics only.\n    The formula blends several structural factors (size, connectivity, clustering,\n    assortativity, degree heterogeneity, triangle abundance, density, and hubiness)\n    into a compact product.  All operations use only built‑in Python functions;\n    no external imports or graph traversal algorithms are required.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed features with the keys:\n            n                (int)   – number of nodes\n            m                (int)   – number of edges\n            density          (float)\n            avg_degree       (float)\n            max_degree       (int)\n            min_degree       (int)\n            std_degree       (float)\n            avg_clustering   (float)\n            transitivity     (float)\n            degree_assortativity (float)\n            num_triangles    (int)\n            degrees          (list of ints) – sorted degree sequence\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']\n\n    # 1. Baseline scaling: grows with network size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Local clustering often forces detours; scale accordingly\n    base *= (1.0 + clust)\n\n    # 3. Assortative mixing can stretch paths; include absolute value to handle both signs\n    base *= (1.0 + abs(assort))\n\n    # 4. Heterogeneity (high std dev) and abundant triangles short‑circuit paths\n    #    Compute triangle ratio (fraction of possible triangles that actually exist)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    # Reduce the estimate when heterogeneity or triangles are high\n    base /= (1.0 + std_deg + tri_ratio)\n\n    # 5. Density provides a global shortcut; ensure factor never collapses to zero\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Presence of very large hubs tends to shrink paths further\n    hub_factor = 1.0 + max_deg / (n + 1e-6)\n    base *= hub_factor\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics only.\n    The formula blends several structural factors (size, connectivity, clustering,\n    assortativity, degree heterogeneity, triangle abundance, density, and hubiness)\n    into a compact product.  All operations use only built‑in Python functions;\n    no external imports or graph traversal algorithms are required.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed features with the keys:\n            n                (int)   – number of nodes\n            m                (int)   – number of edges\n            density          (float)\n            avg_degree       (float)\n            max_degree       (int)\n            min_degree       (int)\n            std_degree       (float)\n            avg_clustering   (float)\n            transitivity     (float)\n            degree_assortativity (float)\n            num_triangles    (int)\n            degrees          (list of ints) – sorted degree sequence\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    max_deg    = float(s['max_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    num_tri    = float(s['num_triangles'])\n    degrees    = s['degrees']\n\n    # 1. Baseline scaling: grows with network size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Local clustering often forces detours; scale accordingly\n    base *= (1.0 + clust)\n\n    # 3. Assortative mixing can stretch paths; include absolute value to handle both signs\n    base *= (1.0 + abs(assort))\n\n    # 4. Heterogeneity (high std dev) and abundant triangles short‑circuit paths\n    #    Compute triangle ratio (fraction of possible triangles that actually exist)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)          # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    # Reduce the estimate when heterogeneity or triangles are high\n    base /= (1.0 + std_deg + tri_ratio)\n\n    # 5. Density provides a global shortcut; ensure factor never collapses to zero\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Presence of very large hubs tends to shrink paths further\n    hub_factor = 1.0 + max_deg / (n + 1e-6)\n    base *= hub_factor\n\n    return base", "spearman": 0.8813635340883523, "pearson": 0.7835811211077914, "rmse": 2.7827175464839553, "mae": 1.8245903189884967}}
{"timestamp": "2026-02-16T12:37:50.904455+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i3_p3_6975096", "generation": 19, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8056182472989195, "fitness_mode": "correlation", "simplicity_score": 0.22095870552600597, "novelty_bonus": 0.22177006503606378, "total_score": 0.5576896847891247, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    only.  The expression combines size, degree distribution, assortativity,\n    clustering, density, triangle prevalence, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n, m\n        - density\n        - avg_degree\n        - max_degree, min_degree\n        - std_degree\n        - avg_clustering\n        - transitivity\n        - degree_assortativity\n        - num_triangles\n        - degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    num_tri  = float(s['num_triangles'])\n    degrees  = s['degrees']\n\n    # Harmonic mean of positive degrees (avoid division by zero)\n    positive_degrees = [d for d in degrees if d > 0]\n    if positive_degrees:\n        hm_den = sum(1.0 / d for d in positive_degrees)\n        harmonic = float(len(positive_degrees)) / hm_den\n    else:\n        harmonic = 0.1  # fallback for empty or all-zero degree lists\n\n    # Triangle ratio (fraction of possible triangles that exist)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n\n    # Degree heterogeneity adjustment (larger std or spread shortens paths)\n    heter = 1.0 + std_deg + (max_deg - min_deg) / (max_deg if max_deg > 0 else 1.0)\n\n    # Baseline: larger n or smaller connectivity yields longer paths\n    inv = n / (harmonic + 1.0)\n\n    # Positive assortativity tends to stretch paths\n    inv *= (1.0 + abs(assort))\n\n    # Local clustering tends to create detours\n    inv *= (1.0 + clust)\n\n    # Heterogeneity (hubs) shortens paths\n    inv /= heter\n\n    # Density reduces expected distance (cap at 0.05)\n    density_factor = max(0.05, 1.0 - density)\n    inv *= density_factor\n\n    # Triangle abundance shortens paths\n    inv /= (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    inv *= (1.0 + trans)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics provided in the dictionary `s`.  The formula is a\n    product‑sum of terms that capture how size, connectivity, degree\n    heterogeneity, clustering, assortativity, density, triangles and\n    transitivity influence expected path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys:\n            n, avg_degree, std_degree, avg_clustering,\n            degree_assortativity, density, max_degree,\n            num_triangles, transitivity\n\n    Returns\n    -------\n    float\n        An approximation of the average shortest‑path length.\n    \"\"\"\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    num_tri    = float(s['num_triangles'])\n    trans      = float(s['transitivity'])\n\n    # 1. Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1.0)\n\n    # 2. Clustering tends to create detours\n    base *= (1.0 + clust)\n\n    # 3. Positive assortativity typically lengthens paths\n    base *= (1.0 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Higher density reduces expected distance\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0.0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Effect of the most connected nodes as central hubs\n    hub_factor = 1.0 + max_deg / (n * (avg_deg + 1e-6))\n    base *= hub_factor\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.107422\nbelow_novelty_threshold: novelty_bonus=0.048614\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph using only the\n    globally pre‑computed statistics supplied in *s*.  The formula is a\n    dimensionless combination of size, mean connectivity, degree\n    heterogeneity, clustering, assortativity, density, triangle\n    abundance, transitivity and the influence of the most connected\n    nodes.  All arithmetic is performed with the built‑in operators\n    and functions so that no external imports are required.\n    \n    Parameters\n    ----------\n    s : dict\n        Must contain the keys\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees.\n    \n    Returns\n    -------\n    float\n        An estimated average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    num_tri  = float(s['num_triangles'])\n    degrees  = s['degrees']\n\n    # 1. Baseline: larger graphs produce longer paths,\n    #    higher mean degree shortens paths.\n    base = n / (avg_deg + 1.0)\n\n    # 2. Degree heterogeneity: a wider spread (high max/min)\n    #    usually creates hubs that act as shortcuts.\n    spread = (max_deg - min_deg) / (max_deg + 1e-6)\n    base /= (1.0 + spread)\n\n    # 3. Clustering can create detours; increase length.\n    base *= (1.0 + clust)\n\n    # 4. Assortativity tends to stretch paths if positive,\n    #    while negative assortativity tends to reduce them.\n    base *= (1.0 + abs(assort))\n\n    # 5. Standard deviation of degrees also introduces hubs.\n    base /= (1.0 + std_deg)\n\n    # 6. Density reduces expected distance.  Use a factor that\n    #    never goes below 0.05 to avoid zeroing the value.\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 7. Triangle abundance: triangles provide local shortcuts.\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0.0:\n        possible_tri = 1.0   # safeguard for tiny or empty graphs\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 8. Transitivity (global clustering) again shortens paths.\n    base *= (1.0 + trans)\n\n    # 9. Influence of the most connected nodes.\n    #    Very large hubs can act as super‑hub, reducing distance.\n    hub_factor = 1.0 + max_deg / (n * (avg_deg + 1e-6))\n    base *= hub_factor\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length of a graph using only the\n    globally pre‑computed statistics supplied in *s*.  The formula is a\n    dimensionless combination of size, mean connectivity, degree\n    heterogeneity, clustering, assortativity, density, triangle\n    abundance, transitivity and the influence of the most connected\n    nodes.  All arithmetic is performed with the built‑in operators\n    and functions so that no external imports are required.\n    \n    Parameters\n    ----------\n    s : dict\n        Must contain the keys\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles, degrees.\n    \n    Returns\n    -------\n    float\n        An estimated average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    num_tri  = float(s['num_triangles'])\n    degrees  = s['degrees']\n\n    # 1. Baseline: larger graphs produce longer paths,\n    #    higher mean degree shortens paths.\n    base = n / (avg_deg + 1.0)\n\n    # 2. Degree heterogeneity: a wider spread (high max/min)\n    #    usually creates hubs that act as shortcuts.\n    spread = (max_deg - min_deg) / (max_deg + 1e-6)\n    base /= (1.0 + spread)\n\n    # 3. Clustering can create detours; increase length.\n    base *= (1.0 + clust)\n\n    # 4. Assortativity tends to stretch paths if positive,\n    #    while negative assortativity tends to reduce them.\n    base *= (1.0 + abs(assort))\n\n    # 5. Standard deviation of degrees also introduces hubs.\n    base /= (1.0 + std_deg)\n\n    # 6. Density reduces expected distance.  Use a factor that\n    #    never goes below 0.05 to avoid zeroing the value.\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 7. Triangle abundance: triangles provide local shortcuts.\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0.0:\n        possible_tri = 1.0   # safeguard for tiny or empty graphs\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 8. Transitivity (global clustering) again shortens paths.\n    base *= (1.0 + trans)\n\n    # 9. Influence of the most connected nodes.\n    #    Very large hubs can act as super‑hub, reducing distance.\n    hub_factor = 1.0 + max_deg / (n * (avg_deg + 1e-6))\n    base *= hub_factor\n\n    return base", "spearman": 0.8939338483462088, "pearson": 0.7646155293664072, "rmse": 1.595867870304302, "mae": 1.1222336636665053}}
{"timestamp": "2026-02-16T12:38:28.038747+00:00", "event_type": "candidate_evaluated", "payload": {"candidate_id": "g19_i3_p4_730072354", "generation": 19, "island_id": 3, "model_name": "gpt-oss:20b", "train_signal": 0.8210804321728691, "fitness_mode": "correlation", "simplicity_score": 0.22137394722358028, "novelty_bonus": 0.1572068073464541, "total_score": 0.529573785072488, "prompt": "You are discovering graph invariant formulas for target `average_shortest_path_length`.\nIsland mode: island_3_free\n\nStrategy: Invent a completely novel mathematical formula. Think about how it relates to density, degree distribution, clustering, and other structural features.\nBest formulas:\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics\n    only.  The expression combines size, degree distribution, assortativity,\n    clustering, density, triangle prevalence, and transitivity.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary containing the following keys:\n        - n, m\n        - density\n        - avg_degree\n        - max_degree, min_degree\n        - std_degree\n        - avg_clustering\n        - transitivity\n        - degree_assortativity\n        - num_triangles\n        - degrees (sorted list of degrees)\n\n    Returns\n    -------\n    float\n        Approximation of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    num_tri  = float(s['num_triangles'])\n    degrees  = s['degrees']\n\n    # Harmonic mean of positive degrees (avoid division by zero)\n    positive_degrees = [d for d in degrees if d > 0]\n    if positive_degrees:\n        hm_den = sum(1.0 / d for d in positive_degrees)\n        harmonic = float(len(positive_degrees)) / hm_den\n    else:\n        harmonic = 0.1  # fallback for empty or all-zero degree lists\n\n    # Triangle ratio (fraction of possible triangles that exist)\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n\n    # Degree heterogeneity adjustment (larger std or spread shortens paths)\n    heter = 1.0 + std_deg + (max_deg - min_deg) / (max_deg if max_deg > 0 else 1.0)\n\n    # Baseline: larger n or smaller connectivity yields longer paths\n    inv = n / (harmonic + 1.0)\n\n    # Positive assortativity tends to stretch paths\n    inv *= (1.0 + abs(assort))\n\n    # Local clustering tends to create detours\n    inv *= (1.0 + clust)\n\n    # Heterogeneity (hubs) shortens paths\n    inv /= heter\n\n    # Density reduces expected distance (cap at 0.05)\n    density_factor = max(0.05, 1.0 - density)\n    inv *= density_factor\n\n    # Triangle abundance shortens paths\n    inv /= (1.0 + tri_ratio)\n\n    # Global transitivity further shortens paths\n    inv *= (1.0 + trans)\n\n    return inv\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics.  The expression is a weighted product of terms that\n    reflect how the size of the network, its average connectivity,\n    degree heterogeneity, clustering, density, and the abundance of\n    triangles influence path lengths.  All operations are safe from\n    division by zero and rely only on basic arithmetic and the\n    pre‑computed features supplied in the dictionary *s*.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys listed in the problem statement.\n\n    Returns\n    -------\n    float\n        An estimate of the average shortest‑path length.\n    \"\"\"\n    # Basic scalars\n    n        = float(s['n'])\n    avg_deg  = float(s['avg_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    density  = float(s['density'])\n    max_deg  = float(s['max_degree'])\n    num_tri  = float(s['num_triangles'])\n\n    # 1. Baseline: grows with size, shrinks with mean connectivity\n    base = n / (avg_deg + 1.0)\n\n    # 2. Assortativity tends to stretch paths\n    base *= (1.0 + abs(assort))\n\n    # 3. Local clustering creates detours\n    base *= (1.0 + clust)\n\n    # 4. Heterogeneity (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Density reduces the expected distance (cap at a small value)\n    base *= max(0.05, 1.0 - density)\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    possible_tri = max(1.0, possible_tri)  # avoid division by zero\n    tri_ratio    = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Extra factor from the most connected nodes\n    #    Very large hubs can act as central hubs for many routes\n    base *= (1.0 + max_deg / (n * (avg_deg + 1e-6)))\n\n    return base\n\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length using only global graph\n    statistics provided in the dictionary `s`.  The formula is a\n    product‑sum of terms that capture how size, connectivity, degree\n    heterogeneity, clustering, assortativity, density, triangles and\n    transitivity influence expected path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys:\n            n, avg_degree, std_degree, avg_clustering,\n            degree_assortativity, density, max_degree,\n            num_triangles, transitivity\n\n    Returns\n    -------\n    float\n        An approximation of the average shortest‑path length.\n    \"\"\"\n    n          = float(s['n'])\n    avg_deg    = float(s['avg_degree'])\n    std_deg    = float(s['std_degree'])\n    clust      = float(s['avg_clustering'])\n    assort     = float(s['degree_assortativity'])\n    density    = float(s['density'])\n    max_deg    = float(s['max_degree'])\n    num_tri    = float(s['num_triangles'])\n    trans      = float(s['transitivity'])\n\n    # 1. Baseline: grows with n, shrinks with average degree\n    base = n / (avg_deg + 1.0)\n\n    # 2. Clustering tends to create detours\n    base *= (1.0 + clust)\n\n    # 3. Positive assortativity typically lengthens paths\n    base *= (1.0 + abs(assort))\n\n    # 4. High degree variance (hubs) shortens paths\n    base /= (1.0 + std_deg)\n\n    # 5. Higher density reduces expected distance\n    density_factor = max(0.05, 1.0 - density)\n    base *= density_factor\n\n    # 6. Triangle abundance provides local shortcuts\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    if possible_tri <= 0.0:\n        possible_tri = 1.0\n    tri_ratio = num_tri / possible_tri\n    base /= (1.0 + tri_ratio)\n\n    # 7. Global transitivity (another form of clustering) shortens paths\n    base *= (1.0 + trans)\n\n    # 8. Effect of the most connected nodes as central hubs\n    hub_factor = 1.0 + max_deg / (n * (avg_deg + 1e-6))\n    base *= hub_factor\n\n    return base\nRecent failures:\nbelow_novelty_threshold: novelty_bonus=0.107422\nbelow_novelty_threshold: novelty_bonus=0.048614\nno_valid_train_predictions: static_invalid: forbidden token detected: import \nReturn only python code defining `def new_invariant(s):` where s is a dict of pre-computed graph features.\nAvailable keys in s: n (node count), m (edge count), density, avg_degree, max_degree, min_degree, std_degree, avg_clustering, transitivity, degree_assortativity, num_triangles, degrees (sorted degree list).\n\nFORBIDDEN: Do NOT return a single feature directly (e.g., return s['diameter']).\nDo NOT implement BFS/DFS/shortest-path algorithms.\nThe input is a pre-computed feature dict, not a graph object.\n\nExample formulas:\ndef new_invariant(s): return s['n'] / (s['m'] + 1)\ndef new_invariant(s): return np.log(s['n']) * np.mean(s['degrees']) / max(s['max_degree'], 1)\ndef new_invariant(s): return np.sqrt(s['n']) / (1 + s['avg_clustering'])\n", "llm_response": "```python\ndef new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics only.\n    The formula is a product‑sum of terms that reflect how the size of the\n    network, its connectivity, degree heterogeneity, clustering, density,\n    assortativity, triangle abundance and the balance between minimum and\n    maximum degree influence typical path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles\n\n    Returns\n    -------\n    float\n        An approximation of the average shortest‑path length.\n    \"\"\"\n    # Convert to float for safe arithmetic\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    num_tri  = float(s['num_triangles'])\n\n    # Basic safety guards\n    avg_deg   = max(avg_deg, 0.1)       # avoid division by zero\n    max_deg   = max(max_deg, 1.0)       # avoid division by zero\n    density   = max(density, 0.0)       # density is non‑negative\n    min_deg   = max(min_deg, 0.0)\n\n    # Triangle ratio – how many triangles out of all possible ones\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    tri_ratio = num_tri / (possible_tri + 1e-6)   # avoid zero denominator\n\n    # Ratio of minimum to maximum degree – captures balance of connectivity\n    minmax_ratio = min_deg / max_deg\n\n    # Baseline: grows with size, shrinks with mean connectivity and density\n    base = n / (avg_deg * (density + 0.05))\n\n    # Adjust for local clustering (creates detours)\n    base *= (1.0 + clust)\n\n    # Global transitivity also provides shortcuts\n    base *= (1.0 + trans)\n\n    # Positive assortativity typically lengthens paths\n    base *= (1.0 + abs(assort))\n\n    # Degree heterogeneity (high std) shortens paths via hubs\n    base /= (1.0 + std_deg)\n\n    # Triangle abundance shortens paths\n    base /= (1.0 + tri_ratio)\n\n    # Extremely uneven degree distribution (small min/max) can slightly\n    # inflate the estimate\n    base *= (1.0 + minmax_ratio)\n\n    return base\n```", "extracted_code": "def new_invariant(s):\n    \"\"\"\n    Estimate the average shortest‑path length from global graph statistics only.\n    The formula is a product‑sum of terms that reflect how the size of the\n    network, its connectivity, degree heterogeneity, clustering, density,\n    assortativity, triangle abundance and the balance between minimum and\n    maximum degree influence typical path lengths.\n\n    Parameters\n    ----------\n    s : dict\n        Must contain the keys:\n            n, m, density, avg_degree, max_degree, min_degree,\n            std_degree, avg_clustering, transitivity,\n            degree_assortativity, num_triangles\n\n    Returns\n    -------\n    float\n        An approximation of the average shortest‑path length.\n    \"\"\"\n    # Convert to float for safe arithmetic\n    n        = float(s['n'])\n    m        = float(s['m'])\n    density  = float(s['density'])\n    avg_deg  = float(s['avg_degree'])\n    max_deg  = float(s['max_degree'])\n    min_deg  = float(s['min_degree'])\n    std_deg  = float(s['std_degree'])\n    clust    = float(s['avg_clustering'])\n    trans    = float(s['transitivity'])\n    assort   = float(s['degree_assortativity'])\n    num_tri  = float(s['num_triangles'])\n\n    # Basic safety guards\n    avg_deg   = max(avg_deg, 0.1)       # avoid division by zero\n    max_deg   = max(max_deg, 1.0)       # avoid division by zero\n    density   = max(density, 0.0)       # density is non‑negative\n    min_deg   = max(min_deg, 0.0)\n\n    # Triangle ratio – how many triangles out of all possible ones\n    possible_tri = n * (n - 1.0) * (n - 2.0) / 6.0\n    tri_ratio = num_tri / (possible_tri + 1e-6)   # avoid zero denominator\n\n    # Ratio of minimum to maximum degree – captures balance of connectivity\n    minmax_ratio = min_deg / max_deg\n\n    # Baseline: grows with size, shrinks with mean connectivity and density\n    base = n / (avg_deg * (density + 0.05))\n\n    # Adjust for local clustering (creates detours)\n    base *= (1.0 + clust)\n\n    # Global transitivity also provides shortcuts\n    base *= (1.0 + trans)\n\n    # Positive assortativity typically lengthens paths\n    base *= (1.0 + abs(assort))\n\n    # Degree heterogeneity (high std) shortens paths via hubs\n    base /= (1.0 + std_deg)\n\n    # Triangle abundance shortens paths\n    base /= (1.0 + tri_ratio)\n\n    # Extremely uneven degree distribution (small min/max) can slightly\n    # inflate the estimate\n    base *= (1.0 + minmax_ratio)\n\n    return base", "spearman": 0.8762739068476713, "pearson": 0.7298088728138594, "rmse": 83.13556064957854, "mae": 52.76551429053461}}
{"timestamp": "2026-02-16T12:38:28.039279+00:00", "event_type": "generation_migration", "payload": {"generation": 19, "model_name": "gpt-oss:20b"}}
{"timestamp": "2026-02-16T12:38:28.041659+00:00", "event_type": "generation_summary", "payload": {"experiment_id": "seed_22", "generation": 20, "model_name": "gpt-oss:20b", "best_val_score": 0.5711878370419312, "no_improve_count": 2}}
