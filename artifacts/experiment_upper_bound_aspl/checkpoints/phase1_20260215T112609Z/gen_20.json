{
  "experiment_id": "phase1_20260215T112609Z",
  "generation": 20,
  "rng_seed": 42,
  "rng_state": {
    "bit_generator": "PCG64",
    "state": {
      "state": 288855794798708287401896038457709997979,
      "inc": 332724090758049132448979897138935081983
    },
    "has_uint32": 1,
    "uinteger": 2574329487
  },
  "best_val_score": 0.45331732044510276,
  "no_improve_count": 0,
  "island_stagnation": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_prompt_mode": {
    "0": "free",
    "1": "free",
    "2": "free",
    "3": "free"
  },
  "island_constrained_generations": {
    "0": 0,
    "1": 0,
    "2": 0,
    "3": 0
  },
  "island_recent_failures": {
    "0": [
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "no_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`",
      "below_novelty_threshold: novelty_bonus=0.010695"
    ],
    "1": [
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "below_novelty_threshold: novelty_bonus=0.001241",
      "no_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`"
    ],
    "2": [
      "below_novelty_threshold: novelty_bonus=0.000000",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import ",
      "no_valid_train_predictions: static_invalid: code must define exactly one function named `new_invariant`"
    ],
    "3": [
      "no_valid_train_predictions: static_invalid: disallowed syntax: Try",
      "below_novelty_threshold: novelty_bonus=0.019441",
      "no_valid_train_predictions: static_invalid: forbidden token detected: import "
    ]
  },
  "islands": {
    "0": [
      {
        "id": "g19_i0_p4_736617357",
        "code": "def new_invariant(s):\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    bounds = [float(n - 1)]          # trivial bound\n\n    density = s.get('density', 0.0)\n    if density > 0.5:\n        bounds.append(2.0)\n\n    max_deg = s.get('max_degree', 0)\n    if max_deg > 1:\n        count = 1          # vertices reachable within current radius\n        term = 1           # (max_deg-1)^i\n        r = 0\n        while count < n:\n            r += 1\n            count += max_deg * term\n            term *= (max_deg - 1)\n        bounds.append(float(2 * r))\n\n    return min(bounds)",
        "island_id": 0,
        "generation": 19,
        "train_score": 0.33966277735920863,
        "val_score": 0.38031374388272055,
        "simplicity_score": 0.20121486861329896,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g17_i0_p0_370922283",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound for the average shortest path length (ASPL).\n\n    The bound is the minimum of several provably safe inequalities that\n    depend only on pre‑computed graph statistics.  Each inequality is\n    valid for every connected simple graph, so the returned value is\n    guaranteed to be ≥ the true ASPL while being as tight as possible\n    given the available features.\n\n    Inequalities used:\n\n    1. Trivial bound:  ASPL ≤ n – 1\n    2. Moore bound with maximum degree Δ:\n           ASPL ≤ 2·r   where r is the smallest integer such that\n           1 + Δ + Δ(Δ‑1) + … + Δ(Δ‑1)^(r‑1) ≥ n\n    3. Moore bound with minimum degree δ:\n           ASPL ≤ 2·r   where r is the smallest integer such that\n           1 + δ + δ(δ‑1) + … + δ(δ‑1)^(r‑1) ≥ n\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'          : number of nodes\n            - 'max_degree' : maximum degree\n            - 'min_degree' : minimum degree\n\n    Returns\n    -------\n    float\n        A numeric upper bound on the average shortest path length.\n    \"\"\"\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    bounds = [float(n - 1)]          # trivial bound\n\n    # Moore bound with maximum degree\n    max_deg = s.get('max_degree', 0)\n    if max_deg > 1:\n        count = 1          # vertices reachable within current radius\n        term = 1           # (max_deg-1)^i\n        r = 0\n        while count < n:\n            r += 1\n            count += max_deg * term\n            term *= (max_deg - 1)\n        bounds.append(float(2 * r))\n\n    # Moore bound with minimum degree\n    min_deg = s.get('min_degree', 0)\n    if min_deg > 1:\n        count = 1\n        term = 1\n        r = 0\n        while count < n:\n            r += 1\n            count += min_deg * term\n            term *= (min_deg - 1)\n        bounds.append(float(2 * r))\n\n    return min(bounds)",
        "island_id": 0,
        "generation": 17,
        "train_score": 0.33966277735920863,
        "val_score": 0.3796442481733225,
        "simplicity_score": 0.19786739006630882,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g19_i0_p2_886295917",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound for the average shortest path length (ASPL).\n\n    The bound is the minimum of several provably safe inequalities that\n    depend only on pre‑computed graph statistics.  Each inequality is\n    valid for every connected simple graph, so the returned value is\n    guaranteed to be ≥ the true ASPL while being as tight as possible\n    given the available features.\n\n    Inequalities used:\n\n    1. Trivial bound:  ASPL ≤ n – 1\n    2. Moore bound with maximum degree Δ:\n           ASPL ≤ 2·r   where r is the smallest integer such that\n           1 + Δ + Δ(Δ‑1) + … + Δ(Δ‑1)^(r‑1) ≥ n\n    3. Moore bound with minimum degree δ (if δ > 1):\n           ASPL ≤ 2·r   where r is the smallest integer such that\n           1 + δ + δ(δ‑1) + … + δ(δ‑1)^(r‑1) ≥ n\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'          : number of nodes\n            - 'max_degree' : maximum degree\n            - 'min_degree' : minimum degree\n\n    Returns\n    -------\n    float\n        A numeric upper bound on the average shortest path length.\n    \"\"\"\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    bounds = [float(n - 1)]          # trivial bound\n\n    # Moore bound with maximum degree\n    max_deg = s.get('max_degree', 0)\n    if max_deg > 1:\n        count = 1          # vertices reachable within current radius\n        term = 1           # (max_deg-1)^i\n        r = 0\n        while count < n:\n            r += 1\n            count += max_deg * term\n            term *= (max_deg - 1)\n        bounds.append(float(2 * r))\n\n    # Moore bound with minimum degree\n    min_deg = s.get('min_degree', 0)\n    if min_deg > 1:\n        count = 1\n        term = 1\n        r = 0\n        while count < n:\n            r += 1\n            count += min_deg * term\n            term *= (min_deg - 1)\n        bounds.append(float(2 * r))\n\n    return min(bounds)",
        "island_id": 0,
        "generation": 19,
        "train_score": 0.33966277735920863,
        "val_score": 0.3796442481733225,
        "simplicity_score": 0.19786739006630882,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g15_i0_p3_520672402",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound for the average shortest path length (ASPL).\n\n    The bound is the minimum of several provably safe inequalities that\n    depend only on pre‑computed graph statistics.  Each inequality is\n    valid for every connected simple graph, so the returned value is\n    guaranteed to be ≥ the true ASPL while being as tight as possible\n    given the available features.\n\n    The inequalities used are:\n\n    1.  Trivial bound:  ASPL ≤ n – 1\n    2.  Density bound:  if density > 0.5 then ASPL ≤ 2\n    3.  Moore bound with maximum degree Δ:\n            ASPL ≤ 2·r   where r is the smallest integer such that\n            1 + Δ + Δ(Δ‑1) + … + Δ(Δ‑1)^(r‑1) ≥ n.\n    4.  Moore bound with minimum degree δ:\n            ASPL ≤ 2·r   where r is the smallest integer such that\n            1 + δ + δ(δ‑1) + … + δ(δ‑1)^(r‑1) ≥ n.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'          : number of nodes\n            - 'density'    : edge density\n            - 'max_degree' : maximum degree\n            - 'min_degree' : minimum degree\n\n    Returns\n    -------\n    float\n        A numeric upper bound on the average shortest path length.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    bounds = [float(n - 1)]          # trivial bound\n\n    # Density bound\n    if s['density'] > 0.5:\n        bounds.append(2.0)\n\n    # Moore bound with maximum degree\n    Δ = s['max_degree']\n    if Δ > 2:\n        count = 1          # vertices reachable within current radius\n        term = 1           # (Δ-1)^i\n        r = 0\n        while count < n:\n            r += 1\n            count += Δ * term\n            term *= (Δ - 1)\n        bounds.append(float(2 * r))\n\n    # Moore bound with minimum degree\n    δ = s['min_degree']\n    if δ > 1:\n        count = 1\n        term = 1\n        r = 0\n        while count < n:\n            r += 1\n            count += δ * term\n            term *= (δ - 1)\n        bounds.append(float(2 * r))\n\n    return min(bounds)",
        "island_id": 0,
        "generation": 15,
        "train_score": 0.33966277735920863,
        "val_score": 0.37954366219740066,
        "simplicity_score": 0.19736446018669984,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g15_i0_p0_953772862",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound for the average shortest path length (ASPL).\n\n    The bound is the minimum of several provably safe inequalities that\n    depend only on pre‑computed graph statistics.  Each inequality is\n    valid for every connected simple graph, so the returned value is\n    guaranteed to be ≥ the true ASPL while being as tight as possible\n    given the available features.\n\n    Inequalities used:\n\n    1. Trivial bound:  ASPL ≤ n – 1\n    2. Density bound:  if density > 0.5 then ASPL ≤ 2\n    3. Moore bound with maximum degree Δ:\n           ASPL ≤ 2·r   where r is the smallest integer such that\n           1 + Δ + Δ(Δ‑1) + … + Δ(Δ‑1)^(r‑1) ≥ n\n    4. Moore bound with minimum degree δ:\n           ASPL ≤ 2·r   where r is the smallest integer such that\n           1 + δ + δ(δ‑1) + … + δ(δ‑1)^(r‑1) ≥ n\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'          : number of nodes\n            - 'density'    : edge density\n            - 'max_degree' : maximum degree\n            - 'min_degree' : minimum degree\n\n    Returns\n    -------\n    float\n        A numeric upper bound on the average shortest path length.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    bounds = [float(n - 1)]          # trivial bound\n\n    # Density bound\n    density = s.get('density', 0.0)\n    if density > 0.5:\n        bounds.append(2.0)\n\n    # Moore bound with maximum degree\n    max_deg = s.get('max_degree', 0)\n    if max_deg > 1:\n        count = 1          # vertices reachable within current radius\n        term = 1           # (max_deg-1)^i\n        r = 0\n        while count < n:\n            r += 1\n            count += max_deg * term\n            term *= (max_deg - 1)\n        bounds.append(float(2 * r))\n\n    # Moore bound with minimum degree\n    min_deg = s.get('min_degree', 0)\n    if min_deg > 1:\n        count = 1\n        term = 1\n        r = 0\n        while count < n:\n            r += 1\n            count += min_deg * term\n            term *= (min_deg - 1)\n        bounds.append(float(2 * r))\n\n    return min(bounds)",
        "island_id": 0,
        "generation": 15,
        "train_score": 0.33966277735920863,
        "val_score": 0.37944052749441437,
        "simplicity_score": 0.1968487866717683,
        "novelty_bonus": 0.5521213665879059
      }
    ],
    "1": [
      {
        "id": "g19_i1_p3_5307072",
        "code": "def new_invariant(s):\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # Path‑graph bound (maximum ASPL over all connected graphs)\n    path_bound = (n + 1) / 3.0\n\n    # Density bound: if density > 0.5, diameter ≤ 2\n    density = s.get('density', 0.0)\n    density_bound = 2.0 if density > 0.5 else n - 1\n\n    # Moore bound using maximum degree Δ\n    max_deg = s.get('max_degree', 1)\n    moore_max = n - 1\n    if max_deg > 2:\n        nodes = 1\n        power = 1\n        radius = 0\n        deg = int(max_deg)\n        while nodes < n:\n            nodes += deg * power\n            power *= (deg - 1)\n            radius += 1\n        moore_max = radius + 1\n\n    # Moore bound using minimum degree δ\n    min_deg = s.get('min_degree', 1)\n    moore_min = n - 1\n    if min_deg > 1:\n        nodes = 1\n        power = 1\n        radius = 0\n        deg = int(min_deg)\n        while nodes < n:\n            nodes += deg * power\n            power *= (deg - 1)\n            radius += 1\n        moore_min = radius + 1\n\n    # Moore bound using average degree\n    avg_deg = s.get('avg_degree', 1)\n    moore_avg = n - 1\n    if avg_deg > 1:\n        nodes = 1\n        power = 1\n        radius = 0\n        deg = int(avg_deg)\n        while nodes < n:\n            nodes += deg * power\n            power *= (deg - 1)\n            radius += 1\n        moore_avg = radius + 1\n\n    # Trivial bound\n    trivial = n - 1\n\n    # Choose the tightest guaranteed upper bound\n    final = path_bound\n    if density_bound < final:\n        final = density_bound\n    if moore_max < final:\n        final = moore_max\n    if moore_min < final:\n        final = moore_min\n    if moore_avg < final:\n        final = moore_avg\n    if trivial < final:\n        final = trivial\n\n    return float(final)",
        "island_id": 1,
        "generation": 19,
        "train_score": 0.532044713370125,
        "val_score": 0.45331732044510276,
        "simplicity_score": 0.16117643469767504,
        "novelty_bonus": 0.5474180993662181
      },
      {
        "id": "g18_i1_p0_90928824",
        "code": "def new_invariant(s):\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # Path-graph bound (maximum ASPL over all connected graphs)\n    path_bound = (n + 1) / 3.0\n\n    # Density bound: if density > 0.5, diameter ≤ 2\n    density = s.get('density', 0.0)\n    density_bound = 2.0 if density > 0.5 else n - 1\n\n    # Moore bound using maximum degree Δ\n    max_deg = s.get('max_degree', 1)\n    if max_deg <= 2:\n        moore_max = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += max_deg * power\n            power *= (max_deg - 1)\n            radius += 1\n        moore_max = radius + 1\n\n    # Moore bound using minimum degree δ\n    min_deg = s.get('min_degree', 1)\n    if min_deg <= 1:\n        moore_min = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += min_deg * power\n            power *= (min_deg - 1)\n            radius += 1\n        moore_min = radius + 1\n\n    # Moore bound using average degree\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg <= 1:\n        moore_avg = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += avg_deg * power\n            power *= (avg_deg - 1)\n            radius += 1\n        moore_avg = radius + 1\n\n    # Trivial bound\n    trivial = n - 1\n\n    # Choose the tightest guaranteed upper bound\n    final = path_bound\n    if density_bound < final:\n        final = density_bound\n    if moore_max < final:\n        final = moore_max\n    if moore_min < final:\n        final = moore_min\n    if moore_avg < final:\n        final = moore_avg\n    if trivial < final:\n        final = trivial\n\n    return float(final)",
        "island_id": 1,
        "generation": 18,
        "train_score": 0.532044713370125,
        "val_score": 0.44901775921318077,
        "simplicity_score": 0.16168457876515868,
        "novelty_bonus": 0.5501320075867819
      },
      {
        "id": "g15_i1_p3_21612079",
        "code": "def new_invariant(s):\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # Path-graph bound (maximum ASPL over all connected graphs)\n    path_bound = (n * n - 1) / (3 * (n - 1))\n\n    # Density bound: if density > 0.5, diameter ≤ 2\n    density = s.get('density', 0.0)\n    density_bound = 2.0 if density > 0.5 else n - 1\n\n    # Moore bound using maximum degree Δ\n    max_deg = s.get('max_degree', 1)\n    if max_deg <= 2:\n        moore_max = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += max_deg * power\n            power *= (max_deg - 1)\n            radius += 1\n        moore_max = radius + 1\n\n    # Moore bound using minimum degree δ\n    min_deg = s.get('min_degree', 1)\n    if min_deg <= 1:\n        moore_min = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += min_deg * power\n            power *= (min_deg - 1)\n            radius += 1\n        moore_min = radius + 1\n\n    # Moore bound using average degree\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg <= 1:\n        moore_avg = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += avg_deg * power\n            power *= (avg_deg - 1)\n            radius += 1\n        moore_avg = radius + 1\n\n    # Trivial bound\n    trivial = n - 1\n\n    # Take the tightest guaranteed upper bound\n    final = path_bound\n    if density_bound < final:\n        final = density_bound\n    if moore_max < final:\n        final = moore_max\n    if moore_min < final:\n        final = moore_min\n    if moore_avg < final:\n        final = moore_avg\n    if trivial < final:\n        final = trivial\n\n    return float(final)",
        "island_id": 1,
        "generation": 15,
        "train_score": 0.532044713370125,
        "val_score": 0.44897012276457193,
        "simplicity_score": 0.16144639652211454,
        "novelty_bonus": 0.5501320075867819
      },
      {
        "id": "g17_i1_p3_290917837",
        "code": "def new_invariant(s):\n    \"\"\"Safe upper bound on average shortest path length using pre‑computed graph features.\"\"\"\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # Path‑graph bound (maximum ASPL over all connected graphs)\n    path_bound = (n * n - 1) / (3 * (n - 1))\n\n    # Density bound: if density > 0.5, diameter ≤ 2\n    density = s.get('density', 0.0)\n    density_bound = 2.0 if density > 0.5 else n - 1\n\n    # Moore bound using maximum degree Δ\n    max_deg = s.get('max_degree', 1)\n    if max_deg <= 2:\n        moore_max = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += max_deg * power\n            power *= (max_deg - 1)\n            radius += 1\n        moore_max = radius + 1\n\n    # Moore bound using minimum degree δ\n    min_deg = s.get('min_degree', 1)\n    if min_deg <= 1:\n        moore_min = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += min_deg * power\n            power *= (min_deg - 1)\n            radius += 1\n        moore_min = radius + 1\n\n    # Moore bound using average degree\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg <= 1:\n        moore_avg = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += avg_deg * power\n            power *= (avg_deg - 1)\n            radius += 1\n        moore_avg = radius + 1\n\n    # Trivial bound\n    trivial = n - 1\n\n    # Take the tightest guaranteed upper bound\n    final = path_bound\n    if density_bound < final:\n        final = density_bound\n    if moore_max < final:\n        final = moore_max\n    if moore_min < final:\n        final = moore_min\n    if moore_avg < final:\n        final = moore_avg\n    if trivial < final:\n        final = trivial\n\n    return float(final)",
        "island_id": 1,
        "generation": 17,
        "train_score": 0.532044713370125,
        "val_score": 0.4489616580900323,
        "simplicity_score": 0.16140407314941654,
        "novelty_bonus": 0.5501320075867819
      },
      {
        "id": "g18_i1_p4_890792490",
        "code": "def new_invariant(s):\n    \"\"\"Safe upper bound on the average shortest path length (ASPL) for any connected graph.\"\"\"\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # Path‑graph bound (maximum ASPL over all connected graphs)\n    path_bound = (n * n - 1) / (3 * (n - 1))\n\n    # Density bound: if density > 0.5, diameter ≤ 2\n    density = s.get('density', 0.0)\n    density_bound = 2.0 if density > 0.5 else n - 1\n\n    # Moore bound using maximum degree Δ\n    max_deg = s.get('max_degree', 1)\n    if max_deg <= 2:\n        moore_max = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += max_deg * power\n            power *= (max_deg - 1)\n            radius += 1\n        moore_max = radius + 1\n\n    # Moore bound using minimum degree δ\n    min_deg = s.get('min_degree', 1)\n    if min_deg <= 1:\n        moore_min = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += min_deg * power\n            power *= (min_deg - 1)\n            radius += 1\n        moore_min = radius + 1\n\n    # Moore bound using average degree\n    avg_deg = s.get('avg_degree', 1)\n    if avg_deg <= 1:\n        moore_avg = n - 1\n    else:\n        nodes = 1\n        power = 1\n        radius = 0\n        while nodes < n:\n            nodes += avg_deg * power\n            power *= (avg_deg - 1)\n            radius += 1\n        moore_avg = radius + 1\n\n    # Trivial bound\n    trivial = n - 1\n\n    # Take the tightest guaranteed upper bound\n    final = path_bound\n    if density_bound < final:\n        final = density_bound\n    if moore_max < final:\n        final = moore_max\n    if moore_min < final:\n        final = moore_min\n    if moore_avg < final:\n        final = moore_avg\n    if trivial < final:\n        final = trivial\n\n    return float(final)",
        "island_id": 1,
        "generation": 18,
        "train_score": 0.532044713370125,
        "val_score": 0.4489616580900323,
        "simplicity_score": 0.16140407314941654,
        "novelty_bonus": 0.5501320075867819
      }
    ],
    "2": [
      {
        "id": "g19_i2_p3_67642863",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound on the average shortest path length (ASPL) for any connected graph.\n    The bound is the minimum of several provably valid upper bounds that depend\n    only on pre‑computed graph statistics.  All bounds are guaranteed to be\n    greater than or equal to the true ASPL for all connected graphs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n'          : number of nodes\n            - 'max_degree' : maximum degree in the graph\n            - 'min_degree' : minimum degree in the graph\n            - 'density'    : edge density in [0, 1]\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    # 1. Path‑graph bound: maximum possible ASPL for any connected graph\n    path_bound = (n + 1) / 3.0\n\n    # 2. Maximum‑degree bound (Moore‑like)\n    max_deg = s['max_degree']\n    max_deg_bound = n / (max_deg + 1.0) + 1.0\n\n    # 3. Minimum‑degree bound (Moore‑like diameter bound)\n    min_deg = s['min_degree']\n    if min_deg <= 2:\n        min_deg_bound = float(n - 1)\n    else:\n        r = 0\n        reachable = 1\n        # Grow reachable nodes exponentially until it covers the graph\n        while reachable < n:\n            r += 1\n            # reachable = 1 + δ * ((δ-1)^r - 1) / (δ-2)\n            power = (min_deg - 1) ** r\n            reachable = 1 + min_deg * (power - 1) // (min_deg - 2)\n        min_deg_bound = float(r)\n\n    # 4. Density bound\n    density = s['density']\n    density_bound = (n - 1) * (1.0 - density) + 1.0\n\n    # Choose the tightest (smallest) bound\n    bound = path_bound\n    if max_deg_bound < bound:\n        bound = max_deg_bound\n    if min_deg_bound < bound:\n        bound = min_deg_bound\n    if density_bound < bound:\n        bound = density_bound\n\n    # ASPL is at least 1 for any connected graph with n >= 2\n    if bound < 1.0:\n        bound = 1.0\n\n    return bound",
        "island_id": 2,
        "generation": 19,
        "train_score": 0.3284155921582774,
        "val_score": 0.2882552377751726,
        "simplicity_score": 0.20732736994004375,
        "novelty_bonus": 0.28154940514701876
      },
      {
        "id": "g19_i2_p4_831112672",
        "code": "def new_invariant(s):\n    \"\"\"\n    Guaranteed upper bound on the average shortest path length (ASPL)\n    for any connected graph, using only pre‑computed graph statistics.\n\n    The bound is the minimum of several provably valid upper bounds:\n\n    1. Path‑graph bound   : (n + 1) / 3\n    2. Max‑degree bound   : n / (Δ + 1) + 1\n    3. Density bound      : (n – 1) * (1 – density) + 1\n    4. Minimum‑degree (Moore‑like) bound : smallest integer r such that\n       1 + δ * ((δ – 1)^r – 1) / (δ – 2) ≥ n  (δ = min_degree)\n    5. Simple min‑degree bound : n / (δ + 1) + 1\n\n    The smallest of these values is returned, clamped to a minimum of\n    1.0 for graphs with at least two vertices (the ASPL of a single‑vertex\n    graph is defined to be 0.0).\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys:\n            - 'n'          : number of nodes\n            - 'max_degree' : maximum degree\n            - 'min_degree' : minimum degree\n            - 'density'    : edge density in [0, 1]\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    # 1. Path‑graph bound\n    path_bound = (n + 1) / 3.0\n\n    # 2. Max‑degree bound\n    max_deg = s['max_degree']\n    max_deg_bound = n / (max_deg + 1.0) + 1.0\n\n    # 3. Density bound\n    density = s['density']\n    density_bound = (n - 1) * (1.0 - density) + 1.0\n\n    # 4. Minimum‑degree (Moore‑like) bound\n    min_deg = s['min_degree']\n    if min_deg <= 2:\n        min_deg_bound = float(n - 1)\n    else:\n        r = 0\n        reachable = 1\n        power = 1  # (min_deg - 1)^r\n        while reachable < n:\n            r += 1\n            power *= (min_deg - 1)\n            reachable = 1 + min_deg * (power - 1) // (min_deg - 2)\n        min_deg_bound = float(r)\n\n    # 5. Simple min‑degree bound\n    min_degree_simple = n / (min_deg + 1.0) + 1.0\n\n    # Choose the tightest (smallest) bound\n    bound = path_bound\n    if max_deg_bound < bound:\n        bound = max_deg_bound\n    if density_bound < bound:\n        bound = density_bound\n    if min_deg_bound < bound:\n        bound = min_deg_bound\n    if min_degree_simple < bound:\n        bound = min_degree_simple\n\n    # Ensure the bound is at least 1 for non‑trivial graphs\n    if bound < 1.0:\n        bound = 1.0\n\n    return bound",
        "island_id": 2,
        "generation": 19,
        "train_score": 0.3284155921582774,
        "val_score": 0.2880391173113448,
        "simplicity_score": 0.20624676762090463,
        "novelty_bonus": 0.28154940514701876
      },
      {
        "id": "g19_i2_p1_31911050",
        "code": "def new_invariant(s):\n    \"\"\"\n    Guaranteed upper bound on the average shortest path length (ASPL)\n    for any connected graph, expressed solely in terms of pre‑computed\n    graph statistics.\n\n    The bound is the minimum of several classical bounds that are\n    provably valid for all connected graphs.  The bounds used are:\n\n    1. Path‑graph bound: (n + 1) / 3.\n    2. Average‑degree bound: n / (avg_degree + 1).\n    3. Maximum‑degree bound: n / (max_degree + 1) + 1.\n    4. Minimum‑degree (Moore‑like) bound: the smallest integer r\n       such that 1 + δ * ((δ‑1)^r – 1)/(δ‑2) ≥ n, where δ is the\n       minimum degree (for δ ≤ 2 the bound is n – 1).\n    5. Density bound: (n – 1) * (1 – density) + 1.\n\n    The smallest of these bounds is returned, clamped to a minimum of\n    1.0 for graphs with at least two nodes.  For a single‑vertex graph\n    the ASPL is defined to be 0.0.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'          : number of nodes\n            - 'avg_degree' : average degree (2m/n)\n            - 'max_degree' : maximum degree\n            - 'min_degree' : minimum degree\n            - 'density'    : edge density in [0, 1]\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n\n    # 1. Path‑graph bound\n    path_bound = (n + 1) / 3.0\n\n    # 2. Average‑degree bound\n    avg_deg_bound = n / (avg_deg + 1.0)\n\n    # 3. Maximum‑degree bound\n    max_deg_bound = n / (max_deg + 1.0) + 1.0\n\n    # 4. Minimum‑degree (Moore‑like) bound\n    if min_deg <= 2:\n        min_deg_bound = float(n - 1)\n    else:\n        r = 0\n        reachable = 1\n        while reachable < n:\n            r += 1\n            reachable = 1 + min_deg * ((pow(min_deg - 1, r) - 1) // (min_deg - 2))\n        min_deg_bound = float(r)\n\n    # 5. Density bound\n    density_bound = (n - 1) * (1.0 - density) + 1.0\n\n    # Choose the tightest (smallest) bound\n    bound = path_bound\n    if avg_deg_bound < bound:\n        bound = avg_deg_bound\n    if max_deg_bound < bound:\n        bound = max_deg_bound\n    if min_deg_bound < bound:\n        bound = min_deg_bound\n    if density_bound < bound:\n        bound = density_bound\n\n    # Ensure the bound is at least 1 for non‑trivial graphs\n    if bound < 1.0:\n        bound = 1.0\n\n    return bound",
        "island_id": 2,
        "generation": 19,
        "train_score": 0.3284155921582774,
        "val_score": 0.28772326827450034,
        "simplicity_score": 0.20624676762090463,
        "novelty_bonus": 0.2801582900665318
      },
      {
        "id": "g18_i2_p1_893446639",
        "code": "def new_invariant(s):\n    \"\"\"\n    Guaranteed upper bound on the average shortest path length (ASPL)\n    for any connected graph, expressed only in terms of pre‑computed\n    graph statistics.\n\n    The bound is the minimum of several classical upper bounds that\n    hold for all graphs.  All computations use only the supplied\n    features and simple arithmetic; no graph traversal or external\n    libraries are required.\n\n    Parameters\n    ----------\n    s : dict\n        Pre‑computed graph features.  Expected keys:\n            - 'n'          : number of nodes\n            - 'avg_degree' : average degree (2m/n)\n            - 'max_degree' : maximum degree\n            - 'min_degree' : minimum degree\n            - 'density'    : edge density in [0, 1]\n\n    Returns\n    -------\n    float\n        An upper bound on the ASPL.  The bound is at least 1.0 for any\n        connected graph with at least two vertices; for a single‑vertex\n        graph it returns 0.0.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    avg_deg = s['avg_degree']\n    max_deg = s['max_degree']\n    min_deg = s['min_degree']\n    density = s['density']\n\n    # 1. Path‑graph bound: ASPL of a simple path of length n‑1\n    path_bound = (n + 1) / 3.0\n\n    # 2. Average‑degree bound: n/(avg_deg+1)\n    avg_deg_bound = n / (avg_deg + 1.0)\n\n    # 3. Max‑degree bound: n/(Δ+1)+1\n    max_deg_bound = n / (max_deg + 1.0) + 1.0\n\n    # 4. Density bound: (n‑1)*(1‑density)+1\n    density_bound = (n - 1) * (1.0 - density) + 1.0\n\n    # 5. Minimum‑degree (Moore‑like) bound\n    if min_deg <= 2:\n        min_deg_bound = float(n - 1)\n    else:\n        r = 0\n        reachable = 1\n        # Use integer arithmetic; the loop terminates quickly because growth is exponential\n        while reachable < n:\n            r += 1\n            # reachable = 1 + δ * ((δ‑1)^r – 1)/(δ‑2)\n            power = (min_deg - 1) ** r\n            reachable = 1 + min_deg * (power - 1) // (min_deg - 2)\n        min_deg_bound = float(r)\n\n    # Choose the tightest (smallest) bound\n    bound = path_bound\n    if avg_deg_bound < bound:\n        bound = avg_deg_bound\n    if max_deg_bound < bound:\n        bound = max_deg_bound\n    if density_bound < bound:\n        bound = density_bound\n    if min_deg_bound < bound:\n        bound = min_deg_bound\n\n    # Ensure the bound is at least 1 for non‑trivial graphs\n    if bound < 1.0:\n        bound = 1.0\n\n    return bound",
        "island_id": 2,
        "generation": 18,
        "train_score": 0.3284155921582774,
        "val_score": 0.2876950008697987,
        "simplicity_score": 0.2061054305973965,
        "novelty_bonus": 0.2801582900665318
      },
      {
        "id": "g19_i1_p3_5307072",
        "code": "def new_invariant(s):\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # Path‑graph bound (maximum ASPL over all connected graphs)\n    path_bound = (n + 1) / 3.0\n\n    # Density bound: if density > 0.5, diameter ≤ 2\n    density = s.get('density', 0.0)\n    density_bound = 2.0 if density > 0.5 else n - 1\n\n    # Moore bound using maximum degree Δ\n    max_deg = s.get('max_degree', 1)\n    moore_max = n - 1\n    if max_deg > 2:\n        nodes = 1\n        power = 1\n        radius = 0\n        deg = int(max_deg)\n        while nodes < n:\n            nodes += deg * power\n            power *= (deg - 1)\n            radius += 1\n        moore_max = radius + 1\n\n    # Moore bound using minimum degree δ\n    min_deg = s.get('min_degree', 1)\n    moore_min = n - 1\n    if min_deg > 1:\n        nodes = 1\n        power = 1\n        radius = 0\n        deg = int(min_deg)\n        while nodes < n:\n            nodes += deg * power\n            power *= (deg - 1)\n            radius += 1\n        moore_min = radius + 1\n\n    # Moore bound using average degree\n    avg_deg = s.get('avg_degree', 1)\n    moore_avg = n - 1\n    if avg_deg > 1:\n        nodes = 1\n        power = 1\n        radius = 0\n        deg = int(avg_deg)\n        while nodes < n:\n            nodes += deg * power\n            power *= (deg - 1)\n            radius += 1\n        moore_avg = radius + 1\n\n    # Trivial bound\n    trivial = n - 1\n\n    # Choose the tightest guaranteed upper bound\n    final = path_bound\n    if density_bound < final:\n        final = density_bound\n    if moore_max < final:\n        final = moore_max\n    if moore_min < final:\n        final = moore_min\n    if moore_avg < final:\n        final = moore_avg\n    if trivial < final:\n        final = trivial\n\n    return float(final)",
        "island_id": 1,
        "generation": 19,
        "train_score": 0.532044713370125,
        "val_score": 0.45331732044510276,
        "simplicity_score": 0.16117643469767504,
        "novelty_bonus": 0.5474180993662181
      }
    ],
    "3": [
      {
        "id": "g11_i3_p2_176772782",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound on the average shortest‑path length (ASPL) for any connected,\n    undirected, simple graph.  The bound is the minimum of two provable\n    inequalities that depend solely on the pre‑computed features in *s*.\n    \n    1. Path‑graph bound:  (n + 1) / 3.  \n       For a simple path on n vertices the ASPL is exactly this value and\n       no connected graph can have a larger ASPL.\n\n    2. Moore diameter bound:  r  (the smallest integer satisfying the\n       Moore inequality).  The Moore inequality guarantees that the\n       diameter of the graph is at most r, hence ASPL ≤ r.  This bound\n       uses the maximum degree Δ and the node count n.\n\n    The function returns the tighter of the two bounds.  All arithmetic\n    uses only built‑in operators; no external modules are imported,\n    respecting the sandbox restrictions.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph statistics.  Expected keys are:\n            - 'n'          : number of vertices (int, >= 1)\n            - 'max_degree' : maximum degree (int, >= 1)\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    # Basic graph size\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # Path‑graph bound\n    path_bound = (n + 1) / 3.0\n\n    # Moore diameter bound\n    max_deg = s.get('max_degree', 0)\n    if max_deg <= 0:\n        moore_bound = float(n - 1)\n    elif max_deg <= 2:\n        # For Δ = 1 or 2 the worst case diameter is n-1\n        moore_bound = float(n - 1)\n    else:\n        # Find the smallest integer r such that\n        # 1 + Δ * ((Δ-1)^r - 1) / (Δ-2) >= n\n        r = 0\n        reachable = 1          # vertices reachable within r steps\n        power = 1              # (Δ-1)^r\n        # iterate until the bound is satisfied\n        while reachable < n:\n            r += 1\n            power *= (max_deg - 1)\n            # use floating arithmetic to avoid overflow\n            reachable = 1 + max_deg * (power - 1) / (max_deg - 2)\n        moore_bound = float(r)\n\n    # Return the tighter of the two bounds\n    if moore_bound < path_bound:\n        return moore_bound\n    else:\n        return path_bound",
        "island_id": 3,
        "generation": 11,
        "train_score": 0.12019794560048529,
        "val_score": 0.29323971130365156,
        "simplicity_score": 0.25384115519850103,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g19_i3_p0_891911453",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound on the average shortest‑path length (ASPL) for any connected,\n    undirected, simple graph described by the pre‑computed statistics in *s*.\n    \n    The bound is the minimum of three provable inequalities that depend\n    only on the supplied statistics.\n    \n    1. **Path‑graph bound**  \n       The simple path on *n* vertices has the largest possible ASPL among\n       all connected graphs:\n           ASPL ≤ (n + 1) / 3\n       (proved by induction on *n*).\n    \n    2. **Moore diameter bound**  \n       If Δ is the maximum degree, the graph’s diameter is at most the\n       smallest integer *r* satisfying  \n           1 + Δ * ((Δ – 1)^r – 1) / (Δ – 2) ≥ n\n       (Δ > 2).  For Δ ≤ 2 the worst case diameter is *n* – 1.  Because\n       ASPL ≤ diameter, the same *r* is a valid upper bound for the ASPL.\n    \n    3. **Density based diameter‑2 bound**  \n       If the graph is sufficiently dense, all pairs of vertices are\n       within distance two.  A simple Turán‑type result shows that\n           m > n²/4   ⇒   diameter ≤ 2\n       which in terms of the density *d* = 2m/[n(n‑1)] becomes  \n           d > n / [2(n–1)]   ⇒   ASPL ≤ 2\n    \n    The function returns the tightest of these three bounds.\n    \n    Parameters\n    ----------\n    s : dict\n        Pre‑computed statistics with at least the following keys:\n            - 'n'          : number of vertices (int, ≥ 1)\n            - 'max_degree' : maximum degree (int, ≥ 1)\n            - 'density'    : graph density (float, 0 ≤ d ≤ 1)\n    \n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    # Basic size of the graph\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # 1. Path‑graph bound\n    path_bound = (n + 1) / 3.0\n\n    # 2. Moore diameter bound\n    max_deg = s.get('max_degree', 0)\n    if max_deg <= 1:\n        moore_bound = float(n - 1)\n    elif max_deg == 2:\n        moore_bound = float(n - 1)\n    else:\n        r = 0\n        reachable = 1          # vertices reachable within r steps\n        power = 1              # (Δ – 1)^r\n        # iterate until the Moore inequality is satisfied\n        while reachable < n:\n            r += 1\n            power *= (max_deg - 1)\n            reachable = 1 + max_deg * (power - 1) / (max_deg - 2)\n        moore_bound = float(r)\n\n    # 3. Density‑based bound (diameter ≤ 2)\n    density = s.get('density', 0.0)\n    dens_bound = float('inf')\n    if n > 1 and density > n / (2.0 * (n - 1)):\n        dens_bound = 2.0\n\n    # Return the tightest bound\n    best = path_bound\n    if moore_bound < best:\n        best = moore_bound\n    if dens_bound < best:\n        best = dens_bound\n    return best",
        "island_id": 3,
        "generation": 19,
        "train_score": 0.12019794560048529,
        "val_score": 0.28720110154373485,
        "simplicity_score": 0.22364810639891763,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g16_i3_p2_141262147",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound on the average shortest‑path length (ASPL) for any\n    connected, undirected, simple graph.\n\n    The bound is the minimum of two provable inequalities that depend\n    only on pre‑computed graph statistics contained in *s*.\n\n    1.  **Path‑graph bound** – A path on *n* vertices has the largest\n        possible ASPL among all connected graphs:\n              ASPL ≤ (n + 1) / 3\n\n    2.  **Moore diameter bound** – If Δ is the maximum degree,\n        the diameter is at most the smallest integer *r* satisfying\n\n                 1 + Δ * ((Δ‑1)^r – 1) / (Δ‑2)  ≥  n     (Δ > 2)\n\n        For Δ = 1 or 2 the worst case diameter is n – 1.  Because\n        ASPL ≤ diameter, the same value of *r* is a valid upper bound\n        for the ASPL.\n\n    The minimum of these two bounds is returned.  All arithmetic uses\n    built‑in operators only; no external modules or graph traversal\n    algorithms are required.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Required keys:\n\n            'n'          : number of nodes (int, ≥ 1)\n            'max_degree' : maximum degree in the graph (int, ≥ 1)\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    # --- Basic graph size ---------------------------------------------\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # --- Path‑graph bound -----------------------------------------------\n    path_bound = (n + 1) / 3.0\n\n    # --- Moore diameter bound ------------------------------------------\n    max_deg = s.get('max_degree', 0)\n    if max_deg <= 1:\n        moore_bound = float(n - 1)\n    elif max_deg == 2:\n        moore_bound = float(n - 1)\n    else:\n        # Find the smallest integer r such that\n        #   1 + Δ * ((Δ-1)^r – 1) / (Δ-2)  ≥  n\n        r = 0\n        reach = 1            # vertices reachable within r steps\n        power = 1            # (Δ-1)^r\n        # iterate until the inequality holds\n        while reach < n:\n            r += 1\n            power *= (max_deg - 1)\n            reach = 1 + max_deg * (power - 1) // (max_deg - 2)\n        moore_bound = float(r)\n\n    # --- Final bound: the tighter of the two provable upper bounds -----\n    bound = path_bound if path_bound < moore_bound else moore_bound\n    return bound",
        "island_id": 3,
        "generation": 16,
        "train_score": 0.12019794560048529,
        "val_score": 0.28460400082058923,
        "simplicity_score": 0.2106626027831897,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g18_i3_p2_772012432",
        "code": "def new_invariant(s):\n    \"\"\"\n    An upper bound on the average shortest‑path length (ASPL) of a connected,\n    undirected, simple graph, expressed only in terms of pre‑computed graph\n    statistics.\n\n    The bound is the minimum of two provable inequalities:\n\n    1. Path‑graph bound – a path on n vertices has the largest possible\n       ASPL among all connected graphs:\n           ASPL ≤ (n + 1) / 3\n\n    2. Moore diameter bound – with maximum degree Δ the diameter is at\n       most the smallest integer r satisfying\n\n           1 + Δ * ((Δ – 1)^r – 1) / (Δ – 2)  ≥  n      (Δ > 2)\n\n       Since ASPL ≤ diameter, the same r is an upper bound on the ASPL.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys:\n\n            'n'          : number of nodes  (int, ≥ 1)\n            'max_degree' : maximum degree in the graph (int, ≥ 1)\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    # ---- basic graph size ---------------------------------------------\n    n = s.get('n', 0)\n    if n <= 1:\n        return 0.0\n\n    # ---- Path‑graph bound ----------------------------------------------\n    path_bound = (n + 1) / 3.0\n\n    # ---- Moore diameter bound ------------------------------------------\n    max_deg = s.get('max_degree', 0)\n    if max_deg <= 1:\n        moore_bound = float(n - 1)\n    elif max_deg == 2:\n        moore_bound = float(n - 1)\n    else:\n        r = 0\n        reach = 1          # vertices reachable within r steps\n        power = 1          # (Δ – 1)^r\n        while reach < n:\n            r += 1\n            power *= (max_deg - 1)\n            # use integer division for a safe lower estimate\n            reach = 1 + max_deg * (power - 1) // (max_deg - 2)\n        moore_bound = float(r)\n\n    # ---- final bound: the tighter of the two provable upper bounds -------\n    bound = path_bound if path_bound < moore_bound else moore_bound\n    return bound",
        "island_id": 3,
        "generation": 18,
        "train_score": 0.12019794560048529,
        "val_score": 0.28460400082058923,
        "simplicity_score": 0.2106626027831897,
        "novelty_bonus": 0.5521213665879059
      },
      {
        "id": "g19_i2_p3_67642863",
        "code": "def new_invariant(s):\n    \"\"\"\n    Upper bound on the average shortest path length (ASPL) for any connected graph.\n    The bound is the minimum of several provably valid upper bounds that depend\n    only on pre‑computed graph statistics.  All bounds are guaranteed to be\n    greater than or equal to the true ASPL for all connected graphs.\n\n    Parameters\n    ----------\n    s : dict\n        Dictionary of pre‑computed graph features.  Expected keys are:\n            - 'n'          : number of nodes\n            - 'max_degree' : maximum degree in the graph\n            - 'min_degree' : minimum degree in the graph\n            - 'density'    : edge density in [0, 1]\n\n    Returns\n    -------\n    float\n        A guaranteed upper bound on the ASPL.\n    \"\"\"\n    n = s['n']\n    if n <= 1:\n        return 0.0\n\n    # 1. Path‑graph bound: maximum possible ASPL for any connected graph\n    path_bound = (n + 1) / 3.0\n\n    # 2. Maximum‑degree bound (Moore‑like)\n    max_deg = s['max_degree']\n    max_deg_bound = n / (max_deg + 1.0) + 1.0\n\n    # 3. Minimum‑degree bound (Moore‑like diameter bound)\n    min_deg = s['min_degree']\n    if min_deg <= 2:\n        min_deg_bound = float(n - 1)\n    else:\n        r = 0\n        reachable = 1\n        # Grow reachable nodes exponentially until it covers the graph\n        while reachable < n:\n            r += 1\n            # reachable = 1 + δ * ((δ-1)^r - 1) / (δ-2)\n            power = (min_deg - 1) ** r\n            reachable = 1 + min_deg * (power - 1) // (min_deg - 2)\n        min_deg_bound = float(r)\n\n    # 4. Density bound\n    density = s['density']\n    density_bound = (n - 1) * (1.0 - density) + 1.0\n\n    # Choose the tightest (smallest) bound\n    bound = path_bound\n    if max_deg_bound < bound:\n        bound = max_deg_bound\n    if min_deg_bound < bound:\n        bound = min_deg_bound\n    if density_bound < bound:\n        bound = density_bound\n\n    # ASPL is at least 1 for any connected graph with n >= 2\n    if bound < 1.0:\n        bound = 1.0\n\n    return bound",
        "island_id": 2,
        "generation": 19,
        "train_score": 0.3284155921582774,
        "val_score": 0.2882552377751726,
        "simplicity_score": 0.20732736994004375,
        "novelty_bonus": 0.28154940514701876
      }
    ]
  }
}